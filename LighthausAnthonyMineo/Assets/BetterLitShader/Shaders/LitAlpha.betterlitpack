{"MonoBehaviour":{"m_Enabled":true,"m_EditorHideFlags":0,"m_Name":"","m_EditorClassIdentifier":"","entries":[{"srpTarget":2,"UnityVersionMin":20194,"UnityVersionMax":20201,"shader":{"instanceID":0},"shaderSrc":"////////////////////////////////////////\n// Generated with Better Shaders\n//\n// Auto-generated shader code, don't hand edit!\n//\n//   Unity Version: 2020.3.0f1\n//   Render Pipeline: HDRP2019\n//   Platform: OSXEditor\n////////////////////////////////////////\n\n\nShader \"Hidden/Better Lit/Lit Alpha\"\n{\n   Properties\n   {\n      \n   [HideInInspector]_NoiseTex(\"Noise Texture\", 2D) = \"black\" {}\n\n\n    [HideInInspector]_MainTex(\"Unity Standard Shader Hack Property\", 2D) = \"white\" {} // use this to do material conversion.\n    [HideInInspector]_BaseColor(\"Unity HDRP/URP Shader Hack Property\", 2D) = \"white\" {} // use this to do material conversion.\n    [HideInInspector]_BumpMap(\"Unity Standard Shader Hack Property\", 2D) = \"bump\" {} // use this to do material conversion.\n    [HideInInspector]_IsConverted(\"Have we done one time conversion yet?\", Float) = 0\n    \n    _TriplanarSpace (\"Triplanar Space\", Float) = 0\n    _TriplanarContrast (\"Triplanar Contrast\", Range(1, 10)) = 4\n    _UVSource(\"UV Source\", Float) = 0\n    _AlbedoMap(\"Albedo/Height\", 2D) = \"white\" {}\n    _Tint (\"Tint\", Color) = (1, 1, 1, 1)\n    _AlbedoBrightness(\"Brightness\", Range(-1, 1)) = 0\n    _AlbedoContrast(\"Contrast\", Range(0,2)) = 1\n    _AlphaThreshold(\"Alpha Threshold\", Range(0,1)) = 0.0\n    _Cutoff(\"Unity Lightmapper sucks\", Range(0, 1)) = 0.0\n    _NormalMap(\"Normal\", 2D) = \"bump\" {}\n    _NormalStrength(\"Normal Strength\", Range(0,2)) = 1\n    \n    _MaskMap(\"Mask Map\", 2D) = \"black\" {}\n    _Smoothness(\"Smoothness\", Range(0,1)) = 0\n    _Metallic(\"Metallic\", Range(0,1)) = 0\n    _SpecularMap(\"Specular Map\", 2D) = \"black\" {}\n\n    _EmissionMap(\"Emission Map\", 2D) = \"black\" {}\n    _EmissionColor(\"Emission Strength\", Color) = (0,0,0,0)\n\n    _SmoothnessRemap(\"Smoothness Remap\", Vector) = (0, 1, 0, 0)\n    _AORemap(\"AO Remap\", Vector) = (0, 1, 0, 0)\n    _MetallicRemap(\"Metallic Remap\", Vector) = (0, 1, 0, 0)\n    _HeightRemap(\"Height Remap\", Vector) = (0, 1, 0, 0)\n\n    _DetailUVSource(\"Detail UV Source\", Float) = 0\n    _DetailMap(\"Detail Map\", 2D) = \"white\" {}\n    _DetailAlbedoStrength(\"Detail Albedo Strength\", Range(0, 2)) = 1\n    _DetailNormalStrength(\"Detail Normal Strength\", Range(0, 2)) = 1\n    _DetailSmoothnessStrength(\"Detail Smoothness Strength\", Range(0, 2)) = 1\n    _DetailTriplanarSpace (\"Triplanar Space\", Float) = 0\n    _DetailTriplanarContrast (\"Triplanar Contrast\", Range(1, 10)) = 4\n    _DetailStochasticContrast(\"Stochastic Contrast\", Range(0.01,0.999)) = 0.7\n    _DetailStochasticScale(\"Stochastic Contrast\", Range(0.2,1.5)) = 0.5\n    _FlatShadingBlend(\"Flat Shading Blend\", Range(0,4)) = 1\n    _StochasticContrast(\"Stochastic Contrast\", Range(0.01,0.999)) = 0.7\n    _StochasticScale(\"Stochastic Contrast\", Range(0.2,1.5)) = 0.5\n    _ParallaxHeight(\"Parallax Height\", Range(0, 0.25)) = 0\n\n    _MicroShadowStrength(\"Micro Shadow Strength\", Range(0, 2)) = 0\n    _FuzzyShadingOn(\"FuzzyShadingToggle\", Float) = 0\n    _FuzzyShadingColor(\"Fuzzy Shading Color\", Color) = (1,1,1,1)\n    _FuzzyShadingParams(\"Fuzzy Shading Params\", Vector) = (0.3,1,1.5,1) // coreMult, edgeMult, power\n\n    //_POMMaxSamples (\"POM Max Samples\", Range(4, 32)) = 8\n    //_POMMin (\"POM Min Distance\", Float) = 25\n    //_POMFade (\"Pom Fade Range\", Float) = 25\n\n\n\n\t_TintMask(\"Tint Mask\", 2D) = \"white\" {}\n\t_RColor(\"R Color\", Color) = (0.5,0.5,0.5,1)\n\t_GColor(\"G Color\", Color) = (0.5,0.5,0.5,1)\n\t_BColor(\"B Color\", Color) = (0.5,0.5,0.5,1)\n\t_AColor(\"A Color\", Color) = (0.5,0.5,0.5,1)\n\n\n\t_LayerTextureMask(\"Layer Texture Mask\", 2D) = \"white\" {}\n    _LayerTextureMaskUVMode(\"Layer Texture Mask UV Mode\", Float) = 0\n\n\n\t_LayerUVSource(\"Detail UV Source\", Float) = 0\n    [Enum(Multiply2X, 0, AlphaBlend, 1, HeightBlend, 2)]_LayerBlendMode(\"Layer Blend Mode\", Float) = 0\n    _LayerStrength(\"Layer Strength\", Range(0,2)) = 1\n    _LayerAlbedoStrength(\"Detail Albedo Strength\", Range(0, 2)) = 1\n    _LayerNormalStrength(\"Detail Normal Strength\", Range(0, 2)) = 1\n    _LayerSmoothnessRemap(\"Smoothness Remap\", Vector) = (0, 1, 0, 0)\n    _LayerAORemap(\"Occlusion Remap\", Vector) = (0, 1, 0, 0)\n    _LayerMetallicRemap(\"Metallic Remap\", Vector) = (0, 1, 0, 0)\n    _LayerSmoothness(\"Smoothness\", Range(0,1)) = 0\n    _LayerSmoothnessStrength(\"Smoothness Strength\", Range(0,1)) = 1\n    _LayerHeightRemap(\"Height Remap\", Vector) = (0, 1, 0, 0)\n    _LayerHeightContrast(\"Height Contrast\", Range(0.01, 0.99)) = 0.5\n    _LayerMetallic(\"Metallic\", Range(0,1)) = 0\n    _LayerScale(\"Detail UV Scale\", Float) = 3\n    _LayerTriplanarSpace (\"Triplanar Space\", Float) = 0\n    _LayerTriplanarContrast (\"Triplanar Contrast\", Range(1, 10)) = 4\n    _LayerAlbedoMap(\"Albedo/Height\", 2D) = \"white\" {}\n    _LayerNormalMap(\"Normal\", 2D) = \"bump\" {}\n    _LayerMaskMap(\"Mask Map\", 2D) = \"black\" {}\n    _LayerNoiseFrequency(\"Noise Frequency\", Float) = 1\n    _LayerNoiseAmplitude(\"Noise Amplitude\", Range(0,10)) = 0.5\n    _LayerNoiseOffset(\"Noise Offset\", Float) = 0\n    _LayerNoiseCenter(\"Noise Center\", Range(-5, 5)) = 0\n    _LayerStochasticContrast(\"Stochastic Contrast\", Range(0.01,0.999)) = 0.7\n    _LayerStochasticScale(\"Stochastic Scale\", Range(0.2,1.5)) = 0.5\n    _LayerBlendTint(\"Layer Blend Tint\", Color) = (1,1,1,1)\n    _LayerBlendContrast(\"Layer Blend Contrast\", Range(0.5, 8)) = 2\n    _LayerTint(\"Layer Tint\", Color) = (1,1,1,1)\n    _LayerAlbedoBrightness(\"Layer Brightness\", Range(-1, 1)) = 0\n    _LayerAlbedoContrast(\"Layer Contrast\", Range(0, 2)) = 1\n    _LayerEmissionMap(\"Layer Emission Map\", 2D) = \"black\" {}\n    _LayerEmissionColor(\"Layer Emission Multiplier\", Color) = (0,0,0,0)\n    _LayerAngleMin(\"Angle Minimum\", Range(0,1)) = 0.1\n    _LayerVertexNormalBlend(\"Vertex->Normal Filter\", Range(0,1)) = 0.8\n    _LayerHeight(\"Height Filter\", Range(0,1)) = 0\n    [Enum(Top,0,Bottom,1)] _LayerInvertHeight (\"Layer on\", Float) = 0\n    _LayerFalloff(\"Angle Falloff Contrast\", Range(2, 40)) = 8\n    _LayerTessStrength(\"Displacement Strength\", Range(0,1)) = 1\n    _LayerWeightOverDistance(\"Weight Over Distance\", Vector) = (1,1,1,1) // start distance/weight, end fade range/weight\n    _LayerMicroShadowStrength(\"Micro Shadow Strength\", Range(0,2)) = 0\n    _LayerFuzzyShadingOn(\"FuzzyShadingToggle\", Float) = 0\n    _LayerFuzzyShadingColor(\"Fuzzy Shading Color\", Color) = (1,1,1,1)\n    _LayerFuzzyShadingParams(\"Fuzzy Shading Params\", Vector) = (0.3,1,1.5,1) // coreMult, edgeMult, power\n\n\n\n\n\t_LayerUVSource_Ext_1(\"Detail UV Source\", Float) = 0\n    [Enum(Multiply2X, 0, AlphaBlend, 1, HeightBlend, 2)]_LayerBlendMode_Ext_1(\"Layer Blend Mode\", Float) = 0\n    _LayerStrength_Ext_1(\"Layer Strength\", Range(0,2)) = 1\n    _LayerAlbedoStrength_Ext_1(\"Detail Albedo Strength\", Range(0, 2)) = 1\n    _LayerNormalStrength_Ext_1(\"Detail Normal Strength\", Range(0, 2)) = 1\n    _LayerSmoothnessRemap_Ext_1(\"Smoothness Remap\", Vector) = (0, 1, 0, 0)\n    _LayerAORemap_Ext_1(\"Occlusion Remap\", Vector) = (0, 1, 0, 0)\n    _LayerMetallicRemap_Ext_1(\"Metallic Remap\", Vector) = (0, 1, 0, 0)\n    _LayerSmoothness_Ext_1(\"Smoothness\", Range(0,1)) = 0\n    _LayerSmoothnessStrength_Ext_1(\"Smoothness Strength\", Range(0,1)) = 1\n    _LayerHeightRemap_Ext_1(\"Height Remap\", Vector) = (0, 1, 0, 0)\n    _LayerHeightContrast_Ext_1(\"Height Contrast\", Range(0.01, 0.99)) = 0.5\n    _LayerMetallic_Ext_1(\"Metallic\", Range(0,1)) = 0\n    _LayerScale_Ext_1(\"Detail UV Scale\", Float) = 3\n    _LayerTriplanarSpace_Ext_1 (\"Triplanar Space\", Float) = 0\n    _LayerTriplanarContrast_Ext_1 (\"Triplanar Contrast\", Range(1, 10)) = 4\n    _LayerAlbedoMap_Ext_1(\"Albedo/Height\", 2D) = \"white\" {}\n    _LayerNormalMap_Ext_1(\"Normal\", 2D) = \"bump\" {}\n    _LayerMaskMap_Ext_1(\"Mask Map\", 2D) = \"black\" {}\n    _LayerNoiseFrequency_Ext_1(\"Noise Frequency\", Float) = 1\n    _LayerNoiseAmplitude_Ext_1(\"Noise Amplitude\", Range(0,10)) = 0.5\n    _LayerNoiseOffset_Ext_1(\"Noise Offset\", Float) = 0\n    _LayerNoiseCenter_Ext_1(\"Noise Center\", Range(-5, 5)) = 0\n    _LayerStochasticContrast_Ext_1(\"Stochastic Contrast\", Range(0.01,0.999)) = 0.7\n    _LayerStochasticScale_Ext_1(\"Stochastic Scale\", Range(0.2,1.5)) = 0.5\n    _LayerBlendTint_Ext_1(\"Layer Blend Tint\", Color) = (1,1,1,1)\n    _LayerBlendContrast_Ext_1(\"Layer Blend Contrast\", Range(0.5, 8)) = 2\n    _LayerTint_Ext_1(\"Layer Tint\", Color) = (1,1,1,1)\n    _LayerAlbedoBrightness_Ext_1(\"Layer Brightness\", Range(-1, 1)) = 0\n    _LayerAlbedoContrast_Ext_1(\"Layer Contrast\", Range(0, 2)) = 1\n    _LayerEmissionMap_Ext_1(\"Layer Emission Map\", 2D) = \"black\" {}\n    _LayerEmissionColor_Ext_1(\"Layer Emission Multiplier\", Color) = (0,0,0,0)\n    _LayerAngleMin_Ext_1(\"Angle Minimum\", Range(0,1)) = 0.1\n    _LayerVertexNormalBlend_Ext_1(\"Vertex->Normal Filter\", Range(0,1)) = 0.8\n    _LayerHeight_Ext_1(\"Height Filter\", Range(0,1)) = 0\n    [Enum(Top,0,Bottom,1)] _LayerInvertHeight_Ext_1 (\"Layer on\", Float) = 0\n    _LayerFalloff_Ext_1(\"Angle Falloff Contrast\", Range(2, 40)) = 8\n    _LayerTessStrength_Ext_1(\"Displacement Strength\", Range(0,1)) = 1\n    _LayerWeightOverDistance_Ext_1(\"Weight Over Distance\", Vector) = (1,1,1,1) // start distance/weight, end fade range/weight\n    _LayerMicroShadowStrength_Ext_1(\"Micro Shadow Strength\", Range(0,2)) = 0\n    _LayerFuzzyShadingOn_Ext_1(\"FuzzyShadingToggle\", Float) = 0\n    _LayerFuzzyShadingColor_Ext_1(\"Fuzzy Shading Color\", Color) = (1,1,1,1)\n    _LayerFuzzyShadingParams_Ext_1(\"Fuzzy Shading Params\", Vector) = (0.3,1,1.5,1) // coreMult, edgeMult, power\n\n\n\n\n\t_LayerUVSource_Ext_2(\"Detail UV Source\", Float) = 0\n    [Enum(Multiply2X, 0, AlphaBlend, 1, HeightBlend, 2)]_LayerBlendMode_Ext_2(\"Layer Blend Mode\", Float) = 0\n    _LayerStrength_Ext_2(\"Layer Strength\", Range(0,2)) = 1\n    _LayerAlbedoStrength_Ext_2(\"Detail Albedo Strength\", Range(0, 2)) = 1\n    _LayerNormalStrength_Ext_2(\"Detail Normal Strength\", Range(0, 2)) = 1\n    _LayerSmoothnessRemap_Ext_2(\"Smoothness Remap\", Vector) = (0, 1, 0, 0)\n    _LayerAORemap_Ext_2(\"Occlusion Remap\", Vector) = (0, 1, 0, 0)\n    _LayerMetallicRemap_Ext_2(\"Metallic Remap\", Vector) = (0, 1, 0, 0)\n    _LayerSmoothness_Ext_2(\"Smoothness\", Range(0,1)) = 0\n    _LayerSmoothnessStrength_Ext_2(\"Smoothness Strength\", Range(0,1)) = 1\n    _LayerHeightRemap_Ext_2(\"Height Remap\", Vector) = (0, 1, 0, 0)\n    _LayerHeightContrast_Ext_2(\"Height Contrast\", Range(0.01, 0.99)) = 0.5\n    _LayerMetallic_Ext_2(\"Metallic\", Range(0,1)) = 0\n    _LayerScale_Ext_2(\"Detail UV Scale\", Float) = 3\n    _LayerTriplanarSpace_Ext_2 (\"Triplanar Space\", Float) = 0\n    _LayerTriplanarContrast_Ext_2 (\"Triplanar Contrast\", Range(1, 10)) = 4\n    _LayerAlbedoMap_Ext_2(\"Albedo/Height\", 2D) = \"white\" {}\n    _LayerNormalMap_Ext_2(\"Normal\", 2D) = \"bump\" {}\n    _LayerMaskMap_Ext_2(\"Mask Map\", 2D) = \"black\" {}\n    _LayerNoiseFrequency_Ext_2(\"Noise Frequency\", Float) = 1\n    _LayerNoiseAmplitude_Ext_2(\"Noise Amplitude\", Range(0,10)) = 0.5\n    _LayerNoiseOffset_Ext_2(\"Noise Offset\", Float) = 0\n    _LayerNoiseCenter_Ext_2(\"Noise Center\", Range(-5, 5)) = 0\n    _LayerStochasticContrast_Ext_2(\"Stochastic Contrast\", Range(0.01,0.999)) = 0.7\n    _LayerStochasticScale_Ext_2(\"Stochastic Scale\", Range(0.2,1.5)) = 0.5\n    _LayerBlendTint_Ext_2(\"Layer Blend Tint\", Color) = (1,1,1,1)\n    _LayerBlendContrast_Ext_2(\"Layer Blend Contrast\", Range(0.5, 8)) = 2\n    _LayerTint_Ext_2(\"Layer Tint\", Color) = (1,1,1,1)\n    _LayerAlbedoBrightness_Ext_2(\"Layer Brightness\", Range(-1, 1)) = 0\n    _LayerAlbedoContrast_Ext_2(\"Layer Contrast\", Range(0, 2)) = 1\n    _LayerEmissionMap_Ext_2(\"Layer Emission Map\", 2D) = \"black\" {}\n    _LayerEmissionColor_Ext_2(\"Layer Emission Multiplier\", Color) = (0,0,0,0)\n    _LayerAngleMin_Ext_2(\"Angle Minimum\", Range(0,1)) = 0.1\n    _LayerVertexNormalBlend_Ext_2(\"Vertex->Normal Filter\", Range(0,1)) = 0.8\n    _LayerHeight_Ext_2(\"Height Filter\", Range(0,1)) = 0\n    [Enum(Top,0,Bottom,1)] _LayerInvertHeight_Ext_2 (\"Layer on\", Float) = 0\n    _LayerFalloff_Ext_2(\"Angle Falloff Contrast\", Range(2, 40)) = 8\n    _LayerTessStrength_Ext_2(\"Displacement Strength\", Range(0,1)) = 1\n    _LayerWeightOverDistance_Ext_2(\"Weight Over Distance\", Vector) = (1,1,1,1) // start distance/weight, end fade range/weight\n    _LayerMicroShadowStrength_Ext_2(\"Micro Shadow Strength\", Range(0,2)) = 0\n    _LayerFuzzyShadingOn_Ext_2(\"FuzzyShadingToggle\", Float) = 0\n    _LayerFuzzyShadingColor_Ext_2(\"Fuzzy Shading Color\", Color) = (1,1,1,1)\n    _LayerFuzzyShadingParams_Ext_2(\"Fuzzy Shading Params\", Vector) = (0.3,1,1.5,1) // coreMult, edgeMult, power\n\n\n\n\n    [Toggle] _Trax(\"Enable Trax\", Float) = 0\n    _TraxAlbedo(\"Trax Albedo\", 2D) = \"white\" {}\n    _TraxPackedNormal(\"Trax Packed Normal\", 2D) = \"bump\" {}\n    _TraxNormalStrength(\"Normal Strength\", Range(0,2)) = 1\n    _TraxDisplacementDepth(\"Trax Depression Depth\", Float) = 0.1\n    _TraxDisplacementStrength(\"Trax Displacement\", Range(0,3)) = 0.2\n    _TraxMipBias(\"Trax Mip Bias\", Range(0, 5)) = 3\n    _TraxInterpContrast(\"Interpolation Contrast\", Range(0,1)) = 0.9\n    _TraxHeightContrast(\"Height Contrast\", Range(0,1)) = 0.5\n    _TraxTint(\"Tint Color\", Color) = (1,1,1,1)\n\n\n   _WetnessMode(\"Wetness Mode\", Int) = 0\n   _PuddleMode(\"Puddle Mode\", Int) = 0\n   _RainMode(\"Rain Mode\", Int) = 0\n   _WetnessAmount(\"Wetness Amount\", Range(0,1)) = 0\n   _Porosity(\"Porosity\", Range(0,1)) = 0.4\n   _WetnessMin(\"Minimum Wetness\", Range(0,1)) = 0\n   _WetnessMax(\"Maximum Wetness\", Range(0,1)) = 1\n   _WetnessFalloff(\"Angle Falloff\", Range(0,1)) = 1\n   _WetnessAngleMin(\"Wetness Minimum Angle\", Range(-1,1)) = -1\n   _PuddleAmount(\"Puddle Amount\", Range(0,1)) = 0\n   _PuddleFalloff(\"Puddle Contrast\", Range(2, 50)) = 12\n   _PuddleAngleMin(\"Moss Angle Minimum\", Range(0,1)) = 0.1\n   _PuddleColor(\"Puddle Color\", Color) = (0.2, 0.2, 0.2, 0.7)\n   _PuddleNoiseFrequency(\"Noise Frequency\", Float) = 1\n   _PuddleNoiseAmplitude(\"Noise Amplitude\", Range(0,10)) = 0.5\n   _PuddleNoiseCenter(\"Noise Center\", Range(-5, 5)) = 0\n   _PuddleNoiseOffset(\"Noise Offset\", Float) = 0\n   _RainDropTexture(\"RainDrop Texture\", 2D) = \"white\" {}\n   _RainIntensityScale(\"Intensity/Scale/MinWet\", Vector) = (1, 25, 0, 0)\n   _WetnessShoreline(\"Wetness Shore Height\", Float) = -99999\n\n\n    _SnowMode(\"Snow Mode\", Int) = 0\n    _SnowAlbedo(\"Snow Albedo\", 2D) = \"white\" {}\n    _SnowTint(\"Snow Trax Albedo\", Color) = (1,1,1,1)\n    _SnowNormal(\"Snow Normal\", 2D) = \"bump\" {}\n    _SnowMaskMap(\"Snow Mask Map\", 2D) = \"black\" {}\n    _SnowAmount(\"Snow Amount\", Range(0,1)) = 1\n    _SnowAngle(\"Snow Angle Falloff\", Range(0,2)) = 1\n    _SnowContrast(\"Snow Contrast\", Range(0.5, 4)) = 1.5\n    _SnowVertexHeight(\"Snow Vertex Height\", Range(0,1)) = 0.05\n    _SnowWorldFade(\"Snow Height Fade\", Vector) = (100, 50, 0, 0)\n    _SnowTraxAlbedo(\"Snow Trax Albedo\", 2D) = \"white\" {}\n    _SnowTraxTint(\"Snow Trax Albedo\", Color) = (1,1,1,1)\n    _SnowTraxNormal(\"Snow Trax Normal\", 2D) = \"bump\" {}\n    _SnowTraxMaskMap(\"Snow Trax Mask Map\", 2D) = \"black\" {}\n    _SnowNoiseFreq(\"Snow Noise Frequency\", Float) = 1\n    _SnowNoiseAmp(\"Snow Noise Amplitude\", Float) = 1\n    _SnowNoiseOffset(\"Snow Noise Offset\", Float) = 0\n    _SnowStochasticContrast(\"Snow Stochastic Contrast\", Range(0.01, 0.99)) = 0.7\n    _SnowStochasticScale(\"Snow Stochastic Scale\", Range(0,2)) = 1\n\n\n   [BetterHeader(Wind Particulate)]\n   [Toggle] _Wind(\"Enable Wind\", Float) = 0\n   [Enum(World, 0, UV, 1)]_WindParticulateSpace(\"Wind UV Source\", Float) = 0\n   _WindParticulate(\"Wind Texture\", 2D) = \"black\" {}\n   _WindParticulateStrength(\"Strength\", Range(0, 3)) = 2\n   _WindParticulateSpeed(\"Speed\", Float) = 1\n   _WindParticulatePower(\"Contrast\", Range(0.2, 6)) = 1\n   _WindParticulateRotation(\"Rotation\", Float) = 0\n   _WindParticulateColor(\"Color, strength\", Color) = (1, 1, 1, 1)\n   _WindParticulateWorldHeightMask(\"Wind Height Mask\", Vector) = (-99999, -99999, 99999, 99999)\n   _WindParticulateTextureHeight(\"Wind Texture Height\", Range(0,1)) = 1\n   _WindParticulateAngleMask(\"Wind Angle Mask\", Vector) = (-1, -1, 1, 1)\n   _WindParticulateOcclusionStrength(\"Wind Occlusion Strength\", Range(0,1)) = 1\n   _WindParticulateEmissive(\"Wind Emissive\", Color) = (0,0,0,0)\n\n\n   [Enum(Off,0,Front,1,Back,2)]_CullMode(\"Culling Mode\", Float) = 2\n   [Enum(Flip, 0, Mirror, 1, None, 2)] _DoubleSidedNormalMode(\"Double sided normal mode\", Float) = 1\n\n\n   _AutoNormalStrength(\"Auto Normal Strength\", Range(0,2)) = 0.5\n\n\n\t_DebugSampleCountThreshold (\"Debug Sample Threshold\", Int) = 12\n\n\n\t[Toggle(_DISSOLVE)] _DissolveEnabled (\"Enable Dissolve\", Float) = 0\n    _DissolveAmount(\"Dissolve Amount\", Range(0,1)) = 0\n\t_DissolveTexture(\"Dissolve Texture\", 2D) = \"black\" {}\n    _DissolveGradient(\"Dissolve Gradient\", 2D) = \"white\" {}\n\t_DissolveColoration(\"Dissolve Coloration\", Range(0,1)) = 1\n\t_DissolveEdgeContrast(\"Dissolve Edge Contrast\", Range(2, 128)) = 10\n    _DissolveEmissiveStr(\"Dissolve Emissive Strength\", Range(0,4)) = 0\n\n\n\n\n\n\n\t[BetterHeader(Bakery)]\n    [Toggle(USEBAKERY)] _USEBAKERY (\"Enabled Bakery\", Float) = 0\n\t[KeywordEnum(Standard, RNM, SH, Vertex, VertexDirectional, VertexSH)] _LightmapMode (\"Lightmapping mode\", Float) = 0\n    [Toggle(BAKERY_VERTEXLMMASK)] _BAKERY_VERTEXLMMASK (\"Enable vertex shadowmask\", Float) = 0\n    [Toggle(BAKERY_SHNONLINEAR)] _BAKERY_SHNONLINEAR (\"SH non-linear mode\", Float) = 1\n    [Toggle(BAKERY_LMSPEC)] _BAKERY_LMSPEC (\"Enable Lightmap Specular\", Float) = 0\n    [Toggle(BAKERY_BICUBIC)] _BAKERY_BICUBIC (\"Enable Bicubic Filter\", Float) = 0\n    [Toggle(BAKERY_VOLUME)] _BAKERY_VOLUME (\"Use volumes\", Float) = 0\n    [Toggle(BAKERY_VOLROTATION)] _BAKERY_VOLROTATION (\"Allow volume rotation\", Float) = 0\n\n\n\n\n\n   _IsAlpha(\"Not Used or set, just so the editor knows we are an alpha shader\", Float) = 0\n\n\n\n      [HideInInspector] _StencilRef(\"Vector1 \", Int) = 0\n      [HideInInspector] _StencilWriteMask(\"Vector1 \", Int) = 3\n      [HideInInspector] _StencilRefDepth(\"Vector1 \", Int) = 0\n      [HideInInspector] _StencilWriteMaskDepth(\"Vector1 \", Int) = 32\n      [HideInInspector] _StencilRefMV(\"Vector1 \", Int) = 128\n      [HideInInspector] _StencilWriteMaskMV(\"Vector1 \", Int) = 128\n      [HideInInspector] _StencilRefDistortionVec(\"Vector1 \", Int) = 64\n      [HideInInspector] _StencilWriteMaskDistortionVec(\"Vector1 \", Int) = 64\n      [HideInInspector] _StencilWriteMaskGBuffer(\"Vector1 \", Int) = 3\n      [HideInInspector] _StencilRefGBuffer(\"Vector1 \", Int) = 2\n      [HideInInspector] _ZTestGBuffer(\"Vector1 \", Int) = 4\n      [HideInInspector] [ToggleUI] _RequireSplitLighting(\"Boolean\", Float) = 0\n      [HideInInspector] [ToggleUI] _ReceivesSSR(\"Boolean\", Float) = 1\n      [HideInInspector] _SurfaceType(\"Vector1 \", Float) = 0\n      [HideInInspector] [ToggleUI] _ZWrite(\"Boolean\", Float) = 0\n      [HideInInspector] _TransparentSortPriority(\"Vector1 \", Int) = 0\n      [HideInInspector] _ZTestDepthEqualForOpaque(\"Vector1 \", Int) = 4\n      [HideInInspector] [Enum(UnityEngine.Rendering.CompareFunction)] _ZTestTransparent(\"Vector1\", Float) = 4\n      [HideInInspector] [ToggleUI] _TransparentBackfaceEnable(\"Boolean\", Float) = 0\n      [HideInInspector] [ToggleUI] _AlphaCutoffEnable(\"Boolean\", Float) = 0\n      [HideInInspector] [ToggleUI] _UseShadowThreshold(\"Boolean\", Float) = 0\n      [HideInInspector] _BlendMode(\"Float\", Float) = 0\n   }\n   SubShader\n   {\n      Tags { \"RenderPipeline\"=\"HDRenderPipeline\" \"RenderPipeline\" = \"HDRenderPipeline\" \"RenderType\" = \"HDLitShader\" \"Queue\" = \"Transparent\" }\n\n      \n              Pass\n        {\n            // based on HDLitPass.template\n            Name \"Forward\"\n            Tags { \"LightMode\" = \"Forward\" }\n\n            Blend SrcAlpha OneMinusSrcAlpha, One OneMinusSrcAlpha\nCull Back\n ZTest LEqual\nZWrite Off\n            \n        \n            \n            // Stencil setup\n        Stencil\n        {\n           WriteMask [_StencilWriteMask]\n           Ref [_StencilRef]\n           Comp Always\n           Pass Replace\n        }\n        \n            ColorMask [_ColorMaskTransparentVel] 1\n\n               Cull [_CullMode]\n\n            \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 ps4 xboxone vulkan metal switch\n            //#pragma enable_d3d11_debug_symbols\n        \n            #pragma multi_compile_instancing\n        \n            //#pragma multi_compile_local _ _ALPHATEST_ON\n        \n            // #pragma multi_compile _ LOD_FADE_CROSSFADE\n        \n            //#pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADDITIVE _BLENDMODE_PRE_MULTIPLY\n        \n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            // #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            #define SHADERPASS SHADERPASS_FORWARD\n            #define _PASSFORWARD 1\n            \n            \n\n\n   #pragma shader_feature_local_fragment _ _PACKEDFAST\n   #pragma shader_feature_local _ _TRIPLANAR\n   #pragma shader_feature_local_fragment _ _NORMALMAP \n   #pragma shader_feature_local_fragment _ _MASKMAP\n   #pragma shader_feature_local_fragment _ _DETAIL\n   #pragma shader_feature_local_fragment _ _DETAILTRIPLANAR\n   #pragma shader_feature_local_fragment _ _DETAILSTOCHASTIC\n   #pragma shader_feature_local_fragment _ _EMISSION\n   #pragma shader_feature_local_fragment _ _FLATSHADE\n   #pragma shader_feature_local _ _STOCHASTIC\n   #pragma shader_feature_local_fragment _ _PARALLAX //_POM\n   #pragma shader_feature_local_fragment _ _SPECULAR\n   #pragma shader_feature_local _ _NOISEWORLD _NOISELOCAL\n   #pragma shader_feature_local _ _NOISEHQ _NOISETEXTURE _NOISEWORLEY\n   // only for URP/Standard Forward\n   #pragma shader_feature_local_fragment _ _SIMPLELIT\n\n\n   #pragma shader_feature_local_fragment _ _TINTMASK\n\n\n    #pragma shader_feature_local _ _LAYERVERTEXMASK _LAYERTEXTUREMASK\n\n    #define _HAS_WEIGHTTEXTURE_MASK 1\n\n\n   #pragma shader_feature_local _ _USELAYER\n   #pragma shader_feature_local _ _LAYERTRIPLANAR\n   #pragma shader_feature_local _ _LAYERALBEDO\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL\n   #pragma shader_feature_local _ _LAYERMASK\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION\n   #pragma shader_feature_local _ _LAYERNOISE\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC\n   #pragma shader_feature_local _ _LAYERANGLEFILTER\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_1\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_1\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_1\n   #pragma shader_feature_local _ _LAYERMASK_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_1\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_1\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_1\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_1\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_2\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_2\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_2\n   #pragma shader_feature_local _ _LAYERMASK_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_2\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_2\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_2\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_2\n\n\n   #pragma shader_feature_local _ _TRAX_ON\n\n\n   #pragma shader_feature_local_fragment _ _WETNESS\n   #pragma shader_feature_local_fragment _ _PUDDLES\n   #pragma shader_feature_local_fragment _ _PUDDLENOISE\n   #pragma shader_feature_local_fragment _ _RAINDROPS\n\n\n   #pragma shader_feature_local _ _SNOW\n   #pragma shader_feature_local _ _SNOWMASKMAP\n   #pragma shader_feature_local _ _SNOWNOISE\n   #pragma shader_feature_local_fragment _SNOWSTOCHASTIC\n\n\n   #pragma shader_feature_local_fragment _ _WIND_ON\n\n\n\n\n   #pragma shader_feature_local_fragment _ _SURFACEGRADIENT _AUTONORMAL\n   #define _WORLDSPACENORMAL 1\n\n\n   #pragma shader_feature_local _ _DEBUG_SAMPLECOUNT\n\n\n\t#pragma shader_feature_local_fragment _ _DISSOLVE\n\n\n   #pragma multi_compile_local  LOD_FADE_CROSSFADE\n\n\n\n#pragma instancing_options procedural:setupVSPro forwardadd\n\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\nstruct IndirectShaderData\n{\n\tfloat4x4 PositionMatrix;\n\tfloat4x4 InversePositionMatrix;\n\tfloat4 ControlData;\n};\n\n#if defined(SHADER_API_GLCORE) || defined(SHADER_API_D3D11) || defined(SHADER_API_GLES3) || defined(SHADER_API_METAL) || defined(SHADER_API_VULKAN) || defined(SHADER_API_PSSL) || defined(SHADER_API_XBOXONE)\n\tuniform StructuredBuffer<IndirectShaderData> VisibleShaderDataBuffer;\n#endif\n\n#endif\n\nfloat VSPRenderingLayerMask;\n\nvoid setupVSPro()\n{\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\n    #if _HDRP\n\t    unity_RenderingLayer.x = VSPRenderingLayerMask;\n    #endif\n\n\t#ifdef unity_ObjectToWorld\n\t#undef unity_ObjectToWorld\n\t#endif\n\n\t#ifdef unity_WorldToObject\n\t#undef unity_WorldToObject\n\t#endif\n\n\tunity_ObjectToWorld = VisibleShaderDataBuffer[unity_InstanceID].PositionMatrix;\n\tunity_WorldToObject = VisibleShaderDataBuffer[unity_InstanceID].InversePositionMatrix;\n#endif\n\n}\n\n\n\t#pragma multi_compile _LIGHTMAPMODE_STANDARD _LIGHTMAPMODE_RNM _LIGHTMAPMODE_SH _LIGHTMAPMODE_VERTEX _LIGHTMAPMODE_VERTEXDIRECTIONAL _LIGHTMAPMODE_VERTEXSH\n\n    #pragma shader_feature USEBAKERY\n    #pragma shader_feature BAKERY_VERTEXLMMASK\n    #pragma shader_feature BAKERY_SHNONLINEAR\n    #pragma shader_feature BAKERY_LMSPEC\n    #pragma shader_feature BAKERY_BICUBIC\n    #pragma shader_feature BAKERY_VOLUME\n    #pragma shader_feature BAKERY_VOLROTATION\n    #pragma shader_feature BAKERY_COMPRESSED_VOLUME\n\n    #if _USEBAKERY\n\t    #define _OVERRIDE_BAKEDGI\n        #if BAKERY_VOLUME || (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)) && defined(BAKERY_VERTEXLMMASK)\n            #define _OVERRIDE_SHADOWMASK\n        #endif\n    #endif\n\n\n\n\n\n\n\n\n   #define _HDRP 1\n#define _BLENDMODE_ALPHA 1\n#define _SURFACE_TYPE_TRANSPARENT 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            \n            #pragma multi_compile _ DEBUG_DISPLAY\n            #pragma multi_compile _ LIGHTMAP_ON\n            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n            #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n            #pragma multi_compile _ SHADOWS_SHADOWMASK\n            #pragma multi_compile DECALS_OFF DECALS_3RT DECALS_4RT\n            #pragma multi_compile USE_FPTL_LIGHTLIST USE_CLUSTERED_LIGHTLIST\n            #pragma multi_compile SHADOW_LOW SHADOW_MEDIUM SHADOW_HIGH\n            #define REQUIRE_DEPTH_TEXTURE\n            \n\n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n            #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n        \n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n        \n            // define FragInputs structure\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n               #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\"\n            #endif\n\n\n        \n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n        #ifdef DEBUG_DISPLAY\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n        #endif\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n        \n        #if (SHADERPASS == SHADERPASS_FORWARD)\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n        \n            #define HAS_LIGHTLOOP\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n        #else\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n        #endif\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n        \n            // Used by SceneSelectionPass\n            int _ObjectId;\n            int _PassValue;\n        \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCCOORD3;\n               float4 texcoord1 : TEXCCOORD4;\n               float4 texcoord2 : TEXCCOORD5;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n               // float4 texcoord3 : TEXCCOORD6;\n                #endif\n\n                #if LOD_FADE_CROSSFADE\n                float4 screenPos : TEXCOORD7;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR_centroid;\n                #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                float4 extraV2F4 : TEXCOORD12_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                float4 extraV2F5 : TEXCOORD13_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F6 : TEXCOORD14_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F7 : TEXCOORD15_centroid;\n                #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n\n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n   half4 weightTextureMask;\n   \n\n\n   float traxBuffer;\n\n\n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // would love to strip these, but they are used in certain\n               // combinations of the lighting system, and may be used\n               // by the user as well, so no easy way to strip them.\n\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR_centroid;\n                #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                float4 extraV2F4 : TEXCOORD9_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                float4 extraV2F5 : TEXCOORD10_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F6 : TEXCOORD11_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F7 : TEXCOORD12_centroid;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n               #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n               #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n               #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n               #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()     unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n               #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V   unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n               #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V    mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n               #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n               #endif\n               #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _StencilRef;\n               float _StencilWriteMask;\n               float _StencilRefDepth;\n               float _StencilWriteMaskDepth;\n               float _StencilRefMV;\n               float _StencilWriteMaskMV;\n               float _StencilRefDistortionVec;\n               float _StencilWriteMaskDistortionVec;\n               float _StencilWriteMaskGBuffer;\n               float _StencilRefGBuffer;\n               float _ZTestGBuffer;\n               float _RequireSplitLighting;\n               float _ReceivesSSR;\n               float _ZWrite;\n               float _TransparentSortPriority;\n               float _ZTestDepthEqualForOpaque;\n               float _ZTestTransparent;\n               float _TransparentBackfaceEnable;\n               float _AlphaCutoffEnable;\n               float _UseShadowThreshold;\n\n               \n\n\n   half4 _Tint;\n   half _UVSource;\n   half _TriplanarContrast;\n   half _AlbedoContrast;\n   half _AlbedoBrightness;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half3 _EmissionColor;\n   float _DetailUVSource;\n   half _StochasticScale;\n   half _DetailStochasticScale;\n   half _Smoothness;\n   half _Metallic;\n   half2 _SmoothnessRemap;\n   half2 _AORemap;\n   half2 _MetallicRemap;\n   half2 _HeightRemap;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n   half _AlphaThreshold;\n   half _Cutoff; // for Unity's light mapper\n   half _TriplanarSpace;\n   half _DetailTriplanarSpace;\n   half _DetailTriplanarContrast;\n   half _MicroShadowStrength;\n   half3 _FuzzyShadingColor;\n   half _FuzzyShadingOn;\n   half3 _FuzzyShadingParams;\n\n   //int _POMMaxSamples;\n   //float _POMMin;\n   //float _POMFade;\n#if _FLATSHADE\n   half _FlatShadingBlend;\n#endif\n\n   half _StochasticContrast;\n   half _DetailStochasticContrast;\n\n#if _PARALLAX || _POM\n   half _ParallaxHeight;\n#endif\n\n\n\n\tfloat4 _TintMask_ST;\n\thalf3 _RColor;\n\thalf3 _GColor;\n\thalf3 _BColor;\n\thalf3 _AColor;\n\n\n\thalf _LayerTextureMaskUVMode;\n    float4 _LayerTextureMask_ST;\n\n\n   //#if _USELAYER\n       float4 _LayerAlbedoMap_ST;\n       half3 _LayerTint;\n       half _LayerBlendMode;\n       float _LayerUVSource;\n       half _LayerAlbedoBrightness;\n       half _LayerAlbedoContrast;\n       half _LayerHeightContrast;\n       half _LayerStrength;\n       half _LayerAlbedoStrength;\n       half _LayerNormalStrength;\n       half _LayerSmoothnessStrength;\n       half _LayerSmoothness;\n       half _LayerMetallic;\n       half _LayerStochasticScale;\n       half2 _LayerSmoothnessRemap;\n       half2 _LayerAORemap;\n       half2 _LayerMetallicRemap;\n       half2 _LayerHeightRemap;\n       float4 _LayerWeightOverDistance;\n       half _LayerMicroShadowStrength;\n       //#if _LAYERNOISE\n           float _LayerNoiseFrequency;\n           float _LayerNoiseAmplitude;\n           float _LayerNoiseOffset;\n           float _LayerNoiseCenter;\n           half3 _LayerBlendTint;\n       //#endif\n       //#if _LAYERANGLEFILTER\n           half _LayerFalloff;\n           half _LayerAngleMin;\n           half _LayerHeight;\n           half _LayerInvertHeight;\n           half _LayerVertexNormalBlend;\n       //#endif\n       half _LayerTriplanarSpace;\n       half _LayerTriplanarContrast;\n       half _LayerBlendContrast;\n       half3 _LayerEmissionColor;\n       half _LayerStochasticContrast;\n       half _LayerTessStrength;\n       half3 _LayerFuzzyShadingColor;\n       half _LayerFuzzyShadingOn;\n       half3 _LayerFuzzyShadingParams;\n   //#endif\n\n\n   //#if _USELAYER_DEF_1\n       float4 _LayerAlbedoMap_Ext_1_ST;\n       half3 _LayerTint_Ext_1;\n       half _LayerBlendMode_Ext_1;\n       float _LayerUVSource_Ext_1;\n       half _LayerAlbedoBrightness_Ext_1;\n       half _LayerAlbedoContrast_Ext_1;\n       half _LayerHeightContrast_Ext_1;\n       half _LayerStrength_Ext_1;\n       half _LayerAlbedoStrength_Ext_1;\n       half _LayerNormalStrength_Ext_1;\n       half _LayerSmoothnessStrength_Ext_1;\n       half _LayerSmoothness_Ext_1;\n       half _LayerMetallic_Ext_1;\n       half _LayerStochasticScale_Ext_1;\n       half2 _LayerSmoothnessRemap_Ext_1;\n       half2 _LayerAORemap_Ext_1;\n       half2 _LayerMetallicRemap_Ext_1;\n       half2 _LayerHeightRemap_Ext_1;\n       float4 _LayerWeightOverDistance_Ext_1;\n       half _LayerMicroShadowStrength_Ext_1;\n       //#if _LAYERNOISE_DEF_1\n           float _LayerNoiseFrequency_Ext_1;\n           float _LayerNoiseAmplitude_Ext_1;\n           float _LayerNoiseOffset_Ext_1;\n           float _LayerNoiseCenter_Ext_1;\n           half3 _LayerBlendTint_Ext_1;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_1\n           half _LayerFalloff_Ext_1;\n           half _LayerAngleMin_Ext_1;\n           half _LayerHeight_Ext_1;\n           half _LayerInvertHeight_Ext_1;\n           half _LayerVertexNormalBlend_Ext_1;\n       //#endif\n       half _LayerTriplanarSpace_Ext_1;\n       half _LayerTriplanarContrast_Ext_1;\n       half _LayerBlendContrast_Ext_1;\n       half3 _LayerEmissionColor_Ext_1;\n       half _LayerStochasticContrast_Ext_1;\n       half _LayerTessStrength_Ext_1;\n       half3 _LayerFuzzyShadingColor_Ext_1;\n       half _LayerFuzzyShadingOn_Ext_1;\n       half3 _LayerFuzzyShadingParams_Ext_1;\n   //#endif\n\n\n   //#if _USELAYER_DEF_2\n       float4 _LayerAlbedoMap_Ext_2_ST;\n       half3 _LayerTint_Ext_2;\n       half _LayerBlendMode_Ext_2;\n       float _LayerUVSource_Ext_2;\n       half _LayerAlbedoBrightness_Ext_2;\n       half _LayerAlbedoContrast_Ext_2;\n       half _LayerHeightContrast_Ext_2;\n       half _LayerStrength_Ext_2;\n       half _LayerAlbedoStrength_Ext_2;\n       half _LayerNormalStrength_Ext_2;\n       half _LayerSmoothnessStrength_Ext_2;\n       half _LayerSmoothness_Ext_2;\n       half _LayerMetallic_Ext_2;\n       half _LayerStochasticScale_Ext_2;\n       half2 _LayerSmoothnessRemap_Ext_2;\n       half2 _LayerAORemap_Ext_2;\n       half2 _LayerMetallicRemap_Ext_2;\n       half2 _LayerHeightRemap_Ext_2;\n       float4 _LayerWeightOverDistance_Ext_2;\n       half _LayerMicroShadowStrength_Ext_2;\n       //#if _LAYERNOISE_DEF_2\n           float _LayerNoiseFrequency_Ext_2;\n           float _LayerNoiseAmplitude_Ext_2;\n           float _LayerNoiseOffset_Ext_2;\n           float _LayerNoiseCenter_Ext_2;\n           half3 _LayerBlendTint_Ext_2;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_2\n           half _LayerFalloff_Ext_2;\n           half _LayerAngleMin_Ext_2;\n           half _LayerHeight_Ext_2;\n           half _LayerInvertHeight_Ext_2;\n           half _LayerVertexNormalBlend_Ext_2;\n       //#endif\n       half _LayerTriplanarSpace_Ext_2;\n       half _LayerTriplanarContrast_Ext_2;\n       half _LayerBlendContrast_Ext_2;\n       half3 _LayerEmissionColor_Ext_2;\n       half _LayerStochasticContrast_Ext_2;\n       half _LayerTessStrength_Ext_2;\n       half3 _LayerFuzzyShadingColor_Ext_2;\n       half _LayerFuzzyShadingOn_Ext_2;\n       half3 _LayerFuzzyShadingParams_Ext_2;\n   //#endif\n\n\n    half _TraxDisplacementDepth;\n    half _TraxDisplacementStrength;\n    half _TraxMipBias;\n    half _TraxNormalStrength;\n    float4 _TraxAlbedo_ST;\n    half _TraxInterpContrast;\n    half _TraxHeightContrast;\n    half3 _TraxTint;\n\n\n\n    half _Porosity;\n    int _WetnessMode;\n    int _PuddleMode;\n\n    half  _PuddleAmount;\n    half  _PuddleFalloff;\n    half4 _PuddleColor;\n    half _PuddleNoiseFrequency;\n    half _PuddleNoiseAmplitude;\n    half _PuddleNoiseOffset;\n    half _PuddleNoiseCenter;\n    half _PuddleAngleMin;\n\n    half _WetnessAmount;\n\thalf _WetnessMin;\n    half _WetnessMax;\n    half _WetnessFalloff;\n\thalf _WetnessAngleMin;\n    float _WetnessShoreline;\n\n    int _RainMode;\n    half3 _RainIntensityScale;\n\n\n\n\n    float4 _SnowAlbedo_ST;\n    half3 _SnowTint;\n    half _SnowAmount;\n    half _SnowAngle;\n    half _SnowContrast;\n    half _SnowVertexHeight;\n    half _SnowMode;\n    half3 _SnowWorldFade; // z is on/off\n    float4 _SnowTraxAlbedo_ST;\n    half3 _SnowTraxTint;\n\n    half _SnowNoiseFreq; \n    half _SnowNoiseAmp;\n    half _SnowNoiseOffset;\n    half _SnowStochasticContrast;\n    half _SnowStochasticScale;\n\n\n    half     _WindParticulateSpace;\n    half     _WindParticulateRotation;\n    half      _WindParticulateSpeed;\n    float4     _WindParticulate_ST;\n    half      _WindParticulatePower;\n    half4    _WindParticulateColor;\n    half4    _WindParticulateWorldHeightMask;\n    half4    _WindParticulateAngleMask;\n    half      _WindParticulateOcclusionStrength;\n    half      _WindParticulateStrength;\n    half4    _WindParticulateEmissive;\n    half     _WindParticulateTextureHeight;\n\n\n   float _DoubleSidedNormalMode;\n\n\n\thalf _AutoNormalStrength;\n\n\n\tint _DebugSampleCountThreshold;\n\n\n\thalf _DissolveAmount;\n\thalf _DissolveEmissiveStr;\n\thalf _DissolveEdgeContrast;\n\thalf _DissolveColoration;\n\tfloat4 _DissolveTexture_ST;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n\n            \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\n#ifndef __STACKABLEFUNCLIBRARY_INCLUDES__\n#define __STACKABLEFUNCLIBRARY_INCLUDES__\n\n   #if _DEBUG_SAMPLECOUNT\n      int _sampleCount;\n      #define COUNTSAMPLE { _sampleCount++; }\n   #else\n      #define COUNTSAMPLE\n   #endif\n\n   TEXTURE2D(_NoiseTex);\n   SAMPLER(sampler_NoiseTex);\n\n\n\n   half3 AdjustContrast(half3 color, half contrast)\n   {\n       half3 comp = 0.5;\n   #if !UNITY_COLORSPACE_GAMMA\n       comp = 0.22;\n   #endif\n       color = saturate(lerp(comp, color, contrast));\n       return color;\n   }\n\n   float2 DoParallaxOffset( half h, half height, half3 viewDir)\n   {\n      h = h * height - height/2.0;\n      float3 v = normalize(viewDir);\n      v.z += 0.42;\n      return h * (v.xy / v.z);\n   }\n\n\n\n   #define SAMPLEBARY SampleTexBary\n\n   struct SampleConfig\n   {\n      float2 uv0;\n      float2 uv1;\n      float2 uv2;\n      float2 dx0;\n      float2 dy0;\n      float2 dx1;\n      float2 dy1;\n      float2 dx2;\n      float2 dy2;\n      float3 weights;\n      float3 origWeights;\n   };\n\n   struct Config\n   {\n      float2 origUV; // unscaled uv\n      float2 origScale;\n      float2 uv;        // no stocastic or triplanar\n      float2 dx;\n      float2 dy;\n      SampleConfig uvT; // just stochastic, or just triplanar\n      SampleConfig uvX; // stochastic and triplanar\n      SampleConfig uvY;\n      SampleConfig uvZ;\n\n      \n      float3 absVertNormal;\n      half3 axisSign;\n      float3 normal;\n   };\n\n\n    float2 Hash2D( float2 x )\n    {\n        float2 k = float2( 0.3183099, 0.3678794 );\n        x = x*k + k.yx;\n        return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );\n    }\n\n    float Noise2D(float2 p )\n    {\n        float2 i = floor( p );\n        float2 f = frac( p );\n         \n        float2 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), \n                        dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),\n                    lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), \n                        dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);\n    }\n      \n\n    float2 WorleyHash2D(float2 p)\n    {\n \t    return frac(cos(mul(p, float2x2(-64.2,71.3,81.4,-29.8)))*8321.3); \n    }\n    float WorleyNoise2D(float2 p)\n    {\n        float dist = 1;\n        float2 i = floor(p);\n        float2 f = frac(p);\n    \n        for(int x = -1;x<=1;x++)\n        {\n            for(int y = -1;y<=1;y++)\n            {\n                float d = distance(WorleyHash2D(i+float2(x,y))+float2(x,y),f);\n                dist = min(dist,d);\n            }\n        }\n        return dist;\n\t\n    }\n\n#ifndef PI\n    #define PI 3.14159265359\n#endif\n\n    float GetIntegerNoise(float2 p)\n    {\n        p  = 53.7 * frac( (p*0.3183099) + float2(0.71,0.113));\n        return frac( p.x*p.y*(p.x+p.y) );\n    }\n\n    float WorleyHash3D(float f)\n    {\n        return frac(sin(f)*43758.5453);\n    }\n\n    float WorleyHash31(float3 v)\n    {\n        return WorleyHash3D(dot(v, float3(253.14, 453.74, 183.3)));\n    }\n\n    float3 WorleyRandom3D( float3 p )\n    {\n        return frac(sin(float3(dot(p,float3(127.1,311.7,217.3)),dot(p,float3(269.5,183.3,431.1)), dot(p,float3(365.6,749.9,323.7))))*437158.5453);\n    }\n\n    float WorleyNoise3D(float3 uvw)\n    {\n        float noise = 0.0;\n    \n        float3 p = floor(uvw);\n        float3 f = frac(uvw);\n    \n        float4 res = 1;\n        for(int x = -1; x <=1; ++x)\n        {\n            for(int y = -1; y <=1; ++y)\n            {\n                for(int z = -1; z <=1; ++z)\n                {\n                    float3 gp = p + float3(x, y, z);\n\n                    float3 v = WorleyRandom3D(gp);\n\n\t\t\t\t    float3 diff = gp + v - uvw;\n                \n                    float d = length(diff);\n                \n                    if(d < res.x)\n                    {\n                        res.xyz = float3(d, res.x, res.y);\n                    }\n                    else if(d < res.y)\n                    {\n                        res.xyz = float3(res.x, d, res.y);\n                    }\n                    else if(d < res.z)\n                    {\n                        res.z = d;\n                    }\n                \n                    res.w = WorleyHash31(gp);\n                }\n            }\n        }\n\n        return res.x;\n    }\n    \n      \n    float3 Hash3D( float3 p )\n    {\n        p = float3( dot(p,float3(127.1,311.7, 74.7)),\n                dot(p,float3(269.5,183.3,246.1)),\n                dot(p,float3(113.5,271.9,124.6)));\n\n        return -1.0 + 2.0*frac(sin(p)*437.5453123);\n    }\n\n    float Noise3D( float3 p )\n    {\n        float3 i = floor( p );\n        float3 f = frac( p );\n         \n        float3 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),\n                    lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n    }\n\n    \n    float FBM2D(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           return SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n\n    }\n      \n    float FBM3D(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           half A = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.zy).g;\n           half B = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33).g;\n           half C = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoise(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3D(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3D(d.localSpacePosition * frequency+ offset, d.localSpaceNormal);\n        #else\n           return FBM2D(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n    \n    #if _SURFACEGRADIENT  \n\n    #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)\n\n      \n      \n    half3 SurfaceGradientFromTBN(ShaderData d, half2 deriv)\n    {\n        return deriv.x * d.TBNMatrix[0] + deriv.y * d.TBNMatrix[1];\n    }\n\n    half2 TspaceNormalToDerivative(half3 vM)\n    {\n        const half scale = 1.0/128.0;\n        const half3 vMa = abs(vM);\n        const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));\n\n        return -half2(vM.x, vM.y)/z_ma;\n    }\n\n    half3 SurfgradFromVolumeGradient(ShaderData d, half3 grad)\n    {\n        return grad - dot(d.worldSpaceNormal, grad) * d.worldSpaceNormal;\n    }\n\n    half3 SurfgradFromTriplanarProjection(ShaderData d, half3 pN, half3 xN, half3 yN, half3 zN)\n    {\n        const half w0 = pN.x;\n        const half w1 = pN.y;\n        const half w2 = pN.z;\n\n        half2 xD = TspaceNormalToDerivative(xN);\n        half2 yD = TspaceNormalToDerivative(yN);\n        half2 zD = TspaceNormalToDerivative(zN);\n\n        half3 volumeGrad = half3(w2 * zD.x + w1 * yD.y, w2 * zD.y + w0 * xD.y, w0 * xD.x + w1 * yD.x);\n\n        return SurfgradFromVolumeGradient(d, volumeGrad);\n    }\n\n    half3 ConvertNormalToGradient(ShaderData d, half3 normal)\n    {\n        half2 deriv = TspaceNormalToDerivative(normal);\n\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n    half3 ConvertNormal2ToGradient(ShaderData d, half2 packedNormal)\n    {\n        half2 tNormal = packedNormal;\n        half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF\n        half2 deriv = tNormal * -rcpZ;\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n\n    half3 ResolveNormalFromSurfaceGradient(ShaderData d, half3 gradient)\n    {\n        return normalize(d.worldSpaceNormal - gradient);\n    }\n\n    #endif // _SURFACEGRADIENT\n\n\n    // normals are in surface gradient or world space depending on settings, and can also be generated by height\n    half3 GetWorldSpaceNormal(ShaderData d, half3 normal, half pheight)\n    {\n       #if _SURFACEGRADIENT\n          return ResolveNormalFromSurfaceGradient(d, normal);\n       #elif _AUTONORMAL\n          float3 dx = ddx(d.worldSpacePosition);\n          float3 dy = ddy(d.worldSpacePosition);\n          float3 crossX = cross(float3(0,1,0), dx);\n          float3 crossY = cross(float3(0,1,0), dy);\n          float3 dt = abs(dot(crossY, dx));\n          float height = _AutoNormalStrength * 0.5 * pheight;\n          float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n          n.y *= -1.0;\n          return TangentToWorldSpace(d, normalize((dt * float3(0,1,0)) - n).xzy);\n       #else\n          return TangentToWorldSpace(d, normal);\n          \n       #endif\n       \n    }\n\n   void WaterBRDF (inout half3 albedo, inout half smoothness, half metallic, half wetFactor, half surfPorosity) \n   {\n      half porosity = saturate((( (1 - smoothness) - 0.5)) / max(surfPorosity, 0.001));\n      half factor = lerp(1, 0.2, (1 - metallic) * porosity);\n      albedo *= lerp(1.0, factor, wetFactor);\n      smoothness = lerp(smoothness, 0.92f, wetFactor);\n   }\n\n   void OffsetUV(inout Config c, float2 offset)\n   {\n       c.uv += offset;\n       c.uvT.uv0 += offset;\n       c.uvT.uv1 += offset;\n       c.uvT.uv2 += offset;\n       c.uvX.uv0 += offset;\n       c.uvX.uv1 += offset;\n       c.uvX.uv2 += offset;\n       c.uvY.uv0 += offset;\n       c.uvY.uv1 += offset;\n       c.uvY.uv2 += offset;\n       c.uvZ.uv0 += offset;\n       c.uvZ.uv1 += offset;\n       c.uvZ.uv2 += offset;\n   }\n\n\n    void TriangleGrid(float2 uv, float scale,\n       out float w1, out float w2, out float w3,\n       out int2 vertex1, out int2 vertex2, out int2 vertex3)\n    {\n       // Scaling of the input\n       uv *= 3.464 * scale; // 2 * sqrt(3)\n\n       // Skew input space into simplex triangle grid\n       const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);\n       float2 skewedCoord = mul(gridToSkewedGrid, uv);\n\n       // Compute local triangle vertex IDs and local barycentric coordinates\n       int2 baseId = int2(floor(skewedCoord));\n       float3 temp = float3(frac(skewedCoord), 0);\n       temp.z = 1.0 - temp.x - temp.y;\n       if (temp.z > 0.0)\n       {\n          w1 = temp.z;\n          w2 = temp.y;\n          w3 = temp.x;\n          vertex1 = baseId;\n          vertex2 = baseId + int2(0, 1);\n          vertex3 = baseId + int2(1, 0);\n       }\n       else\n       {\n          w1 = -temp.z;\n          w2 = 1.0 - temp.y;\n          w3 = 1.0 - temp.x;\n          vertex1 = baseId + int2(1, 1);\n          vertex2 = baseId + int2(1, 0);\n          vertex3 = baseId + int2(0, 1);\n       }\n    }\n\n    // Fast random hash function\n    float2 SimpleHash2(float2 p)\n    {\n       return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 43758.5453);\n    }\n\n\n    half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)\n    {\n        // compute weight with height map\n        const half epsilon = 1.0f / 1024.0f;\n        half3 weights = half3(iWeights.x * (tex0 + epsilon), \n                                 iWeights.y * (tex1 + epsilon),\n                                 iWeights.z * (tex2 + epsilon));\n\n        // Contrast weights\n        half maxWeight = max(weights.x, max(weights.y, weights.z));\n        half transition = contrast * maxWeight;\n        half threshold = maxWeight - transition;\n        half scale = 1.0f / transition;\n        weights = saturate((weights - threshold) * scale);\n        // Normalize weights.\n        half weightScale = 1.0f / (weights.x + weights.y + weights.z);\n        weights *= weightScale;\n        return weights;\n    }\n\n\n    half3 PackedUnpackScaleNormal(half4 packedNormal, float scale)\n   {\n       #if _PACKEDFAST\n          half3 normal;\n          normal.xy = (packedNormal.ag * 2 - 1) * scale;\n          normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n          return normal;  \n       #endif\n       return UnpackScaleNormal(packedNormal, scale);\n   }\n\n    void InitStochasticDxDy(inout SampleConfig c, Config cfg)\n    {\n      c.dx0 = ddx(cfg.origUV) * cfg.origScale;\n      c.dy0 = ddy(cfg.origUV) * cfg.origScale;\n      c.dx1 = c.dx0; c.dx1 = c.dx0;\n      c.dx2 = c.dy0; c.dy2 = c.dy0;\n    }\n\n    void PrepareStochasticUVs(float scale, float2 uv, out SampleConfig c)\n    {\n       // Get triangle info\n       ZERO_INITIALIZE(SampleConfig, c);\n       float w1, w2, w3;\n       int2 vertex1, vertex2, vertex3;\n       TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n       // Assign random offset to each triangle vertex\n       c.uv0 = uv;\n       c.uv1 = uv;\n       c.uv2 = uv;\n   \n       c.uv0.xy += SimpleHash2(vertex1);\n       c.uv1.xy += SimpleHash2(vertex2);\n       c.uv2.xy += SimpleHash2(vertex3);\n       c.weights = half3(w1, w2, w3);\n       c.origWeights = half3(w1, w2, w3);\n    }\n\n\n   half3 LitBlendDetailNormal(half3 n1, half3 n2)\n   {\n      #if _SURFACEGRADIENT\n         return n1 + n2;\n      #else\n         return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n      #endif\n   }\n\n   float3 TriplanarBlendUnpackedRNM(float3 n1, float3 n2)\n   {\n       n1.z += 1;\n       n2.xy = -n2.xy;\n       return n1 * dot(n1, n2) / n1.z - n2;\n   }\n\n   void InitConfigDxDy(inout Config c)\n   {\n      c.uvT.dx0 = ddx(c.uvT.uv0);\n      c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1);\n      c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2);\n      c.uvT.dy2 = ddy(c.uvT.uv2);\n   }\n\n   Config CreateConfig(ShaderData d, float4 scale, float space, int uvsource, half triplanarContrast)\n   {\n      Config c;\n      ZERO_INITIALIZE(Config, c);\n\n      float3 pos = d.worldSpacePosition;\n      float3 normal = d.worldSpaceNormal;\n      if (space > 0)\n      {\n         pos = d.localSpacePosition;\n         normal = d.localSpaceNormal;\n      }\n\n      c.uv = d.texcoord0.xy;\n      \n      if (uvsource == 1)\n        c.uv = d.texcoord1.xy;\n      else if (uvsource == 2)\n        c.uv = pos.yz * float2(1, -1);\n      else if (uvsource == 3)\n        c.uv = pos.xz * float2(1, -1);\n      else if (uvsource == 4)\n        c.uv = pos.xy * float2(1, -1);\n\n      c.origUV = c.uv;\n      c.origScale = scale.xy;\n\n      c.uv = c.uv * scale.xy + scale.zw;\n      c.dx = ddx(c.uv);\n      c.dy = ddy(c.uv);\n\n      c.normal = normal;\n      c.uvT.uv0 = pos.zy * scale.xy + scale.zw;\n      c.uvT.uv1 = pos.xz * scale.xy + scale.zw;\n      c.uvT.uv2 = pos.xy * scale.xy + scale.zw;\n        \n      c.uvT.uv1 += 0.33;\n      c.uvT.uv2 += 0.67;\n\n      c.uvT.dx0 = ddx(c.uvT.uv0); c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1); c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2); c.uvT.dy2 = ddy(c.uvT.uv2);\n\n      half3 triblend = saturate(pow(abs(c.normal), triplanarContrast));\n      triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n      c.uvT.weights = triblend;\n      c.uvT.origWeights = triblend;\n      c.axisSign = d.worldSpaceNormal < 0 ? -1 : 1;\n      c.absVertNormal = abs(d.worldSpaceNormal);\n     \n\n      return c;\n   }\n\n\n   half4 TriSample(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0) * c.weights.x;\n      }\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1) * c.weights.y;\n      }  \n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2) * c.weights.z;\n      }\n\n      return res;\n   }\n\n   half4 TriSampleBary(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      c.weights = BaryWeightBlend(c.origWeights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   half4 TriSampleGrad(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvX, contrast, d) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvY, contrast, d) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n           res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvZ, contrast, d) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   \n   half4 SampleTexBaryStochastic(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   half4 SampleTexBaryTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleGrad(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   \n   half4 SampleTexBary(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        COUNTSAMPLE\n        return SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv, c.dx, c.dy);\n   }\n\n   half4 SampleTexStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ) * c.uvT.weights.z;\n\n        return res;     \n   }\n\n   \n   half4 SampleTexStochastic(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n\n   half4 SampleTexTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n   \n   half4 SampleTex(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       COUNTSAMPLE\n       return SAMPLE_TEXTURE2D(tex, ss, c.uv);\n   }\n   \n\n \n   half3 SampleNormalStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n         dataX = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n         dataY = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n         dataZ = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ));\n\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n\n          return WorldToTangentSpace(d, worldNormal);\n       #endif\n   }\n\n\n   half3 SampleNormalTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n      {\n          COUNTSAMPLE\n          dataX = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv0, c.uvT.dx0, c.uvT.dy0));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n      {\n          COUNTSAMPLE\n          dataY = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv1, c.uvT.dx1, c.uvT.dy1));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n      {\n         COUNTSAMPLE\n         dataZ = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv2, c.uvT.dx2, c.uvT.dy2));\n      }\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n          return WorldToTangentSpace(d, worldNormal);\n      #endif\n   }\n\n   half3 SampleNormalStochastic(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n     half4 normal = TriSample(tex, ss, c.uvT);\n     #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half3 SampleNormal(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 normal = SAMPLE_TEXTURE2D(tex, ss, c.uv);\n      #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half HeightBlend(half h1, half h2, half slope, half contrast)\n   {\n      h2 = 1 - h2;\n      half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); \n      half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));\n      return blend;\n   }\n\n\n    #if _POM\n    float2 POM(TEXTURE2D_PARAM(tex, ss), Config c, float contrast, ShaderData d)\n    {\n       float2 curv = float2(0, 0);\n       float refPlane = 0;\n\n       float result = 0;\n       int stepIndex = 0;\n       int maxSamples = _POMMaxSamples;\n       int minSamples = 4;\n       float camDist = distance(_WorldSpaceCameraPos, d.worldSpacePosition);\n       float distanceFade = 1 - saturate((camDist - _POMMin) / max(1, _POMFade));\n       int numSteps = ( int )lerp( maxSamples, minSamples, dot( d.worldSpaceNormal, d.worldSpaceViewDir )) * distanceFade;\n       if (numSteps < 1)\n           numSteps = 1;\n       float layerHeight = 1.0 / numSteps;\n       float2 plane = _ParallaxHeight * ( d.tangentSpaceViewDir.xy / d.tangentSpaceViewDir.z ) * distanceFade;\n       OffsetUV(c, refPlane * plane);\n       float2 deltaTex = -plane * layerHeight;\n       float2 prevTexOffset = 0;\n       float prevRayZ = 1.0f;\n       float prevHeight = 0.0f;\n       float2 currTexOffset = deltaTex;\n       float currRayZ = 1.0f - layerHeight;\n       float currHeight = 0.0f;\n       float intersection = 0;\n       float2 finalTexOffset = 0;\n\n       while ( stepIndex < numSteps + 1 )\n       {\n          result = dot( curv, currTexOffset * currTexOffset );\n          Config cfg = c;\n          OffsetUV(cfg, currTexOffset);\n          currHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( currHeight > currRayZ )\n          {\n             stepIndex = numSteps + 1;\n          }\n          else\n          {\n             stepIndex++;\n             prevTexOffset = currTexOffset;\n             prevRayZ = currRayZ;\n             prevHeight = currHeight;\n             currTexOffset += deltaTex;\n             currRayZ -= layerHeight * ( 1 - result );\n          }\n       }\n       int sectionSteps = 10;\n       int sectionIndex = 0;\n       float newZ = 0;\n       float newHeight = 0;\n       while ( sectionIndex < sectionSteps )\n       {\n          intersection = ( prevHeight - prevRayZ ) / ( prevHeight - currHeight + currRayZ - prevRayZ );\n          finalTexOffset = prevTexOffset + intersection * deltaTex;\n          newZ = prevRayZ - intersection * layerHeight;\n          Config cfg = c;\n          OffsetUV(cfg, finalTexOffset);\n          newHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( newHeight > newZ )\n          {\n             currTexOffset = finalTexOffset;\n             currHeight = newHeight;\n             currRayZ = newZ;\n             deltaTex = intersection * deltaTex;\n             layerHeight = intersection * layerHeight;\n          }\n          else\n          {\n             prevTexOffset = finalTexOffset;\n             prevHeight = newHeight;\n             prevRayZ = newZ;\n             deltaTex = ( 1 - intersection ) * deltaTex;\n             layerHeight = ( 1 - intersection ) * layerHeight;\n          }\n          sectionIndex++;\n       }\n       #if _PASSHADOWS\n       if ( unity_LightShadowBias.z == 0.0 )\n       {\n       #endif\n          if ( result > 1 )\n             clip( -1 );\n       #if _PASSHADOWS\n       }\n       #endif\n       return finalTexOffset;\n    }\n    #endif\n\n   \n\n   // tess versions\n   #if _TESSELLATION_ON\n   half4 TriSampleLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias) * c.weights.x;\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias) * c.weights.y;\n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias) * c.weights.z;\n\n      return res;\n   }\n\n   half4 TriSampleBaryLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias, float contrast)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias);\n      half4 r2 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias);\n      half4 r3 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias);\n      c.weights = BaryWeightBlend(c.weights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryLODStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvX, bias, contrast) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvY, bias, contrast) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvZ, bias, contrast) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   half4 SampleTexBaryLODStochastic(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n       return TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias, contrast);\n   }\n\n   half4 SampleTexBaryLODTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return TriSampleLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias);\n   }\n\n   half4 SampleTexBaryLOD(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv, bias);\n   }\n\n\n    float FBM2DLOD(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           return SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv, _TessellationMipBias).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n        \n        \n    }\n\n    float FBM3DLOD(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           half A = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.zy, _TessellationMipBias).g;\n           half B = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33, _TessellationMipBias).g;\n           half C = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67, _TessellationMipBias).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoiseLOD(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3DLOD(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3DLOD(d.localSpacePosition * frequency + offset, d.localSpaceNormal);\n        #else\n           return FBM2DLOD(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n   #endif //_TESSELLATION_ON\n\n\n    half3 FuzzyShade(ShaderData d, half height, half3 color, half3 normal, half coreMult, half edgeMult, half power)\n    {\n        float3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half dt = saturate(dot(d.worldSpaceViewDir, worldNormal));\n        half dark = 1.0 - (coreMult * dt);\n        half edge = pow(1-dt, abs(power)) * edgeMult;\n        return color * (dark + edge);\n    }\n\n\thalf MicroShadow(ShaderData d, half3 normal, half height, half ao, half strength)\n\t{\n        float3 sun;\n\t\tfloat3 sunColor;\n\t\tGetSun(sun, sunColor);\n\t\tfloat3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half shadow = saturate(abs(dot(worldNormal, sun)) + (ao * ao * 2.0) - 1.0);\n        return 1 - ((1-shadow) * strength);\n\t}\n\n\n#endif\n\n\n\n   #if defined(_SPECULAR)\n      #define _USESPECULAR 1\n      #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n   #endif\n\n   \n   TEXTURE2D(_AlbedoMap);\n   SAMPLER(sampler_AlbedoMap);\n   TEXTURE2D(_NormalMap);\n   SAMPLER(sampler_NormalMap);\n   TEXTURE2D(_MaskMap);\n   TEXTURE2D(_DetailMap);\n   TEXTURE2D(_EmissionMap);\n\n   #if _SPECULAR\n       TEXTURE2D(_SpecularMap);\n   #endif\n\n   \n   \n   void Ext_SurfaceFunction0 (inout Surface o, inout ShaderData d)\n   {\n      // define samplers based on settings\n      #undef SAMPLEBARY\n      #undef SAMPLE\n      #undef SAMPLENORMAL\n      #if _STOCHASTIC && _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n        #define SAMPLE     SampleTexStochasticTriplanar\n        #define SAMPLENORMAL SampleNormalStochasticTriplanar\n      #elif _STOCHASTIC\n        #define SAMPLEBARY SampleTexBaryStochastic\n        #define SAMPLE     SampleTexStochastic\n        #define SAMPLENORMAL SampleNormalStochastic\n      #elif _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryTriplanar\n        #define SAMPLE     SampleTexTriplanar\n        #define SAMPLENORMAL SampleNormalTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBary\n        #define SAMPLE     SampleTex\n        #define SAMPLENORMAL SampleNormal\n      #endif\n\n      Config c = CreateConfig(d, _AlbedoMap_ST, _TriplanarSpace, _UVSource, _TriplanarContrast);\n      InitConfigDxDy(c);\n      #if _STOCHASTIC && !_TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uv, c.uvT);\n         InitStochasticDxDy(c.uvT, c);\n      #elif _STOCHASTIC && _TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv0, c.uvX);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv1, c.uvY);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv2, c.uvZ);\n         InitStochasticDxDy(c.uvX, c);\n         InitStochasticDxDy(c.uvY, c);\n         InitStochasticDxDy(c.uvZ, c);\n      #endif\n\n      #if _POM\n          // would need to handle height remapping if we ever want to ship this\n          float2 pomOffset = POM(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n          OffsetUV(c, pomOffset);\n      #endif\n\n      half4 albedo = SAMPLEBARY(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n      \n      #if _PARALLAX\n         float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n         OffsetUV(c, offset);\n         albedo = SAMPLE(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c);\n         \n      #endif\n      albedo.a = lerp(_HeightRemap.x, _HeightRemap.y, albedo.a);\n      albedo.rgb *= _Tint.rgb;\n\n      albedo.rgb = AdjustContrast(albedo.rgb, _AlbedoContrast);\n      albedo.rgb += _AlbedoBrightness;\n\n\n      if (_AlphaThreshold > 0)\n      {\n         clip(albedo.a - _AlphaThreshold);\n      }\n\n      #if defined(_FLATSHADE)\n\t\t     float3 dx = ddx(d.worldSpacePosition);\n\t\t     float3 dy = ddy(d.worldSpacePosition);\n\t\t     float3 worldNormal = normalize(cross(dy, dx));\n\t\t     worldNormal = lerp(d.worldSpaceNormal, worldNormal, _FlatShadingBlend);\n\t\t     d.worldSpaceNormal = worldNormal;\n\t\t     d.TBNMatrix[2] = worldNormal;\n      #endif\n\n\n\n      o.Albedo = albedo.rgb;\n      o.Alpha = albedo.a;\n\n      float smoothness = _Smoothness;\n      float ao = 1;\n\n      #if defined(_NORMALMAP) && !defined(_AUTONORMAL)\n         o.Normal = SAMPLENORMAL(TEXTURE2D_ARGS(_NormalMap, sampler_NormalMap), c, d, _NormalStrength, smoothness, ao);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, ao);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n      #endif\n\n      half detailMask = 1;\n      o.Smoothness = smoothness;\n      o.Occlusion = ao;\n      o.Metallic = _Metallic;\n      #if defined(_MASKMAP) && !_PACKEDFAST\n         // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = SampleTex(TEXTURE2D_ARGS(_MaskMap, sampler_AlbedoMap), c);\n         o.Metallic = lerp(_MetallicRemap.x, _MetallicRemap.y, mask.r);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, mask.g);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, mask.a);\n         detailMask = mask.b;\n      #endif // separate maps\n\n      #if _SPECULAR\n         o.Specular = SAMPLE(TEXTURE2D_ARGS(_SpecularMap, sampler_AlbedoMap), c).rgb;\n      #endif\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = SAMPLE(TEXTURE2D_ARGS(_EmissionMap, sampler_AlbedoMap), c).rgb * _EmissionColor;\n      #endif\n\n      if (_FuzzyShadingOn > 0)\n      {\n        o.Albedo *= FuzzyShade(d, albedo.a, _FuzzyShadingColor, o.Normal, _FuzzyShadingParams.x, _FuzzyShadingParams.y, _FuzzyShadingParams.z);\n      }\n\n\n      // HDRP style detail texturing\n\n      #if defined(_DETAIL)\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _DETAILSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n         Config dc = CreateConfig(d, _DetailMap_ST, _DetailTriplanarSpace, _DetailUVSource, _DetailTriplanarContrast);\n         InitConfigDxDy(dc);\n         #if _DETAILSTOCHASTIC && !_DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uv, dc.uvT);\n             InitStochasticDxDy(dc.uvT, dc);\n         #elif _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv0, dc.uvX);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv1, dc.uvY);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv2, dc.uvZ);\n             InitStochasticDxDy(dc.uvX, dc);\n             InitStochasticDxDy(dc.uvY, dc);\n             InitStochasticDxDy(dc.uvZ, dc);\n         #endif\n\n         half4 detailSample = SAMPLEBARY(TEXTURE2D_ARGS(_DetailMap, sampler_AlbedoMap), dc, _DetailStochasticContrast, d);\n         smoothness = detailSample.z;\n         #if !_AUTONORMAL\n            half3 dnormal = float3(detailSample.ag * 2 - 1, 1) * detailMask * _DetailNormalStrength;\n            dnormal.z = sqrt(1 - dnormal.x * dnormal.x - dnormal.y * dnormal.y);\n            #if _SURFACEGRADIENT\n               dnormal = ConvertNormalToGradient(d, dnormal);\n            #endif\n            o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n         #endif\n     \n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * smoothness, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n      if (_MicroShadowStrength > 0)\n      {\n        o.Occlusion *= MicroShadow(d, o.Normal, o.Alpha, o.Occlusion, _MicroShadowStrength);\n      }\n  \n      // in case something needs height in the stack..\n      o.Height = o.Alpha;\n\n\n      \n   }\n\n\n\n\t#if _TINTMASK\n\t\tTEXTURE2D(_TintMask);\n\t\tSAMPLER(sampler_TintMask);\n\t#endif\n\n\tvoid Ext_SurfaceFunction1 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _TINTMASK\n\t\t   half4 w = SAMPLE_TEXTURE2D(_TintMask, sampler_TintMask, d.texcoord0.xy * _TintMask_ST.xy + _TintMask_ST.zw);\n\t\t   // allow black to be no tint..\n\t\t   half3 tint = o.Albedo * (_RColor.rgb * 2 * w.r + _GColor.rgb * 2 * w.g + _BColor.rgb * 2 * w.b + _AColor.rgb * 2 * w.a);\n\t\t   o.Albedo = lerp(o.Albedo, tint, saturate(w.r + w.g + w.b + w.a));\n\t\t#endif\n\t}\n\n\n\n\n\t#if _LAYERTEXTUREMASK\n       TEXTURE2D(_LayerTextureMask);\n       SAMPLER(sampler_LayerTextureMask); \n    #endif\n\n   void Ext_ModifyTessellatedVertex2 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON\n          float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n\n          #if _LAYERTEXTUREMASK\n               float2 layerUV = v.texcoord0.xy;\n               if (_LayerTextureMaskUVMode == 1)\n                  layerUV = v.texcoord1.xy;\n               else if (_LayerTextureMaskUVMode == 2)\n                  layerUV = worldSpacePosition.yz;\n               else if (_LayerTextureMaskUVMode == 3)\n                  layerUV = worldSpacePosition.xz;\n               else if (_LayerTextureMaskUVMode == 4)\n                  layerUV = worldSpacePosition.xy;\n\n              e.blackboard.weightTextureMask = SAMPLE_TEXTURE2D_LOD(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw, _TessellationMipBias);\n          #endif\n      #endif\n    }\n\n\n\tvoid Ext_SurfaceFunction2 (inout Surface o, inout ShaderData d)\n\t{\n\t\t#if _LAYERTEXTUREMASK\n           float2 layerUV = d.texcoord0.xy;\n           if (_LayerTextureMaskUVMode == 1)\n              layerUV = d.texcoord1.xy;\n           else if (_LayerTextureMaskUVMode == 2)\n              layerUV = d.worldSpacePosition.yz;\n           else if (_LayerTextureMaskUVMode == 3)\n              layerUV = d.worldSpacePosition.xz;\n           else if (_LayerTextureMaskUVMode == 4)\n              layerUV = d.worldSpacePosition.xy;\n\n          d.blackboard.weightTextureMask = SAMPLE_TEXTURE2D(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw);\n      #endif\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap);\n   SAMPLER(sampler_LayerAlbedoMap);\n   TEXTURE2D(_LayerNormalMap);\n   TEXTURE2D(_LayerMaskMap);\n   TEXTURE2D(_LayerEmissionMap);\n\n   \n\n   void Ext_ModifyTessellatedVertex3 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER) && defined(_LAYERALBEDO) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n         half detailMask = 1;\n         #if _LAYERNOISE\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency,  _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin;\n            dt = saturate(dt * _LayerFalloff);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight) * _LayerFalloff);\n            if (_LayerInvertHeight > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength;\n         detailMask *= _LayerTessStrength;\n\n         #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast).a;\n         albedo = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo);\n\n         if (_LayerBlendMode == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction3 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n            // noise up the mask\n            #if _LAYERNOISE\n               mask = DoNoise(d, _LayerNoiseFrequency, _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend);\n\t    \n                dt -= _LayerAngleMin;\n                dt = saturate(dt * _LayerFalloff);\n\n                float hf = saturate((o.Height - _LayerHeight) * _LayerFalloff);\n                if (_LayerInvertHeight > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 0\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 0\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength;\n\n            #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint, 0.5);\n            #if defined(_LAYERALBEDO)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c, _LayerStochasticContrast, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c);\n                #endif\n                albedo.rgb *= _LayerTint;\n                albedo.a = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL || _LAYERMASK\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap, sampler_LayerAlbedoMap, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast);\n            albedo.rgb += _LayerAlbedoBrightness;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap, sampler_LayerAlbedoMap), c, d, _LayerNormalStrength * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO)\n                if (_LayerFuzzyShadingOn > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor.rgb, dnormal,\n                                            _LayerFuzzyShadingParams.x, _LayerFuzzyShadingParams.y, _LayerFuzzyShadingParams.z);\n                }\n\n                if (_LayerBlendMode == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast);\n                else if (_LayerBlendMode == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE\n                      float maskDif = (_LayerBlendContrast * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength);\n                   #if _LAYERNOISE\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap, sampler_LayerAlbedoMap), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength);\n                }\n\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap, sampler_LayerAlbedoMap), c).rgb * _LayerEmissionColor;\n                #if _LAYERALBEDO\n                    if (_LayerBlendMode > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_1);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_1);\n   TEXTURE2D(_LayerNormalMap_Ext_1);\n   TEXTURE2D(_LayerMaskMap_Ext_1);\n   TEXTURE2D(_LayerEmissionMap_Ext_1);\n\n   \n\n   void Ext_ModifyTessellatedVertex4 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_1) && defined(_LAYERALBEDO_DEF_1) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_1\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_1,  _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_1\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_1;\n            dt = saturate(dt * _LayerFalloff_Ext_1);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n            if (_LayerInvertHeight_Ext_1 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_1;\n         detailMask *= _LayerTessStrength_Ext_1;\n\n         #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_1).a;\n         albedo = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo);\n\n         if (_LayerBlendMode_Ext_1 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_1);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_1 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction4 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_1)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_1\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_1, _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_1\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_1);\n\t    \n                dt -= _LayerAngleMin_Ext_1;\n                dt = saturate(dt * _LayerFalloff_Ext_1);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n                if (_LayerInvertHeight_Ext_1 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 01\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 01\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_1;\n\n            #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_1, 0.5);\n            #if defined(_LAYERALBEDO_DEF_1)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, _LayerStochasticContrast_Ext_1, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_1;\n                albedo.a = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_1 || _LAYERMASK_DEF_1\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_1);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_1;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, d, _LayerNormalStrength_Ext_1 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_1)\n                if (_LayerFuzzyShadingOn_Ext_1 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_1.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_1.x, _LayerFuzzyShadingParams_Ext_1.y, _LayerFuzzyShadingParams_Ext_1.z);\n                }\n\n                if (_LayerBlendMode_Ext_1 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_1);\n                else if (_LayerBlendMode_Ext_1 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_1 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_1);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_1\n                      float maskDif = (_LayerBlendContrast_Ext_1 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_1 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                   #if _LAYERNOISE_DEF_1\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_1));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_1 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_1);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_1) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_1 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_1);\n                }\n\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_1);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_1, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_1, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_1\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c).rgb * _LayerEmissionColor_Ext_1;\n                #if _LAYERALBEDO_DEF_1\n                    if (_LayerBlendMode_Ext_1 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_2);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_2);\n   TEXTURE2D(_LayerNormalMap_Ext_2);\n   TEXTURE2D(_LayerMaskMap_Ext_2);\n   TEXTURE2D(_LayerEmissionMap_Ext_2);\n\n   \n\n   void Ext_ModifyTessellatedVertex5 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_2) && defined(_LAYERALBEDO_DEF_2) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_2\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_2,  _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_2\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_2;\n            dt = saturate(dt * _LayerFalloff_Ext_2);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n            if (_LayerInvertHeight_Ext_2 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_2;\n         detailMask *= _LayerTessStrength_Ext_2;\n\n         #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_2).a;\n         albedo = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo);\n\n         if (_LayerBlendMode_Ext_2 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_2);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_2 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction5 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_2)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_2\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_2, _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_2\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_2);\n\t    \n                dt -= _LayerAngleMin_Ext_2;\n                dt = saturate(dt * _LayerFalloff_Ext_2);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n                if (_LayerInvertHeight_Ext_2 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 02\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 02\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_2;\n\n            #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_2, 0.5);\n            #if defined(_LAYERALBEDO_DEF_2)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, _LayerStochasticContrast_Ext_2, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_2;\n                albedo.a = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_2 || _LAYERMASK_DEF_2\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_2);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_2;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, d, _LayerNormalStrength_Ext_2 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_2)\n                if (_LayerFuzzyShadingOn_Ext_2 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_2.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_2.x, _LayerFuzzyShadingParams_Ext_2.y, _LayerFuzzyShadingParams_Ext_2.z);\n                }\n\n                if (_LayerBlendMode_Ext_2 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_2);\n                else if (_LayerBlendMode_Ext_2 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_2 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_2);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_2\n                      float maskDif = (_LayerBlendContrast_Ext_2 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_2 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                   #if _LAYERNOISE_DEF_2\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_2));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_2 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_2);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_2) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_2 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_2);\n                }\n\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_2);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_2, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_2, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_2\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c).rgb * _LayerEmissionColor_Ext_2;\n                #if _LAYERALBEDO_DEF_2\n                    if (_LayerBlendMode_Ext_2 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   #if _TRAX_ON\n   TEXTURE2D(_TraxAlbedo);\n   SAMPLER(sampler_TraxAlbedo);\n   TEXTURE2D(_TraxPackedNormal);\n   TEXTURE2D(_TraxMask);\n\n   sampler2D_float _GMSTraxBuffer;\n\n   float4 _GMSTraxBuffer_TexelSize;\n   float3 _GMSTraxBufferPosition;\n   float _GMSTraxBufferWorldSize;\n   float _GMSTraxFudgeFactor;\n\n   float SampleTraxBufferLOD(float3 worldPos)\n   {    \n      // generate UVs for the buffer, which is moving\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 8);\n      uv *= 0.5;\n      uv += 0.5;\n            \n      float s =  tex2Dlod(_GMSTraxBuffer, float4(uv, 0, 0)).r;\n\n      return 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n   }\n         \n        \n   float SampleTraxBuffer(float3 worldPos, out float3 norm)\n   {\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 3);\n      uv *= 0.5;\n      uv += 0.5;\n            \n\n      float2 offset = _GMSTraxBuffer_TexelSize.xy;\n\n      float s = tex2D(_GMSTraxBuffer, uv).r;\n               \n      float s1 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, -1)).r;\n      float s2 = tex2D(_GMSTraxBuffer, uv + offset * float2(-1, 0)).r;\n      float s3 = tex2D(_GMSTraxBuffer, uv + offset * float2(1, 0)).r;\n      float s4 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, 1)).r;\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      float r = 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n \n      // generate normals\n      norm.x = (s1 - s4) * 0.25; \n      norm.y = (s2 - s3) * 0.25;\n      norm.z = 2;\n      norm = normalize(norm);\n     \n      norm.xy *= 1 - r;\n            \n      return r;\n   }\n   #endif\n\n   void Ext_ModifyTessellatedVertex6 (inout VertexData v, inout ExtraV2F d)\n   {\n       #if _TESSELLATION_ON && _TRAX_ON && _HAS_LIT_TESSELLATION\n          \n           float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n           float3 worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n           float traxBuffer = SampleTraxBufferLOD(worldSpacePosition);\n           d.blackboard.traxBuffer = traxBuffer;\n           float2 uv = worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n           half albedo = SAMPLE_TEXTURE2D_LOD(_TraxAlbedo, sampler_TraxAlbedo, uv, _TraxMipBias).a;\n\n           float traxOffset = albedo * _TraxDisplacementStrength;\n           traxOffset *= 1 - v.texcoord0.z;\n           traxOffset *= _TessellationDisplacement;\n           float dig = _TraxDisplacementDepth * (1 - v.texcoord0.z);\n           float3 traxVertex = d.blackboard.originalVertexPosition + (v.normal * (traxOffset - dig));\n           v.vertex.xyz = lerp(traxVertex, v.vertex.xyz, traxBuffer);\n\n           d.blackboard.vertexHeightOffset = lerp(traxOffset-dig, d.blackboard.vertexHeightOffset, traxBuffer);\n\n       #endif\n\n   }\n\n   void Ext_SurfaceFunction6 (inout Surface o, inout ShaderData d)\n   {\n      #if _TRAX_ON\n        float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n        float2 fsdx = ddx(uv);\n        float2 fsdy = ddy(uv);\n\n        float3 traxNormal;\n        float traxBuffer = SampleTraxBuffer(d.worldSpacePosition, traxNormal);\n        \n        #if _TESSELLATION_ON\n            traxBuffer -= _TraxDisplacementDepth;\n        #endif\n\n        d.blackboard.traxBuffer = traxBuffer;\n\n        UNITY_BRANCH\n        if (traxBuffer > 0)\n        {\n            half4 albedo = SAMPLE_TEXTURE2D_GRAD(_TraxAlbedo, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            albedo.rgb *= _TraxTint.rgb;\n            half4 normalSample = SAMPLE_TEXTURE2D_GRAD(_TraxPackedNormal, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n\n            half smoothness = normalSample.r;\n            half ao = normalSample.b;\n            half3 normal;\n            normal.xy = (normalSample.ag * 2 - 1) * _TraxNormalStrength;\n            normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n\n            \n            half h = HeightBlend(albedo.a, o.Alpha, traxBuffer, _TraxHeightContrast);\n\n            h = lerp(traxBuffer, h, _TraxInterpContrast);\n\n            o.Albedo = lerp(albedo, o.Albedo, h);\n\n            #if _SURFACEGRADIENT\n                o.Normal = lerp(normal, o.Normal, h);\n            #else\n                o.Normal = lerp(normal + traxNormal, o.Normal, h);\n            #endif\n        \n            o.Smoothness = lerp(smoothness, o.Smoothness, h);\n            o.Occlusion = lerp(ao, o.Occlusion, h);\n        }\n      #endif\n   }\n\n\n\n\n    #if _RAINDROPS\n       TEXTURE2D(_RainDropTexture);\n       SAMPLER(sampler_RainDropTexture);\n       half _Global_RainIntensity;\n    #endif\n\n    #if _WETNESS\n       half2 _Global_WetnessParams; // global, not in cbuffer\n    #endif\n   \n    #if _RAINDROPS\n    half2 ComputeRipple(float2 uv, half time, half weight)\n    {\n        half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_RainDropTexture, uv);\n        COUNTSAMPLE\n        ripple.yz = ripple.yz * 2 - 1;\n\n        half dropFrac = frac(ripple.w + time);\n        half timeFrac = dropFrac - 1.0 + ripple.x;\n        half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);\n        half finalFactor = dropFactor * ripple.x * \n                                sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);\n\n        return half2(ripple.yz * finalFactor);\n    }\n    #endif\n\n    half2 DoRain(half2 waterNorm, float2 uv, out half2 ripple)\n    {\n        #if _RAINDROPS\n            float rainIntensity = _RainIntensityScale.x;\n            if (_RainMode > 1)\n            {\n                rainIntensity = _Global_RainIntensity;\n            }\n\n            half dropStrength = rainIntensity;\n            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); \n            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);\n            half4 times = _Time.yyyy;\n            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);\n\n            float2 ruv1 = uv * _RainIntensityScale.yy;\n            float2 ruv2 = ruv1;\n\n            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);\n            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);\n            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);\n            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);\n            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);\n            weights = saturate(weights * 4);\n\n            half2 rippleNormal = half2( weights.x * ripple1.xy +\n                        weights.y * ripple2.xy + \n                        weights.z * ripple3.xy + \n                        weights.w * ripple4.xy);\n\n            ripple = rippleNormal * dropStrength * rainIntensity;\n            waterNorm = lerp(waterNorm, normalize(half3(rippleNormal.xy + rippleNormal.xy, 1)).xy, rainIntensity * dropStrength); \n            return waterNorm;                        \n        #else\n            return waterNorm;\n        #endif\n    }\n\n   half2 _Global_PuddleParams;   // this is a global, so keep it out of the cbuffer\n   void GetPuddleParams(ShaderData d, inout float puddleMask, inout float pudHeight)\n   {\n      #if _PUDDLES || _GLOBALPUDDLES\n          pudHeight = _PuddleAmount;\n          if (_PuddleMode > 0)\n             pudHeight = _Global_PuddleParams.x;    \n      \n\n          half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t      dt -= _PuddleAngleMin;\n          dt = saturate(dt * _PuddleFalloff);\n          puddleMask *= dt;\n      #endif\n   }\n   \n   void Ext_ModifyTessellatedVertex7 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _PUDDLES && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n         half mask = 1;\n         half pudHeight = 1;\n\n         // save some ops by doing this in 2d\n         #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2DLOD(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2DLOD(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #else\n                mask = (FBM2DLOD(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n         #endif\n\n         GetPuddleParams(d, mask, pudHeight);\n         float height = pudHeight * mask;\n         if (e.blackboard.vertexHeightOffset < height)\n         {\n            e.blackboard.vertexHeightOffset = height;\n            height -= _TessellationOffset; \n            // dampen cracks\n            height *= 1 - v.texcoord0.z;\n            height *= _TessellationDisplacement;\n            v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n            \n        }\n      #endif\n   }\n\n\n#if _WETNESS\n\n   float GetWetnessLevel(Surface o, ShaderData d, float wetnessMask)\n   {\n      float wetLevel = clamp(_WetnessAmount, _WetnessMin, _WetnessMax);\n      \n      if (_WetnessMode > 0)\n         wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);\n\n      wetLevel = saturate(wetLevel + (1 - saturate(d.worldSpacePosition.y - _WetnessShoreline)));\n      float3x3 tbn = float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal);\n      float dt = dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0));\n      dt -= _WetnessAngleMin;\n      dt = saturate(dt * _WetnessFalloff * wetLevel);\n      dt *= wetnessMask;\n      return dt;\n   }\n#endif\n   \n\n   void Ext_SurfaceFunction7 (inout Surface o, ShaderData d)\n   {\n      half wetnessLevel = 0;\n      #if _WETNESS\n          wetnessLevel = GetWetnessLevel(o, d, 1); // mask one day?\n      #endif\n\n      half depthMask = 0;\n      half depth = 0;\n\n      #if _PUDDLES\n          half mask = 1;\n          half pudHeight = 1;\n          #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2D(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2D(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);      \n            #else\n                mask = (FBM2D(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n          #endif\n\n          GetPuddleParams(d, mask, pudHeight);\n          pudHeight *= mask;\n          depth = pudHeight - o.Height;\n          depthMask = saturate(depth * _PuddleFalloff);\n          depthMask *= _PuddleColor.a;\n          depth = o.Height - pudHeight;\n\n          // extend wetness slighting higher than the puddle\n          half wetmask = saturate((pudHeight + 0.05 - o.Height) * _PuddleFalloff);\n          wetnessLevel = max(wetmask, wetnessLevel);\n       #endif\n\n       \n       #if _WETNESS || _PUDDLES\n          half3 waterNorm = half3(0,0,1);\n          half3 wetAlbedo = o.Albedo;\n          half wetSmoothness = o.Smoothness;\n          #if _PUDDLES\n             wetAlbedo *= _PuddleColor.rgb;\n          #endif\n          WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetnessLevel, _Porosity);\n\n          half ri = 0;\n          half2 ripple = 0;\n          #if (_RAINDROPS || _GLOBALRAIN) && (_PUDDLES || _GLOBALPUDDLES)\n             ri = _RainIntensityScale.z;\n             waterNorm.xy = DoRain(waterNorm.xy, d.texcoord0.xy, ripple) * depthMask;\n          #endif\n\n          o.Normal = lerp(o.Normal, waterNorm, depthMask);\n          o.Normal = lerp(o.Normal, LitBlendDetailNormal(o.Normal, half3(ripple.xy, 1)), saturate(ri - depthMask) * wetnessLevel);\n          o.Occlusion = lerp(o.Occlusion, 1, depthMask);\n          o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetnessLevel);\n          o.Albedo = lerp(o.Albedo, wetAlbedo, wetnessLevel);\n          o.Emission *= 1 + depth;\n          o.Metallic *= 1 + depth;\n          o.Specular *= 1 + depth;\n\n       #endif\n\n   }\n\n\n\n\n    #if _SNOW\n       TEXTURE2D(_SnowAlbedo);\n       SAMPLER(sampler_SnowAlbedo);\n       TEXTURE2D(_SnowNormal);\n       TEXTURE2D(_SnowMaskMap);\n       #if _TRAX_ON\n          TEXTURE2D(_SnowTraxAlbedo);\n          TEXTURE2D(_SnowTraxNormal);\n          TEXTURE2D(_SnowTraxMaskMap);\n       #endif\n    #endif\n\n   float _Global_SnowLevel;\n\n\n   void Ext_ModifyVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n    #if (_SNOW)\n        float amount = _SnowAmount;\n        if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n        float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n        float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n        snowAmount -= _SnowAngle;\n        snowAmount *= _SnowContrast * 0.5;\n        snowAmount = saturate(snowAmount) * amount;\n        float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n        if (_SnowWorldFade.z > 0)\n        {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n        }\n        #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n        #endif\n        snowAmount = saturate(snowAmount);\n\n        #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n        #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n        #endif\n\n        float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n        v.vertex.xyz = v.vertex.xyz + displacementVec * snowAmount * snowAmount * _SnowVertexHeight;\n    #endif\n   }\n\n   void Ext_ModifyTessellatedVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _SNOW && _HAS_LIT_TESSELLATION\n         float amount = _SnowAmount;\n         if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n         float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n         float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n         snowAmount -= _SnowAngle;\n         snowAmount *= _SnowContrast * 0.5;\n         float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n         if (_SnowWorldFade.z > 0)\n         {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n         }\n\n         snowAmount = saturate(snowAmount) * amount;\n\n         #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n         #endif\n         snowAmount = saturate(snowAmount);\n\n         #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n         #endif\n\n         float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n         half heightMap = SAMPLE_TEXTURE2D_LOD(_SnowAlbedo, sampler_SnowAlbedo, worldPos.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw, 2);\n\n         float height = max(_SnowVertexHeight * 3 * snowAmount + snowAmount * heightMap, e.blackboard.vertexHeightOffset);\n         #if _TRAX_ON\n            height *= e.blackboard.traxBuffer;\n         #endif\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n\n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n         \n      #endif\n\n   }\n\n   void SampleSnowSurface(TEXTURE2D_PARAM(alb, ss), TEXTURE2D_PARAM(norm, ss2), TEXTURE2D_PARAM(mask, ss3),\n        ShaderData d, float2 uv, float2 dx, float2 dy, out half4 albedo, out half3 normal, out half2 smoothAO)\n   {\n      #if _SNOWSTOCHASTIC\n         float w1, w2, w3;\n         int2 vertex1, vertex2, vertex3;\n         TriangleGrid(uv, _SnowStochasticScale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n         // Assign random offset to each triangle vertex\n         float2 uv0 = uv;\n         float2 uv1 = uv;\n         float2 uv2 = uv;\n   \n         uv0.xy += SimpleHash2(vertex1);\n         uv1.xy += SimpleHash2(vertex2);\n         uv2.xy += SimpleHash2(vertex3);\n         half3 weights = half3(w1, w2, w3);\n\n         half4 albedo0 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv0, dx, dy);\n         half4 albedo1 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv1, dx, dy);\n         half4 albedo2 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv2, dx, dy);\n         COUNTSAMPLE\n         COUNTSAMPLE\n         COUNTSAMPLE\n         weights = BaryWeightBlend(weights, albedo0.a, albedo1.a, albedo2.a, _SnowStochasticContrast);\n         albedo = albedo0 * weights.x + albedo1 * weights.y + albedo2 * weights.z;\n\n         normal = half3(0,0,1);\n         smoothAO = half2(0, 1);\n\n         #if !_AUTONORMAL\n            half4 n0 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv0, dx, dy);\n            half4 n1 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv1, dx, dy);\n            half4 n2 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n            half4 snowNormSamp = n0 * weights.x + n1 * weights.y + n2 * weights.z;\n\n            normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n                \n            #if _PACKEDFAST\n               smoothAO.x = snowNormSamp.r;\n               smoothAO.y = snowNormSamp.b;\n            #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask0 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv0, dx, dy);\n            half4 snowMask1 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv1, dx, dy);\n            half4 snowMask2 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n            half4 snowMask = snowMask0 * weights.x + snowMask1 * weights.y + snowMask2 * weights.z;\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n      #else // not stochastic\n          albedo = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv, dx, dy);\n          COUNTSAMPLE\n\n          normal = half3(0,0,1);\n          smoothAO = half2(0, 1);\n\n          #if !_AUTONORMAL\n             half4 snowNormSamp = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv, dx, dy);\n             COUNTSAMPLE\n             normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n             #if _SURFACEGRADIENT\n                normal = ConvertNormalToGradient(d, normal);\n             #endif\n                 \n             #if _PACKEDFAST\n                smoothAO.x = snowNormSamp.r;\n                smoothAO.y = snowNormSamp.b;\n             #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv, dx, dy);\n            COUNTSAMPLE\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n     #endif // stochastic\n   }\n\n   \n   void Ext_SurfaceFunction8 (inout Surface o, ShaderData d)\n   {\n      #if _SNOW\n          float amount = _SnowAmount;\n          if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n          float snowAmount = lerp(dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), dot(d.worldSpaceNormal, float3(0,1,0)), amount * 0.8) + 1;\n          snowAmount -= _SnowAngle;\n          snowAmount *= _SnowContrast;\n          snowAmount = saturate(snowAmount) - (1-amount) * (1-amount);\n\n          if (_SnowWorldFade.z > 0)\n          {\n             float worldFade = saturate((d.worldSpacePosition.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n             snowAmount *= worldFade;\n          }\n\n          #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(d.worldSpacePosition.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n          #endif\n          snowAmount = saturate(snowAmount);\n\n          float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw;\n          float2 dx = ddx(uv);\n          float2 dy = ddy(uv);\n\n          #if _TRAX_ON\n              float2 tuv = d.worldSpacePosition.xz * float2(1, -1) * _SnowTraxAlbedo_ST.xy + _SnowTraxAlbedo_ST.zw;\n              float2 tdx = ddx(uv);\n              float2 tdy = ddy(uv);\n          #endif\n\n          #if _LAYERVERTEXMASK\n              snowAmount *= d.vertexColor.a;\n          #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n              snowAmount *= d.blackboard.weightTextureMask.a;\n          #endif\n\n          UNITY_BRANCH\n          if (snowAmount > 0)\n          {\n             half4 snowAlbedo;\n             half3 snowNormal;\n             half2 snowSmoothAO;\n             SampleSnowSurface(TEXTURE2D_ARGS(_SnowAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowNormal, sampler_SnowAlbedo),\n                    TEXTURE2D_ARGS(_SnowMaskMap, sampler_SnowAlbedo), d, uv, dx, dy, snowAlbedo, snowNormal, snowSmoothAO);\n\n             snowAlbedo.rgb *= _SnowTint.rgb;\n\n             #if _TRAX_ON\n                half traxBuffer = 1 - d.blackboard.traxBuffer;\n                UNITY_BRANCH\n                if (traxBuffer > 0)\n                {\n                    half4 tsnowAlbedo;\n                    half3 tsnowNormal;\n                    half2 tsnowSmoothAO;\n                    SampleSnowSurface(TEXTURE2D_ARGS(_SnowTraxAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowTraxNormal, sampler_SnowAlbedo),\n                        TEXTURE2D_ARGS(_SnowTraxMaskMap, sampler_SnowAlbedo), d, tuv, tdx, tdy, tsnowAlbedo, tsnowNormal, tsnowSmoothAO);\n\n                    tsnowAlbedo.rgb *= _SnowTraxTint;\n                    half h = HeightBlend(snowAlbedo.a, tsnowAlbedo.a, traxBuffer, 0.5);\n                    snowAlbedo = lerp(snowAlbedo, tsnowAlbedo, h);\n                    snowNormal = lerp(snowNormal, tsnowNormal, h);\n                    snowSmoothAO = lerp(snowSmoothAO, tsnowSmoothAO, h);\n                }\n             #endif\n\n             #if !_AUTONORMAL\n                o.Normal = lerp(o.Normal, snowNormal, snowAmount);\n             #endif\n             o.Albedo = lerp(o.Albedo, snowAlbedo.rgb, snowAmount);\n             o.Alpha = lerp(o.Alpha, snowAlbedo.a, snowAmount);\n             o.Smoothness = lerp(o.Smoothness, snowSmoothAO.x, snowAmount);\n             o.Occlusion = lerp(o.Occlusion, snowSmoothAO.y, snowAmount);\n             o.Height = o.Alpha;\n\n          }\n      #endif\n   }\n\n   \n\n\n\n\n\n   TEXTURE2D(_WindParticulate);\n   SAMPLER(sampler_WindParticulate);\n\n// In case we want to read it more than once..\n\n#ifndef __STACKABLE_WIND_INCLUDES__\n#define __STACKABLE_WIND_INCLUDES__\n\n\n   half FilterRange(float4 range, float y)\n   {\n      half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));\n      w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));\n      return w;\n   }\n\n   \n   float2 RotateUV(float2 uv, float amt)\n   {\n      uv -=0.5;\n      float s = sin ( amt);\n      float c = cos ( amt );\n      float2x2 mtx = float2x2( c, -s, s, c);\n      mtx *= 0.5;\n      mtx += 0.5;\n      mtx = mtx * 2-1;\n      uv = mul ( uv, mtx );\n      uv += 0.5;\n      return uv;\n   }\n\n\n   half FilterWindParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)\n   {\n      float2 windDir = RotateUV(float2(1, 0), windRot);\n      float2 flow = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));\n      float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill\n      return FilterRange(range, cofacing);\n   }\n\n   half ProcessWindParticulateMask(inout half mask, float contrast)\n   {\n      mask = pow(abs(mask), abs(contrast));\n      half invMask = 1.0 - mask;\n      invMask *= invMask; \n      invMask *= invMask;\n      return invMask;\n   }\n#endif // include guard\n\n   void Ext_SurfaceFunction9 (inout Surface o, ShaderData d)\n   {\n      #if _WIND_ON && !_PASSMETA\n   \n         float3 upVector = float3(0,0,1);\n\n         half upDot = max(0.0, dot(d.worldSpaceNormal, float3(0, 1, 0)));\n\n         float2 uv = d.worldSpacePosition.xz;\n         if (_WindParticulateSpace > 0.5)\n            uv = d.texcoord0.xy;\n         float windRotation = _WindParticulateRotation;\n         float windStrength = _WindParticulateStrength;\n\n         float2 wuv = RotateUV(uv, windRotation);\n\n         half windBlend = 1.0;\n\n         float windWorldMask = FilterRange(_WindParticulateWorldHeightMask, d.worldSpacePosition.y);\n         windWorldMask *= FilterRange(_WindParticulateAngleMask, upDot);\n\n         // compute mask\n         wuv *= float2(_WindParticulate_ST.x, 1) * _WindParticulate_ST.y + _WindParticulate_ST.zw;\n         float speed = _Time.x * _WindParticulateSpeed;\n         half w1 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv * 3 + speed * float2(1,0)).g;\n         half w2 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv + speed * float2(1.1,0)).a;\n         half windMask = (w1 * w2);\n\n         windMask *= windStrength * windBlend * windWorldMask;\n         windMask *= saturate((_WindParticulateTextureHeight - o.Height) * 10);\n\n         half windInvMask = ProcessWindParticulateMask(windMask, _WindParticulatePower);\n    \n         o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);\n         o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindParticulateEmissive.rgb;\n         o.Normal.xy *= windInvMask;\n         o.Smoothness *= windInvMask;\n         o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;\n         o.Metallic *= windInvMask;\n      #endif\n\n   }\n\n\n\n\n\tvoid Ext_SurfaceFunction10 (inout Surface o, ShaderData d)\n\t{\n        if (_DoubleSidedNormalMode == 0)\n        {\n           o.Normal *= d.isFrontFace ? 1 : -1;\n        }\n        else if (_DoubleSidedNormalMode == 1)\n        {\n\t\t   o.Normal.z *= d.isFrontFace ? 1 : -1;\n        }\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction11 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _SURFACEGRADIENT\n\t\t\to.Normal = ResolveNormalFromSurfaceGradient(d, o.Normal);\n\t    #elif _AUTONORMAL\n\t        float3 dx = ddx(d.worldSpacePosition);\n\t\t\tfloat3 dy = ddy(d.worldSpacePosition);\n\t\t\tfloat3 crossX = cross(float3(0,1,0), dx);\n\t\t\tfloat3 crossY = cross(float3(0,1,0), dy);\n\t\t\tfloat3 dt = abs(dot(crossY, dx));\n\t\t\tfloat height = _AutoNormalStrength * 0.5 * o.Alpha;\n\t\t\tfloat3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n\t\t\tn.y *= -1.0;\n\t\t\to.Normal = normalize((dt * float3(0,1,0)) - n).xzy;\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#else\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#endif\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction12 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DEBUG_SAMPLECOUNT\n\t\t\tif (_sampleCount > _DebugSampleCountThreshold)\n\t\t\t{\n\t\t\t\to.Albedo.r = 1;\n\t\t\t\to.Albedo.gb *= 0.2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\to.Albedo.b = 1;\n\t\t\t}\n\n        #endif\n\t}\n\n\n\n\n\tSAMPLER(sampler_DissolveTexture);\n\tTEXTURE2D(_DissolveTexture);\n\tTEXTURE2D(_DissolveGradient);\n\n\tvoid Ext_SurfaceFunction13 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DISSOLVE\n\t\tfloat2 uv = d.texcoord0.xy * _DissolveTexture_ST.xy + _DissolveTexture_ST.zw;\n\t\tfloat2 dx = ddx(uv);\n\t\tfloat2 dy = ddy(uv);\n\n\t\tUNITY_BRANCH\n\t\tif (_DissolveAmount > 0)\n\t\t{\n\t\t\thalf dissolve = SAMPLE_TEXTURE2D_GRAD(_DissolveTexture, sampler_DissolveTexture, uv, dx, dy).g;\n\t\t\thalf cp =  saturate(_DissolveAmount - (dissolve - _DissolveAmount) * _DissolveEdgeContrast) + _DissolveAmount;\n\t\t\thalf cp2 = saturate(1.0 - abs((dissolve - _DissolveAmount) * _DissolveEdgeContrast));\n\t\t\tclip(1.0 - cp);\n\t\t\tfloat2 fuv = float2(cp2, 0.5);\n\t\t\thalf3 col = SAMPLE_TEXTURE2D_LOD(_DissolveGradient, sampler_DissolveTexture, fuv, 0).rgb;\n\t\t\t\t\n\t\t\to.Albedo = lerp(o.Albedo, col, _DissolveColoration * cp2);\n\t\t\to.Emission = lerp(o.Emission, col * _DissolveEmissiveStr, _DissolveColoration * cp2);\n\t\t}\n\t\t#endif\n\t}\n\n\n\n\n    float Dither8x8Bayer( int x, int y )\n    {\n        const float dither[ 64 ] = {\n                1, 49, 13, 61,  4, 52, 16, 64,\n            33, 17, 45, 29, 36, 20, 48, 32,\n                9, 57,  5, 53, 12, 60,  8, 56,\n            41, 25, 37, 21, 44, 28, 40, 24,\n                3, 51, 15, 63,  2, 50, 14, 62,\n            35, 19, 47, 31, 34, 18, 46, 30,\n            11, 59,  7, 55, 10, 58,  6, 54,\n            43, 27, 39, 23, 42, 26, 38, 22};\n        int r = y * 8 + x;\n        return dither[r] / 64; \n    }\n\n    void ApplyDitherCrossFadeVSP(float2 vpos, float fadeValue)\n    {\n        float dither = Dither8x8Bayer( fmod(vpos.x, 8), fmod(vpos.y, 8) );\n        float sgn = fadeValue > 0 ? 1.0f : -1.0f;\n        clip(dither - (1-fadeValue) * sgn);\n    }\n    \n\n\tvoid Ext_SurfaceFunction14 (inout Surface o, ShaderData d)\n\t{\n\t\t#if LOD_FADE_CROSSFADE\n            float4 screenPosNorm = d.screenPos / d.screenPos.w;\n            screenPosNorm.z = ( UNITY_NEAR_CLIP_VALUE >= 0 ) ? screenPosNorm.z : screenPosNorm.z * 0.5 + 0.5;\n            float2 clipScreen = screenPosNorm.xy * _ScreenParams.xy;\n            ApplyDitherCrossFadeVSP(clipScreen,unity_LODFade.x);\n        #endif\n\t}\n\n\n\n\n\n\n// declare outside of CBuffer\n\nfloat4x4 _GlobalVolumeMatrix;\nfloat4x4 _VolumeMatrix;\nfloat3 _VolumeMin;\nfloat3 _VolumeInvSize;\nfloat3 _GlobalVolumeMin;\nfloat3 _GlobalVolumeInvSize;\n\n// I inlined a section of your include. You can use includes in better shaders, but doing it via a subshader or this way\n// is much better. The reason is that this allows your shader to be all inclusive, and packed up for asset store distribition,\n// without requiring specific paths to other files, etc.\n//\n\n#ifndef BAKERY_INCLUDED\n#define BAKERY_INCLUDED\n\n#define BAKERYMODE_DEFAULT 0\n#define BAKERYMODE_VERTEXLM 1.0f\n#define BAKERYMODE_RNM 2.0f\n#define BAKERYMODE_SH 3.0f\n\n\n// can't fit vertexLM SH to sm3_0 interpolators\n#ifndef SHADER_API_D3D11\n    #undef _LIGHTMAPMODE_VERTEXSH\n#endif\n\n// can't do stuff on sm2_0 due to standard shader alrady taking up all instructions\n#if SHADER_TARGET < 30\n    #undef BAKERY_BICUBIC\n    #undef BAKERY_LMSPEC\n\n    #undef _LIGHTMAPMODE_RNM\n    #undef _LIGHTMAPMODE_SH\n    #undef _LIGHTMAPMODE_VERTEX\n#endif\n\n#define lumaConv float3(0.2125f, 0.7154f, 0.0721f)\n\n#ifdef BAKERY_VOLUME\n    #ifdef BAKERY_COMPRESSED_VOLUME\n        Texture3D _Volume3;\n    #endif\n#endif\n\n\nhalf3 LinearToGamma (half3 linRGB)\n{\n    linRGB = max(linRGB, half3(0.h, 0.h, 0.h));\n    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n    return max(1.055h * pow(linRGB, 0.416666667h) - 0.055h, 0.h);\n}\n\nfloat shEvaluateDiffuseL1Geomerics(float L0, float3 L1, float3 n)\n{\n    // average energy\n    float R0 = L0;\n\n    // avg direction of incoming light\n    float3 R1 = 0.5f * L1;\n\n    // directional brightness\n    float lenR1 = length(R1);\n\n    // linear angle between normal and direction 0-1\n    //float q = 0.5f * (1.0f + dot(R1 / lenR1, n));\n    //float q = dot(R1 / lenR1, n) * 0.5 + 0.5;\n    float q = dot(normalize(R1), n) * 0.5 + 0.5;\n\n    // power for q\n    // lerps from 1 (linear) to 3 (cubic) based on directionality\n    float p = 1.0f + 2.0f * lenR1 / R0;\n\n    // dynamic range constant\n    // should vary between 4 (highly directional) and 0 (ambient)\n    float a = (1.0f - lenR1 / R0) / (1.0f + lenR1 / R0);\n\n    return R0 * (a + (1.0f - a) * (p + 1.0f) * pow(q, p));\n}\n\n#ifdef BAKERY_VERTEXLMMASK\n    float4 unpack4NFloats(float src)\n\t{\n        //return fmod(float4(src / 262144.0, src / 4096.0, src / 64.0, src), 64.0)/64.0;\n        return frac(float4(src / (262144.0*64), src / (4096.0*64), src / (64.0*64), src));\n    }\n#endif\n\n#if defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n    float3 unpack3NFloats(float src)\n\t{\n        float r = frac(src);\n        float g = frac(src * 256.0);\n        float b = frac(src * 65536.0);\n        return float3(r, g, b);\n    }\n#endif\n\n// Unity defines these under different names in each SRP, so use our own\ninline float3 Bakery_SafeNormalize(float3 inVec)\n{\n    float dp3 = max(0.001f, dot(inVec, inVec));\n    return inVec * rsqrt(dp3);\n}\n\n#if _URP || _HDRP\n\nfloat SmoothnessToPerceptualRoughness(float smoothness)\n{\n    return (1 - smoothness);\n}\n#endif\n\n#if !_STANDARD\nhalf4 unity_Lightmap_HDR;\ninline half3 DecodeLightmap( half4 color )\n{\n    return DecodeLightmap( color, unity_Lightmap_HDR );\n}\n\n#define UNITY_INV_PI        0.31830988618f\ninline float GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return UNITY_INV_PI * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n    void BakeryVertexLMDirection(inout float3 diffuseColor, inout float3 specularColor, float3 lightDirection, float3 vertexNormalWorld, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 dominantDir = Bakery_SafeNormalize(lightDirection);\n        half halfLambert = dot(normalWorld, dominantDir) * 0.5 + 0.5;\n        half flatNormalHalfLambert = dot(vertexNormalWorld, dominantDir) * 0.5 + 0.5;\n\n        #ifdef BAKERY_LMSPEC\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = spec * diffuseColor;\n        #endif\n\n        diffuseColor *= halfLambert / max(1e-4h, flatNormalHalfLambert);\n    }\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXSH\n    void BakeryVertexLMSH(inout float3 diffuseColor, inout float3 specularColor, float3 shL1x, float3 shL1y, float3 shL1z, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 L0 = diffuseColor;\n        float3 nL1x = shL1x;\n        float3 nL1y = shL1y;\n        float3 nL1z = shL1z;\n        float3 L1x = nL1x * L0 * 2;\n        float3 L1y = nL1y * L0 * 2;\n        float3 L1z = nL1z * L0 * 2;\n\n        float3 sh;\n    #if BAKERY_SHNONLINEAR\n        //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n        //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n        //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n        float lumaL0 = dot(L0, 1);\n        float lumaL1x = dot(L1x, 1);\n        float lumaL1y = dot(L1y, 1);\n        float lumaL1z = dot(L1z, 1);\n        float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n        float regularLumaSH = dot(sh, 1);\n        //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n        sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    #else\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    #endif\n\n        diffuseColor = max(sh, 0.0);\n\n        #ifdef BAKERY_LMSPEC\n            float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n            float focus = saturate(length(dominantDir));\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = max(spec * sh, 0.0);\n        #endif\n    }\n#endif\n\n\n\n#ifdef BAKERY_BICUBIC\nfloat BakeryBicubic_w0(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-a + 3.0f) - 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w1(float a)\n{\n    return (1.0f/6.0f)*(a*a*(3.0f*a - 6.0f) + 4.0f);\n}\n\nfloat BakeryBicubic_w2(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-3.0f*a + 3.0f) + 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w3(float a)\n{\n    return (1.0f/6.0f)*(a*a*a);\n}\n\nfloat BakeryBicubic_g0(float a)\n{\n    return BakeryBicubic_w0(a) + BakeryBicubic_w1(a);\n}\n\nfloat BakeryBicubic_g1(float a)\n{\n    return BakeryBicubic_w2(a) + BakeryBicubic_w3(a);\n}\n\nfloat BakeryBicubic_h0(float a)\n{\n    return -1.0f + BakeryBicubic_w1(a) / (BakeryBicubic_w0(a) + BakeryBicubic_w1(a)) + 0.5f;\n}\n\nfloat BakeryBicubic_h1(float a)\n{\n    return 1.0f + BakeryBicubic_w3(a) / (BakeryBicubic_w2(a) + BakeryBicubic_w3(a)) + 0.5f;\n}\n#endif\n\n\n#if defined(_LIGHTMAPMODE_RNM) || defined(_LIGHTMAPMODE_SH)\nTexture2D _RNM0, _RNM1, _RNM2;\n#endif\n\n#ifdef BAKERY_VOLUME\nTexture3D _Volume0, _Volume1, _Volume2, _VolumeMask;\nSamplerState sampler_Volume0;\n#endif\n\n#if defined(BAKERY_BICUBIC) && defined(LIGHTMAP_ON) && defined(SHADER_API_D3D11)\n    // Bicubic\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\tfloat width, height;\n\t\ttex.GetDimensions(width, height);\n\t\tfloat texelSize = 1.0f / width;\n\n        float x = uv.x * width;\n        float y = uv.y * width;\n\n        x -= 0.5f;\n        y -= 0.5f;\n\n        float px = floor(x);\n        float py = floor(y);\n\n        float fx = x - px;\n        float fy = y - py;\n\n        float g0x = BakeryBicubic_g0(fx);\n        float g1x = BakeryBicubic_g1(fx);\n        float h0x = BakeryBicubic_h0(fx);\n        float h1x = BakeryBicubic_h1(fx);\n        float h0y = BakeryBicubic_h0(fy);\n        float h1y = BakeryBicubic_h1(fy);\n\n        return     BakeryBicubic_g0(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h0y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h0y) * texelSize))) +\n\n                   BakeryBicubic_g1(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h1y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h1y) * texelSize)));\n    }\n#else\n    // Bilinear\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\t#ifdef LIGHTMAP_ON\n\t\t\treturn tex.Sample(samplerunity_Lightmap, uv);\n\t\t#else\n\t\t\treturn float4(1,0,0,1);\n\t\t#endif\n    }\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\n#ifdef BAKERY_LMSPEC\nfloat BakeryDirectionalLightmapSpecular(float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 dominantDir = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap, lmUV).xyz * 2 - 1;\n    half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n    half nh = saturate(dot(normalWorld, halfDir));\n    half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n    half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n    half spec = GGXTerm(nh, roughness);\n    return spec;\n}\n#endif\n#endif\n\n\n\n#ifdef _LIGHTMAPMODE_RNM\nvoid BakeryRNM(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalMap, float smoothness, float3 viewDirT)\n{\n    const float3 rnmBasis0 = float3(0.816496580927726f, 0, 0.5773502691896258f);\n    const float3 rnmBasis1 = float3(-0.4082482904638631f, 0.7071067811865475f, 0.5773502691896258f);\n    const float3 rnmBasis2 = float3(-0.4082482904638631f, -0.7071067811865475f, 0.5773502691896258f);\n\n    float3 rnm0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 rnm1 = DecodeLightmap(BakeryTex2D(_RNM1, lmUV));\n    float3 rnm2 = DecodeLightmap(BakeryTex2D(_RNM2, lmUV));\n\n    #ifdef BAKERY_SSBUMP\n        diffuseColor = normalMap.x * rnm0\n                     + normalMap.z * rnm1\n                     + normalMap.y * rnm2;\n         diffuseColor *= 2;\n    #else\n        diffuseColor = saturate(dot(rnmBasis0, normalMap)) * rnm0\n                     + saturate(dot(rnmBasis1, normalMap)) * rnm1\n                     + saturate(dot(rnmBasis2, normalMap)) * rnm2;\n    #endif\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDirT = rnmBasis0 * dot(rnm0, lumaConv) +\n                              rnmBasis1 * dot(rnm1, lumaConv) +\n                              rnmBasis2 * dot(rnm2, lumaConv);\n\n        float3 dominantDirTN = normalize(dominantDirT);\n        float3 specColor = saturate(dot(rnmBasis0, dominantDirTN)) * rnm0 +\n                           saturate(dot(rnmBasis1, dominantDirTN)) * rnm1 +\n                           saturate(dot(rnmBasis2, dominantDirTN)) * rnm2;\n\n        half3 halfDir = Bakery_SafeNormalize(dominantDirTN - viewDirT);\n        half nh = saturate(dot(normalMap, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n        specularColor = spec * specColor;\n    #endif\n}\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\ninline half3 Unity_DecodeDirectionalLightmap(half3 color, half4 dirTex, half3 normalWorld)\n{\n    // In directional (non-specular) mode Enlighten bakes dominant light direction\n    // in a way, that using it for half Lambert and then dividing by a \"rebalancing coefficient\"\n    // gives a result close to plain diffuse response lightmaps, but normalmapped.\n\n    // Note that dir is not unit length on purpose. Its length is \"directionality\", like\n    // for the directional specular lightmaps.\n\n    half halfLambert = dot(normalWorld, dirTex.xyz - 0.5) + 0.5;\n\n    return color * halfLambert / max(1e-4h, dirTex.w);\n}\n#endif\n\n#ifdef _LIGHTMAPMODE_SH\nvoid BakerySH(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 L0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 nL1x = BakeryTex2D(_RNM0, lmUV) * 2 - 1;\n    float3 nL1y = BakeryTex2D(_RNM1, lmUV) * 2 - 1;\n    float3 nL1z = BakeryTex2D(_RNM2, lmUV) * 2 - 1;\n    float3 L1x = nL1x * L0 * 2;\n    float3 L1y = nL1y * L0 * 2;\n    float3 L1z = nL1z * L0 * 2;\n\n    float3 sh;\n#if BAKERY_SHNONLINEAR\n    float lumaL0 = dot(L0, 1);\n    float lumaL1x = dot(L1x, 1);\n    float lumaL1y = dot(L1y, 1);\n    float lumaL1z = dot(L1z, 1);\n    float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    float regularLumaSH = dot(sh, 1);\n    //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n    sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n    //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n    //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n#else\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n#endif\n\n    diffuseColor = max(sh, 0.0);\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n        float focus = saturate(length(dominantDir));\n        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n        half nh = saturate(dot(normalWorld, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n\n        sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n\n        specularColor = max(spec * sh, 0.0);\n    #endif\n}\n#endif\n\n#endif // include guards\n\n\n    void Ext_ModifyVertex15 (inout VertexData v, inout ExtraV2F e)\n    {\n        #if _USEBAKERY\n\t\t    #if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\t\t\t    // Unpack from RGBM\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.a * 8.0f;\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.rgb;\n\n\t\t\t    #ifdef BAKERY_VERTEXLMMASK\n\t\t\t\t    e.extraV2F4.xyzw = unpack4NFloats(v.texcoord1);\n\t\t\t    #endif\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXSH\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n                e.extraV2F6.xyz = unpack3NFloats(v.texcoord3.x) * 2 - 1;\n                e.extraV2F7.xyz = unpack3NFloats(v.texcoord3.y) * 2 - 1;\n            #endif\n       #endif\n    }\n\n#if _HDRP || _URP\n    half3 SHEvalLinearL0L1 (half4 normal)\n    {\n        half3 x;\n\n        // Linear (L1) + constant (L0) polynomial terms\n        x.r = dot(unity_SHAr,normal);\n        x.g = dot(unity_SHAg,normal);\n        x.b = dot(unity_SHAb,normal);\n\n        return x;\n    }\n\n    // normal should be normalized, w=1.0\n    half3 SHEvalLinearL2 (half4 normal)\n    {\n        half3 x1, x2;\n        // 4 of the quadratic (L2) polynomials\n        half4 vB = normal.xyzz * normal.yzzx;\n        x1.r = dot(unity_SHBr,vB);\n        x1.g = dot(unity_SHBg,vB);\n        x1.b = dot(unity_SHBb,vB);\n\n        // Final (5th) quadratic (L2) polynomial\n        half vC = normal.x*normal.x - normal.y*normal.y;\n        x2 = unity_SHC.rgb * vC;\n\n        return x1 + x2;\n    }\n\n    half3 ShadeSH9 (half4 normal)\n    {\n        // Linear + constant polynomial terms\n        half3 res = SHEvalLinearL0L1 (normal);\n\n        // Quadratic polynomials\n        res += SHEvalLinearL2 (normal);\n\n        #ifdef UNITY_COLORSPACE_GAMMA\n            res = LinearToGamma (res);\n        #endif\n\n        return res;\n\n    }\n#endif\n\n\n\n\tvoid DoBakeryStuff(inout float3 indDif, inout float3 indSpec, inout float4 shadowmask, float3 tangentNormal, float smoothness, ShaderData d)\n\t{\n\t\t// Quality!\n\t\tindDif = 1;\n\t\tindSpec = 0;\n\n        #if defined(_PASSFORWARD) || defined(_PASSGBUFFER) // forward pass on URP/Standard/HDRP + built-in deferred\n\n            float3 normalWorld = mul(tangentNormal, d.TBNMatrix);\n\n\t\t\t#ifdef LIGHTMAP_ON\n\n                // Static\n\n\t\t\t\tfloat2 lmUV = d.texcoord1 * unity_LightmapST.xy + unity_LightmapST.zw;\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_STANDARD\n\t\t\t\t\tindDif = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n\n\t\t\t\t\t#ifdef DIRLIGHTMAP_COMBINED\n\t\t\t\t\t\tfloat4 dirMap = BakeryTex2D(unity_LightmapInd, lmUV);\n\t\t\t\t\t\tindDif = Unity_DecodeDirectionalLightmap(indDif, dirMap, normalWorld);\n\n\t\t\t\t\t\t#ifdef BAKERY_LMSPEC\n\t\t\t\t\t\t\tindSpec = BakeryDirectionalLightmapSpecular(lmUV, normalWorld, -d.worldSpaceViewDir, smoothness) * indDif;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\n\t\t\t\t\tindDif = d.vertexColor;\n\n                    #ifdef BAKERY_VERTEXLMMASK\n                        shadowmask = d.extraV2F4;\n                    #endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n\t\t\t\t\t\t// worldSpaceNormal is per-vertex\n\t\t\t\t\t\t// normalWorld is per-pixel\n\t\t\t\t\t\tfloat3 bakedLightDirection = d.extraV2F5;\n\t\t\t\t\t\tBakeryVertexLMDirection(indDif, indSpec, bakedLightDirection, d.worldSpaceNormal, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXSH\n\t\t\t\t\t\tBakeryVertexLMSH(indDif, indSpec, d.extraV2F5, d.extraV2F6, d.extraV2F7, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_RNM\n\t\t\t\t\tBakeryRNM(indDif, indSpec, lmUV, tangentNormal, smoothness, -d.tangentSpaceViewDir);\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_SH\n\t\t\t\t\tBakerySH(indDif, indSpec, lmUV, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t#endif\n\n            #else\n\n                // Dynamic\n\n                #ifdef BAKERY_VOLUME\n\n                    bool isGlobal = dot(abs(_VolumeInvSize),1) == 0;\n                    float3 volViewDir = -d.worldSpaceViewDir;\n                    #ifdef BAKERY_VOLROTATION\n                        float4x4 volMatrix = (isGlobal ? _GlobalVolumeMatrix : _VolumeMatrix);\n                        float3 volInvSize = (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 lpUV = mul(volMatrix, float4(d.worldSpacePosition,1)).xyz * volInvSize + 0.5f;\n                        float3 volNormal = mul((float3x3)volMatrix, normalWorld);\n                        #ifdef BAKERY_LMSPEC\n                            volViewDir = mul((float3x3)volMatrix, volViewDir);\n                        #endif\n                    #else\n                        float3 lpUV = (d.worldSpacePosition - (isGlobal ? _GlobalVolumeMin : _VolumeMin)) * (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 volNormal = normalWorld;\n                    #endif\n\n                    #ifdef BAKERY_COMPRESSED_VOLUME\n                        float4 tex0, tex1, tex2, tex3;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex3 = _Volume3.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz * L0;\n                        L1y = tex2.xyz * L0;\n                        L1z = tex3.xyz * L0;\n                    #else\n                        float4 tex0, tex1, tex2;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV);\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV);\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz;\n                        L1y = tex2.xyz;\n                        L1z = float3(tex0.w, tex1.w, tex2.w);\n                    #endif\n                    indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), volNormal);\n                    indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), volNormal);\n                    indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), volNormal);\n\n                    #ifdef UNITY_COLORSPACE_GAMMA\n                        indDif = pow(indDif, 1.0f / 2.2f);\n                    #endif\n\n                    #ifdef BAKERY_LMSPEC\n                        float3 nL1x = L1x / L0;\n                        float3 nL1y = L1y / L0;\n                        float3 nL1z = L1z / L0;\n                        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n                        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - volViewDir);\n                        half nh = saturate(dot(volNormal, halfDir));\n                        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n                        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n                        half spec = GGXTerm(nh, roughness);\n                        float3 sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n                        indSpec = max(spec * sh, 0.0);\n                    #endif\n\n                    shadowmask = _VolumeMask.Sample(sampler_Volume0, lpUV);\n\n                #else\n\n                    #ifdef BAKERY_SHNONLINEAR\n                        float3 L0 = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);\n                        indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, unity_SHAr.xyz, normalWorld);\n                        indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, unity_SHAg.xyz, normalWorld);\n                        indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, unity_SHAb.xyz, normalWorld);\n                    #else\n                        indDif = ShadeSH9(float4(normalWorld,1));\n                    #endif\n\n                #endif\n\n\t\t\t#endif\n\n        #endif\n\t}\n\n\t// this is the main surface function. Surface is like a surface shader output structure, but\n\t// with our new outputs as well.\n\tvoid Ext_SurfaceFunction15 (inout Surface o, ShaderData d)\n\t{\n        #if _USEBAKERY\n\t\t    float3 indDif;\n\t\t    float3 indSpec;\n            float4 shadowmask = 1;\n\t\t    DoBakeryStuff(indDif, indSpec, shadowmask, o.Normal, o.Smoothness, d);\n\t\t    o.DiffuseGI = indDif;\n\t\t    o.BackDiffuseGI = indDif;\n\t\t    o.SpecularGI = indSpec;\n            o.ShadowMask = shadowmask;\n        #endif\n\t}\n\n\n\n\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                  Ext_SurfaceFunction1(l, d);\n                  Ext_SurfaceFunction2(l, d);\n                  Ext_SurfaceFunction3(l, d);\n                  Ext_SurfaceFunction4(l, d);\n                  Ext_SurfaceFunction5(l, d);\n                  Ext_SurfaceFunction6(l, d);\n                  Ext_SurfaceFunction7(l, d);\n                  Ext_SurfaceFunction8(l, d);\n                  Ext_SurfaceFunction9(l, d);\n\t\t            Ext_SurfaceFunction10(l, d);\n                  Ext_SurfaceFunction11(l, d);\n                  Ext_SurfaceFunction12(l, d);\n                  Ext_SurfaceFunction13(l, d);\n                  Ext_SurfaceFunction14(l, d);\n                  Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraV2F d;\n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                  Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                  Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                  #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                  v2p.extraV2F4 = d.extraV2F4;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                  v2p.extraV2F5 = d.extraV2F5;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F6 = d.extraV2F6;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F7 = d.extraV2F7;\n                  #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                d.extraV2F4 = v2p.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                d.extraV2F5 = v2p.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F6 = v2p.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F7 = v2p.extraV2F7;\n                #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n                Ext_ModifyTessellatedVertex2(v, d);\n                Ext_ModifyTessellatedVertex3(v, d);\n                Ext_ModifyTessellatedVertex4(v, d);\n                Ext_ModifyTessellatedVertex5(v, d);\n                Ext_ModifyTessellatedVertex6(v, d);\n                Ext_ModifyTessellatedVertex7(v, d);\n                Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                v2p.extraV2F4 = d.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                v2p.extraV2F5 = d.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F6 = d.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F7 = d.extraV2F7;\n                #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n            // d.texcoord3 = i.texcoord3;\n             #endif\n\n             d.isFrontFace = facing;\n             #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n             d.vertexColor = i.vertexColor;\n             #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(i.worldPos, 1)).xyz;\n            #endif\n             d.localSpaceNormal = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n             #if LOD_FADE_CROSSFADE\n             d.screenPos = i.screenPos;\n             d.screenUV = (i.screenPos.xy / i.screenPos.w);\n             #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n             #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n             d.extraV2F4 = i.extraV2F4;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n             d.extraV2F5 = i.extraV2F5;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F6 = i.extraV2F6;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F7 = i.extraV2F7;\n             #endif\n\n            return d;\n         }\n         \n\n            \n\nstruct VaryingsToPS\n{\n   VertexToPixel vmesh;\n   #ifdef VARYINGS_NEED_PASS\n      VaryingsPassToPS vpass;\n   #endif\n};\n\nstruct PackedVaryingsToPS\n{\n   #ifdef VARYINGS_NEED_PASS\n      PackedVaryingsPassToPS vpass;\n   #endif\n   VertexToPixel vmesh;\n\n   UNITY_VERTEX_OUTPUT_STEREO\n};\n\nPackedVaryingsToPS PackVaryingsToPS(VaryingsToPS input)\n{\n   PackedVaryingsToPS output = (PackedVaryingsToPS)0;\n   output.vmesh = input.vmesh;\n   #ifdef VARYINGS_NEED_PASS\n      output.vpass = PackVaryingsPassToPS(input.vpass);\n   #endif\n\n   UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n   return output;\n}\n\n\n\n\nVertexToPixel VertMesh(VertexData input)\n{\n    VertexToPixel output = (VertexToPixel)0;\n\n    UNITY_SETUP_INSTANCE_ID(input);\n    UNITY_TRANSFER_INSTANCE_ID(input, output);\n\n    \n    ChainModifyVertex(input, output);\n\n\n    // This return the camera relative position (if enable)\n    float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n    float3 normalWS = TransformObjectToWorldNormal(input.normal);\n    float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n    output.worldPos = GetAbsolutePositionWS(positionRWS);\n    output.pos = TransformWorldToHClip(positionRWS);\n    output.worldNormal = normalWS;\n    output.worldTangent = tangentWS;\n\n\n    output.texcoord0 = input.texcoord0;\n    output.texcoord1 = input.texcoord1;\n    output.texcoord2 = input.texcoord2;\n     #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n    // output.texcoord3 = input.texcoord3;\n     #endif\n\n     #if LOD_FADE_CROSSFADE\n     output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n     #endif\n\n     #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n     output.vertexColor = input.vertexColor;\n     #endif\n    return output;\n}\n\n\n#if (SHADERPASS == SHADERPASS_DBUFFER_MESH)\nvoid MeshDecalsPositionZBias(inout VaryingsToPS input)\n{\n#if defined(UNITY_REVERSED_Z)\n    input.vmesh.pos.z -= _DecalMeshDepthBias;\n#else\n    input.vmesh.pos.z += _DecalMeshDepthBias;\n#endif\n}\n#endif\n\n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n// This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\nfloat unity_OneOverOutputBoost;\nfloat unity_MaxOutputValue;\n\nCBUFFER_START(UnityMetaPass)\n// x = use uv1 as raster position\n// y = use uv2 as raster position\nbool4 unity_MetaVertexControl;\n\n// x = return albedo\n// y = return normal\nbool4 unity_MetaFragmentControl;\nCBUFFER_END\n\nPackedVaryingsToPS Vert(VertexData inputMesh)\n{\n    VaryingsToPS output = (VaryingsToPS)0;\n    output.vmesh = (VertexToPixel)0;\n\n    UNITY_SETUP_INSTANCE_ID(inputMesh);\n    UNITY_TRANSFER_INSTANCE_ID(inputMesh, output.vmesh);\n\n    // Output UV coordinate in vertex shader\n    float2 uv = float2(0.0, 0.0);\n\n    if (unity_MetaVertexControl.x)\n    {\n        uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n    }\n    else if (unity_MetaVertexControl.y)\n    {\n        uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n    }\n\n    // OpenGL right now needs to actually use the incoming vertex position\n    // so we create a fake dependency on it here that haven't any impact.\n    output.vmesh.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n#ifdef VARYINGS_NEED_POSITION_WS\n    output.vmesh.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz);\n#endif\n\n#ifdef VARYINGS_NEED_TANGENT_TO_WORLD\n    // Normal is required for triplanar mapping\n    output.vmesh.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n    // Not required but assign to silent compiler warning\n    output.vmesh.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n#endif\n\n    output.vmesh.texcoord0 = inputMesh.texcoord0;\n    output.vmesh.texcoord1 = inputMesh.texcoord1;\n    output.vmesh.texcoord2 = inputMesh.texcoord2;\n     #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n    // output.vmesh.texcoord3 = inputMesh.texcoord3;\n     #endif\n\n     #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n     output.vmesh.vertexColor = inputMesh.vertexColor;\n     #endif\n\n    return PackVaryingsToPS(output);\n}\n#else\n\nPackedVaryingsToPS Vert(VertexData inputMesh)\n{\n    VaryingsToPS varyingsType;\n    varyingsType.vmesh = VertMesh(inputMesh);\n    #if (SHADERPASS == SHADERPASS_DBUFFER_MESH)\n       MeshDecalsPositionZBias(varyingsType);\n    #endif\n    return PackVaryingsToPS(varyingsType);\n}\n\n#endif\n\n\n\n            \n\n            \n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n            \n                    output.positionRWS = input.worldPos;\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n            \n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n        \n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n        \n           #ifdef _HAS_REFRACTION\n                   if (_EnableSSRefraction)\n                   {\n                       // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                       // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                       // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n        \n                       surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                       surfaceDescription.Alpha = 1.0;\n                   }\n                   else\n                   {\n                       surfaceData.ior = 1.0;\n                       surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                       surfaceData.atDistance = 1.0;\n                       surfaceData.transmittanceMask = 0.0;\n                       surfaceDescription.Alpha = 1.0;\n                   }\n           #else\n                   surfaceData.ior = 1.0;\n                   surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                   surfaceData.atDistance = 1.0;\n                   surfaceData.transmittanceMask = 0.0;\n           #endif\n                \n                   // These static material feature allow compile time optimization\n                   surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n           #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n           #endif\n           #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n           #endif\n           #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n           #endif\n                   // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n        \n           #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n           #endif\n           #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n           #endif\n        \n           #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                   // Require to have setup baseColor\n                   // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                   surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n           #endif\n\n        \n                   // tangent-space normal\n                   float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                   normalTS = surfaceDescription.Normal;\n        \n                   // compute world space normal\n                   #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(normalTS, fragInputs.tangentToWorld);\n                   #else\n                      surfaceData.normalWS = normalTS;  \n                   #endif\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                   // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent, fragInputs.tangentToWorld);\n        \n           #if HAVE_DECALS\n                   if (_EnableDecals)\n                   {\n                       #if VERSION_GREATER_EQUAL(10,2)\n                          DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput,  surfaceData.geomNormalWS, surfaceDescription.Alpha);\n                          ApplyDecalToSurfaceData(decalSurfaceData,  surfaceData.geomNormalWS, surfaceData);\n                       #else\n                          DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                          ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                       #endif\n                   }\n           #endif\n        \n                   bentNormalWS = surfaceData.normalWS;\n               \n                   surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n        \n        \n                   // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                   // If user provide bent normal then we process a better term\n           #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                   // Just use the value passed through via the slot (not active otherwise)\n           #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                   // If we have bent normal and ambient occlusion, process a specular occlusion\n                   surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n           #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                   surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n           #endif\n        \n           #ifdef _ENABLE_GEOMETRIC_SPECULAR_AA\n                   surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n           #endif\n        \n           #ifdef DEBUG_DISPLAY\n                   if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                   {\n                       // TODO: need to update mip info\n                       surfaceData.metallic = 0;\n                   }\n        \n                   // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                   // as it can modify attribute use for static lighting\n                   ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n           #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //    uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to _ScreenSize values\n                 //    LODDitheringTransition(fadeMaskSeed, unity_LODFade.x);\n                 //#endif\n        \n                 d = CreateShaderData(m2ps\n                  #if NEED_FACING\n                    , facing\n                  #endif\n                 );\n\n                 \n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #ifdef _DEPTHOFFSET_ON\n                    l.outputDepth = posInput.deviceDepth;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #ifdef _DEPTHOFFSET_ON\n                    posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n        \n                 #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     //builtinData.distortion = surfaceDescription.Distortion;\n                     //builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                     builtinData.distortion = float2(0.0, 0.0);\n                     builtinData.distortionBlur = 0.0;\n                 #else\n                     builtinData.distortion = float2(0.0, 0.0);\n                     builtinData.distortionBlur = 0.0;\n                 #endif\n        \n                   PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n               }\n            \n                      \n          void Frag(PackedVaryingsToPS packedInput,\n          #ifdef OUTPUT_SPLIT_LIGHTING\n              out float4 outColor : SV_Target0,  // outSpecularLighting\n              out float4 outDiffuseLighting : SV_Target1,\n              OUTPUT_SSSBUFFER(outSSSBuffer)\n          #else\n              out float4 outColor : SV_Target0\n          #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n              , out float4 outMotionVec : SV_Target1\n          #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n          #endif // OUTPUT_SPLIT_LIGHTING\n          #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n          #endif\n          #if NEED_FACING\n            , bool facing : SV_IsFrontFace\n          #endif\n          )\n          {\n          #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n              // Init outMotionVector here to solve compiler warning (potentially unitialized variable)\n              // It is init to the value of forceNoMotion (with 2.0)\n              outMotionVec = float4(2.0, 0.0, 0.0, 0.0);\n          #endif\n\n              UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(packedInput);\n              FragInputs input = BuildFragInputs(packedInput.vmesh);\n\n              // We need to readapt the SS position as our screen space positions are for a low res buffer, but we try to access a full res buffer.\n              input.positionSS.xy = _OffScreenRendering > 0 ? (input.positionSS.xy * _OffScreenDownsampleFactor) : input.positionSS.xy;\n\n              uint2 tileIndex = uint2(input.positionSS.xy) / GetTileSize();\n\n              // input.positionSS is SV_Position\n              PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS.xyz, tileIndex);\n\n              #ifdef VARYINGS_NEED_POSITION_WS\n                 float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n              #else\n                 // Unused\n                 float3 V = float3(1.0, 1.0, 1.0); // Avoid the division by 0\n              #endif\n\n              SurfaceData surfaceData;\n              BuiltinData builtinData;\n              Surface l;\n              ShaderData d;\n              GetSurfaceAndBuiltinData(packedInput.vmesh, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n\n              BSDFData bsdfData = ConvertSurfaceDataToBSDFData(input.positionSS.xy, surfaceData);\n\n              PreLightData preLightData = GetPreLightData(V, posInput, bsdfData);\n\n              outColor = float4(0.0, 0.0, 0.0, 0.0);\n\n              // We need to skip lighting when doing debug pass because the debug pass is done before lighting so some buffers may not be properly initialized potentially causing crashes on PS4.\n\n          #ifdef DEBUG_DISPLAY\n              // Init in debug display mode to quiet warning\n          #ifdef OUTPUT_SPLIT_LIGHTING\n              outDiffuseLighting = 0;\n              ENCODE_INTO_SSSBUFFER(surfaceData, posInput.positionSS, outSSSBuffer);\n          #endif\n\n              \n\n              // Same code in ShaderPassForwardUnlit.shader\n              // Reminder: _DebugViewMaterialArray[i]\n              //   i==0 -> the size used in the buffer\n              //   i>0  -> the index used (0 value means nothing)\n              // The index stored in this buffer could either be\n              //   - a gBufferIndex (always stored in _DebugViewMaterialArray[1] as only one supported)\n              //   - a property index which is different for each kind of material even if reflecting the same thing (see MaterialSharedProperty)\n              bool viewMaterial = false;\n              int bufferSize = int(_DebugViewMaterialArray[0]);\n              if (bufferSize != 0)\n              {\n                  bool needLinearToSRGB = false;\n                  float3 result = float3(1.0, 0.0, 1.0);\n\n                  // Loop through the whole buffer\n                  // Works because GetSurfaceDataDebug will do nothing if the index is not a known one\n                  for (int index = 1; index <= bufferSize; index++)\n                  {\n                      int indexMaterialProperty = int(_DebugViewMaterialArray[index]);\n\n                      // skip if not really in use\n                      if (indexMaterialProperty != 0)\n                      {\n                          viewMaterial = true;\n\n                          GetPropertiesDataDebug(indexMaterialProperty, result, needLinearToSRGB);\n                          GetVaryingsDataDebug(indexMaterialProperty, input, result, needLinearToSRGB);\n                          GetBuiltinDataDebug(indexMaterialProperty, builtinData, result, needLinearToSRGB);\n                          GetSurfaceDataDebug(indexMaterialProperty, surfaceData, result, needLinearToSRGB);\n                          GetBSDFDataDebug(indexMaterialProperty, bsdfData, result, needLinearToSRGB);\n                      }\n                  }\n\n                  // TEMP!\n                  // For now, the final blit in the backbuffer performs an sRGB write\n                  // So in the meantime we apply the inverse transform to linear data to compensate.\n                  if (!needLinearToSRGB)\n                      result = SRGBToLinear(max(0, result));\n\n                  outColor = float4(result, 1.0);\n              }\n\n              if (!viewMaterial)\n              {\n                  if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_VALIDATE_DIFFUSE_COLOR || _DebugFullScreenMode == FULLSCREENDEBUGMODE_VALIDATE_SPECULAR_COLOR)\n                  {\n                      float3 result = float3(0.0, 0.0, 0.0);\n\n                      GetPBRValidatorDebug(surfaceData, result);\n\n                      outColor = float4(result, 1.0f);\n                  }\n                  else if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_TRANSPARENCY_OVERDRAW)\n                  {\n                      float4 result = _DebugTransparencyOverdrawWeight * float4(TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_A);\n                      outColor = result;\n                  }\n                  else\n          #endif\n                  {\n          #ifdef _SURFACE_TYPE_TRANSPARENT\n                      uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_TRANSPARENT;\n          #else\n                      uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_OPAQUE;\n          #endif\n\n                      float3 diffuseLighting;\n                      float3 specularLighting;\n\n                      #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                      {\n                         LightLoopOutput lightLoopOutput;\n                         LightLoop(V, posInput, preLightData, bsdfData, builtinData, featureFlags, lightLoopOutput);\n\n                         // Alias\n                         diffuseLighting = lightLoopOutput.diffuseLighting;\n                         specularLighting = lightLoopOutput.specularLighting;\n                      }\n                      #else\n                      {\n                         LightLoop(V, posInput, preLightData, bsdfData, builtinData, featureFlags, diffuseLighting, specularLighting);\n                      }\n                      #endif\n\n                      diffuseLighting *= GetCurrentExposureMultiplier();\n                      specularLighting *= GetCurrentExposureMultiplier();\n\n          #ifdef OUTPUT_SPLIT_LIGHTING\n                      if (_EnableSubsurfaceScattering != 0 && ShouldOutputSplitLighting(bsdfData))\n                      {\n                          outColor = float4(specularLighting, 1.0);\n                          outDiffuseLighting = float4(TagLightingForSSS(diffuseLighting), 1.0);\n                      }\n                      else\n                      {\n                          outColor = float4(diffuseLighting + specularLighting, 1.0);\n                          outDiffuseLighting = 0;\n                      }\n                      ENCODE_INTO_SSSBUFFER(surfaceData, posInput.positionSS, outSSSBuffer);\n          #else\n                      outColor = ApplyBlendMode(diffuseLighting, specularLighting, builtinData.opacity);\n                      outColor = EvaluateAtmosphericScattering(posInput, V, outColor);\n          #endif\n\n          ChainFinalColorForward(l, d, outColor);\n\n          #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n                      VaryingsPassToPS inputPass = UnpackVaryingsPassToPS(packedInput.vpass);\n                      bool forceNoMotion = any(unity_MotionVectorsParams.yw == 0.0);\n                      // outMotionVec is already initialize at the value of forceNoMotion (see above)\n                      if (!forceNoMotion)\n                      {\n                          float2 motionVec = CalculateMotionVector(inputPass.positionCS, inputPass.previousPositionCS);\n                          EncodeMotionVector(motionVec * 0.5, outMotionVec);\n                          outMotionVec.zw = 1.0;\n                      }\n          #endif\n                  }\n\n          #ifdef DEBUG_DISPLAY\n              }\n          #endif\n\n          #ifdef _DEPTHOFFSET_ON\n              outputDepth = posInput.deviceDepth;\n          #endif\n          }\n\n            ENDHLSL\n        }\n\n      \n      \n      Pass\n        {\n            // based on HDLitPass.template\n            Name \"META\"\n            Tags { \"LightMode\" = \"META\" }\n            \n            Cull Off\n        \n               Cull [_CullMode]\n\n        \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 ps4 xboxone vulkan metal switch\n            //#pragma enable_d3d11_debug_symbols\n        \n            #pragma multi_compile_instancing\n\n            //#pragma multi_compile_local _ _ALPHATEST_ON\n\n\n            //#pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n        \n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            // #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            #define SHADERPASS SHADERPASS_LIGHT_TRANSPORT\n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #define REQUIRE_DEPTH_TEXTURE\n            #define _PASSMETA 1\n\n        \n            \n\n\n   #pragma shader_feature_local_fragment _ _PACKEDFAST\n   #pragma shader_feature_local _ _TRIPLANAR\n   #pragma shader_feature_local_fragment _ _NORMALMAP \n   #pragma shader_feature_local_fragment _ _MASKMAP\n   #pragma shader_feature_local_fragment _ _DETAIL\n   #pragma shader_feature_local_fragment _ _DETAILTRIPLANAR\n   #pragma shader_feature_local_fragment _ _DETAILSTOCHASTIC\n   #pragma shader_feature_local_fragment _ _EMISSION\n   #pragma shader_feature_local_fragment _ _FLATSHADE\n   #pragma shader_feature_local _ _STOCHASTIC\n   #pragma shader_feature_local_fragment _ _PARALLAX //_POM\n   #pragma shader_feature_local_fragment _ _SPECULAR\n   #pragma shader_feature_local _ _NOISEWORLD _NOISELOCAL\n   #pragma shader_feature_local _ _NOISEHQ _NOISETEXTURE _NOISEWORLEY\n   // only for URP/Standard Forward\n   #pragma shader_feature_local_fragment _ _SIMPLELIT\n\n\n   #pragma shader_feature_local_fragment _ _TINTMASK\n\n\n    #pragma shader_feature_local _ _LAYERVERTEXMASK _LAYERTEXTUREMASK\n\n    #define _HAS_WEIGHTTEXTURE_MASK 1\n\n\n   #pragma shader_feature_local _ _USELAYER\n   #pragma shader_feature_local _ _LAYERTRIPLANAR\n   #pragma shader_feature_local _ _LAYERALBEDO\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL\n   #pragma shader_feature_local _ _LAYERMASK\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION\n   #pragma shader_feature_local _ _LAYERNOISE\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC\n   #pragma shader_feature_local _ _LAYERANGLEFILTER\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_1\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_1\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_1\n   #pragma shader_feature_local _ _LAYERMASK_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_1\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_1\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_1\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_1\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_2\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_2\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_2\n   #pragma shader_feature_local _ _LAYERMASK_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_2\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_2\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_2\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_2\n\n\n   #pragma shader_feature_local _ _TRAX_ON\n\n\n   #pragma shader_feature_local_fragment _ _WETNESS\n   #pragma shader_feature_local_fragment _ _PUDDLES\n   #pragma shader_feature_local_fragment _ _PUDDLENOISE\n   #pragma shader_feature_local_fragment _ _RAINDROPS\n\n\n   #pragma shader_feature_local _ _SNOW\n   #pragma shader_feature_local _ _SNOWMASKMAP\n   #pragma shader_feature_local _ _SNOWNOISE\n   #pragma shader_feature_local_fragment _SNOWSTOCHASTIC\n\n\n   #pragma shader_feature_local_fragment _ _WIND_ON\n\n\n\n\n   #pragma shader_feature_local_fragment _ _SURFACEGRADIENT _AUTONORMAL\n   #define _WORLDSPACENORMAL 1\n\n\n   #pragma shader_feature_local _ _DEBUG_SAMPLECOUNT\n\n\n\t#pragma shader_feature_local_fragment _ _DISSOLVE\n\n\n   #pragma multi_compile_local  LOD_FADE_CROSSFADE\n\n\n\n#pragma instancing_options procedural:setupVSPro forwardadd\n\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\nstruct IndirectShaderData\n{\n\tfloat4x4 PositionMatrix;\n\tfloat4x4 InversePositionMatrix;\n\tfloat4 ControlData;\n};\n\n#if defined(SHADER_API_GLCORE) || defined(SHADER_API_D3D11) || defined(SHADER_API_GLES3) || defined(SHADER_API_METAL) || defined(SHADER_API_VULKAN) || defined(SHADER_API_PSSL) || defined(SHADER_API_XBOXONE)\n\tuniform StructuredBuffer<IndirectShaderData> VisibleShaderDataBuffer;\n#endif\n\n#endif\n\nfloat VSPRenderingLayerMask;\n\nvoid setupVSPro()\n{\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\n    #if _HDRP\n\t    unity_RenderingLayer.x = VSPRenderingLayerMask;\n    #endif\n\n\t#ifdef unity_ObjectToWorld\n\t#undef unity_ObjectToWorld\n\t#endif\n\n\t#ifdef unity_WorldToObject\n\t#undef unity_WorldToObject\n\t#endif\n\n\tunity_ObjectToWorld = VisibleShaderDataBuffer[unity_InstanceID].PositionMatrix;\n\tunity_WorldToObject = VisibleShaderDataBuffer[unity_InstanceID].InversePositionMatrix;\n#endif\n\n}\n\n\n\t#pragma multi_compile _LIGHTMAPMODE_STANDARD _LIGHTMAPMODE_RNM _LIGHTMAPMODE_SH _LIGHTMAPMODE_VERTEX _LIGHTMAPMODE_VERTEXDIRECTIONAL _LIGHTMAPMODE_VERTEXSH\n\n    #pragma shader_feature USEBAKERY\n    #pragma shader_feature BAKERY_VERTEXLMMASK\n    #pragma shader_feature BAKERY_SHNONLINEAR\n    #pragma shader_feature BAKERY_LMSPEC\n    #pragma shader_feature BAKERY_BICUBIC\n    #pragma shader_feature BAKERY_VOLUME\n    #pragma shader_feature BAKERY_VOLROTATION\n    #pragma shader_feature BAKERY_COMPRESSED_VOLUME\n\n    #if _USEBAKERY\n\t    #define _OVERRIDE_BAKEDGI\n        #if BAKERY_VOLUME || (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)) && defined(BAKERY_VERTEXLMMASK)\n            #define _OVERRIDE_SHADOWMASK\n        #endif\n    #endif\n\n\n\n\n\n\n\n\n   #define _HDRP 1\n#define _BLENDMODE_ALPHA 1\n#define _SURFACE_TYPE_TRANSPARENT 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n        \n\n            \n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n            #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n        \n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n        \n            // define FragInputs structure\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n               #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\"\n            #endif\n\n\n        \n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n        #ifdef DEBUG_DISPLAY\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n        #endif\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n        \n        #if (SHADERPASS == SHADERPASS_FORWARD)\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n        \n            #define HAS_LIGHTLOOP\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n        #else\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n        #endif\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n        \n            // Used by SceneSelectionPass\n            int _ObjectId;\n            int _PassValue;\n        \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCCOORD3;\n               float4 texcoord1 : TEXCCOORD4;\n               float4 texcoord2 : TEXCCOORD5;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n               // float4 texcoord3 : TEXCCOORD6;\n                #endif\n\n                #if LOD_FADE_CROSSFADE\n                float4 screenPos : TEXCOORD7;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR_centroid;\n                #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                float4 extraV2F4 : TEXCOORD12_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                float4 extraV2F5 : TEXCOORD13_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F6 : TEXCOORD14_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F7 : TEXCOORD15_centroid;\n                #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n\n  \n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n   half4 weightTextureMask;\n   \n\n\n   float traxBuffer;\n\n\n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // would love to strip these, but they are used in certain\n               // combinations of the lighting system, and may be used\n               // by the user as well, so no easy way to strip them.\n\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR_centroid;\n                #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                float4 extraV2F4 : TEXCOORD9_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                float4 extraV2F5 : TEXCOORD10_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F6 : TEXCOORD11_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F7 : TEXCOORD12_centroid;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n               #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n               #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n               #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n               #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()     unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n               #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V   unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n               #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V    mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n               #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n               #endif\n               #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n\n               float _StencilRef;\n               float _StencilWriteMask;\n               float _StencilRefDepth;\n               float _StencilWriteMaskDepth;\n               float _StencilRefMV;\n               float _StencilWriteMaskMV;\n               float _StencilRefDistortionVec;\n               float _StencilWriteMaskDistortionVec;\n               float _StencilWriteMaskGBuffer;\n               float _StencilRefGBuffer;\n               float _ZTestGBuffer;\n               float _RequireSplitLighting;\n               float _ReceivesSSR;\n               float _ZWrite;\n               float _TransparentSortPriority;\n               float _ZTestDepthEqualForOpaque;\n               float _ZTestTransparent;\n               float _TransparentBackfaceEnable;\n               float _AlphaCutoffEnable;\n               float _UseShadowThreshold;\n\n               \n\n\n   half4 _Tint;\n   half _UVSource;\n   half _TriplanarContrast;\n   half _AlbedoContrast;\n   half _AlbedoBrightness;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half3 _EmissionColor;\n   float _DetailUVSource;\n   half _StochasticScale;\n   half _DetailStochasticScale;\n   half _Smoothness;\n   half _Metallic;\n   half2 _SmoothnessRemap;\n   half2 _AORemap;\n   half2 _MetallicRemap;\n   half2 _HeightRemap;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n   half _AlphaThreshold;\n   half _Cutoff; // for Unity's light mapper\n   half _TriplanarSpace;\n   half _DetailTriplanarSpace;\n   half _DetailTriplanarContrast;\n   half _MicroShadowStrength;\n   half3 _FuzzyShadingColor;\n   half _FuzzyShadingOn;\n   half3 _FuzzyShadingParams;\n\n   //int _POMMaxSamples;\n   //float _POMMin;\n   //float _POMFade;\n#if _FLATSHADE\n   half _FlatShadingBlend;\n#endif\n\n   half _StochasticContrast;\n   half _DetailStochasticContrast;\n\n#if _PARALLAX || _POM\n   half _ParallaxHeight;\n#endif\n\n\n\n\tfloat4 _TintMask_ST;\n\thalf3 _RColor;\n\thalf3 _GColor;\n\thalf3 _BColor;\n\thalf3 _AColor;\n\n\n\thalf _LayerTextureMaskUVMode;\n    float4 _LayerTextureMask_ST;\n\n\n   //#if _USELAYER\n       float4 _LayerAlbedoMap_ST;\n       half3 _LayerTint;\n       half _LayerBlendMode;\n       float _LayerUVSource;\n       half _LayerAlbedoBrightness;\n       half _LayerAlbedoContrast;\n       half _LayerHeightContrast;\n       half _LayerStrength;\n       half _LayerAlbedoStrength;\n       half _LayerNormalStrength;\n       half _LayerSmoothnessStrength;\n       half _LayerSmoothness;\n       half _LayerMetallic;\n       half _LayerStochasticScale;\n       half2 _LayerSmoothnessRemap;\n       half2 _LayerAORemap;\n       half2 _LayerMetallicRemap;\n       half2 _LayerHeightRemap;\n       float4 _LayerWeightOverDistance;\n       half _LayerMicroShadowStrength;\n       //#if _LAYERNOISE\n           float _LayerNoiseFrequency;\n           float _LayerNoiseAmplitude;\n           float _LayerNoiseOffset;\n           float _LayerNoiseCenter;\n           half3 _LayerBlendTint;\n       //#endif\n       //#if _LAYERANGLEFILTER\n           half _LayerFalloff;\n           half _LayerAngleMin;\n           half _LayerHeight;\n           half _LayerInvertHeight;\n           half _LayerVertexNormalBlend;\n       //#endif\n       half _LayerTriplanarSpace;\n       half _LayerTriplanarContrast;\n       half _LayerBlendContrast;\n       half3 _LayerEmissionColor;\n       half _LayerStochasticContrast;\n       half _LayerTessStrength;\n       half3 _LayerFuzzyShadingColor;\n       half _LayerFuzzyShadingOn;\n       half3 _LayerFuzzyShadingParams;\n   //#endif\n\n\n   //#if _USELAYER_DEF_1\n       float4 _LayerAlbedoMap_Ext_1_ST;\n       half3 _LayerTint_Ext_1;\n       half _LayerBlendMode_Ext_1;\n       float _LayerUVSource_Ext_1;\n       half _LayerAlbedoBrightness_Ext_1;\n       half _LayerAlbedoContrast_Ext_1;\n       half _LayerHeightContrast_Ext_1;\n       half _LayerStrength_Ext_1;\n       half _LayerAlbedoStrength_Ext_1;\n       half _LayerNormalStrength_Ext_1;\n       half _LayerSmoothnessStrength_Ext_1;\n       half _LayerSmoothness_Ext_1;\n       half _LayerMetallic_Ext_1;\n       half _LayerStochasticScale_Ext_1;\n       half2 _LayerSmoothnessRemap_Ext_1;\n       half2 _LayerAORemap_Ext_1;\n       half2 _LayerMetallicRemap_Ext_1;\n       half2 _LayerHeightRemap_Ext_1;\n       float4 _LayerWeightOverDistance_Ext_1;\n       half _LayerMicroShadowStrength_Ext_1;\n       //#if _LAYERNOISE_DEF_1\n           float _LayerNoiseFrequency_Ext_1;\n           float _LayerNoiseAmplitude_Ext_1;\n           float _LayerNoiseOffset_Ext_1;\n           float _LayerNoiseCenter_Ext_1;\n           half3 _LayerBlendTint_Ext_1;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_1\n           half _LayerFalloff_Ext_1;\n           half _LayerAngleMin_Ext_1;\n           half _LayerHeight_Ext_1;\n           half _LayerInvertHeight_Ext_1;\n           half _LayerVertexNormalBlend_Ext_1;\n       //#endif\n       half _LayerTriplanarSpace_Ext_1;\n       half _LayerTriplanarContrast_Ext_1;\n       half _LayerBlendContrast_Ext_1;\n       half3 _LayerEmissionColor_Ext_1;\n       half _LayerStochasticContrast_Ext_1;\n       half _LayerTessStrength_Ext_1;\n       half3 _LayerFuzzyShadingColor_Ext_1;\n       half _LayerFuzzyShadingOn_Ext_1;\n       half3 _LayerFuzzyShadingParams_Ext_1;\n   //#endif\n\n\n   //#if _USELAYER_DEF_2\n       float4 _LayerAlbedoMap_Ext_2_ST;\n       half3 _LayerTint_Ext_2;\n       half _LayerBlendMode_Ext_2;\n       float _LayerUVSource_Ext_2;\n       half _LayerAlbedoBrightness_Ext_2;\n       half _LayerAlbedoContrast_Ext_2;\n       half _LayerHeightContrast_Ext_2;\n       half _LayerStrength_Ext_2;\n       half _LayerAlbedoStrength_Ext_2;\n       half _LayerNormalStrength_Ext_2;\n       half _LayerSmoothnessStrength_Ext_2;\n       half _LayerSmoothness_Ext_2;\n       half _LayerMetallic_Ext_2;\n       half _LayerStochasticScale_Ext_2;\n       half2 _LayerSmoothnessRemap_Ext_2;\n       half2 _LayerAORemap_Ext_2;\n       half2 _LayerMetallicRemap_Ext_2;\n       half2 _LayerHeightRemap_Ext_2;\n       float4 _LayerWeightOverDistance_Ext_2;\n       half _LayerMicroShadowStrength_Ext_2;\n       //#if _LAYERNOISE_DEF_2\n           float _LayerNoiseFrequency_Ext_2;\n           float _LayerNoiseAmplitude_Ext_2;\n           float _LayerNoiseOffset_Ext_2;\n           float _LayerNoiseCenter_Ext_2;\n           half3 _LayerBlendTint_Ext_2;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_2\n           half _LayerFalloff_Ext_2;\n           half _LayerAngleMin_Ext_2;\n           half _LayerHeight_Ext_2;\n           half _LayerInvertHeight_Ext_2;\n           half _LayerVertexNormalBlend_Ext_2;\n       //#endif\n       half _LayerTriplanarSpace_Ext_2;\n       half _LayerTriplanarContrast_Ext_2;\n       half _LayerBlendContrast_Ext_2;\n       half3 _LayerEmissionColor_Ext_2;\n       half _LayerStochasticContrast_Ext_2;\n       half _LayerTessStrength_Ext_2;\n       half3 _LayerFuzzyShadingColor_Ext_2;\n       half _LayerFuzzyShadingOn_Ext_2;\n       half3 _LayerFuzzyShadingParams_Ext_2;\n   //#endif\n\n\n    half _TraxDisplacementDepth;\n    half _TraxDisplacementStrength;\n    half _TraxMipBias;\n    half _TraxNormalStrength;\n    float4 _TraxAlbedo_ST;\n    half _TraxInterpContrast;\n    half _TraxHeightContrast;\n    half3 _TraxTint;\n\n\n\n    half _Porosity;\n    int _WetnessMode;\n    int _PuddleMode;\n\n    half  _PuddleAmount;\n    half  _PuddleFalloff;\n    half4 _PuddleColor;\n    half _PuddleNoiseFrequency;\n    half _PuddleNoiseAmplitude;\n    half _PuddleNoiseOffset;\n    half _PuddleNoiseCenter;\n    half _PuddleAngleMin;\n\n    half _WetnessAmount;\n\thalf _WetnessMin;\n    half _WetnessMax;\n    half _WetnessFalloff;\n\thalf _WetnessAngleMin;\n    float _WetnessShoreline;\n\n    int _RainMode;\n    half3 _RainIntensityScale;\n\n\n\n\n    float4 _SnowAlbedo_ST;\n    half3 _SnowTint;\n    half _SnowAmount;\n    half _SnowAngle;\n    half _SnowContrast;\n    half _SnowVertexHeight;\n    half _SnowMode;\n    half3 _SnowWorldFade; // z is on/off\n    float4 _SnowTraxAlbedo_ST;\n    half3 _SnowTraxTint;\n\n    half _SnowNoiseFreq; \n    half _SnowNoiseAmp;\n    half _SnowNoiseOffset;\n    half _SnowStochasticContrast;\n    half _SnowStochasticScale;\n\n\n    half     _WindParticulateSpace;\n    half     _WindParticulateRotation;\n    half      _WindParticulateSpeed;\n    float4     _WindParticulate_ST;\n    half      _WindParticulatePower;\n    half4    _WindParticulateColor;\n    half4    _WindParticulateWorldHeightMask;\n    half4    _WindParticulateAngleMask;\n    half      _WindParticulateOcclusionStrength;\n    half      _WindParticulateStrength;\n    half4    _WindParticulateEmissive;\n    half     _WindParticulateTextureHeight;\n\n\n   float _DoubleSidedNormalMode;\n\n\n\thalf _AutoNormalStrength;\n\n\n\tint _DebugSampleCountThreshold;\n\n\n\thalf _DissolveAmount;\n\thalf _DissolveEmissiveStr;\n\thalf _DissolveEdgeContrast;\n\thalf _DissolveColoration;\n\tfloat4 _DissolveTexture_ST;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n\n            \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\n#ifndef __STACKABLEFUNCLIBRARY_INCLUDES__\n#define __STACKABLEFUNCLIBRARY_INCLUDES__\n\n   #if _DEBUG_SAMPLECOUNT\n      int _sampleCount;\n      #define COUNTSAMPLE { _sampleCount++; }\n   #else\n      #define COUNTSAMPLE\n   #endif\n\n   TEXTURE2D(_NoiseTex);\n   SAMPLER(sampler_NoiseTex);\n\n\n\n   half3 AdjustContrast(half3 color, half contrast)\n   {\n       half3 comp = 0.5;\n   #if !UNITY_COLORSPACE_GAMMA\n       comp = 0.22;\n   #endif\n       color = saturate(lerp(comp, color, contrast));\n       return color;\n   }\n\n   float2 DoParallaxOffset( half h, half height, half3 viewDir)\n   {\n      h = h * height - height/2.0;\n      float3 v = normalize(viewDir);\n      v.z += 0.42;\n      return h * (v.xy / v.z);\n   }\n\n\n\n   #define SAMPLEBARY SampleTexBary\n\n   struct SampleConfig\n   {\n      float2 uv0;\n      float2 uv1;\n      float2 uv2;\n      float2 dx0;\n      float2 dy0;\n      float2 dx1;\n      float2 dy1;\n      float2 dx2;\n      float2 dy2;\n      float3 weights;\n      float3 origWeights;\n   };\n\n   struct Config\n   {\n      float2 origUV; // unscaled uv\n      float2 origScale;\n      float2 uv;        // no stocastic or triplanar\n      float2 dx;\n      float2 dy;\n      SampleConfig uvT; // just stochastic, or just triplanar\n      SampleConfig uvX; // stochastic and triplanar\n      SampleConfig uvY;\n      SampleConfig uvZ;\n\n      \n      float3 absVertNormal;\n      half3 axisSign;\n      float3 normal;\n   };\n\n\n    float2 Hash2D( float2 x )\n    {\n        float2 k = float2( 0.3183099, 0.3678794 );\n        x = x*k + k.yx;\n        return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );\n    }\n\n    float Noise2D(float2 p )\n    {\n        float2 i = floor( p );\n        float2 f = frac( p );\n         \n        float2 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), \n                        dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),\n                    lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), \n                        dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);\n    }\n      \n\n    float2 WorleyHash2D(float2 p)\n    {\n \t    return frac(cos(mul(p, float2x2(-64.2,71.3,81.4,-29.8)))*8321.3); \n    }\n    float WorleyNoise2D(float2 p)\n    {\n        float dist = 1;\n        float2 i = floor(p);\n        float2 f = frac(p);\n    \n        for(int x = -1;x<=1;x++)\n        {\n            for(int y = -1;y<=1;y++)\n            {\n                float d = distance(WorleyHash2D(i+float2(x,y))+float2(x,y),f);\n                dist = min(dist,d);\n            }\n        }\n        return dist;\n\t\n    }\n\n#ifndef PI\n    #define PI 3.14159265359\n#endif\n\n    float GetIntegerNoise(float2 p)\n    {\n        p  = 53.7 * frac( (p*0.3183099) + float2(0.71,0.113));\n        return frac( p.x*p.y*(p.x+p.y) );\n    }\n\n    float WorleyHash3D(float f)\n    {\n        return frac(sin(f)*43758.5453);\n    }\n\n    float WorleyHash31(float3 v)\n    {\n        return WorleyHash3D(dot(v, float3(253.14, 453.74, 183.3)));\n    }\n\n    float3 WorleyRandom3D( float3 p )\n    {\n        return frac(sin(float3(dot(p,float3(127.1,311.7,217.3)),dot(p,float3(269.5,183.3,431.1)), dot(p,float3(365.6,749.9,323.7))))*437158.5453);\n    }\n\n    float WorleyNoise3D(float3 uvw)\n    {\n        float noise = 0.0;\n    \n        float3 p = floor(uvw);\n        float3 f = frac(uvw);\n    \n        float4 res = 1;\n        for(int x = -1; x <=1; ++x)\n        {\n            for(int y = -1; y <=1; ++y)\n            {\n                for(int z = -1; z <=1; ++z)\n                {\n                    float3 gp = p + float3(x, y, z);\n\n                    float3 v = WorleyRandom3D(gp);\n\n\t\t\t\t    float3 diff = gp + v - uvw;\n                \n                    float d = length(diff);\n                \n                    if(d < res.x)\n                    {\n                        res.xyz = float3(d, res.x, res.y);\n                    }\n                    else if(d < res.y)\n                    {\n                        res.xyz = float3(res.x, d, res.y);\n                    }\n                    else if(d < res.z)\n                    {\n                        res.z = d;\n                    }\n                \n                    res.w = WorleyHash31(gp);\n                }\n            }\n        }\n\n        return res.x;\n    }\n    \n      \n    float3 Hash3D( float3 p )\n    {\n        p = float3( dot(p,float3(127.1,311.7, 74.7)),\n                dot(p,float3(269.5,183.3,246.1)),\n                dot(p,float3(113.5,271.9,124.6)));\n\n        return -1.0 + 2.0*frac(sin(p)*437.5453123);\n    }\n\n    float Noise3D( float3 p )\n    {\n        float3 i = floor( p );\n        float3 f = frac( p );\n         \n        float3 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),\n                    lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n    }\n\n    \n    float FBM2D(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           return SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n\n    }\n      \n    float FBM3D(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           half A = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.zy).g;\n           half B = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33).g;\n           half C = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoise(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3D(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3D(d.localSpacePosition * frequency+ offset, d.localSpaceNormal);\n        #else\n           return FBM2D(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n    \n    #if _SURFACEGRADIENT  \n\n    #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)\n\n      \n      \n    half3 SurfaceGradientFromTBN(ShaderData d, half2 deriv)\n    {\n        return deriv.x * d.TBNMatrix[0] + deriv.y * d.TBNMatrix[1];\n    }\n\n    half2 TspaceNormalToDerivative(half3 vM)\n    {\n        const half scale = 1.0/128.0;\n        const half3 vMa = abs(vM);\n        const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));\n\n        return -half2(vM.x, vM.y)/z_ma;\n    }\n\n    half3 SurfgradFromVolumeGradient(ShaderData d, half3 grad)\n    {\n        return grad - dot(d.worldSpaceNormal, grad) * d.worldSpaceNormal;\n    }\n\n    half3 SurfgradFromTriplanarProjection(ShaderData d, half3 pN, half3 xN, half3 yN, half3 zN)\n    {\n        const half w0 = pN.x;\n        const half w1 = pN.y;\n        const half w2 = pN.z;\n\n        half2 xD = TspaceNormalToDerivative(xN);\n        half2 yD = TspaceNormalToDerivative(yN);\n        half2 zD = TspaceNormalToDerivative(zN);\n\n        half3 volumeGrad = half3(w2 * zD.x + w1 * yD.y, w2 * zD.y + w0 * xD.y, w0 * xD.x + w1 * yD.x);\n\n        return SurfgradFromVolumeGradient(d, volumeGrad);\n    }\n\n    half3 ConvertNormalToGradient(ShaderData d, half3 normal)\n    {\n        half2 deriv = TspaceNormalToDerivative(normal);\n\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n    half3 ConvertNormal2ToGradient(ShaderData d, half2 packedNormal)\n    {\n        half2 tNormal = packedNormal;\n        half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF\n        half2 deriv = tNormal * -rcpZ;\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n\n    half3 ResolveNormalFromSurfaceGradient(ShaderData d, half3 gradient)\n    {\n        return normalize(d.worldSpaceNormal - gradient);\n    }\n\n    #endif // _SURFACEGRADIENT\n\n\n    // normals are in surface gradient or world space depending on settings, and can also be generated by height\n    half3 GetWorldSpaceNormal(ShaderData d, half3 normal, half pheight)\n    {\n       #if _SURFACEGRADIENT\n          return ResolveNormalFromSurfaceGradient(d, normal);\n       #elif _AUTONORMAL\n          float3 dx = ddx(d.worldSpacePosition);\n          float3 dy = ddy(d.worldSpacePosition);\n          float3 crossX = cross(float3(0,1,0), dx);\n          float3 crossY = cross(float3(0,1,0), dy);\n          float3 dt = abs(dot(crossY, dx));\n          float height = _AutoNormalStrength * 0.5 * pheight;\n          float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n          n.y *= -1.0;\n          return TangentToWorldSpace(d, normalize((dt * float3(0,1,0)) - n).xzy);\n       #else\n          return TangentToWorldSpace(d, normal);\n          \n       #endif\n       \n    }\n\n   void WaterBRDF (inout half3 albedo, inout half smoothness, half metallic, half wetFactor, half surfPorosity) \n   {\n      half porosity = saturate((( (1 - smoothness) - 0.5)) / max(surfPorosity, 0.001));\n      half factor = lerp(1, 0.2, (1 - metallic) * porosity);\n      albedo *= lerp(1.0, factor, wetFactor);\n      smoothness = lerp(smoothness, 0.92f, wetFactor);\n   }\n\n   void OffsetUV(inout Config c, float2 offset)\n   {\n       c.uv += offset;\n       c.uvT.uv0 += offset;\n       c.uvT.uv1 += offset;\n       c.uvT.uv2 += offset;\n       c.uvX.uv0 += offset;\n       c.uvX.uv1 += offset;\n       c.uvX.uv2 += offset;\n       c.uvY.uv0 += offset;\n       c.uvY.uv1 += offset;\n       c.uvY.uv2 += offset;\n       c.uvZ.uv0 += offset;\n       c.uvZ.uv1 += offset;\n       c.uvZ.uv2 += offset;\n   }\n\n\n    void TriangleGrid(float2 uv, float scale,\n       out float w1, out float w2, out float w3,\n       out int2 vertex1, out int2 vertex2, out int2 vertex3)\n    {\n       // Scaling of the input\n       uv *= 3.464 * scale; // 2 * sqrt(3)\n\n       // Skew input space into simplex triangle grid\n       const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);\n       float2 skewedCoord = mul(gridToSkewedGrid, uv);\n\n       // Compute local triangle vertex IDs and local barycentric coordinates\n       int2 baseId = int2(floor(skewedCoord));\n       float3 temp = float3(frac(skewedCoord), 0);\n       temp.z = 1.0 - temp.x - temp.y;\n       if (temp.z > 0.0)\n       {\n          w1 = temp.z;\n          w2 = temp.y;\n          w3 = temp.x;\n          vertex1 = baseId;\n          vertex2 = baseId + int2(0, 1);\n          vertex3 = baseId + int2(1, 0);\n       }\n       else\n       {\n          w1 = -temp.z;\n          w2 = 1.0 - temp.y;\n          w3 = 1.0 - temp.x;\n          vertex1 = baseId + int2(1, 1);\n          vertex2 = baseId + int2(1, 0);\n          vertex3 = baseId + int2(0, 1);\n       }\n    }\n\n    // Fast random hash function\n    float2 SimpleHash2(float2 p)\n    {\n       return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 43758.5453);\n    }\n\n\n    half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)\n    {\n        // compute weight with height map\n        const half epsilon = 1.0f / 1024.0f;\n        half3 weights = half3(iWeights.x * (tex0 + epsilon), \n                                 iWeights.y * (tex1 + epsilon),\n                                 iWeights.z * (tex2 + epsilon));\n\n        // Contrast weights\n        half maxWeight = max(weights.x, max(weights.y, weights.z));\n        half transition = contrast * maxWeight;\n        half threshold = maxWeight - transition;\n        half scale = 1.0f / transition;\n        weights = saturate((weights - threshold) * scale);\n        // Normalize weights.\n        half weightScale = 1.0f / (weights.x + weights.y + weights.z);\n        weights *= weightScale;\n        return weights;\n    }\n\n\n    half3 PackedUnpackScaleNormal(half4 packedNormal, float scale)\n   {\n       #if _PACKEDFAST\n          half3 normal;\n          normal.xy = (packedNormal.ag * 2 - 1) * scale;\n          normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n          return normal;  \n       #endif\n       return UnpackScaleNormal(packedNormal, scale);\n   }\n\n    void InitStochasticDxDy(inout SampleConfig c, Config cfg)\n    {\n      c.dx0 = ddx(cfg.origUV) * cfg.origScale;\n      c.dy0 = ddy(cfg.origUV) * cfg.origScale;\n      c.dx1 = c.dx0; c.dx1 = c.dx0;\n      c.dx2 = c.dy0; c.dy2 = c.dy0;\n    }\n\n    void PrepareStochasticUVs(float scale, float2 uv, out SampleConfig c)\n    {\n       // Get triangle info\n       ZERO_INITIALIZE(SampleConfig, c);\n       float w1, w2, w3;\n       int2 vertex1, vertex2, vertex3;\n       TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n       // Assign random offset to each triangle vertex\n       c.uv0 = uv;\n       c.uv1 = uv;\n       c.uv2 = uv;\n   \n       c.uv0.xy += SimpleHash2(vertex1);\n       c.uv1.xy += SimpleHash2(vertex2);\n       c.uv2.xy += SimpleHash2(vertex3);\n       c.weights = half3(w1, w2, w3);\n       c.origWeights = half3(w1, w2, w3);\n    }\n\n\n   half3 LitBlendDetailNormal(half3 n1, half3 n2)\n   {\n      #if _SURFACEGRADIENT\n         return n1 + n2;\n      #else\n         return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n      #endif\n   }\n\n   float3 TriplanarBlendUnpackedRNM(float3 n1, float3 n2)\n   {\n       n1.z += 1;\n       n2.xy = -n2.xy;\n       return n1 * dot(n1, n2) / n1.z - n2;\n   }\n\n   void InitConfigDxDy(inout Config c)\n   {\n      c.uvT.dx0 = ddx(c.uvT.uv0);\n      c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1);\n      c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2);\n      c.uvT.dy2 = ddy(c.uvT.uv2);\n   }\n\n   Config CreateConfig(ShaderData d, float4 scale, float space, int uvsource, half triplanarContrast)\n   {\n      Config c;\n      ZERO_INITIALIZE(Config, c);\n\n      float3 pos = d.worldSpacePosition;\n      float3 normal = d.worldSpaceNormal;\n      if (space > 0)\n      {\n         pos = d.localSpacePosition;\n         normal = d.localSpaceNormal;\n      }\n\n      c.uv = d.texcoord0.xy;\n      \n      if (uvsource == 1)\n        c.uv = d.texcoord1.xy;\n      else if (uvsource == 2)\n        c.uv = pos.yz * float2(1, -1);\n      else if (uvsource == 3)\n        c.uv = pos.xz * float2(1, -1);\n      else if (uvsource == 4)\n        c.uv = pos.xy * float2(1, -1);\n\n      c.origUV = c.uv;\n      c.origScale = scale.xy;\n\n      c.uv = c.uv * scale.xy + scale.zw;\n      c.dx = ddx(c.uv);\n      c.dy = ddy(c.uv);\n\n      c.normal = normal;\n      c.uvT.uv0 = pos.zy * scale.xy + scale.zw;\n      c.uvT.uv1 = pos.xz * scale.xy + scale.zw;\n      c.uvT.uv2 = pos.xy * scale.xy + scale.zw;\n        \n      c.uvT.uv1 += 0.33;\n      c.uvT.uv2 += 0.67;\n\n      c.uvT.dx0 = ddx(c.uvT.uv0); c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1); c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2); c.uvT.dy2 = ddy(c.uvT.uv2);\n\n      half3 triblend = saturate(pow(abs(c.normal), triplanarContrast));\n      triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n      c.uvT.weights = triblend;\n      c.uvT.origWeights = triblend;\n      c.axisSign = d.worldSpaceNormal < 0 ? -1 : 1;\n      c.absVertNormal = abs(d.worldSpaceNormal);\n     \n\n      return c;\n   }\n\n\n   half4 TriSample(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0) * c.weights.x;\n      }\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1) * c.weights.y;\n      }  \n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2) * c.weights.z;\n      }\n\n      return res;\n   }\n\n   half4 TriSampleBary(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      c.weights = BaryWeightBlend(c.origWeights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   half4 TriSampleGrad(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvX, contrast, d) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvY, contrast, d) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n           res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvZ, contrast, d) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   \n   half4 SampleTexBaryStochastic(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   half4 SampleTexBaryTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleGrad(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   \n   half4 SampleTexBary(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        COUNTSAMPLE\n        return SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv, c.dx, c.dy);\n   }\n\n   half4 SampleTexStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ) * c.uvT.weights.z;\n\n        return res;     \n   }\n\n   \n   half4 SampleTexStochastic(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n\n   half4 SampleTexTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n   \n   half4 SampleTex(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       COUNTSAMPLE\n       return SAMPLE_TEXTURE2D(tex, ss, c.uv);\n   }\n   \n\n \n   half3 SampleNormalStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n         dataX = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n         dataY = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n         dataZ = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ));\n\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n\n          return WorldToTangentSpace(d, worldNormal);\n       #endif\n   }\n\n\n   half3 SampleNormalTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n      {\n          COUNTSAMPLE\n          dataX = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv0, c.uvT.dx0, c.uvT.dy0));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n      {\n          COUNTSAMPLE\n          dataY = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv1, c.uvT.dx1, c.uvT.dy1));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n      {\n         COUNTSAMPLE\n         dataZ = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv2, c.uvT.dx2, c.uvT.dy2));\n      }\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n          return WorldToTangentSpace(d, worldNormal);\n      #endif\n   }\n\n   half3 SampleNormalStochastic(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n     half4 normal = TriSample(tex, ss, c.uvT);\n     #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half3 SampleNormal(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 normal = SAMPLE_TEXTURE2D(tex, ss, c.uv);\n      #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half HeightBlend(half h1, half h2, half slope, half contrast)\n   {\n      h2 = 1 - h2;\n      half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); \n      half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));\n      return blend;\n   }\n\n\n    #if _POM\n    float2 POM(TEXTURE2D_PARAM(tex, ss), Config c, float contrast, ShaderData d)\n    {\n       float2 curv = float2(0, 0);\n       float refPlane = 0;\n\n       float result = 0;\n       int stepIndex = 0;\n       int maxSamples = _POMMaxSamples;\n       int minSamples = 4;\n       float camDist = distance(_WorldSpaceCameraPos, d.worldSpacePosition);\n       float distanceFade = 1 - saturate((camDist - _POMMin) / max(1, _POMFade));\n       int numSteps = ( int )lerp( maxSamples, minSamples, dot( d.worldSpaceNormal, d.worldSpaceViewDir )) * distanceFade;\n       if (numSteps < 1)\n           numSteps = 1;\n       float layerHeight = 1.0 / numSteps;\n       float2 plane = _ParallaxHeight * ( d.tangentSpaceViewDir.xy / d.tangentSpaceViewDir.z ) * distanceFade;\n       OffsetUV(c, refPlane * plane);\n       float2 deltaTex = -plane * layerHeight;\n       float2 prevTexOffset = 0;\n       float prevRayZ = 1.0f;\n       float prevHeight = 0.0f;\n       float2 currTexOffset = deltaTex;\n       float currRayZ = 1.0f - layerHeight;\n       float currHeight = 0.0f;\n       float intersection = 0;\n       float2 finalTexOffset = 0;\n\n       while ( stepIndex < numSteps + 1 )\n       {\n          result = dot( curv, currTexOffset * currTexOffset );\n          Config cfg = c;\n          OffsetUV(cfg, currTexOffset);\n          currHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( currHeight > currRayZ )\n          {\n             stepIndex = numSteps + 1;\n          }\n          else\n          {\n             stepIndex++;\n             prevTexOffset = currTexOffset;\n             prevRayZ = currRayZ;\n             prevHeight = currHeight;\n             currTexOffset += deltaTex;\n             currRayZ -= layerHeight * ( 1 - result );\n          }\n       }\n       int sectionSteps = 10;\n       int sectionIndex = 0;\n       float newZ = 0;\n       float newHeight = 0;\n       while ( sectionIndex < sectionSteps )\n       {\n          intersection = ( prevHeight - prevRayZ ) / ( prevHeight - currHeight + currRayZ - prevRayZ );\n          finalTexOffset = prevTexOffset + intersection * deltaTex;\n          newZ = prevRayZ - intersection * layerHeight;\n          Config cfg = c;\n          OffsetUV(cfg, finalTexOffset);\n          newHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( newHeight > newZ )\n          {\n             currTexOffset = finalTexOffset;\n             currHeight = newHeight;\n             currRayZ = newZ;\n             deltaTex = intersection * deltaTex;\n             layerHeight = intersection * layerHeight;\n          }\n          else\n          {\n             prevTexOffset = finalTexOffset;\n             prevHeight = newHeight;\n             prevRayZ = newZ;\n             deltaTex = ( 1 - intersection ) * deltaTex;\n             layerHeight = ( 1 - intersection ) * layerHeight;\n          }\n          sectionIndex++;\n       }\n       #if _PASSHADOWS\n       if ( unity_LightShadowBias.z == 0.0 )\n       {\n       #endif\n          if ( result > 1 )\n             clip( -1 );\n       #if _PASSHADOWS\n       }\n       #endif\n       return finalTexOffset;\n    }\n    #endif\n\n   \n\n   // tess versions\n   #if _TESSELLATION_ON\n   half4 TriSampleLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias) * c.weights.x;\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias) * c.weights.y;\n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias) * c.weights.z;\n\n      return res;\n   }\n\n   half4 TriSampleBaryLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias, float contrast)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias);\n      half4 r2 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias);\n      half4 r3 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias);\n      c.weights = BaryWeightBlend(c.weights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryLODStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvX, bias, contrast) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvY, bias, contrast) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvZ, bias, contrast) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   half4 SampleTexBaryLODStochastic(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n       return TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias, contrast);\n   }\n\n   half4 SampleTexBaryLODTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return TriSampleLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias);\n   }\n\n   half4 SampleTexBaryLOD(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv, bias);\n   }\n\n\n    float FBM2DLOD(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           return SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv, _TessellationMipBias).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n        \n        \n    }\n\n    float FBM3DLOD(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           half A = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.zy, _TessellationMipBias).g;\n           half B = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33, _TessellationMipBias).g;\n           half C = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67, _TessellationMipBias).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoiseLOD(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3DLOD(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3DLOD(d.localSpacePosition * frequency + offset, d.localSpaceNormal);\n        #else\n           return FBM2DLOD(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n   #endif //_TESSELLATION_ON\n\n\n    half3 FuzzyShade(ShaderData d, half height, half3 color, half3 normal, half coreMult, half edgeMult, half power)\n    {\n        float3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half dt = saturate(dot(d.worldSpaceViewDir, worldNormal));\n        half dark = 1.0 - (coreMult * dt);\n        half edge = pow(1-dt, abs(power)) * edgeMult;\n        return color * (dark + edge);\n    }\n\n\thalf MicroShadow(ShaderData d, half3 normal, half height, half ao, half strength)\n\t{\n        float3 sun;\n\t\tfloat3 sunColor;\n\t\tGetSun(sun, sunColor);\n\t\tfloat3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half shadow = saturate(abs(dot(worldNormal, sun)) + (ao * ao * 2.0) - 1.0);\n        return 1 - ((1-shadow) * strength);\n\t}\n\n\n#endif\n\n\n\n   #if defined(_SPECULAR)\n      #define _USESPECULAR 1\n      #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n   #endif\n\n   \n   TEXTURE2D(_AlbedoMap);\n   SAMPLER(sampler_AlbedoMap);\n   TEXTURE2D(_NormalMap);\n   SAMPLER(sampler_NormalMap);\n   TEXTURE2D(_MaskMap);\n   TEXTURE2D(_DetailMap);\n   TEXTURE2D(_EmissionMap);\n\n   #if _SPECULAR\n       TEXTURE2D(_SpecularMap);\n   #endif\n\n   \n   \n   void Ext_SurfaceFunction0 (inout Surface o, inout ShaderData d)\n   {\n      // define samplers based on settings\n      #undef SAMPLEBARY\n      #undef SAMPLE\n      #undef SAMPLENORMAL\n      #if _STOCHASTIC && _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n        #define SAMPLE     SampleTexStochasticTriplanar\n        #define SAMPLENORMAL SampleNormalStochasticTriplanar\n      #elif _STOCHASTIC\n        #define SAMPLEBARY SampleTexBaryStochastic\n        #define SAMPLE     SampleTexStochastic\n        #define SAMPLENORMAL SampleNormalStochastic\n      #elif _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryTriplanar\n        #define SAMPLE     SampleTexTriplanar\n        #define SAMPLENORMAL SampleNormalTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBary\n        #define SAMPLE     SampleTex\n        #define SAMPLENORMAL SampleNormal\n      #endif\n\n      Config c = CreateConfig(d, _AlbedoMap_ST, _TriplanarSpace, _UVSource, _TriplanarContrast);\n      InitConfigDxDy(c);\n      #if _STOCHASTIC && !_TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uv, c.uvT);\n         InitStochasticDxDy(c.uvT, c);\n      #elif _STOCHASTIC && _TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv0, c.uvX);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv1, c.uvY);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv2, c.uvZ);\n         InitStochasticDxDy(c.uvX, c);\n         InitStochasticDxDy(c.uvY, c);\n         InitStochasticDxDy(c.uvZ, c);\n      #endif\n\n      #if _POM\n          // would need to handle height remapping if we ever want to ship this\n          float2 pomOffset = POM(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n          OffsetUV(c, pomOffset);\n      #endif\n\n      half4 albedo = SAMPLEBARY(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n      \n      #if _PARALLAX\n         float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n         OffsetUV(c, offset);\n         albedo = SAMPLE(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c);\n         \n      #endif\n      albedo.a = lerp(_HeightRemap.x, _HeightRemap.y, albedo.a);\n      albedo.rgb *= _Tint.rgb;\n\n      albedo.rgb = AdjustContrast(albedo.rgb, _AlbedoContrast);\n      albedo.rgb += _AlbedoBrightness;\n\n\n      if (_AlphaThreshold > 0)\n      {\n         clip(albedo.a - _AlphaThreshold);\n      }\n\n      #if defined(_FLATSHADE)\n\t\t     float3 dx = ddx(d.worldSpacePosition);\n\t\t     float3 dy = ddy(d.worldSpacePosition);\n\t\t     float3 worldNormal = normalize(cross(dy, dx));\n\t\t     worldNormal = lerp(d.worldSpaceNormal, worldNormal, _FlatShadingBlend);\n\t\t     d.worldSpaceNormal = worldNormal;\n\t\t     d.TBNMatrix[2] = worldNormal;\n      #endif\n\n\n\n      o.Albedo = albedo.rgb;\n      o.Alpha = albedo.a;\n\n      float smoothness = _Smoothness;\n      float ao = 1;\n\n      #if defined(_NORMALMAP) && !defined(_AUTONORMAL)\n         o.Normal = SAMPLENORMAL(TEXTURE2D_ARGS(_NormalMap, sampler_NormalMap), c, d, _NormalStrength, smoothness, ao);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, ao);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n      #endif\n\n      half detailMask = 1;\n      o.Smoothness = smoothness;\n      o.Occlusion = ao;\n      o.Metallic = _Metallic;\n      #if defined(_MASKMAP) && !_PACKEDFAST\n         // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = SampleTex(TEXTURE2D_ARGS(_MaskMap, sampler_AlbedoMap), c);\n         o.Metallic = lerp(_MetallicRemap.x, _MetallicRemap.y, mask.r);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, mask.g);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, mask.a);\n         detailMask = mask.b;\n      #endif // separate maps\n\n      #if _SPECULAR\n         o.Specular = SAMPLE(TEXTURE2D_ARGS(_SpecularMap, sampler_AlbedoMap), c).rgb;\n      #endif\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = SAMPLE(TEXTURE2D_ARGS(_EmissionMap, sampler_AlbedoMap), c).rgb * _EmissionColor;\n      #endif\n\n      if (_FuzzyShadingOn > 0)\n      {\n        o.Albedo *= FuzzyShade(d, albedo.a, _FuzzyShadingColor, o.Normal, _FuzzyShadingParams.x, _FuzzyShadingParams.y, _FuzzyShadingParams.z);\n      }\n\n\n      // HDRP style detail texturing\n\n      #if defined(_DETAIL)\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _DETAILSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n         Config dc = CreateConfig(d, _DetailMap_ST, _DetailTriplanarSpace, _DetailUVSource, _DetailTriplanarContrast);\n         InitConfigDxDy(dc);\n         #if _DETAILSTOCHASTIC && !_DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uv, dc.uvT);\n             InitStochasticDxDy(dc.uvT, dc);\n         #elif _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv0, dc.uvX);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv1, dc.uvY);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv2, dc.uvZ);\n             InitStochasticDxDy(dc.uvX, dc);\n             InitStochasticDxDy(dc.uvY, dc);\n             InitStochasticDxDy(dc.uvZ, dc);\n         #endif\n\n         half4 detailSample = SAMPLEBARY(TEXTURE2D_ARGS(_DetailMap, sampler_AlbedoMap), dc, _DetailStochasticContrast, d);\n         smoothness = detailSample.z;\n         #if !_AUTONORMAL\n            half3 dnormal = float3(detailSample.ag * 2 - 1, 1) * detailMask * _DetailNormalStrength;\n            dnormal.z = sqrt(1 - dnormal.x * dnormal.x - dnormal.y * dnormal.y);\n            #if _SURFACEGRADIENT\n               dnormal = ConvertNormalToGradient(d, dnormal);\n            #endif\n            o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n         #endif\n     \n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * smoothness, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n      if (_MicroShadowStrength > 0)\n      {\n        o.Occlusion *= MicroShadow(d, o.Normal, o.Alpha, o.Occlusion, _MicroShadowStrength);\n      }\n  \n      // in case something needs height in the stack..\n      o.Height = o.Alpha;\n\n\n      \n   }\n\n\n\n\t#if _TINTMASK\n\t\tTEXTURE2D(_TintMask);\n\t\tSAMPLER(sampler_TintMask);\n\t#endif\n\n\tvoid Ext_SurfaceFunction1 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _TINTMASK\n\t\t   half4 w = SAMPLE_TEXTURE2D(_TintMask, sampler_TintMask, d.texcoord0.xy * _TintMask_ST.xy + _TintMask_ST.zw);\n\t\t   // allow black to be no tint..\n\t\t   half3 tint = o.Albedo * (_RColor.rgb * 2 * w.r + _GColor.rgb * 2 * w.g + _BColor.rgb * 2 * w.b + _AColor.rgb * 2 * w.a);\n\t\t   o.Albedo = lerp(o.Albedo, tint, saturate(w.r + w.g + w.b + w.a));\n\t\t#endif\n\t}\n\n\n\n\n\t#if _LAYERTEXTUREMASK\n       TEXTURE2D(_LayerTextureMask);\n       SAMPLER(sampler_LayerTextureMask); \n    #endif\n\n   void Ext_ModifyTessellatedVertex2 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON\n          float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n\n          #if _LAYERTEXTUREMASK\n               float2 layerUV = v.texcoord0.xy;\n               if (_LayerTextureMaskUVMode == 1)\n                  layerUV = v.texcoord1.xy;\n               else if (_LayerTextureMaskUVMode == 2)\n                  layerUV = worldSpacePosition.yz;\n               else if (_LayerTextureMaskUVMode == 3)\n                  layerUV = worldSpacePosition.xz;\n               else if (_LayerTextureMaskUVMode == 4)\n                  layerUV = worldSpacePosition.xy;\n\n              e.blackboard.weightTextureMask = SAMPLE_TEXTURE2D_LOD(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw, _TessellationMipBias);\n          #endif\n      #endif\n    }\n\n\n\tvoid Ext_SurfaceFunction2 (inout Surface o, inout ShaderData d)\n\t{\n\t\t#if _LAYERTEXTUREMASK\n           float2 layerUV = d.texcoord0.xy;\n           if (_LayerTextureMaskUVMode == 1)\n              layerUV = d.texcoord1.xy;\n           else if (_LayerTextureMaskUVMode == 2)\n              layerUV = d.worldSpacePosition.yz;\n           else if (_LayerTextureMaskUVMode == 3)\n              layerUV = d.worldSpacePosition.xz;\n           else if (_LayerTextureMaskUVMode == 4)\n              layerUV = d.worldSpacePosition.xy;\n\n          d.blackboard.weightTextureMask = SAMPLE_TEXTURE2D(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw);\n      #endif\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap);\n   SAMPLER(sampler_LayerAlbedoMap);\n   TEXTURE2D(_LayerNormalMap);\n   TEXTURE2D(_LayerMaskMap);\n   TEXTURE2D(_LayerEmissionMap);\n\n   \n\n   void Ext_ModifyTessellatedVertex3 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER) && defined(_LAYERALBEDO) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n         half detailMask = 1;\n         #if _LAYERNOISE\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency,  _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin;\n            dt = saturate(dt * _LayerFalloff);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight) * _LayerFalloff);\n            if (_LayerInvertHeight > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength;\n         detailMask *= _LayerTessStrength;\n\n         #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast).a;\n         albedo = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo);\n\n         if (_LayerBlendMode == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction3 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n            // noise up the mask\n            #if _LAYERNOISE\n               mask = DoNoise(d, _LayerNoiseFrequency, _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend);\n\t    \n                dt -= _LayerAngleMin;\n                dt = saturate(dt * _LayerFalloff);\n\n                float hf = saturate((o.Height - _LayerHeight) * _LayerFalloff);\n                if (_LayerInvertHeight > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 0\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 0\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength;\n\n            #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint, 0.5);\n            #if defined(_LAYERALBEDO)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c, _LayerStochasticContrast, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c);\n                #endif\n                albedo.rgb *= _LayerTint;\n                albedo.a = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL || _LAYERMASK\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap, sampler_LayerAlbedoMap, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast);\n            albedo.rgb += _LayerAlbedoBrightness;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap, sampler_LayerAlbedoMap), c, d, _LayerNormalStrength * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO)\n                if (_LayerFuzzyShadingOn > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor.rgb, dnormal,\n                                            _LayerFuzzyShadingParams.x, _LayerFuzzyShadingParams.y, _LayerFuzzyShadingParams.z);\n                }\n\n                if (_LayerBlendMode == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast);\n                else if (_LayerBlendMode == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE\n                      float maskDif = (_LayerBlendContrast * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength);\n                   #if _LAYERNOISE\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap, sampler_LayerAlbedoMap), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength);\n                }\n\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap, sampler_LayerAlbedoMap), c).rgb * _LayerEmissionColor;\n                #if _LAYERALBEDO\n                    if (_LayerBlendMode > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_1);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_1);\n   TEXTURE2D(_LayerNormalMap_Ext_1);\n   TEXTURE2D(_LayerMaskMap_Ext_1);\n   TEXTURE2D(_LayerEmissionMap_Ext_1);\n\n   \n\n   void Ext_ModifyTessellatedVertex4 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_1) && defined(_LAYERALBEDO_DEF_1) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_1\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_1,  _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_1\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_1;\n            dt = saturate(dt * _LayerFalloff_Ext_1);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n            if (_LayerInvertHeight_Ext_1 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_1;\n         detailMask *= _LayerTessStrength_Ext_1;\n\n         #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_1).a;\n         albedo = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo);\n\n         if (_LayerBlendMode_Ext_1 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_1);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_1 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction4 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_1)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_1\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_1, _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_1\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_1);\n\t    \n                dt -= _LayerAngleMin_Ext_1;\n                dt = saturate(dt * _LayerFalloff_Ext_1);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n                if (_LayerInvertHeight_Ext_1 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 01\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 01\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_1;\n\n            #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_1, 0.5);\n            #if defined(_LAYERALBEDO_DEF_1)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, _LayerStochasticContrast_Ext_1, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_1;\n                albedo.a = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_1 || _LAYERMASK_DEF_1\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_1);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_1;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, d, _LayerNormalStrength_Ext_1 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_1)\n                if (_LayerFuzzyShadingOn_Ext_1 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_1.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_1.x, _LayerFuzzyShadingParams_Ext_1.y, _LayerFuzzyShadingParams_Ext_1.z);\n                }\n\n                if (_LayerBlendMode_Ext_1 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_1);\n                else if (_LayerBlendMode_Ext_1 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_1 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_1);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_1\n                      float maskDif = (_LayerBlendContrast_Ext_1 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_1 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                   #if _LAYERNOISE_DEF_1\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_1));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_1 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_1);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_1) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_1 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_1);\n                }\n\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_1);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_1, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_1, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_1\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c).rgb * _LayerEmissionColor_Ext_1;\n                #if _LAYERALBEDO_DEF_1\n                    if (_LayerBlendMode_Ext_1 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_2);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_2);\n   TEXTURE2D(_LayerNormalMap_Ext_2);\n   TEXTURE2D(_LayerMaskMap_Ext_2);\n   TEXTURE2D(_LayerEmissionMap_Ext_2);\n\n   \n\n   void Ext_ModifyTessellatedVertex5 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_2) && defined(_LAYERALBEDO_DEF_2) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_2\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_2,  _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_2\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_2;\n            dt = saturate(dt * _LayerFalloff_Ext_2);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n            if (_LayerInvertHeight_Ext_2 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_2;\n         detailMask *= _LayerTessStrength_Ext_2;\n\n         #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_2).a;\n         albedo = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo);\n\n         if (_LayerBlendMode_Ext_2 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_2);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_2 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction5 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_2)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_2\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_2, _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_2\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_2);\n\t    \n                dt -= _LayerAngleMin_Ext_2;\n                dt = saturate(dt * _LayerFalloff_Ext_2);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n                if (_LayerInvertHeight_Ext_2 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 02\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 02\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_2;\n\n            #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_2, 0.5);\n            #if defined(_LAYERALBEDO_DEF_2)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, _LayerStochasticContrast_Ext_2, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_2;\n                albedo.a = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_2 || _LAYERMASK_DEF_2\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_2);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_2;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, d, _LayerNormalStrength_Ext_2 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_2)\n                if (_LayerFuzzyShadingOn_Ext_2 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_2.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_2.x, _LayerFuzzyShadingParams_Ext_2.y, _LayerFuzzyShadingParams_Ext_2.z);\n                }\n\n                if (_LayerBlendMode_Ext_2 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_2);\n                else if (_LayerBlendMode_Ext_2 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_2 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_2);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_2\n                      float maskDif = (_LayerBlendContrast_Ext_2 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_2 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                   #if _LAYERNOISE_DEF_2\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_2));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_2 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_2);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_2) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_2 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_2);\n                }\n\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_2);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_2, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_2, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_2\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c).rgb * _LayerEmissionColor_Ext_2;\n                #if _LAYERALBEDO_DEF_2\n                    if (_LayerBlendMode_Ext_2 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   #if _TRAX_ON\n   TEXTURE2D(_TraxAlbedo);\n   SAMPLER(sampler_TraxAlbedo);\n   TEXTURE2D(_TraxPackedNormal);\n   TEXTURE2D(_TraxMask);\n\n   sampler2D_float _GMSTraxBuffer;\n\n   float4 _GMSTraxBuffer_TexelSize;\n   float3 _GMSTraxBufferPosition;\n   float _GMSTraxBufferWorldSize;\n   float _GMSTraxFudgeFactor;\n\n   float SampleTraxBufferLOD(float3 worldPos)\n   {    \n      // generate UVs for the buffer, which is moving\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 8);\n      uv *= 0.5;\n      uv += 0.5;\n            \n      float s =  tex2Dlod(_GMSTraxBuffer, float4(uv, 0, 0)).r;\n\n      return 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n   }\n         \n        \n   float SampleTraxBuffer(float3 worldPos, out float3 norm)\n   {\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 3);\n      uv *= 0.5;\n      uv += 0.5;\n            \n\n      float2 offset = _GMSTraxBuffer_TexelSize.xy;\n\n      float s = tex2D(_GMSTraxBuffer, uv).r;\n               \n      float s1 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, -1)).r;\n      float s2 = tex2D(_GMSTraxBuffer, uv + offset * float2(-1, 0)).r;\n      float s3 = tex2D(_GMSTraxBuffer, uv + offset * float2(1, 0)).r;\n      float s4 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, 1)).r;\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      float r = 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n \n      // generate normals\n      norm.x = (s1 - s4) * 0.25; \n      norm.y = (s2 - s3) * 0.25;\n      norm.z = 2;\n      norm = normalize(norm);\n     \n      norm.xy *= 1 - r;\n            \n      return r;\n   }\n   #endif\n\n   void Ext_ModifyTessellatedVertex6 (inout VertexData v, inout ExtraV2F d)\n   {\n       #if _TESSELLATION_ON && _TRAX_ON && _HAS_LIT_TESSELLATION\n          \n           float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n           float3 worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n           float traxBuffer = SampleTraxBufferLOD(worldSpacePosition);\n           d.blackboard.traxBuffer = traxBuffer;\n           float2 uv = worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n           half albedo = SAMPLE_TEXTURE2D_LOD(_TraxAlbedo, sampler_TraxAlbedo, uv, _TraxMipBias).a;\n\n           float traxOffset = albedo * _TraxDisplacementStrength;\n           traxOffset *= 1 - v.texcoord0.z;\n           traxOffset *= _TessellationDisplacement;\n           float dig = _TraxDisplacementDepth * (1 - v.texcoord0.z);\n           float3 traxVertex = d.blackboard.originalVertexPosition + (v.normal * (traxOffset - dig));\n           v.vertex.xyz = lerp(traxVertex, v.vertex.xyz, traxBuffer);\n\n           d.blackboard.vertexHeightOffset = lerp(traxOffset-dig, d.blackboard.vertexHeightOffset, traxBuffer);\n\n       #endif\n\n   }\n\n   void Ext_SurfaceFunction6 (inout Surface o, inout ShaderData d)\n   {\n      #if _TRAX_ON\n        float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n        float2 fsdx = ddx(uv);\n        float2 fsdy = ddy(uv);\n\n        float3 traxNormal;\n        float traxBuffer = SampleTraxBuffer(d.worldSpacePosition, traxNormal);\n        \n        #if _TESSELLATION_ON\n            traxBuffer -= _TraxDisplacementDepth;\n        #endif\n\n        d.blackboard.traxBuffer = traxBuffer;\n\n        UNITY_BRANCH\n        if (traxBuffer > 0)\n        {\n            half4 albedo = SAMPLE_TEXTURE2D_GRAD(_TraxAlbedo, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            albedo.rgb *= _TraxTint.rgb;\n            half4 normalSample = SAMPLE_TEXTURE2D_GRAD(_TraxPackedNormal, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n\n            half smoothness = normalSample.r;\n            half ao = normalSample.b;\n            half3 normal;\n            normal.xy = (normalSample.ag * 2 - 1) * _TraxNormalStrength;\n            normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n\n            \n            half h = HeightBlend(albedo.a, o.Alpha, traxBuffer, _TraxHeightContrast);\n\n            h = lerp(traxBuffer, h, _TraxInterpContrast);\n\n            o.Albedo = lerp(albedo, o.Albedo, h);\n\n            #if _SURFACEGRADIENT\n                o.Normal = lerp(normal, o.Normal, h);\n            #else\n                o.Normal = lerp(normal + traxNormal, o.Normal, h);\n            #endif\n        \n            o.Smoothness = lerp(smoothness, o.Smoothness, h);\n            o.Occlusion = lerp(ao, o.Occlusion, h);\n        }\n      #endif\n   }\n\n\n\n\n    #if _RAINDROPS\n       TEXTURE2D(_RainDropTexture);\n       SAMPLER(sampler_RainDropTexture);\n       half _Global_RainIntensity;\n    #endif\n\n    #if _WETNESS\n       half2 _Global_WetnessParams; // global, not in cbuffer\n    #endif\n   \n    #if _RAINDROPS\n    half2 ComputeRipple(float2 uv, half time, half weight)\n    {\n        half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_RainDropTexture, uv);\n        COUNTSAMPLE\n        ripple.yz = ripple.yz * 2 - 1;\n\n        half dropFrac = frac(ripple.w + time);\n        half timeFrac = dropFrac - 1.0 + ripple.x;\n        half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);\n        half finalFactor = dropFactor * ripple.x * \n                                sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);\n\n        return half2(ripple.yz * finalFactor);\n    }\n    #endif\n\n    half2 DoRain(half2 waterNorm, float2 uv, out half2 ripple)\n    {\n        #if _RAINDROPS\n            float rainIntensity = _RainIntensityScale.x;\n            if (_RainMode > 1)\n            {\n                rainIntensity = _Global_RainIntensity;\n            }\n\n            half dropStrength = rainIntensity;\n            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); \n            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);\n            half4 times = _Time.yyyy;\n            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);\n\n            float2 ruv1 = uv * _RainIntensityScale.yy;\n            float2 ruv2 = ruv1;\n\n            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);\n            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);\n            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);\n            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);\n            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);\n            weights = saturate(weights * 4);\n\n            half2 rippleNormal = half2( weights.x * ripple1.xy +\n                        weights.y * ripple2.xy + \n                        weights.z * ripple3.xy + \n                        weights.w * ripple4.xy);\n\n            ripple = rippleNormal * dropStrength * rainIntensity;\n            waterNorm = lerp(waterNorm, normalize(half3(rippleNormal.xy + rippleNormal.xy, 1)).xy, rainIntensity * dropStrength); \n            return waterNorm;                        \n        #else\n            return waterNorm;\n        #endif\n    }\n\n   half2 _Global_PuddleParams;   // this is a global, so keep it out of the cbuffer\n   void GetPuddleParams(ShaderData d, inout float puddleMask, inout float pudHeight)\n   {\n      #if _PUDDLES || _GLOBALPUDDLES\n          pudHeight = _PuddleAmount;\n          if (_PuddleMode > 0)\n             pudHeight = _Global_PuddleParams.x;    \n      \n\n          half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t      dt -= _PuddleAngleMin;\n          dt = saturate(dt * _PuddleFalloff);\n          puddleMask *= dt;\n      #endif\n   }\n   \n   void Ext_ModifyTessellatedVertex7 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _PUDDLES && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n         half mask = 1;\n         half pudHeight = 1;\n\n         // save some ops by doing this in 2d\n         #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2DLOD(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2DLOD(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #else\n                mask = (FBM2DLOD(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n         #endif\n\n         GetPuddleParams(d, mask, pudHeight);\n         float height = pudHeight * mask;\n         if (e.blackboard.vertexHeightOffset < height)\n         {\n            e.blackboard.vertexHeightOffset = height;\n            height -= _TessellationOffset; \n            // dampen cracks\n            height *= 1 - v.texcoord0.z;\n            height *= _TessellationDisplacement;\n            v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n            \n        }\n      #endif\n   }\n\n\n#if _WETNESS\n\n   float GetWetnessLevel(Surface o, ShaderData d, float wetnessMask)\n   {\n      float wetLevel = clamp(_WetnessAmount, _WetnessMin, _WetnessMax);\n      \n      if (_WetnessMode > 0)\n         wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);\n\n      wetLevel = saturate(wetLevel + (1 - saturate(d.worldSpacePosition.y - _WetnessShoreline)));\n      float3x3 tbn = float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal);\n      float dt = dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0));\n      dt -= _WetnessAngleMin;\n      dt = saturate(dt * _WetnessFalloff * wetLevel);\n      dt *= wetnessMask;\n      return dt;\n   }\n#endif\n   \n\n   void Ext_SurfaceFunction7 (inout Surface o, ShaderData d)\n   {\n      half wetnessLevel = 0;\n      #if _WETNESS\n          wetnessLevel = GetWetnessLevel(o, d, 1); // mask one day?\n      #endif\n\n      half depthMask = 0;\n      half depth = 0;\n\n      #if _PUDDLES\n          half mask = 1;\n          half pudHeight = 1;\n          #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2D(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2D(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);      \n            #else\n                mask = (FBM2D(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n          #endif\n\n          GetPuddleParams(d, mask, pudHeight);\n          pudHeight *= mask;\n          depth = pudHeight - o.Height;\n          depthMask = saturate(depth * _PuddleFalloff);\n          depthMask *= _PuddleColor.a;\n          depth = o.Height - pudHeight;\n\n          // extend wetness slighting higher than the puddle\n          half wetmask = saturate((pudHeight + 0.05 - o.Height) * _PuddleFalloff);\n          wetnessLevel = max(wetmask, wetnessLevel);\n       #endif\n\n       \n       #if _WETNESS || _PUDDLES\n          half3 waterNorm = half3(0,0,1);\n          half3 wetAlbedo = o.Albedo;\n          half wetSmoothness = o.Smoothness;\n          #if _PUDDLES\n             wetAlbedo *= _PuddleColor.rgb;\n          #endif\n          WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetnessLevel, _Porosity);\n\n          half ri = 0;\n          half2 ripple = 0;\n          #if (_RAINDROPS || _GLOBALRAIN) && (_PUDDLES || _GLOBALPUDDLES)\n             ri = _RainIntensityScale.z;\n             waterNorm.xy = DoRain(waterNorm.xy, d.texcoord0.xy, ripple) * depthMask;\n          #endif\n\n          o.Normal = lerp(o.Normal, waterNorm, depthMask);\n          o.Normal = lerp(o.Normal, LitBlendDetailNormal(o.Normal, half3(ripple.xy, 1)), saturate(ri - depthMask) * wetnessLevel);\n          o.Occlusion = lerp(o.Occlusion, 1, depthMask);\n          o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetnessLevel);\n          o.Albedo = lerp(o.Albedo, wetAlbedo, wetnessLevel);\n          o.Emission *= 1 + depth;\n          o.Metallic *= 1 + depth;\n          o.Specular *= 1 + depth;\n\n       #endif\n\n   }\n\n\n\n\n    #if _SNOW\n       TEXTURE2D(_SnowAlbedo);\n       SAMPLER(sampler_SnowAlbedo);\n       TEXTURE2D(_SnowNormal);\n       TEXTURE2D(_SnowMaskMap);\n       #if _TRAX_ON\n          TEXTURE2D(_SnowTraxAlbedo);\n          TEXTURE2D(_SnowTraxNormal);\n          TEXTURE2D(_SnowTraxMaskMap);\n       #endif\n    #endif\n\n   float _Global_SnowLevel;\n\n\n   void Ext_ModifyVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n    #if (_SNOW)\n        float amount = _SnowAmount;\n        if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n        float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n        float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n        snowAmount -= _SnowAngle;\n        snowAmount *= _SnowContrast * 0.5;\n        snowAmount = saturate(snowAmount) * amount;\n        float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n        if (_SnowWorldFade.z > 0)\n        {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n        }\n        #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n        #endif\n        snowAmount = saturate(snowAmount);\n\n        #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n        #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n        #endif\n\n        float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n        v.vertex.xyz = v.vertex.xyz + displacementVec * snowAmount * snowAmount * _SnowVertexHeight;\n    #endif\n   }\n\n   void Ext_ModifyTessellatedVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _SNOW && _HAS_LIT_TESSELLATION\n         float amount = _SnowAmount;\n         if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n         float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n         float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n         snowAmount -= _SnowAngle;\n         snowAmount *= _SnowContrast * 0.5;\n         float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n         if (_SnowWorldFade.z > 0)\n         {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n         }\n\n         snowAmount = saturate(snowAmount) * amount;\n\n         #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n         #endif\n         snowAmount = saturate(snowAmount);\n\n         #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n         #endif\n\n         float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n         half heightMap = SAMPLE_TEXTURE2D_LOD(_SnowAlbedo, sampler_SnowAlbedo, worldPos.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw, 2);\n\n         float height = max(_SnowVertexHeight * 3 * snowAmount + snowAmount * heightMap, e.blackboard.vertexHeightOffset);\n         #if _TRAX_ON\n            height *= e.blackboard.traxBuffer;\n         #endif\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n\n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n         \n      #endif\n\n   }\n\n   void SampleSnowSurface(TEXTURE2D_PARAM(alb, ss), TEXTURE2D_PARAM(norm, ss2), TEXTURE2D_PARAM(mask, ss3),\n        ShaderData d, float2 uv, float2 dx, float2 dy, out half4 albedo, out half3 normal, out half2 smoothAO)\n   {\n      #if _SNOWSTOCHASTIC\n         float w1, w2, w3;\n         int2 vertex1, vertex2, vertex3;\n         TriangleGrid(uv, _SnowStochasticScale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n         // Assign random offset to each triangle vertex\n         float2 uv0 = uv;\n         float2 uv1 = uv;\n         float2 uv2 = uv;\n   \n         uv0.xy += SimpleHash2(vertex1);\n         uv1.xy += SimpleHash2(vertex2);\n         uv2.xy += SimpleHash2(vertex3);\n         half3 weights = half3(w1, w2, w3);\n\n         half4 albedo0 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv0, dx, dy);\n         half4 albedo1 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv1, dx, dy);\n         half4 albedo2 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv2, dx, dy);\n         COUNTSAMPLE\n         COUNTSAMPLE\n         COUNTSAMPLE\n         weights = BaryWeightBlend(weights, albedo0.a, albedo1.a, albedo2.a, _SnowStochasticContrast);\n         albedo = albedo0 * weights.x + albedo1 * weights.y + albedo2 * weights.z;\n\n         normal = half3(0,0,1);\n         smoothAO = half2(0, 1);\n\n         #if !_AUTONORMAL\n            half4 n0 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv0, dx, dy);\n            half4 n1 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv1, dx, dy);\n            half4 n2 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n            half4 snowNormSamp = n0 * weights.x + n1 * weights.y + n2 * weights.z;\n\n            normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n                \n            #if _PACKEDFAST\n               smoothAO.x = snowNormSamp.r;\n               smoothAO.y = snowNormSamp.b;\n            #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask0 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv0, dx, dy);\n            half4 snowMask1 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv1, dx, dy);\n            half4 snowMask2 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n            half4 snowMask = snowMask0 * weights.x + snowMask1 * weights.y + snowMask2 * weights.z;\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n      #else // not stochastic\n          albedo = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv, dx, dy);\n          COUNTSAMPLE\n\n          normal = half3(0,0,1);\n          smoothAO = half2(0, 1);\n\n          #if !_AUTONORMAL\n             half4 snowNormSamp = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv, dx, dy);\n             COUNTSAMPLE\n             normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n             #if _SURFACEGRADIENT\n                normal = ConvertNormalToGradient(d, normal);\n             #endif\n                 \n             #if _PACKEDFAST\n                smoothAO.x = snowNormSamp.r;\n                smoothAO.y = snowNormSamp.b;\n             #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv, dx, dy);\n            COUNTSAMPLE\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n     #endif // stochastic\n   }\n\n   \n   void Ext_SurfaceFunction8 (inout Surface o, ShaderData d)\n   {\n      #if _SNOW\n          float amount = _SnowAmount;\n          if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n          float snowAmount = lerp(dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), dot(d.worldSpaceNormal, float3(0,1,0)), amount * 0.8) + 1;\n          snowAmount -= _SnowAngle;\n          snowAmount *= _SnowContrast;\n          snowAmount = saturate(snowAmount) - (1-amount) * (1-amount);\n\n          if (_SnowWorldFade.z > 0)\n          {\n             float worldFade = saturate((d.worldSpacePosition.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n             snowAmount *= worldFade;\n          }\n\n          #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(d.worldSpacePosition.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n          #endif\n          snowAmount = saturate(snowAmount);\n\n          float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw;\n          float2 dx = ddx(uv);\n          float2 dy = ddy(uv);\n\n          #if _TRAX_ON\n              float2 tuv = d.worldSpacePosition.xz * float2(1, -1) * _SnowTraxAlbedo_ST.xy + _SnowTraxAlbedo_ST.zw;\n              float2 tdx = ddx(uv);\n              float2 tdy = ddy(uv);\n          #endif\n\n          #if _LAYERVERTEXMASK\n              snowAmount *= d.vertexColor.a;\n          #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n              snowAmount *= d.blackboard.weightTextureMask.a;\n          #endif\n\n          UNITY_BRANCH\n          if (snowAmount > 0)\n          {\n             half4 snowAlbedo;\n             half3 snowNormal;\n             half2 snowSmoothAO;\n             SampleSnowSurface(TEXTURE2D_ARGS(_SnowAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowNormal, sampler_SnowAlbedo),\n                    TEXTURE2D_ARGS(_SnowMaskMap, sampler_SnowAlbedo), d, uv, dx, dy, snowAlbedo, snowNormal, snowSmoothAO);\n\n             snowAlbedo.rgb *= _SnowTint.rgb;\n\n             #if _TRAX_ON\n                half traxBuffer = 1 - d.blackboard.traxBuffer;\n                UNITY_BRANCH\n                if (traxBuffer > 0)\n                {\n                    half4 tsnowAlbedo;\n                    half3 tsnowNormal;\n                    half2 tsnowSmoothAO;\n                    SampleSnowSurface(TEXTURE2D_ARGS(_SnowTraxAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowTraxNormal, sampler_SnowAlbedo),\n                        TEXTURE2D_ARGS(_SnowTraxMaskMap, sampler_SnowAlbedo), d, tuv, tdx, tdy, tsnowAlbedo, tsnowNormal, tsnowSmoothAO);\n\n                    tsnowAlbedo.rgb *= _SnowTraxTint;\n                    half h = HeightBlend(snowAlbedo.a, tsnowAlbedo.a, traxBuffer, 0.5);\n                    snowAlbedo = lerp(snowAlbedo, tsnowAlbedo, h);\n                    snowNormal = lerp(snowNormal, tsnowNormal, h);\n                    snowSmoothAO = lerp(snowSmoothAO, tsnowSmoothAO, h);\n                }\n             #endif\n\n             #if !_AUTONORMAL\n                o.Normal = lerp(o.Normal, snowNormal, snowAmount);\n             #endif\n             o.Albedo = lerp(o.Albedo, snowAlbedo.rgb, snowAmount);\n             o.Alpha = lerp(o.Alpha, snowAlbedo.a, snowAmount);\n             o.Smoothness = lerp(o.Smoothness, snowSmoothAO.x, snowAmount);\n             o.Occlusion = lerp(o.Occlusion, snowSmoothAO.y, snowAmount);\n             o.Height = o.Alpha;\n\n          }\n      #endif\n   }\n\n   \n\n\n\n\n\n   TEXTURE2D(_WindParticulate);\n   SAMPLER(sampler_WindParticulate);\n\n// In case we want to read it more than once..\n\n#ifndef __STACKABLE_WIND_INCLUDES__\n#define __STACKABLE_WIND_INCLUDES__\n\n\n   half FilterRange(float4 range, float y)\n   {\n      half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));\n      w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));\n      return w;\n   }\n\n   \n   float2 RotateUV(float2 uv, float amt)\n   {\n      uv -=0.5;\n      float s = sin ( amt);\n      float c = cos ( amt );\n      float2x2 mtx = float2x2( c, -s, s, c);\n      mtx *= 0.5;\n      mtx += 0.5;\n      mtx = mtx * 2-1;\n      uv = mul ( uv, mtx );\n      uv += 0.5;\n      return uv;\n   }\n\n\n   half FilterWindParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)\n   {\n      float2 windDir = RotateUV(float2(1, 0), windRot);\n      float2 flow = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));\n      float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill\n      return FilterRange(range, cofacing);\n   }\n\n   half ProcessWindParticulateMask(inout half mask, float contrast)\n   {\n      mask = pow(abs(mask), abs(contrast));\n      half invMask = 1.0 - mask;\n      invMask *= invMask; \n      invMask *= invMask;\n      return invMask;\n   }\n#endif // include guard\n\n   void Ext_SurfaceFunction9 (inout Surface o, ShaderData d)\n   {\n      #if _WIND_ON && !_PASSMETA\n   \n         float3 upVector = float3(0,0,1);\n\n         half upDot = max(0.0, dot(d.worldSpaceNormal, float3(0, 1, 0)));\n\n         float2 uv = d.worldSpacePosition.xz;\n         if (_WindParticulateSpace > 0.5)\n            uv = d.texcoord0.xy;\n         float windRotation = _WindParticulateRotation;\n         float windStrength = _WindParticulateStrength;\n\n         float2 wuv = RotateUV(uv, windRotation);\n\n         half windBlend = 1.0;\n\n         float windWorldMask = FilterRange(_WindParticulateWorldHeightMask, d.worldSpacePosition.y);\n         windWorldMask *= FilterRange(_WindParticulateAngleMask, upDot);\n\n         // compute mask\n         wuv *= float2(_WindParticulate_ST.x, 1) * _WindParticulate_ST.y + _WindParticulate_ST.zw;\n         float speed = _Time.x * _WindParticulateSpeed;\n         half w1 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv * 3 + speed * float2(1,0)).g;\n         half w2 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv + speed * float2(1.1,0)).a;\n         half windMask = (w1 * w2);\n\n         windMask *= windStrength * windBlend * windWorldMask;\n         windMask *= saturate((_WindParticulateTextureHeight - o.Height) * 10);\n\n         half windInvMask = ProcessWindParticulateMask(windMask, _WindParticulatePower);\n    \n         o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);\n         o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindParticulateEmissive.rgb;\n         o.Normal.xy *= windInvMask;\n         o.Smoothness *= windInvMask;\n         o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;\n         o.Metallic *= windInvMask;\n      #endif\n\n   }\n\n\n\n\n\tvoid Ext_SurfaceFunction10 (inout Surface o, ShaderData d)\n\t{\n        if (_DoubleSidedNormalMode == 0)\n        {\n           o.Normal *= d.isFrontFace ? 1 : -1;\n        }\n        else if (_DoubleSidedNormalMode == 1)\n        {\n\t\t   o.Normal.z *= d.isFrontFace ? 1 : -1;\n        }\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction11 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _SURFACEGRADIENT\n\t\t\to.Normal = ResolveNormalFromSurfaceGradient(d, o.Normal);\n\t    #elif _AUTONORMAL\n\t        float3 dx = ddx(d.worldSpacePosition);\n\t\t\tfloat3 dy = ddy(d.worldSpacePosition);\n\t\t\tfloat3 crossX = cross(float3(0,1,0), dx);\n\t\t\tfloat3 crossY = cross(float3(0,1,0), dy);\n\t\t\tfloat3 dt = abs(dot(crossY, dx));\n\t\t\tfloat height = _AutoNormalStrength * 0.5 * o.Alpha;\n\t\t\tfloat3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n\t\t\tn.y *= -1.0;\n\t\t\to.Normal = normalize((dt * float3(0,1,0)) - n).xzy;\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#else\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#endif\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction12 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DEBUG_SAMPLECOUNT\n\t\t\tif (_sampleCount > _DebugSampleCountThreshold)\n\t\t\t{\n\t\t\t\to.Albedo.r = 1;\n\t\t\t\to.Albedo.gb *= 0.2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\to.Albedo.b = 1;\n\t\t\t}\n\n        #endif\n\t}\n\n\n\n\n\tSAMPLER(sampler_DissolveTexture);\n\tTEXTURE2D(_DissolveTexture);\n\tTEXTURE2D(_DissolveGradient);\n\n\tvoid Ext_SurfaceFunction13 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DISSOLVE\n\t\tfloat2 uv = d.texcoord0.xy * _DissolveTexture_ST.xy + _DissolveTexture_ST.zw;\n\t\tfloat2 dx = ddx(uv);\n\t\tfloat2 dy = ddy(uv);\n\n\t\tUNITY_BRANCH\n\t\tif (_DissolveAmount > 0)\n\t\t{\n\t\t\thalf dissolve = SAMPLE_TEXTURE2D_GRAD(_DissolveTexture, sampler_DissolveTexture, uv, dx, dy).g;\n\t\t\thalf cp =  saturate(_DissolveAmount - (dissolve - _DissolveAmount) * _DissolveEdgeContrast) + _DissolveAmount;\n\t\t\thalf cp2 = saturate(1.0 - abs((dissolve - _DissolveAmount) * _DissolveEdgeContrast));\n\t\t\tclip(1.0 - cp);\n\t\t\tfloat2 fuv = float2(cp2, 0.5);\n\t\t\thalf3 col = SAMPLE_TEXTURE2D_LOD(_DissolveGradient, sampler_DissolveTexture, fuv, 0).rgb;\n\t\t\t\t\n\t\t\to.Albedo = lerp(o.Albedo, col, _DissolveColoration * cp2);\n\t\t\to.Emission = lerp(o.Emission, col * _DissolveEmissiveStr, _DissolveColoration * cp2);\n\t\t}\n\t\t#endif\n\t}\n\n\n\n\n    float Dither8x8Bayer( int x, int y )\n    {\n        const float dither[ 64 ] = {\n                1, 49, 13, 61,  4, 52, 16, 64,\n            33, 17, 45, 29, 36, 20, 48, 32,\n                9, 57,  5, 53, 12, 60,  8, 56,\n            41, 25, 37, 21, 44, 28, 40, 24,\n                3, 51, 15, 63,  2, 50, 14, 62,\n            35, 19, 47, 31, 34, 18, 46, 30,\n            11, 59,  7, 55, 10, 58,  6, 54,\n            43, 27, 39, 23, 42, 26, 38, 22};\n        int r = y * 8 + x;\n        return dither[r] / 64; \n    }\n\n    void ApplyDitherCrossFadeVSP(float2 vpos, float fadeValue)\n    {\n        float dither = Dither8x8Bayer( fmod(vpos.x, 8), fmod(vpos.y, 8) );\n        float sgn = fadeValue > 0 ? 1.0f : -1.0f;\n        clip(dither - (1-fadeValue) * sgn);\n    }\n    \n\n\tvoid Ext_SurfaceFunction14 (inout Surface o, ShaderData d)\n\t{\n\t\t#if LOD_FADE_CROSSFADE\n            float4 screenPosNorm = d.screenPos / d.screenPos.w;\n            screenPosNorm.z = ( UNITY_NEAR_CLIP_VALUE >= 0 ) ? screenPosNorm.z : screenPosNorm.z * 0.5 + 0.5;\n            float2 clipScreen = screenPosNorm.xy * _ScreenParams.xy;\n            ApplyDitherCrossFadeVSP(clipScreen,unity_LODFade.x);\n        #endif\n\t}\n\n\n\n\n\n\n// declare outside of CBuffer\n\nfloat4x4 _GlobalVolumeMatrix;\nfloat4x4 _VolumeMatrix;\nfloat3 _VolumeMin;\nfloat3 _VolumeInvSize;\nfloat3 _GlobalVolumeMin;\nfloat3 _GlobalVolumeInvSize;\n\n// I inlined a section of your include. You can use includes in better shaders, but doing it via a subshader or this way\n// is much better. The reason is that this allows your shader to be all inclusive, and packed up for asset store distribition,\n// without requiring specific paths to other files, etc.\n//\n\n#ifndef BAKERY_INCLUDED\n#define BAKERY_INCLUDED\n\n#define BAKERYMODE_DEFAULT 0\n#define BAKERYMODE_VERTEXLM 1.0f\n#define BAKERYMODE_RNM 2.0f\n#define BAKERYMODE_SH 3.0f\n\n\n// can't fit vertexLM SH to sm3_0 interpolators\n#ifndef SHADER_API_D3D11\n    #undef _LIGHTMAPMODE_VERTEXSH\n#endif\n\n// can't do stuff on sm2_0 due to standard shader alrady taking up all instructions\n#if SHADER_TARGET < 30\n    #undef BAKERY_BICUBIC\n    #undef BAKERY_LMSPEC\n\n    #undef _LIGHTMAPMODE_RNM\n    #undef _LIGHTMAPMODE_SH\n    #undef _LIGHTMAPMODE_VERTEX\n#endif\n\n#define lumaConv float3(0.2125f, 0.7154f, 0.0721f)\n\n#ifdef BAKERY_VOLUME\n    #ifdef BAKERY_COMPRESSED_VOLUME\n        Texture3D _Volume3;\n    #endif\n#endif\n\n\nhalf3 LinearToGamma (half3 linRGB)\n{\n    linRGB = max(linRGB, half3(0.h, 0.h, 0.h));\n    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n    return max(1.055h * pow(linRGB, 0.416666667h) - 0.055h, 0.h);\n}\n\nfloat shEvaluateDiffuseL1Geomerics(float L0, float3 L1, float3 n)\n{\n    // average energy\n    float R0 = L0;\n\n    // avg direction of incoming light\n    float3 R1 = 0.5f * L1;\n\n    // directional brightness\n    float lenR1 = length(R1);\n\n    // linear angle between normal and direction 0-1\n    //float q = 0.5f * (1.0f + dot(R1 / lenR1, n));\n    //float q = dot(R1 / lenR1, n) * 0.5 + 0.5;\n    float q = dot(normalize(R1), n) * 0.5 + 0.5;\n\n    // power for q\n    // lerps from 1 (linear) to 3 (cubic) based on directionality\n    float p = 1.0f + 2.0f * lenR1 / R0;\n\n    // dynamic range constant\n    // should vary between 4 (highly directional) and 0 (ambient)\n    float a = (1.0f - lenR1 / R0) / (1.0f + lenR1 / R0);\n\n    return R0 * (a + (1.0f - a) * (p + 1.0f) * pow(q, p));\n}\n\n#ifdef BAKERY_VERTEXLMMASK\n    float4 unpack4NFloats(float src)\n\t{\n        //return fmod(float4(src / 262144.0, src / 4096.0, src / 64.0, src), 64.0)/64.0;\n        return frac(float4(src / (262144.0*64), src / (4096.0*64), src / (64.0*64), src));\n    }\n#endif\n\n#if defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n    float3 unpack3NFloats(float src)\n\t{\n        float r = frac(src);\n        float g = frac(src * 256.0);\n        float b = frac(src * 65536.0);\n        return float3(r, g, b);\n    }\n#endif\n\n// Unity defines these under different names in each SRP, so use our own\ninline float3 Bakery_SafeNormalize(float3 inVec)\n{\n    float dp3 = max(0.001f, dot(inVec, inVec));\n    return inVec * rsqrt(dp3);\n}\n\n#if _URP || _HDRP\n\nfloat SmoothnessToPerceptualRoughness(float smoothness)\n{\n    return (1 - smoothness);\n}\n#endif\n\n#if !_STANDARD\nhalf4 unity_Lightmap_HDR;\ninline half3 DecodeLightmap( half4 color )\n{\n    return DecodeLightmap( color, unity_Lightmap_HDR );\n}\n\n#define UNITY_INV_PI        0.31830988618f\ninline float GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return UNITY_INV_PI * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n    void BakeryVertexLMDirection(inout float3 diffuseColor, inout float3 specularColor, float3 lightDirection, float3 vertexNormalWorld, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 dominantDir = Bakery_SafeNormalize(lightDirection);\n        half halfLambert = dot(normalWorld, dominantDir) * 0.5 + 0.5;\n        half flatNormalHalfLambert = dot(vertexNormalWorld, dominantDir) * 0.5 + 0.5;\n\n        #ifdef BAKERY_LMSPEC\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = spec * diffuseColor;\n        #endif\n\n        diffuseColor *= halfLambert / max(1e-4h, flatNormalHalfLambert);\n    }\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXSH\n    void BakeryVertexLMSH(inout float3 diffuseColor, inout float3 specularColor, float3 shL1x, float3 shL1y, float3 shL1z, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 L0 = diffuseColor;\n        float3 nL1x = shL1x;\n        float3 nL1y = shL1y;\n        float3 nL1z = shL1z;\n        float3 L1x = nL1x * L0 * 2;\n        float3 L1y = nL1y * L0 * 2;\n        float3 L1z = nL1z * L0 * 2;\n\n        float3 sh;\n    #if BAKERY_SHNONLINEAR\n        //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n        //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n        //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n        float lumaL0 = dot(L0, 1);\n        float lumaL1x = dot(L1x, 1);\n        float lumaL1y = dot(L1y, 1);\n        float lumaL1z = dot(L1z, 1);\n        float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n        float regularLumaSH = dot(sh, 1);\n        //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n        sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    #else\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    #endif\n\n        diffuseColor = max(sh, 0.0);\n\n        #ifdef BAKERY_LMSPEC\n            float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n            float focus = saturate(length(dominantDir));\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = max(spec * sh, 0.0);\n        #endif\n    }\n#endif\n\n\n\n#ifdef BAKERY_BICUBIC\nfloat BakeryBicubic_w0(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-a + 3.0f) - 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w1(float a)\n{\n    return (1.0f/6.0f)*(a*a*(3.0f*a - 6.0f) + 4.0f);\n}\n\nfloat BakeryBicubic_w2(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-3.0f*a + 3.0f) + 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w3(float a)\n{\n    return (1.0f/6.0f)*(a*a*a);\n}\n\nfloat BakeryBicubic_g0(float a)\n{\n    return BakeryBicubic_w0(a) + BakeryBicubic_w1(a);\n}\n\nfloat BakeryBicubic_g1(float a)\n{\n    return BakeryBicubic_w2(a) + BakeryBicubic_w3(a);\n}\n\nfloat BakeryBicubic_h0(float a)\n{\n    return -1.0f + BakeryBicubic_w1(a) / (BakeryBicubic_w0(a) + BakeryBicubic_w1(a)) + 0.5f;\n}\n\nfloat BakeryBicubic_h1(float a)\n{\n    return 1.0f + BakeryBicubic_w3(a) / (BakeryBicubic_w2(a) + BakeryBicubic_w3(a)) + 0.5f;\n}\n#endif\n\n\n#if defined(_LIGHTMAPMODE_RNM) || defined(_LIGHTMAPMODE_SH)\nTexture2D _RNM0, _RNM1, _RNM2;\n#endif\n\n#ifdef BAKERY_VOLUME\nTexture3D _Volume0, _Volume1, _Volume2, _VolumeMask;\nSamplerState sampler_Volume0;\n#endif\n\n#if defined(BAKERY_BICUBIC) && defined(LIGHTMAP_ON) && defined(SHADER_API_D3D11)\n    // Bicubic\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\tfloat width, height;\n\t\ttex.GetDimensions(width, height);\n\t\tfloat texelSize = 1.0f / width;\n\n        float x = uv.x * width;\n        float y = uv.y * width;\n\n        x -= 0.5f;\n        y -= 0.5f;\n\n        float px = floor(x);\n        float py = floor(y);\n\n        float fx = x - px;\n        float fy = y - py;\n\n        float g0x = BakeryBicubic_g0(fx);\n        float g1x = BakeryBicubic_g1(fx);\n        float h0x = BakeryBicubic_h0(fx);\n        float h1x = BakeryBicubic_h1(fx);\n        float h0y = BakeryBicubic_h0(fy);\n        float h1y = BakeryBicubic_h1(fy);\n\n        return     BakeryBicubic_g0(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h0y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h0y) * texelSize))) +\n\n                   BakeryBicubic_g1(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h1y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h1y) * texelSize)));\n    }\n#else\n    // Bilinear\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\t#ifdef LIGHTMAP_ON\n\t\t\treturn tex.Sample(samplerunity_Lightmap, uv);\n\t\t#else\n\t\t\treturn float4(1,0,0,1);\n\t\t#endif\n    }\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\n#ifdef BAKERY_LMSPEC\nfloat BakeryDirectionalLightmapSpecular(float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 dominantDir = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap, lmUV).xyz * 2 - 1;\n    half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n    half nh = saturate(dot(normalWorld, halfDir));\n    half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n    half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n    half spec = GGXTerm(nh, roughness);\n    return spec;\n}\n#endif\n#endif\n\n\n\n#ifdef _LIGHTMAPMODE_RNM\nvoid BakeryRNM(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalMap, float smoothness, float3 viewDirT)\n{\n    const float3 rnmBasis0 = float3(0.816496580927726f, 0, 0.5773502691896258f);\n    const float3 rnmBasis1 = float3(-0.4082482904638631f, 0.7071067811865475f, 0.5773502691896258f);\n    const float3 rnmBasis2 = float3(-0.4082482904638631f, -0.7071067811865475f, 0.5773502691896258f);\n\n    float3 rnm0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 rnm1 = DecodeLightmap(BakeryTex2D(_RNM1, lmUV));\n    float3 rnm2 = DecodeLightmap(BakeryTex2D(_RNM2, lmUV));\n\n    #ifdef BAKERY_SSBUMP\n        diffuseColor = normalMap.x * rnm0\n                     + normalMap.z * rnm1\n                     + normalMap.y * rnm2;\n         diffuseColor *= 2;\n    #else\n        diffuseColor = saturate(dot(rnmBasis0, normalMap)) * rnm0\n                     + saturate(dot(rnmBasis1, normalMap)) * rnm1\n                     + saturate(dot(rnmBasis2, normalMap)) * rnm2;\n    #endif\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDirT = rnmBasis0 * dot(rnm0, lumaConv) +\n                              rnmBasis1 * dot(rnm1, lumaConv) +\n                              rnmBasis2 * dot(rnm2, lumaConv);\n\n        float3 dominantDirTN = normalize(dominantDirT);\n        float3 specColor = saturate(dot(rnmBasis0, dominantDirTN)) * rnm0 +\n                           saturate(dot(rnmBasis1, dominantDirTN)) * rnm1 +\n                           saturate(dot(rnmBasis2, dominantDirTN)) * rnm2;\n\n        half3 halfDir = Bakery_SafeNormalize(dominantDirTN - viewDirT);\n        half nh = saturate(dot(normalMap, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n        specularColor = spec * specColor;\n    #endif\n}\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\ninline half3 Unity_DecodeDirectionalLightmap(half3 color, half4 dirTex, half3 normalWorld)\n{\n    // In directional (non-specular) mode Enlighten bakes dominant light direction\n    // in a way, that using it for half Lambert and then dividing by a \"rebalancing coefficient\"\n    // gives a result close to plain diffuse response lightmaps, but normalmapped.\n\n    // Note that dir is not unit length on purpose. Its length is \"directionality\", like\n    // for the directional specular lightmaps.\n\n    half halfLambert = dot(normalWorld, dirTex.xyz - 0.5) + 0.5;\n\n    return color * halfLambert / max(1e-4h, dirTex.w);\n}\n#endif\n\n#ifdef _LIGHTMAPMODE_SH\nvoid BakerySH(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 L0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 nL1x = BakeryTex2D(_RNM0, lmUV) * 2 - 1;\n    float3 nL1y = BakeryTex2D(_RNM1, lmUV) * 2 - 1;\n    float3 nL1z = BakeryTex2D(_RNM2, lmUV) * 2 - 1;\n    float3 L1x = nL1x * L0 * 2;\n    float3 L1y = nL1y * L0 * 2;\n    float3 L1z = nL1z * L0 * 2;\n\n    float3 sh;\n#if BAKERY_SHNONLINEAR\n    float lumaL0 = dot(L0, 1);\n    float lumaL1x = dot(L1x, 1);\n    float lumaL1y = dot(L1y, 1);\n    float lumaL1z = dot(L1z, 1);\n    float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    float regularLumaSH = dot(sh, 1);\n    //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n    sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n    //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n    //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n#else\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n#endif\n\n    diffuseColor = max(sh, 0.0);\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n        float focus = saturate(length(dominantDir));\n        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n        half nh = saturate(dot(normalWorld, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n\n        sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n\n        specularColor = max(spec * sh, 0.0);\n    #endif\n}\n#endif\n\n#endif // include guards\n\n\n    void Ext_ModifyVertex15 (inout VertexData v, inout ExtraV2F e)\n    {\n        #if _USEBAKERY\n\t\t    #if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\t\t\t    // Unpack from RGBM\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.a * 8.0f;\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.rgb;\n\n\t\t\t    #ifdef BAKERY_VERTEXLMMASK\n\t\t\t\t    e.extraV2F4.xyzw = unpack4NFloats(v.texcoord1);\n\t\t\t    #endif\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXSH\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n                e.extraV2F6.xyz = unpack3NFloats(v.texcoord3.x) * 2 - 1;\n                e.extraV2F7.xyz = unpack3NFloats(v.texcoord3.y) * 2 - 1;\n            #endif\n       #endif\n    }\n\n#if _HDRP || _URP\n    half3 SHEvalLinearL0L1 (half4 normal)\n    {\n        half3 x;\n\n        // Linear (L1) + constant (L0) polynomial terms\n        x.r = dot(unity_SHAr,normal);\n        x.g = dot(unity_SHAg,normal);\n        x.b = dot(unity_SHAb,normal);\n\n        return x;\n    }\n\n    // normal should be normalized, w=1.0\n    half3 SHEvalLinearL2 (half4 normal)\n    {\n        half3 x1, x2;\n        // 4 of the quadratic (L2) polynomials\n        half4 vB = normal.xyzz * normal.yzzx;\n        x1.r = dot(unity_SHBr,vB);\n        x1.g = dot(unity_SHBg,vB);\n        x1.b = dot(unity_SHBb,vB);\n\n        // Final (5th) quadratic (L2) polynomial\n        half vC = normal.x*normal.x - normal.y*normal.y;\n        x2 = unity_SHC.rgb * vC;\n\n        return x1 + x2;\n    }\n\n    half3 ShadeSH9 (half4 normal)\n    {\n        // Linear + constant polynomial terms\n        half3 res = SHEvalLinearL0L1 (normal);\n\n        // Quadratic polynomials\n        res += SHEvalLinearL2 (normal);\n\n        #ifdef UNITY_COLORSPACE_GAMMA\n            res = LinearToGamma (res);\n        #endif\n\n        return res;\n\n    }\n#endif\n\n\n\n\tvoid DoBakeryStuff(inout float3 indDif, inout float3 indSpec, inout float4 shadowmask, float3 tangentNormal, float smoothness, ShaderData d)\n\t{\n\t\t// Quality!\n\t\tindDif = 1;\n\t\tindSpec = 0;\n\n        #if defined(_PASSFORWARD) || defined(_PASSGBUFFER) // forward pass on URP/Standard/HDRP + built-in deferred\n\n            float3 normalWorld = mul(tangentNormal, d.TBNMatrix);\n\n\t\t\t#ifdef LIGHTMAP_ON\n\n                // Static\n\n\t\t\t\tfloat2 lmUV = d.texcoord1 * unity_LightmapST.xy + unity_LightmapST.zw;\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_STANDARD\n\t\t\t\t\tindDif = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n\n\t\t\t\t\t#ifdef DIRLIGHTMAP_COMBINED\n\t\t\t\t\t\tfloat4 dirMap = BakeryTex2D(unity_LightmapInd, lmUV);\n\t\t\t\t\t\tindDif = Unity_DecodeDirectionalLightmap(indDif, dirMap, normalWorld);\n\n\t\t\t\t\t\t#ifdef BAKERY_LMSPEC\n\t\t\t\t\t\t\tindSpec = BakeryDirectionalLightmapSpecular(lmUV, normalWorld, -d.worldSpaceViewDir, smoothness) * indDif;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\n\t\t\t\t\tindDif = d.vertexColor;\n\n                    #ifdef BAKERY_VERTEXLMMASK\n                        shadowmask = d.extraV2F4;\n                    #endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n\t\t\t\t\t\t// worldSpaceNormal is per-vertex\n\t\t\t\t\t\t// normalWorld is per-pixel\n\t\t\t\t\t\tfloat3 bakedLightDirection = d.extraV2F5;\n\t\t\t\t\t\tBakeryVertexLMDirection(indDif, indSpec, bakedLightDirection, d.worldSpaceNormal, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXSH\n\t\t\t\t\t\tBakeryVertexLMSH(indDif, indSpec, d.extraV2F5, d.extraV2F6, d.extraV2F7, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_RNM\n\t\t\t\t\tBakeryRNM(indDif, indSpec, lmUV, tangentNormal, smoothness, -d.tangentSpaceViewDir);\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_SH\n\t\t\t\t\tBakerySH(indDif, indSpec, lmUV, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t#endif\n\n            #else\n\n                // Dynamic\n\n                #ifdef BAKERY_VOLUME\n\n                    bool isGlobal = dot(abs(_VolumeInvSize),1) == 0;\n                    float3 volViewDir = -d.worldSpaceViewDir;\n                    #ifdef BAKERY_VOLROTATION\n                        float4x4 volMatrix = (isGlobal ? _GlobalVolumeMatrix : _VolumeMatrix);\n                        float3 volInvSize = (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 lpUV = mul(volMatrix, float4(d.worldSpacePosition,1)).xyz * volInvSize + 0.5f;\n                        float3 volNormal = mul((float3x3)volMatrix, normalWorld);\n                        #ifdef BAKERY_LMSPEC\n                            volViewDir = mul((float3x3)volMatrix, volViewDir);\n                        #endif\n                    #else\n                        float3 lpUV = (d.worldSpacePosition - (isGlobal ? _GlobalVolumeMin : _VolumeMin)) * (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 volNormal = normalWorld;\n                    #endif\n\n                    #ifdef BAKERY_COMPRESSED_VOLUME\n                        float4 tex0, tex1, tex2, tex3;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex3 = _Volume3.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz * L0;\n                        L1y = tex2.xyz * L0;\n                        L1z = tex3.xyz * L0;\n                    #else\n                        float4 tex0, tex1, tex2;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV);\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV);\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz;\n                        L1y = tex2.xyz;\n                        L1z = float3(tex0.w, tex1.w, tex2.w);\n                    #endif\n                    indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), volNormal);\n                    indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), volNormal);\n                    indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), volNormal);\n\n                    #ifdef UNITY_COLORSPACE_GAMMA\n                        indDif = pow(indDif, 1.0f / 2.2f);\n                    #endif\n\n                    #ifdef BAKERY_LMSPEC\n                        float3 nL1x = L1x / L0;\n                        float3 nL1y = L1y / L0;\n                        float3 nL1z = L1z / L0;\n                        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n                        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - volViewDir);\n                        half nh = saturate(dot(volNormal, halfDir));\n                        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n                        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n                        half spec = GGXTerm(nh, roughness);\n                        float3 sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n                        indSpec = max(spec * sh, 0.0);\n                    #endif\n\n                    shadowmask = _VolumeMask.Sample(sampler_Volume0, lpUV);\n\n                #else\n\n                    #ifdef BAKERY_SHNONLINEAR\n                        float3 L0 = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);\n                        indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, unity_SHAr.xyz, normalWorld);\n                        indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, unity_SHAg.xyz, normalWorld);\n                        indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, unity_SHAb.xyz, normalWorld);\n                    #else\n                        indDif = ShadeSH9(float4(normalWorld,1));\n                    #endif\n\n                #endif\n\n\t\t\t#endif\n\n        #endif\n\t}\n\n\t// this is the main surface function. Surface is like a surface shader output structure, but\n\t// with our new outputs as well.\n\tvoid Ext_SurfaceFunction15 (inout Surface o, ShaderData d)\n\t{\n        #if _USEBAKERY\n\t\t    float3 indDif;\n\t\t    float3 indSpec;\n            float4 shadowmask = 1;\n\t\t    DoBakeryStuff(indDif, indSpec, shadowmask, o.Normal, o.Smoothness, d);\n\t\t    o.DiffuseGI = indDif;\n\t\t    o.BackDiffuseGI = indDif;\n\t\t    o.SpecularGI = indSpec;\n            o.ShadowMask = shadowmask;\n        #endif\n\t}\n\n\n\n\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                  Ext_SurfaceFunction1(l, d);\n                  Ext_SurfaceFunction2(l, d);\n                  Ext_SurfaceFunction3(l, d);\n                  Ext_SurfaceFunction4(l, d);\n                  Ext_SurfaceFunction5(l, d);\n                  Ext_SurfaceFunction6(l, d);\n                  Ext_SurfaceFunction7(l, d);\n                  Ext_SurfaceFunction8(l, d);\n                  Ext_SurfaceFunction9(l, d);\n\t\t            Ext_SurfaceFunction10(l, d);\n                  Ext_SurfaceFunction11(l, d);\n                  Ext_SurfaceFunction12(l, d);\n                  Ext_SurfaceFunction13(l, d);\n                  Ext_SurfaceFunction14(l, d);\n                  Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraV2F d;\n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                  Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                  Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                  #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                  v2p.extraV2F4 = d.extraV2F4;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                  v2p.extraV2F5 = d.extraV2F5;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F6 = d.extraV2F6;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F7 = d.extraV2F7;\n                  #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                d.extraV2F4 = v2p.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                d.extraV2F5 = v2p.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F6 = v2p.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F7 = v2p.extraV2F7;\n                #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n                Ext_ModifyTessellatedVertex2(v, d);\n                Ext_ModifyTessellatedVertex3(v, d);\n                Ext_ModifyTessellatedVertex4(v, d);\n                Ext_ModifyTessellatedVertex5(v, d);\n                Ext_ModifyTessellatedVertex6(v, d);\n                Ext_ModifyTessellatedVertex7(v, d);\n                Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                v2p.extraV2F4 = d.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                v2p.extraV2F5 = d.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F6 = d.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F7 = d.extraV2F7;\n                #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n            // d.texcoord3 = i.texcoord3;\n             #endif\n\n             d.isFrontFace = facing;\n             #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n             d.vertexColor = i.vertexColor;\n             #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(i.worldPos, 1)).xyz;\n            #endif\n             d.localSpaceNormal = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n             #if LOD_FADE_CROSSFADE\n             d.screenPos = i.screenPos;\n             d.screenUV = (i.screenPos.xy / i.screenPos.w);\n             #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n             #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n             d.extraV2F4 = i.extraV2F4;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n             d.extraV2F5 = i.extraV2F5;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F6 = i.extraV2F6;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F7 = i.extraV2F7;\n             #endif\n\n            return d;\n         }\n         \n\n            \n\nstruct VaryingsToPS\n{\n   VertexToPixel vmesh;\n   #ifdef VARYINGS_NEED_PASS\n      VaryingsPassToPS vpass;\n   #endif\n};\n\nstruct PackedVaryingsToPS\n{\n   #ifdef VARYINGS_NEED_PASS\n      PackedVaryingsPassToPS vpass;\n   #endif\n   VertexToPixel vmesh;\n\n   UNITY_VERTEX_OUTPUT_STEREO\n};\n\nPackedVaryingsToPS PackVaryingsToPS(VaryingsToPS input)\n{\n   PackedVaryingsToPS output = (PackedVaryingsToPS)0;\n   output.vmesh = input.vmesh;\n   #ifdef VARYINGS_NEED_PASS\n      output.vpass = PackVaryingsPassToPS(input.vpass);\n   #endif\n\n   UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n   return output;\n}\n\n\n\n\nVertexToPixel VertMesh(VertexData input)\n{\n    VertexToPixel output = (VertexToPixel)0;\n\n    UNITY_SETUP_INSTANCE_ID(input);\n    UNITY_TRANSFER_INSTANCE_ID(input, output);\n\n    \n    ChainModifyVertex(input, output);\n\n\n    // This return the camera relative position (if enable)\n    float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n    float3 normalWS = TransformObjectToWorldNormal(input.normal);\n    float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n    output.worldPos = GetAbsolutePositionWS(positionRWS);\n    output.pos = TransformWorldToHClip(positionRWS);\n    output.worldNormal = normalWS;\n    output.worldTangent = tangentWS;\n\n\n    output.texcoord0 = input.texcoord0;\n    output.texcoord1 = input.texcoord1;\n    output.texcoord2 = input.texcoord2;\n     #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n    // output.texcoord3 = input.texcoord3;\n     #endif\n\n     #if LOD_FADE_CROSSFADE\n     output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n     #endif\n\n     #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n     output.vertexColor = input.vertexColor;\n     #endif\n    return output;\n}\n\n\n#if (SHADERPASS == SHADERPASS_DBUFFER_MESH)\nvoid MeshDecalsPositionZBias(inout VaryingsToPS input)\n{\n#if defined(UNITY_REVERSED_Z)\n    input.vmesh.pos.z -= _DecalMeshDepthBias;\n#else\n    input.vmesh.pos.z += _DecalMeshDepthBias;\n#endif\n}\n#endif\n\n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n// This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\nfloat unity_OneOverOutputBoost;\nfloat unity_MaxOutputValue;\n\nCBUFFER_START(UnityMetaPass)\n// x = use uv1 as raster position\n// y = use uv2 as raster position\nbool4 unity_MetaVertexControl;\n\n// x = return albedo\n// y = return normal\nbool4 unity_MetaFragmentControl;\nCBUFFER_END\n\nPackedVaryingsToPS Vert(VertexData inputMesh)\n{\n    VaryingsToPS output = (VaryingsToPS)0;\n    output.vmesh = (VertexToPixel)0;\n\n    UNITY_SETUP_INSTANCE_ID(inputMesh);\n    UNITY_TRANSFER_INSTANCE_ID(inputMesh, output.vmesh);\n\n    // Output UV coordinate in vertex shader\n    float2 uv = float2(0.0, 0.0);\n\n    if (unity_MetaVertexControl.x)\n    {\n        uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n    }\n    else if (unity_MetaVertexControl.y)\n    {\n        uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n    }\n\n    // OpenGL right now needs to actually use the incoming vertex position\n    // so we create a fake dependency on it here that haven't any impact.\n    output.vmesh.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n#ifdef VARYINGS_NEED_POSITION_WS\n    output.vmesh.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz);\n#endif\n\n#ifdef VARYINGS_NEED_TANGENT_TO_WORLD\n    // Normal is required for triplanar mapping\n    output.vmesh.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n    // Not required but assign to silent compiler warning\n    output.vmesh.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n#endif\n\n    output.vmesh.texcoord0 = inputMesh.texcoord0;\n    output.vmesh.texcoord1 = inputMesh.texcoord1;\n    output.vmesh.texcoord2 = inputMesh.texcoord2;\n     #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n    // output.vmesh.texcoord3 = inputMesh.texcoord3;\n     #endif\n\n     #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n     output.vmesh.vertexColor = inputMesh.vertexColor;\n     #endif\n\n    return PackVaryingsToPS(output);\n}\n#else\n\nPackedVaryingsToPS Vert(VertexData inputMesh)\n{\n    VaryingsToPS varyingsType;\n    varyingsType.vmesh = VertMesh(inputMesh);\n    #if (SHADERPASS == SHADERPASS_DBUFFER_MESH)\n       MeshDecalsPositionZBias(varyingsType);\n    #endif\n    return PackVaryingsToPS(varyingsType);\n}\n\n#endif\n\n\n\n            \n\n            \n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n            \n                    output.positionRWS = input.worldPos;\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n            \n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n        \n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n        \n           #ifdef _HAS_REFRACTION\n                   if (_EnableSSRefraction)\n                   {\n                       // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                       // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                       // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n        \n                       surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                       surfaceDescription.Alpha = 1.0;\n                   }\n                   else\n                   {\n                       surfaceData.ior = 1.0;\n                       surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                       surfaceData.atDistance = 1.0;\n                       surfaceData.transmittanceMask = 0.0;\n                       surfaceDescription.Alpha = 1.0;\n                   }\n           #else\n                   surfaceData.ior = 1.0;\n                   surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                   surfaceData.atDistance = 1.0;\n                   surfaceData.transmittanceMask = 0.0;\n           #endif\n                \n                   // These static material feature allow compile time optimization\n                   surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n           #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n           #endif\n           #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n           #endif\n           #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n           #endif\n                   // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n        \n           #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n           #endif\n           #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n           #endif\n        \n           #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                   // Require to have setup baseColor\n                   // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                   surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n           #endif\n\n        \n                   // tangent-space normal\n                   float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                   normalTS = surfaceDescription.Normal;\n        \n                   // compute world space normal\n                   #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(normalTS, fragInputs.tangentToWorld);\n                   #else\n                      surfaceData.normalWS = normalTS;  \n                   #endif\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                   // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent, fragInputs.tangentToWorld);\n        \n           #if HAVE_DECALS\n                   if (_EnableDecals)\n                   {\n                       #if VERSION_GREATER_EQUAL(10,2)\n                          DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput,  surfaceData.geomNormalWS, surfaceDescription.Alpha);\n                          ApplyDecalToSurfaceData(decalSurfaceData,  surfaceData.geomNormalWS, surfaceData);\n                       #else\n                          DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                          ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                       #endif\n                   }\n           #endif\n        \n                   bentNormalWS = surfaceData.normalWS;\n               \n                   surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n        \n        \n                   // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                   // If user provide bent normal then we process a better term\n           #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                   // Just use the value passed through via the slot (not active otherwise)\n           #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                   // If we have bent normal and ambient occlusion, process a specular occlusion\n                   surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n           #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                   surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n           #endif\n        \n           #ifdef _ENABLE_GEOMETRIC_SPECULAR_AA\n                   surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n           #endif\n        \n           #ifdef DEBUG_DISPLAY\n                   if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                   {\n                       // TODO: need to update mip info\n                       surfaceData.metallic = 0;\n                   }\n        \n                   // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                   // as it can modify attribute use for static lighting\n                   ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n           #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //    uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to _ScreenSize values\n                 //    LODDitheringTransition(fadeMaskSeed, unity_LODFade.x);\n                 //#endif\n        \n                 d = CreateShaderData(m2ps\n                  #if NEED_FACING\n                    , facing\n                  #endif\n                 );\n\n                 \n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #ifdef _DEPTHOFFSET_ON\n                    l.outputDepth = posInput.deviceDepth;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #ifdef _DEPTHOFFSET_ON\n                    posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n        \n                 #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     //builtinData.distortion = surfaceDescription.Distortion;\n                     //builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                     builtinData.distortion = float2(0.0, 0.0);\n                     builtinData.distortionBlur = 0.0;\n                 #else\n                     builtinData.distortion = float2(0.0, 0.0);\n                     builtinData.distortionBlur = 0.0;\n                 #endif\n        \n                   PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n               }\n\n\n            float4 Frag(PackedVaryingsToPS packedInput\n               #if NEED_FACING\n                  , bool facing : SV_IsFrontFace\n               #endif\n\n            ) : SV_Target\n            {\n                FragInputs input = BuildFragInputs(packedInput.vmesh);\n\n                // input.positionSS is SV_Position\n                PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n            #ifdef VARYINGS_NEED_POSITION_WS\n                float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n            #else\n                // Unused\n                float3 V = float3(1.0, 1.0, 1.0); // Avoid the division by 0\n            #endif\n\n                SurfaceData surfaceData;\n                BuiltinData builtinData;\n                Surface l;\n                ShaderData d;\n                GetSurfaceAndBuiltinData(packedInput.vmesh, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n\n                // no debug apply during light transport pass\n\n                BSDFData bsdfData = ConvertSurfaceDataToBSDFData(input.positionSS.xy, surfaceData);\n                LightTransportData lightTransportData = GetLightTransportData(surfaceData, builtinData, bsdfData);\n\n                // This shader is call two times. Once for getting emissiveColor, the other time to get diffuseColor\n                // We use unity_MetaFragmentControl to make the distinction.\n                float4 res = float4(0.0, 0.0, 0.0, 1.0);\n\n                if (unity_MetaFragmentControl.x)\n                {\n                    // Apply diffuseColor Boost from LightmapSettings.\n                    // put abs here to silent a warning, no cost, no impact as color is assume to be positive.\n                    res.rgb = clamp(pow(abs(lightTransportData.diffuseColor), saturate(unity_OneOverOutputBoost)), 0, unity_MaxOutputValue);\n                }\n\n                if (unity_MetaFragmentControl.y)\n                {\n                    // emissive use HDR format\n                    res.rgb = lightTransportData.emissiveColor;\n                }\n\n                return res;\n            }\n\n\n\n            ENDHLSL\n        }\n        \n              Pass\n        {\n            // based on HDLitPass.template\n            Name \"SceneSelectionPass\"\n            Tags { \"LightMode\" = \"SceneSelectionPass\" }\n        \n            ColorMask 0\n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 ps4 xboxone vulkan metal switch\n            //#pragma enable_d3d11_debug_symbols\n        \n            #pragma multi_compile_instancing\n \n            //#pragma multi_compile_local _ _ALPHATEST_ON\n\n\n            //#pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n        \n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            // #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            #define SHADERPASS SHADERPASS_DEPTH_ONLY\n            #define SCENESELECTIONPASS\n            #pragma editor_sync_compilation\n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #define _PASSSCENESELECT 1\n\n            \n\n\n   #pragma shader_feature_local_fragment _ _PACKEDFAST\n   #pragma shader_feature_local _ _TRIPLANAR\n   #pragma shader_feature_local_fragment _ _NORMALMAP \n   #pragma shader_feature_local_fragment _ _MASKMAP\n   #pragma shader_feature_local_fragment _ _DETAIL\n   #pragma shader_feature_local_fragment _ _DETAILTRIPLANAR\n   #pragma shader_feature_local_fragment _ _DETAILSTOCHASTIC\n   #pragma shader_feature_local_fragment _ _EMISSION\n   #pragma shader_feature_local_fragment _ _FLATSHADE\n   #pragma shader_feature_local _ _STOCHASTIC\n   #pragma shader_feature_local_fragment _ _PARALLAX //_POM\n   #pragma shader_feature_local_fragment _ _SPECULAR\n   #pragma shader_feature_local _ _NOISEWORLD _NOISELOCAL\n   #pragma shader_feature_local _ _NOISEHQ _NOISETEXTURE _NOISEWORLEY\n   // only for URP/Standard Forward\n   #pragma shader_feature_local_fragment _ _SIMPLELIT\n\n\n   #pragma shader_feature_local_fragment _ _TINTMASK\n\n\n    #pragma shader_feature_local _ _LAYERVERTEXMASK _LAYERTEXTUREMASK\n\n    #define _HAS_WEIGHTTEXTURE_MASK 1\n\n\n   #pragma shader_feature_local _ _USELAYER\n   #pragma shader_feature_local _ _LAYERTRIPLANAR\n   #pragma shader_feature_local _ _LAYERALBEDO\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL\n   #pragma shader_feature_local _ _LAYERMASK\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION\n   #pragma shader_feature_local _ _LAYERNOISE\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC\n   #pragma shader_feature_local _ _LAYERANGLEFILTER\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_1\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_1\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_1\n   #pragma shader_feature_local _ _LAYERMASK_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_1\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_1\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_1\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_1\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_2\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_2\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_2\n   #pragma shader_feature_local _ _LAYERMASK_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_2\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_2\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_2\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_2\n\n\n   #pragma shader_feature_local _ _TRAX_ON\n\n\n   #pragma shader_feature_local_fragment _ _WETNESS\n   #pragma shader_feature_local_fragment _ _PUDDLES\n   #pragma shader_feature_local_fragment _ _PUDDLENOISE\n   #pragma shader_feature_local_fragment _ _RAINDROPS\n\n\n   #pragma shader_feature_local _ _SNOW\n   #pragma shader_feature_local _ _SNOWMASKMAP\n   #pragma shader_feature_local _ _SNOWNOISE\n   #pragma shader_feature_local_fragment _SNOWSTOCHASTIC\n\n\n   #pragma shader_feature_local_fragment _ _WIND_ON\n\n\n\n\n   #pragma shader_feature_local_fragment _ _SURFACEGRADIENT _AUTONORMAL\n   #define _WORLDSPACENORMAL 1\n\n\n   #pragma shader_feature_local _ _DEBUG_SAMPLECOUNT\n\n\n\t#pragma shader_feature_local_fragment _ _DISSOLVE\n\n\n   #pragma multi_compile_local  LOD_FADE_CROSSFADE\n\n\n\n#pragma instancing_options procedural:setupVSPro forwardadd\n\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\nstruct IndirectShaderData\n{\n\tfloat4x4 PositionMatrix;\n\tfloat4x4 InversePositionMatrix;\n\tfloat4 ControlData;\n};\n\n#if defined(SHADER_API_GLCORE) || defined(SHADER_API_D3D11) || defined(SHADER_API_GLES3) || defined(SHADER_API_METAL) || defined(SHADER_API_VULKAN) || defined(SHADER_API_PSSL) || defined(SHADER_API_XBOXONE)\n\tuniform StructuredBuffer<IndirectShaderData> VisibleShaderDataBuffer;\n#endif\n\n#endif\n\nfloat VSPRenderingLayerMask;\n\nvoid setupVSPro()\n{\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\n    #if _HDRP\n\t    unity_RenderingLayer.x = VSPRenderingLayerMask;\n    #endif\n\n\t#ifdef unity_ObjectToWorld\n\t#undef unity_ObjectToWorld\n\t#endif\n\n\t#ifdef unity_WorldToObject\n\t#undef unity_WorldToObject\n\t#endif\n\n\tunity_ObjectToWorld = VisibleShaderDataBuffer[unity_InstanceID].PositionMatrix;\n\tunity_WorldToObject = VisibleShaderDataBuffer[unity_InstanceID].InversePositionMatrix;\n#endif\n\n}\n\n\n\t#pragma multi_compile _LIGHTMAPMODE_STANDARD _LIGHTMAPMODE_RNM _LIGHTMAPMODE_SH _LIGHTMAPMODE_VERTEX _LIGHTMAPMODE_VERTEXDIRECTIONAL _LIGHTMAPMODE_VERTEXSH\n\n    #pragma shader_feature USEBAKERY\n    #pragma shader_feature BAKERY_VERTEXLMMASK\n    #pragma shader_feature BAKERY_SHNONLINEAR\n    #pragma shader_feature BAKERY_LMSPEC\n    #pragma shader_feature BAKERY_BICUBIC\n    #pragma shader_feature BAKERY_VOLUME\n    #pragma shader_feature BAKERY_VOLROTATION\n    #pragma shader_feature BAKERY_COMPRESSED_VOLUME\n\n    #if _USEBAKERY\n\t    #define _OVERRIDE_BAKEDGI\n        #if BAKERY_VOLUME || (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)) && defined(BAKERY_VERTEXLMMASK)\n            #define _OVERRIDE_SHADOWMASK\n        #endif\n    #endif\n\n\n\n\n\n\n\n\n   #define _HDRP 1\n#define _BLENDMODE_ALPHA 1\n#define _SURFACE_TYPE_TRANSPARENT 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n        \n            \n        \n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n            #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n        \n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n        \n            // define FragInputs structure\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n               #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\"\n            #endif\n\n\n        \n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n        #ifdef DEBUG_DISPLAY\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n        #endif\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n        \n        #if (SHADERPASS == SHADERPASS_FORWARD)\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n        \n            #define HAS_LIGHTLOOP\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n        #else\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n        #endif\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n        \n            // Used by SceneSelectionPass\n            int _ObjectId;\n            int _PassValue;\n        \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCCOORD3;\n               float4 texcoord1 : TEXCCOORD4;\n               float4 texcoord2 : TEXCCOORD5;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n               // float4 texcoord3 : TEXCCOORD6;\n                #endif\n\n                #if LOD_FADE_CROSSFADE\n                float4 screenPos : TEXCOORD7;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR_centroid;\n                #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                float4 extraV2F4 : TEXCOORD12_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                float4 extraV2F5 : TEXCOORD13_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F6 : TEXCOORD14_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F7 : TEXCOORD15_centroid;\n                #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n      \n  \n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n   half4 weightTextureMask;\n   \n\n\n   float traxBuffer;\n\n\n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // would love to strip these, but they are used in certain\n               // combinations of the lighting system, and may be used\n               // by the user as well, so no easy way to strip them.\n\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR_centroid;\n                #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                float4 extraV2F4 : TEXCOORD9_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                float4 extraV2F5 : TEXCOORD10_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F6 : TEXCOORD11_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F7 : TEXCOORD12_centroid;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n               #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n               #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n               #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n               #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()     unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n               #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V   unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n               #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V    mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n               #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n               #endif\n               #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n\n               float _StencilRef;\n               float _StencilWriteMask;\n               float _StencilRefDepth;\n               float _StencilWriteMaskDepth;\n               float _StencilRefMV;\n               float _StencilWriteMaskMV;\n               float _StencilRefDistortionVec;\n               float _StencilWriteMaskDistortionVec;\n               float _StencilWriteMaskGBuffer;\n               float _StencilRefGBuffer;\n               float _ZTestGBuffer;\n               float _RequireSplitLighting;\n               float _ReceivesSSR;\n               float _ZWrite;\n               float _TransparentSortPriority;\n               float _ZTestDepthEqualForOpaque;\n               float _ZTestTransparent;\n               float _TransparentBackfaceEnable;\n               float _AlphaCutoffEnable;\n               float _UseShadowThreshold;\n\n               \n\n\n   half4 _Tint;\n   half _UVSource;\n   half _TriplanarContrast;\n   half _AlbedoContrast;\n   half _AlbedoBrightness;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half3 _EmissionColor;\n   float _DetailUVSource;\n   half _StochasticScale;\n   half _DetailStochasticScale;\n   half _Smoothness;\n   half _Metallic;\n   half2 _SmoothnessRemap;\n   half2 _AORemap;\n   half2 _MetallicRemap;\n   half2 _HeightRemap;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n   half _AlphaThreshold;\n   half _Cutoff; // for Unity's light mapper\n   half _TriplanarSpace;\n   half _DetailTriplanarSpace;\n   half _DetailTriplanarContrast;\n   half _MicroShadowStrength;\n   half3 _FuzzyShadingColor;\n   half _FuzzyShadingOn;\n   half3 _FuzzyShadingParams;\n\n   //int _POMMaxSamples;\n   //float _POMMin;\n   //float _POMFade;\n#if _FLATSHADE\n   half _FlatShadingBlend;\n#endif\n\n   half _StochasticContrast;\n   half _DetailStochasticContrast;\n\n#if _PARALLAX || _POM\n   half _ParallaxHeight;\n#endif\n\n\n\n\tfloat4 _TintMask_ST;\n\thalf3 _RColor;\n\thalf3 _GColor;\n\thalf3 _BColor;\n\thalf3 _AColor;\n\n\n\thalf _LayerTextureMaskUVMode;\n    float4 _LayerTextureMask_ST;\n\n\n   //#if _USELAYER\n       float4 _LayerAlbedoMap_ST;\n       half3 _LayerTint;\n       half _LayerBlendMode;\n       float _LayerUVSource;\n       half _LayerAlbedoBrightness;\n       half _LayerAlbedoContrast;\n       half _LayerHeightContrast;\n       half _LayerStrength;\n       half _LayerAlbedoStrength;\n       half _LayerNormalStrength;\n       half _LayerSmoothnessStrength;\n       half _LayerSmoothness;\n       half _LayerMetallic;\n       half _LayerStochasticScale;\n       half2 _LayerSmoothnessRemap;\n       half2 _LayerAORemap;\n       half2 _LayerMetallicRemap;\n       half2 _LayerHeightRemap;\n       float4 _LayerWeightOverDistance;\n       half _LayerMicroShadowStrength;\n       //#if _LAYERNOISE\n           float _LayerNoiseFrequency;\n           float _LayerNoiseAmplitude;\n           float _LayerNoiseOffset;\n           float _LayerNoiseCenter;\n           half3 _LayerBlendTint;\n       //#endif\n       //#if _LAYERANGLEFILTER\n           half _LayerFalloff;\n           half _LayerAngleMin;\n           half _LayerHeight;\n           half _LayerInvertHeight;\n           half _LayerVertexNormalBlend;\n       //#endif\n       half _LayerTriplanarSpace;\n       half _LayerTriplanarContrast;\n       half _LayerBlendContrast;\n       half3 _LayerEmissionColor;\n       half _LayerStochasticContrast;\n       half _LayerTessStrength;\n       half3 _LayerFuzzyShadingColor;\n       half _LayerFuzzyShadingOn;\n       half3 _LayerFuzzyShadingParams;\n   //#endif\n\n\n   //#if _USELAYER_DEF_1\n       float4 _LayerAlbedoMap_Ext_1_ST;\n       half3 _LayerTint_Ext_1;\n       half _LayerBlendMode_Ext_1;\n       float _LayerUVSource_Ext_1;\n       half _LayerAlbedoBrightness_Ext_1;\n       half _LayerAlbedoContrast_Ext_1;\n       half _LayerHeightContrast_Ext_1;\n       half _LayerStrength_Ext_1;\n       half _LayerAlbedoStrength_Ext_1;\n       half _LayerNormalStrength_Ext_1;\n       half _LayerSmoothnessStrength_Ext_1;\n       half _LayerSmoothness_Ext_1;\n       half _LayerMetallic_Ext_1;\n       half _LayerStochasticScale_Ext_1;\n       half2 _LayerSmoothnessRemap_Ext_1;\n       half2 _LayerAORemap_Ext_1;\n       half2 _LayerMetallicRemap_Ext_1;\n       half2 _LayerHeightRemap_Ext_1;\n       float4 _LayerWeightOverDistance_Ext_1;\n       half _LayerMicroShadowStrength_Ext_1;\n       //#if _LAYERNOISE_DEF_1\n           float _LayerNoiseFrequency_Ext_1;\n           float _LayerNoiseAmplitude_Ext_1;\n           float _LayerNoiseOffset_Ext_1;\n           float _LayerNoiseCenter_Ext_1;\n           half3 _LayerBlendTint_Ext_1;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_1\n           half _LayerFalloff_Ext_1;\n           half _LayerAngleMin_Ext_1;\n           half _LayerHeight_Ext_1;\n           half _LayerInvertHeight_Ext_1;\n           half _LayerVertexNormalBlend_Ext_1;\n       //#endif\n       half _LayerTriplanarSpace_Ext_1;\n       half _LayerTriplanarContrast_Ext_1;\n       half _LayerBlendContrast_Ext_1;\n       half3 _LayerEmissionColor_Ext_1;\n       half _LayerStochasticContrast_Ext_1;\n       half _LayerTessStrength_Ext_1;\n       half3 _LayerFuzzyShadingColor_Ext_1;\n       half _LayerFuzzyShadingOn_Ext_1;\n       half3 _LayerFuzzyShadingParams_Ext_1;\n   //#endif\n\n\n   //#if _USELAYER_DEF_2\n       float4 _LayerAlbedoMap_Ext_2_ST;\n       half3 _LayerTint_Ext_2;\n       half _LayerBlendMode_Ext_2;\n       float _LayerUVSource_Ext_2;\n       half _LayerAlbedoBrightness_Ext_2;\n       half _LayerAlbedoContrast_Ext_2;\n       half _LayerHeightContrast_Ext_2;\n       half _LayerStrength_Ext_2;\n       half _LayerAlbedoStrength_Ext_2;\n       half _LayerNormalStrength_Ext_2;\n       half _LayerSmoothnessStrength_Ext_2;\n       half _LayerSmoothness_Ext_2;\n       half _LayerMetallic_Ext_2;\n       half _LayerStochasticScale_Ext_2;\n       half2 _LayerSmoothnessRemap_Ext_2;\n       half2 _LayerAORemap_Ext_2;\n       half2 _LayerMetallicRemap_Ext_2;\n       half2 _LayerHeightRemap_Ext_2;\n       float4 _LayerWeightOverDistance_Ext_2;\n       half _LayerMicroShadowStrength_Ext_2;\n       //#if _LAYERNOISE_DEF_2\n           float _LayerNoiseFrequency_Ext_2;\n           float _LayerNoiseAmplitude_Ext_2;\n           float _LayerNoiseOffset_Ext_2;\n           float _LayerNoiseCenter_Ext_2;\n           half3 _LayerBlendTint_Ext_2;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_2\n           half _LayerFalloff_Ext_2;\n           half _LayerAngleMin_Ext_2;\n           half _LayerHeight_Ext_2;\n           half _LayerInvertHeight_Ext_2;\n           half _LayerVertexNormalBlend_Ext_2;\n       //#endif\n       half _LayerTriplanarSpace_Ext_2;\n       half _LayerTriplanarContrast_Ext_2;\n       half _LayerBlendContrast_Ext_2;\n       half3 _LayerEmissionColor_Ext_2;\n       half _LayerStochasticContrast_Ext_2;\n       half _LayerTessStrength_Ext_2;\n       half3 _LayerFuzzyShadingColor_Ext_2;\n       half _LayerFuzzyShadingOn_Ext_2;\n       half3 _LayerFuzzyShadingParams_Ext_2;\n   //#endif\n\n\n    half _TraxDisplacementDepth;\n    half _TraxDisplacementStrength;\n    half _TraxMipBias;\n    half _TraxNormalStrength;\n    float4 _TraxAlbedo_ST;\n    half _TraxInterpContrast;\n    half _TraxHeightContrast;\n    half3 _TraxTint;\n\n\n\n    half _Porosity;\n    int _WetnessMode;\n    int _PuddleMode;\n\n    half  _PuddleAmount;\n    half  _PuddleFalloff;\n    half4 _PuddleColor;\n    half _PuddleNoiseFrequency;\n    half _PuddleNoiseAmplitude;\n    half _PuddleNoiseOffset;\n    half _PuddleNoiseCenter;\n    half _PuddleAngleMin;\n\n    half _WetnessAmount;\n\thalf _WetnessMin;\n    half _WetnessMax;\n    half _WetnessFalloff;\n\thalf _WetnessAngleMin;\n    float _WetnessShoreline;\n\n    int _RainMode;\n    half3 _RainIntensityScale;\n\n\n\n\n    float4 _SnowAlbedo_ST;\n    half3 _SnowTint;\n    half _SnowAmount;\n    half _SnowAngle;\n    half _SnowContrast;\n    half _SnowVertexHeight;\n    half _SnowMode;\n    half3 _SnowWorldFade; // z is on/off\n    float4 _SnowTraxAlbedo_ST;\n    half3 _SnowTraxTint;\n\n    half _SnowNoiseFreq; \n    half _SnowNoiseAmp;\n    half _SnowNoiseOffset;\n    half _SnowStochasticContrast;\n    half _SnowStochasticScale;\n\n\n    half     _WindParticulateSpace;\n    half     _WindParticulateRotation;\n    half      _WindParticulateSpeed;\n    float4     _WindParticulate_ST;\n    half      _WindParticulatePower;\n    half4    _WindParticulateColor;\n    half4    _WindParticulateWorldHeightMask;\n    half4    _WindParticulateAngleMask;\n    half      _WindParticulateOcclusionStrength;\n    half      _WindParticulateStrength;\n    half4    _WindParticulateEmissive;\n    half     _WindParticulateTextureHeight;\n\n\n   float _DoubleSidedNormalMode;\n\n\n\thalf _AutoNormalStrength;\n\n\n\tint _DebugSampleCountThreshold;\n\n\n\thalf _DissolveAmount;\n\thalf _DissolveEmissiveStr;\n\thalf _DissolveEdgeContrast;\n\thalf _DissolveColoration;\n\tfloat4 _DissolveTexture_ST;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n\n            \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\n#ifndef __STACKABLEFUNCLIBRARY_INCLUDES__\n#define __STACKABLEFUNCLIBRARY_INCLUDES__\n\n   #if _DEBUG_SAMPLECOUNT\n      int _sampleCount;\n      #define COUNTSAMPLE { _sampleCount++; }\n   #else\n      #define COUNTSAMPLE\n   #endif\n\n   TEXTURE2D(_NoiseTex);\n   SAMPLER(sampler_NoiseTex);\n\n\n\n   half3 AdjustContrast(half3 color, half contrast)\n   {\n       half3 comp = 0.5;\n   #if !UNITY_COLORSPACE_GAMMA\n       comp = 0.22;\n   #endif\n       color = saturate(lerp(comp, color, contrast));\n       return color;\n   }\n\n   float2 DoParallaxOffset( half h, half height, half3 viewDir)\n   {\n      h = h * height - height/2.0;\n      float3 v = normalize(viewDir);\n      v.z += 0.42;\n      return h * (v.xy / v.z);\n   }\n\n\n\n   #define SAMPLEBARY SampleTexBary\n\n   struct SampleConfig\n   {\n      float2 uv0;\n      float2 uv1;\n      float2 uv2;\n      float2 dx0;\n      float2 dy0;\n      float2 dx1;\n      float2 dy1;\n      float2 dx2;\n      float2 dy2;\n      float3 weights;\n      float3 origWeights;\n   };\n\n   struct Config\n   {\n      float2 origUV; // unscaled uv\n      float2 origScale;\n      float2 uv;        // no stocastic or triplanar\n      float2 dx;\n      float2 dy;\n      SampleConfig uvT; // just stochastic, or just triplanar\n      SampleConfig uvX; // stochastic and triplanar\n      SampleConfig uvY;\n      SampleConfig uvZ;\n\n      \n      float3 absVertNormal;\n      half3 axisSign;\n      float3 normal;\n   };\n\n\n    float2 Hash2D( float2 x )\n    {\n        float2 k = float2( 0.3183099, 0.3678794 );\n        x = x*k + k.yx;\n        return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );\n    }\n\n    float Noise2D(float2 p )\n    {\n        float2 i = floor( p );\n        float2 f = frac( p );\n         \n        float2 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), \n                        dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),\n                    lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), \n                        dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);\n    }\n      \n\n    float2 WorleyHash2D(float2 p)\n    {\n \t    return frac(cos(mul(p, float2x2(-64.2,71.3,81.4,-29.8)))*8321.3); \n    }\n    float WorleyNoise2D(float2 p)\n    {\n        float dist = 1;\n        float2 i = floor(p);\n        float2 f = frac(p);\n    \n        for(int x = -1;x<=1;x++)\n        {\n            for(int y = -1;y<=1;y++)\n            {\n                float d = distance(WorleyHash2D(i+float2(x,y))+float2(x,y),f);\n                dist = min(dist,d);\n            }\n        }\n        return dist;\n\t\n    }\n\n#ifndef PI\n    #define PI 3.14159265359\n#endif\n\n    float GetIntegerNoise(float2 p)\n    {\n        p  = 53.7 * frac( (p*0.3183099) + float2(0.71,0.113));\n        return frac( p.x*p.y*(p.x+p.y) );\n    }\n\n    float WorleyHash3D(float f)\n    {\n        return frac(sin(f)*43758.5453);\n    }\n\n    float WorleyHash31(float3 v)\n    {\n        return WorleyHash3D(dot(v, float3(253.14, 453.74, 183.3)));\n    }\n\n    float3 WorleyRandom3D( float3 p )\n    {\n        return frac(sin(float3(dot(p,float3(127.1,311.7,217.3)),dot(p,float3(269.5,183.3,431.1)), dot(p,float3(365.6,749.9,323.7))))*437158.5453);\n    }\n\n    float WorleyNoise3D(float3 uvw)\n    {\n        float noise = 0.0;\n    \n        float3 p = floor(uvw);\n        float3 f = frac(uvw);\n    \n        float4 res = 1;\n        for(int x = -1; x <=1; ++x)\n        {\n            for(int y = -1; y <=1; ++y)\n            {\n                for(int z = -1; z <=1; ++z)\n                {\n                    float3 gp = p + float3(x, y, z);\n\n                    float3 v = WorleyRandom3D(gp);\n\n\t\t\t\t    float3 diff = gp + v - uvw;\n                \n                    float d = length(diff);\n                \n                    if(d < res.x)\n                    {\n                        res.xyz = float3(d, res.x, res.y);\n                    }\n                    else if(d < res.y)\n                    {\n                        res.xyz = float3(res.x, d, res.y);\n                    }\n                    else if(d < res.z)\n                    {\n                        res.z = d;\n                    }\n                \n                    res.w = WorleyHash31(gp);\n                }\n            }\n        }\n\n        return res.x;\n    }\n    \n      \n    float3 Hash3D( float3 p )\n    {\n        p = float3( dot(p,float3(127.1,311.7, 74.7)),\n                dot(p,float3(269.5,183.3,246.1)),\n                dot(p,float3(113.5,271.9,124.6)));\n\n        return -1.0 + 2.0*frac(sin(p)*437.5453123);\n    }\n\n    float Noise3D( float3 p )\n    {\n        float3 i = floor( p );\n        float3 f = frac( p );\n         \n        float3 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),\n                    lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n    }\n\n    \n    float FBM2D(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           return SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n\n    }\n      \n    float FBM3D(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           half A = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.zy).g;\n           half B = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33).g;\n           half C = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoise(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3D(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3D(d.localSpacePosition * frequency+ offset, d.localSpaceNormal);\n        #else\n           return FBM2D(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n    \n    #if _SURFACEGRADIENT  \n\n    #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)\n\n      \n      \n    half3 SurfaceGradientFromTBN(ShaderData d, half2 deriv)\n    {\n        return deriv.x * d.TBNMatrix[0] + deriv.y * d.TBNMatrix[1];\n    }\n\n    half2 TspaceNormalToDerivative(half3 vM)\n    {\n        const half scale = 1.0/128.0;\n        const half3 vMa = abs(vM);\n        const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));\n\n        return -half2(vM.x, vM.y)/z_ma;\n    }\n\n    half3 SurfgradFromVolumeGradient(ShaderData d, half3 grad)\n    {\n        return grad - dot(d.worldSpaceNormal, grad) * d.worldSpaceNormal;\n    }\n\n    half3 SurfgradFromTriplanarProjection(ShaderData d, half3 pN, half3 xN, half3 yN, half3 zN)\n    {\n        const half w0 = pN.x;\n        const half w1 = pN.y;\n        const half w2 = pN.z;\n\n        half2 xD = TspaceNormalToDerivative(xN);\n        half2 yD = TspaceNormalToDerivative(yN);\n        half2 zD = TspaceNormalToDerivative(zN);\n\n        half3 volumeGrad = half3(w2 * zD.x + w1 * yD.y, w2 * zD.y + w0 * xD.y, w0 * xD.x + w1 * yD.x);\n\n        return SurfgradFromVolumeGradient(d, volumeGrad);\n    }\n\n    half3 ConvertNormalToGradient(ShaderData d, half3 normal)\n    {\n        half2 deriv = TspaceNormalToDerivative(normal);\n\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n    half3 ConvertNormal2ToGradient(ShaderData d, half2 packedNormal)\n    {\n        half2 tNormal = packedNormal;\n        half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF\n        half2 deriv = tNormal * -rcpZ;\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n\n    half3 ResolveNormalFromSurfaceGradient(ShaderData d, half3 gradient)\n    {\n        return normalize(d.worldSpaceNormal - gradient);\n    }\n\n    #endif // _SURFACEGRADIENT\n\n\n    // normals are in surface gradient or world space depending on settings, and can also be generated by height\n    half3 GetWorldSpaceNormal(ShaderData d, half3 normal, half pheight)\n    {\n       #if _SURFACEGRADIENT\n          return ResolveNormalFromSurfaceGradient(d, normal);\n       #elif _AUTONORMAL\n          float3 dx = ddx(d.worldSpacePosition);\n          float3 dy = ddy(d.worldSpacePosition);\n          float3 crossX = cross(float3(0,1,0), dx);\n          float3 crossY = cross(float3(0,1,0), dy);\n          float3 dt = abs(dot(crossY, dx));\n          float height = _AutoNormalStrength * 0.5 * pheight;\n          float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n          n.y *= -1.0;\n          return TangentToWorldSpace(d, normalize((dt * float3(0,1,0)) - n).xzy);\n       #else\n          return TangentToWorldSpace(d, normal);\n          \n       #endif\n       \n    }\n\n   void WaterBRDF (inout half3 albedo, inout half smoothness, half metallic, half wetFactor, half surfPorosity) \n   {\n      half porosity = saturate((( (1 - smoothness) - 0.5)) / max(surfPorosity, 0.001));\n      half factor = lerp(1, 0.2, (1 - metallic) * porosity);\n      albedo *= lerp(1.0, factor, wetFactor);\n      smoothness = lerp(smoothness, 0.92f, wetFactor);\n   }\n\n   void OffsetUV(inout Config c, float2 offset)\n   {\n       c.uv += offset;\n       c.uvT.uv0 += offset;\n       c.uvT.uv1 += offset;\n       c.uvT.uv2 += offset;\n       c.uvX.uv0 += offset;\n       c.uvX.uv1 += offset;\n       c.uvX.uv2 += offset;\n       c.uvY.uv0 += offset;\n       c.uvY.uv1 += offset;\n       c.uvY.uv2 += offset;\n       c.uvZ.uv0 += offset;\n       c.uvZ.uv1 += offset;\n       c.uvZ.uv2 += offset;\n   }\n\n\n    void TriangleGrid(float2 uv, float scale,\n       out float w1, out float w2, out float w3,\n       out int2 vertex1, out int2 vertex2, out int2 vertex3)\n    {\n       // Scaling of the input\n       uv *= 3.464 * scale; // 2 * sqrt(3)\n\n       // Skew input space into simplex triangle grid\n       const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);\n       float2 skewedCoord = mul(gridToSkewedGrid, uv);\n\n       // Compute local triangle vertex IDs and local barycentric coordinates\n       int2 baseId = int2(floor(skewedCoord));\n       float3 temp = float3(frac(skewedCoord), 0);\n       temp.z = 1.0 - temp.x - temp.y;\n       if (temp.z > 0.0)\n       {\n          w1 = temp.z;\n          w2 = temp.y;\n          w3 = temp.x;\n          vertex1 = baseId;\n          vertex2 = baseId + int2(0, 1);\n          vertex3 = baseId + int2(1, 0);\n       }\n       else\n       {\n          w1 = -temp.z;\n          w2 = 1.0 - temp.y;\n          w3 = 1.0 - temp.x;\n          vertex1 = baseId + int2(1, 1);\n          vertex2 = baseId + int2(1, 0);\n          vertex3 = baseId + int2(0, 1);\n       }\n    }\n\n    // Fast random hash function\n    float2 SimpleHash2(float2 p)\n    {\n       return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 43758.5453);\n    }\n\n\n    half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)\n    {\n        // compute weight with height map\n        const half epsilon = 1.0f / 1024.0f;\n        half3 weights = half3(iWeights.x * (tex0 + epsilon), \n                                 iWeights.y * (tex1 + epsilon),\n                                 iWeights.z * (tex2 + epsilon));\n\n        // Contrast weights\n        half maxWeight = max(weights.x, max(weights.y, weights.z));\n        half transition = contrast * maxWeight;\n        half threshold = maxWeight - transition;\n        half scale = 1.0f / transition;\n        weights = saturate((weights - threshold) * scale);\n        // Normalize weights.\n        half weightScale = 1.0f / (weights.x + weights.y + weights.z);\n        weights *= weightScale;\n        return weights;\n    }\n\n\n    half3 PackedUnpackScaleNormal(half4 packedNormal, float scale)\n   {\n       #if _PACKEDFAST\n          half3 normal;\n          normal.xy = (packedNormal.ag * 2 - 1) * scale;\n          normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n          return normal;  \n       #endif\n       return UnpackScaleNormal(packedNormal, scale);\n   }\n\n    void InitStochasticDxDy(inout SampleConfig c, Config cfg)\n    {\n      c.dx0 = ddx(cfg.origUV) * cfg.origScale;\n      c.dy0 = ddy(cfg.origUV) * cfg.origScale;\n      c.dx1 = c.dx0; c.dx1 = c.dx0;\n      c.dx2 = c.dy0; c.dy2 = c.dy0;\n    }\n\n    void PrepareStochasticUVs(float scale, float2 uv, out SampleConfig c)\n    {\n       // Get triangle info\n       ZERO_INITIALIZE(SampleConfig, c);\n       float w1, w2, w3;\n       int2 vertex1, vertex2, vertex3;\n       TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n       // Assign random offset to each triangle vertex\n       c.uv0 = uv;\n       c.uv1 = uv;\n       c.uv2 = uv;\n   \n       c.uv0.xy += SimpleHash2(vertex1);\n       c.uv1.xy += SimpleHash2(vertex2);\n       c.uv2.xy += SimpleHash2(vertex3);\n       c.weights = half3(w1, w2, w3);\n       c.origWeights = half3(w1, w2, w3);\n    }\n\n\n   half3 LitBlendDetailNormal(half3 n1, half3 n2)\n   {\n      #if _SURFACEGRADIENT\n         return n1 + n2;\n      #else\n         return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n      #endif\n   }\n\n   float3 TriplanarBlendUnpackedRNM(float3 n1, float3 n2)\n   {\n       n1.z += 1;\n       n2.xy = -n2.xy;\n       return n1 * dot(n1, n2) / n1.z - n2;\n   }\n\n   void InitConfigDxDy(inout Config c)\n   {\n      c.uvT.dx0 = ddx(c.uvT.uv0);\n      c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1);\n      c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2);\n      c.uvT.dy2 = ddy(c.uvT.uv2);\n   }\n\n   Config CreateConfig(ShaderData d, float4 scale, float space, int uvsource, half triplanarContrast)\n   {\n      Config c;\n      ZERO_INITIALIZE(Config, c);\n\n      float3 pos = d.worldSpacePosition;\n      float3 normal = d.worldSpaceNormal;\n      if (space > 0)\n      {\n         pos = d.localSpacePosition;\n         normal = d.localSpaceNormal;\n      }\n\n      c.uv = d.texcoord0.xy;\n      \n      if (uvsource == 1)\n        c.uv = d.texcoord1.xy;\n      else if (uvsource == 2)\n        c.uv = pos.yz * float2(1, -1);\n      else if (uvsource == 3)\n        c.uv = pos.xz * float2(1, -1);\n      else if (uvsource == 4)\n        c.uv = pos.xy * float2(1, -1);\n\n      c.origUV = c.uv;\n      c.origScale = scale.xy;\n\n      c.uv = c.uv * scale.xy + scale.zw;\n      c.dx = ddx(c.uv);\n      c.dy = ddy(c.uv);\n\n      c.normal = normal;\n      c.uvT.uv0 = pos.zy * scale.xy + scale.zw;\n      c.uvT.uv1 = pos.xz * scale.xy + scale.zw;\n      c.uvT.uv2 = pos.xy * scale.xy + scale.zw;\n        \n      c.uvT.uv1 += 0.33;\n      c.uvT.uv2 += 0.67;\n\n      c.uvT.dx0 = ddx(c.uvT.uv0); c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1); c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2); c.uvT.dy2 = ddy(c.uvT.uv2);\n\n      half3 triblend = saturate(pow(abs(c.normal), triplanarContrast));\n      triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n      c.uvT.weights = triblend;\n      c.uvT.origWeights = triblend;\n      c.axisSign = d.worldSpaceNormal < 0 ? -1 : 1;\n      c.absVertNormal = abs(d.worldSpaceNormal);\n     \n\n      return c;\n   }\n\n\n   half4 TriSample(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0) * c.weights.x;\n      }\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1) * c.weights.y;\n      }  \n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2) * c.weights.z;\n      }\n\n      return res;\n   }\n\n   half4 TriSampleBary(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      c.weights = BaryWeightBlend(c.origWeights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   half4 TriSampleGrad(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvX, contrast, d) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvY, contrast, d) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n           res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvZ, contrast, d) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   \n   half4 SampleTexBaryStochastic(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   half4 SampleTexBaryTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleGrad(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   \n   half4 SampleTexBary(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        COUNTSAMPLE\n        return SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv, c.dx, c.dy);\n   }\n\n   half4 SampleTexStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ) * c.uvT.weights.z;\n\n        return res;     \n   }\n\n   \n   half4 SampleTexStochastic(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n\n   half4 SampleTexTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n   \n   half4 SampleTex(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       COUNTSAMPLE\n       return SAMPLE_TEXTURE2D(tex, ss, c.uv);\n   }\n   \n\n \n   half3 SampleNormalStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n         dataX = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n         dataY = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n         dataZ = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ));\n\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n\n          return WorldToTangentSpace(d, worldNormal);\n       #endif\n   }\n\n\n   half3 SampleNormalTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n      {\n          COUNTSAMPLE\n          dataX = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv0, c.uvT.dx0, c.uvT.dy0));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n      {\n          COUNTSAMPLE\n          dataY = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv1, c.uvT.dx1, c.uvT.dy1));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n      {\n         COUNTSAMPLE\n         dataZ = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv2, c.uvT.dx2, c.uvT.dy2));\n      }\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n          return WorldToTangentSpace(d, worldNormal);\n      #endif\n   }\n\n   half3 SampleNormalStochastic(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n     half4 normal = TriSample(tex, ss, c.uvT);\n     #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half3 SampleNormal(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 normal = SAMPLE_TEXTURE2D(tex, ss, c.uv);\n      #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half HeightBlend(half h1, half h2, half slope, half contrast)\n   {\n      h2 = 1 - h2;\n      half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); \n      half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));\n      return blend;\n   }\n\n\n    #if _POM\n    float2 POM(TEXTURE2D_PARAM(tex, ss), Config c, float contrast, ShaderData d)\n    {\n       float2 curv = float2(0, 0);\n       float refPlane = 0;\n\n       float result = 0;\n       int stepIndex = 0;\n       int maxSamples = _POMMaxSamples;\n       int minSamples = 4;\n       float camDist = distance(_WorldSpaceCameraPos, d.worldSpacePosition);\n       float distanceFade = 1 - saturate((camDist - _POMMin) / max(1, _POMFade));\n       int numSteps = ( int )lerp( maxSamples, minSamples, dot( d.worldSpaceNormal, d.worldSpaceViewDir )) * distanceFade;\n       if (numSteps < 1)\n           numSteps = 1;\n       float layerHeight = 1.0 / numSteps;\n       float2 plane = _ParallaxHeight * ( d.tangentSpaceViewDir.xy / d.tangentSpaceViewDir.z ) * distanceFade;\n       OffsetUV(c, refPlane * plane);\n       float2 deltaTex = -plane * layerHeight;\n       float2 prevTexOffset = 0;\n       float prevRayZ = 1.0f;\n       float prevHeight = 0.0f;\n       float2 currTexOffset = deltaTex;\n       float currRayZ = 1.0f - layerHeight;\n       float currHeight = 0.0f;\n       float intersection = 0;\n       float2 finalTexOffset = 0;\n\n       while ( stepIndex < numSteps + 1 )\n       {\n          result = dot( curv, currTexOffset * currTexOffset );\n          Config cfg = c;\n          OffsetUV(cfg, currTexOffset);\n          currHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( currHeight > currRayZ )\n          {\n             stepIndex = numSteps + 1;\n          }\n          else\n          {\n             stepIndex++;\n             prevTexOffset = currTexOffset;\n             prevRayZ = currRayZ;\n             prevHeight = currHeight;\n             currTexOffset += deltaTex;\n             currRayZ -= layerHeight * ( 1 - result );\n          }\n       }\n       int sectionSteps = 10;\n       int sectionIndex = 0;\n       float newZ = 0;\n       float newHeight = 0;\n       while ( sectionIndex < sectionSteps )\n       {\n          intersection = ( prevHeight - prevRayZ ) / ( prevHeight - currHeight + currRayZ - prevRayZ );\n          finalTexOffset = prevTexOffset + intersection * deltaTex;\n          newZ = prevRayZ - intersection * layerHeight;\n          Config cfg = c;\n          OffsetUV(cfg, finalTexOffset);\n          newHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( newHeight > newZ )\n          {\n             currTexOffset = finalTexOffset;\n             currHeight = newHeight;\n             currRayZ = newZ;\n             deltaTex = intersection * deltaTex;\n             layerHeight = intersection * layerHeight;\n          }\n          else\n          {\n             prevTexOffset = finalTexOffset;\n             prevHeight = newHeight;\n             prevRayZ = newZ;\n             deltaTex = ( 1 - intersection ) * deltaTex;\n             layerHeight = ( 1 - intersection ) * layerHeight;\n          }\n          sectionIndex++;\n       }\n       #if _PASSHADOWS\n       if ( unity_LightShadowBias.z == 0.0 )\n       {\n       #endif\n          if ( result > 1 )\n             clip( -1 );\n       #if _PASSHADOWS\n       }\n       #endif\n       return finalTexOffset;\n    }\n    #endif\n\n   \n\n   // tess versions\n   #if _TESSELLATION_ON\n   half4 TriSampleLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias) * c.weights.x;\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias) * c.weights.y;\n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias) * c.weights.z;\n\n      return res;\n   }\n\n   half4 TriSampleBaryLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias, float contrast)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias);\n      half4 r2 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias);\n      half4 r3 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias);\n      c.weights = BaryWeightBlend(c.weights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryLODStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvX, bias, contrast) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvY, bias, contrast) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvZ, bias, contrast) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   half4 SampleTexBaryLODStochastic(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n       return TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias, contrast);\n   }\n\n   half4 SampleTexBaryLODTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return TriSampleLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias);\n   }\n\n   half4 SampleTexBaryLOD(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv, bias);\n   }\n\n\n    float FBM2DLOD(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           return SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv, _TessellationMipBias).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n        \n        \n    }\n\n    float FBM3DLOD(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           half A = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.zy, _TessellationMipBias).g;\n           half B = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33, _TessellationMipBias).g;\n           half C = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67, _TessellationMipBias).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoiseLOD(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3DLOD(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3DLOD(d.localSpacePosition * frequency + offset, d.localSpaceNormal);\n        #else\n           return FBM2DLOD(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n   #endif //_TESSELLATION_ON\n\n\n    half3 FuzzyShade(ShaderData d, half height, half3 color, half3 normal, half coreMult, half edgeMult, half power)\n    {\n        float3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half dt = saturate(dot(d.worldSpaceViewDir, worldNormal));\n        half dark = 1.0 - (coreMult * dt);\n        half edge = pow(1-dt, abs(power)) * edgeMult;\n        return color * (dark + edge);\n    }\n\n\thalf MicroShadow(ShaderData d, half3 normal, half height, half ao, half strength)\n\t{\n        float3 sun;\n\t\tfloat3 sunColor;\n\t\tGetSun(sun, sunColor);\n\t\tfloat3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half shadow = saturate(abs(dot(worldNormal, sun)) + (ao * ao * 2.0) - 1.0);\n        return 1 - ((1-shadow) * strength);\n\t}\n\n\n#endif\n\n\n\n   #if defined(_SPECULAR)\n      #define _USESPECULAR 1\n      #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n   #endif\n\n   \n   TEXTURE2D(_AlbedoMap);\n   SAMPLER(sampler_AlbedoMap);\n   TEXTURE2D(_NormalMap);\n   SAMPLER(sampler_NormalMap);\n   TEXTURE2D(_MaskMap);\n   TEXTURE2D(_DetailMap);\n   TEXTURE2D(_EmissionMap);\n\n   #if _SPECULAR\n       TEXTURE2D(_SpecularMap);\n   #endif\n\n   \n   \n   void Ext_SurfaceFunction0 (inout Surface o, inout ShaderData d)\n   {\n      // define samplers based on settings\n      #undef SAMPLEBARY\n      #undef SAMPLE\n      #undef SAMPLENORMAL\n      #if _STOCHASTIC && _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n        #define SAMPLE     SampleTexStochasticTriplanar\n        #define SAMPLENORMAL SampleNormalStochasticTriplanar\n      #elif _STOCHASTIC\n        #define SAMPLEBARY SampleTexBaryStochastic\n        #define SAMPLE     SampleTexStochastic\n        #define SAMPLENORMAL SampleNormalStochastic\n      #elif _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryTriplanar\n        #define SAMPLE     SampleTexTriplanar\n        #define SAMPLENORMAL SampleNormalTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBary\n        #define SAMPLE     SampleTex\n        #define SAMPLENORMAL SampleNormal\n      #endif\n\n      Config c = CreateConfig(d, _AlbedoMap_ST, _TriplanarSpace, _UVSource, _TriplanarContrast);\n      InitConfigDxDy(c);\n      #if _STOCHASTIC && !_TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uv, c.uvT);\n         InitStochasticDxDy(c.uvT, c);\n      #elif _STOCHASTIC && _TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv0, c.uvX);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv1, c.uvY);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv2, c.uvZ);\n         InitStochasticDxDy(c.uvX, c);\n         InitStochasticDxDy(c.uvY, c);\n         InitStochasticDxDy(c.uvZ, c);\n      #endif\n\n      #if _POM\n          // would need to handle height remapping if we ever want to ship this\n          float2 pomOffset = POM(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n          OffsetUV(c, pomOffset);\n      #endif\n\n      half4 albedo = SAMPLEBARY(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n      \n      #if _PARALLAX\n         float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n         OffsetUV(c, offset);\n         albedo = SAMPLE(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c);\n         \n      #endif\n      albedo.a = lerp(_HeightRemap.x, _HeightRemap.y, albedo.a);\n      albedo.rgb *= _Tint.rgb;\n\n      albedo.rgb = AdjustContrast(albedo.rgb, _AlbedoContrast);\n      albedo.rgb += _AlbedoBrightness;\n\n\n      if (_AlphaThreshold > 0)\n      {\n         clip(albedo.a - _AlphaThreshold);\n      }\n\n      #if defined(_FLATSHADE)\n\t\t     float3 dx = ddx(d.worldSpacePosition);\n\t\t     float3 dy = ddy(d.worldSpacePosition);\n\t\t     float3 worldNormal = normalize(cross(dy, dx));\n\t\t     worldNormal = lerp(d.worldSpaceNormal, worldNormal, _FlatShadingBlend);\n\t\t     d.worldSpaceNormal = worldNormal;\n\t\t     d.TBNMatrix[2] = worldNormal;\n      #endif\n\n\n\n      o.Albedo = albedo.rgb;\n      o.Alpha = albedo.a;\n\n      float smoothness = _Smoothness;\n      float ao = 1;\n\n      #if defined(_NORMALMAP) && !defined(_AUTONORMAL)\n         o.Normal = SAMPLENORMAL(TEXTURE2D_ARGS(_NormalMap, sampler_NormalMap), c, d, _NormalStrength, smoothness, ao);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, ao);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n      #endif\n\n      half detailMask = 1;\n      o.Smoothness = smoothness;\n      o.Occlusion = ao;\n      o.Metallic = _Metallic;\n      #if defined(_MASKMAP) && !_PACKEDFAST\n         // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = SampleTex(TEXTURE2D_ARGS(_MaskMap, sampler_AlbedoMap), c);\n         o.Metallic = lerp(_MetallicRemap.x, _MetallicRemap.y, mask.r);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, mask.g);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, mask.a);\n         detailMask = mask.b;\n      #endif // separate maps\n\n      #if _SPECULAR\n         o.Specular = SAMPLE(TEXTURE2D_ARGS(_SpecularMap, sampler_AlbedoMap), c).rgb;\n      #endif\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = SAMPLE(TEXTURE2D_ARGS(_EmissionMap, sampler_AlbedoMap), c).rgb * _EmissionColor;\n      #endif\n\n      if (_FuzzyShadingOn > 0)\n      {\n        o.Albedo *= FuzzyShade(d, albedo.a, _FuzzyShadingColor, o.Normal, _FuzzyShadingParams.x, _FuzzyShadingParams.y, _FuzzyShadingParams.z);\n      }\n\n\n      // HDRP style detail texturing\n\n      #if defined(_DETAIL)\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _DETAILSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n         Config dc = CreateConfig(d, _DetailMap_ST, _DetailTriplanarSpace, _DetailUVSource, _DetailTriplanarContrast);\n         InitConfigDxDy(dc);\n         #if _DETAILSTOCHASTIC && !_DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uv, dc.uvT);\n             InitStochasticDxDy(dc.uvT, dc);\n         #elif _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv0, dc.uvX);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv1, dc.uvY);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv2, dc.uvZ);\n             InitStochasticDxDy(dc.uvX, dc);\n             InitStochasticDxDy(dc.uvY, dc);\n             InitStochasticDxDy(dc.uvZ, dc);\n         #endif\n\n         half4 detailSample = SAMPLEBARY(TEXTURE2D_ARGS(_DetailMap, sampler_AlbedoMap), dc, _DetailStochasticContrast, d);\n         smoothness = detailSample.z;\n         #if !_AUTONORMAL\n            half3 dnormal = float3(detailSample.ag * 2 - 1, 1) * detailMask * _DetailNormalStrength;\n            dnormal.z = sqrt(1 - dnormal.x * dnormal.x - dnormal.y * dnormal.y);\n            #if _SURFACEGRADIENT\n               dnormal = ConvertNormalToGradient(d, dnormal);\n            #endif\n            o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n         #endif\n     \n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * smoothness, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n      if (_MicroShadowStrength > 0)\n      {\n        o.Occlusion *= MicroShadow(d, o.Normal, o.Alpha, o.Occlusion, _MicroShadowStrength);\n      }\n  \n      // in case something needs height in the stack..\n      o.Height = o.Alpha;\n\n\n      \n   }\n\n\n\n\t#if _TINTMASK\n\t\tTEXTURE2D(_TintMask);\n\t\tSAMPLER(sampler_TintMask);\n\t#endif\n\n\tvoid Ext_SurfaceFunction1 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _TINTMASK\n\t\t   half4 w = SAMPLE_TEXTURE2D(_TintMask, sampler_TintMask, d.texcoord0.xy * _TintMask_ST.xy + _TintMask_ST.zw);\n\t\t   // allow black to be no tint..\n\t\t   half3 tint = o.Albedo * (_RColor.rgb * 2 * w.r + _GColor.rgb * 2 * w.g + _BColor.rgb * 2 * w.b + _AColor.rgb * 2 * w.a);\n\t\t   o.Albedo = lerp(o.Albedo, tint, saturate(w.r + w.g + w.b + w.a));\n\t\t#endif\n\t}\n\n\n\n\n\t#if _LAYERTEXTUREMASK\n       TEXTURE2D(_LayerTextureMask);\n       SAMPLER(sampler_LayerTextureMask); \n    #endif\n\n   void Ext_ModifyTessellatedVertex2 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON\n          float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n\n          #if _LAYERTEXTUREMASK\n               float2 layerUV = v.texcoord0.xy;\n               if (_LayerTextureMaskUVMode == 1)\n                  layerUV = v.texcoord1.xy;\n               else if (_LayerTextureMaskUVMode == 2)\n                  layerUV = worldSpacePosition.yz;\n               else if (_LayerTextureMaskUVMode == 3)\n                  layerUV = worldSpacePosition.xz;\n               else if (_LayerTextureMaskUVMode == 4)\n                  layerUV = worldSpacePosition.xy;\n\n              e.blackboard.weightTextureMask = SAMPLE_TEXTURE2D_LOD(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw, _TessellationMipBias);\n          #endif\n      #endif\n    }\n\n\n\tvoid Ext_SurfaceFunction2 (inout Surface o, inout ShaderData d)\n\t{\n\t\t#if _LAYERTEXTUREMASK\n           float2 layerUV = d.texcoord0.xy;\n           if (_LayerTextureMaskUVMode == 1)\n              layerUV = d.texcoord1.xy;\n           else if (_LayerTextureMaskUVMode == 2)\n              layerUV = d.worldSpacePosition.yz;\n           else if (_LayerTextureMaskUVMode == 3)\n              layerUV = d.worldSpacePosition.xz;\n           else if (_LayerTextureMaskUVMode == 4)\n              layerUV = d.worldSpacePosition.xy;\n\n          d.blackboard.weightTextureMask = SAMPLE_TEXTURE2D(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw);\n      #endif\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap);\n   SAMPLER(sampler_LayerAlbedoMap);\n   TEXTURE2D(_LayerNormalMap);\n   TEXTURE2D(_LayerMaskMap);\n   TEXTURE2D(_LayerEmissionMap);\n\n   \n\n   void Ext_ModifyTessellatedVertex3 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER) && defined(_LAYERALBEDO) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n         half detailMask = 1;\n         #if _LAYERNOISE\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency,  _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin;\n            dt = saturate(dt * _LayerFalloff);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight) * _LayerFalloff);\n            if (_LayerInvertHeight > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength;\n         detailMask *= _LayerTessStrength;\n\n         #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast).a;\n         albedo = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo);\n\n         if (_LayerBlendMode == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction3 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n            // noise up the mask\n            #if _LAYERNOISE\n               mask = DoNoise(d, _LayerNoiseFrequency, _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend);\n\t    \n                dt -= _LayerAngleMin;\n                dt = saturate(dt * _LayerFalloff);\n\n                float hf = saturate((o.Height - _LayerHeight) * _LayerFalloff);\n                if (_LayerInvertHeight > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 0\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 0\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength;\n\n            #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint, 0.5);\n            #if defined(_LAYERALBEDO)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c, _LayerStochasticContrast, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c);\n                #endif\n                albedo.rgb *= _LayerTint;\n                albedo.a = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL || _LAYERMASK\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap, sampler_LayerAlbedoMap, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast);\n            albedo.rgb += _LayerAlbedoBrightness;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap, sampler_LayerAlbedoMap), c, d, _LayerNormalStrength * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO)\n                if (_LayerFuzzyShadingOn > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor.rgb, dnormal,\n                                            _LayerFuzzyShadingParams.x, _LayerFuzzyShadingParams.y, _LayerFuzzyShadingParams.z);\n                }\n\n                if (_LayerBlendMode == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast);\n                else if (_LayerBlendMode == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE\n                      float maskDif = (_LayerBlendContrast * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength);\n                   #if _LAYERNOISE\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap, sampler_LayerAlbedoMap), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength);\n                }\n\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap, sampler_LayerAlbedoMap), c).rgb * _LayerEmissionColor;\n                #if _LAYERALBEDO\n                    if (_LayerBlendMode > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_1);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_1);\n   TEXTURE2D(_LayerNormalMap_Ext_1);\n   TEXTURE2D(_LayerMaskMap_Ext_1);\n   TEXTURE2D(_LayerEmissionMap_Ext_1);\n\n   \n\n   void Ext_ModifyTessellatedVertex4 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_1) && defined(_LAYERALBEDO_DEF_1) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_1\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_1,  _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_1\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_1;\n            dt = saturate(dt * _LayerFalloff_Ext_1);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n            if (_LayerInvertHeight_Ext_1 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_1;\n         detailMask *= _LayerTessStrength_Ext_1;\n\n         #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_1).a;\n         albedo = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo);\n\n         if (_LayerBlendMode_Ext_1 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_1);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_1 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction4 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_1)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_1\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_1, _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_1\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_1);\n\t    \n                dt -= _LayerAngleMin_Ext_1;\n                dt = saturate(dt * _LayerFalloff_Ext_1);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n                if (_LayerInvertHeight_Ext_1 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 01\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 01\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_1;\n\n            #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_1, 0.5);\n            #if defined(_LAYERALBEDO_DEF_1)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, _LayerStochasticContrast_Ext_1, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_1;\n                albedo.a = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_1 || _LAYERMASK_DEF_1\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_1);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_1;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, d, _LayerNormalStrength_Ext_1 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_1)\n                if (_LayerFuzzyShadingOn_Ext_1 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_1.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_1.x, _LayerFuzzyShadingParams_Ext_1.y, _LayerFuzzyShadingParams_Ext_1.z);\n                }\n\n                if (_LayerBlendMode_Ext_1 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_1);\n                else if (_LayerBlendMode_Ext_1 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_1 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_1);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_1\n                      float maskDif = (_LayerBlendContrast_Ext_1 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_1 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                   #if _LAYERNOISE_DEF_1\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_1));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_1 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_1);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_1) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_1 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_1);\n                }\n\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_1);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_1, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_1, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_1\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c).rgb * _LayerEmissionColor_Ext_1;\n                #if _LAYERALBEDO_DEF_1\n                    if (_LayerBlendMode_Ext_1 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_2);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_2);\n   TEXTURE2D(_LayerNormalMap_Ext_2);\n   TEXTURE2D(_LayerMaskMap_Ext_2);\n   TEXTURE2D(_LayerEmissionMap_Ext_2);\n\n   \n\n   void Ext_ModifyTessellatedVertex5 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_2) && defined(_LAYERALBEDO_DEF_2) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_2\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_2,  _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_2\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_2;\n            dt = saturate(dt * _LayerFalloff_Ext_2);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n            if (_LayerInvertHeight_Ext_2 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_2;\n         detailMask *= _LayerTessStrength_Ext_2;\n\n         #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_2).a;\n         albedo = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo);\n\n         if (_LayerBlendMode_Ext_2 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_2);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_2 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction5 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_2)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_2\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_2, _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_2\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_2);\n\t    \n                dt -= _LayerAngleMin_Ext_2;\n                dt = saturate(dt * _LayerFalloff_Ext_2);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n                if (_LayerInvertHeight_Ext_2 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 02\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 02\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_2;\n\n            #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_2, 0.5);\n            #if defined(_LAYERALBEDO_DEF_2)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, _LayerStochasticContrast_Ext_2, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_2;\n                albedo.a = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_2 || _LAYERMASK_DEF_2\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_2);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_2;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, d, _LayerNormalStrength_Ext_2 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_2)\n                if (_LayerFuzzyShadingOn_Ext_2 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_2.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_2.x, _LayerFuzzyShadingParams_Ext_2.y, _LayerFuzzyShadingParams_Ext_2.z);\n                }\n\n                if (_LayerBlendMode_Ext_2 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_2);\n                else if (_LayerBlendMode_Ext_2 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_2 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_2);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_2\n                      float maskDif = (_LayerBlendContrast_Ext_2 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_2 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                   #if _LAYERNOISE_DEF_2\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_2));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_2 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_2);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_2) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_2 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_2);\n                }\n\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_2);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_2, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_2, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_2\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c).rgb * _LayerEmissionColor_Ext_2;\n                #if _LAYERALBEDO_DEF_2\n                    if (_LayerBlendMode_Ext_2 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   #if _TRAX_ON\n   TEXTURE2D(_TraxAlbedo);\n   SAMPLER(sampler_TraxAlbedo);\n   TEXTURE2D(_TraxPackedNormal);\n   TEXTURE2D(_TraxMask);\n\n   sampler2D_float _GMSTraxBuffer;\n\n   float4 _GMSTraxBuffer_TexelSize;\n   float3 _GMSTraxBufferPosition;\n   float _GMSTraxBufferWorldSize;\n   float _GMSTraxFudgeFactor;\n\n   float SampleTraxBufferLOD(float3 worldPos)\n   {    \n      // generate UVs for the buffer, which is moving\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 8);\n      uv *= 0.5;\n      uv += 0.5;\n            \n      float s =  tex2Dlod(_GMSTraxBuffer, float4(uv, 0, 0)).r;\n\n      return 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n   }\n         \n        \n   float SampleTraxBuffer(float3 worldPos, out float3 norm)\n   {\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 3);\n      uv *= 0.5;\n      uv += 0.5;\n            \n\n      float2 offset = _GMSTraxBuffer_TexelSize.xy;\n\n      float s = tex2D(_GMSTraxBuffer, uv).r;\n               \n      float s1 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, -1)).r;\n      float s2 = tex2D(_GMSTraxBuffer, uv + offset * float2(-1, 0)).r;\n      float s3 = tex2D(_GMSTraxBuffer, uv + offset * float2(1, 0)).r;\n      float s4 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, 1)).r;\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      float r = 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n \n      // generate normals\n      norm.x = (s1 - s4) * 0.25; \n      norm.y = (s2 - s3) * 0.25;\n      norm.z = 2;\n      norm = normalize(norm);\n     \n      norm.xy *= 1 - r;\n            \n      return r;\n   }\n   #endif\n\n   void Ext_ModifyTessellatedVertex6 (inout VertexData v, inout ExtraV2F d)\n   {\n       #if _TESSELLATION_ON && _TRAX_ON && _HAS_LIT_TESSELLATION\n          \n           float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n           float3 worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n           float traxBuffer = SampleTraxBufferLOD(worldSpacePosition);\n           d.blackboard.traxBuffer = traxBuffer;\n           float2 uv = worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n           half albedo = SAMPLE_TEXTURE2D_LOD(_TraxAlbedo, sampler_TraxAlbedo, uv, _TraxMipBias).a;\n\n           float traxOffset = albedo * _TraxDisplacementStrength;\n           traxOffset *= 1 - v.texcoord0.z;\n           traxOffset *= _TessellationDisplacement;\n           float dig = _TraxDisplacementDepth * (1 - v.texcoord0.z);\n           float3 traxVertex = d.blackboard.originalVertexPosition + (v.normal * (traxOffset - dig));\n           v.vertex.xyz = lerp(traxVertex, v.vertex.xyz, traxBuffer);\n\n           d.blackboard.vertexHeightOffset = lerp(traxOffset-dig, d.blackboard.vertexHeightOffset, traxBuffer);\n\n       #endif\n\n   }\n\n   void Ext_SurfaceFunction6 (inout Surface o, inout ShaderData d)\n   {\n      #if _TRAX_ON\n        float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n        float2 fsdx = ddx(uv);\n        float2 fsdy = ddy(uv);\n\n        float3 traxNormal;\n        float traxBuffer = SampleTraxBuffer(d.worldSpacePosition, traxNormal);\n        \n        #if _TESSELLATION_ON\n            traxBuffer -= _TraxDisplacementDepth;\n        #endif\n\n        d.blackboard.traxBuffer = traxBuffer;\n\n        UNITY_BRANCH\n        if (traxBuffer > 0)\n        {\n            half4 albedo = SAMPLE_TEXTURE2D_GRAD(_TraxAlbedo, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            albedo.rgb *= _TraxTint.rgb;\n            half4 normalSample = SAMPLE_TEXTURE2D_GRAD(_TraxPackedNormal, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n\n            half smoothness = normalSample.r;\n            half ao = normalSample.b;\n            half3 normal;\n            normal.xy = (normalSample.ag * 2 - 1) * _TraxNormalStrength;\n            normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n\n            \n            half h = HeightBlend(albedo.a, o.Alpha, traxBuffer, _TraxHeightContrast);\n\n            h = lerp(traxBuffer, h, _TraxInterpContrast);\n\n            o.Albedo = lerp(albedo, o.Albedo, h);\n\n            #if _SURFACEGRADIENT\n                o.Normal = lerp(normal, o.Normal, h);\n            #else\n                o.Normal = lerp(normal + traxNormal, o.Normal, h);\n            #endif\n        \n            o.Smoothness = lerp(smoothness, o.Smoothness, h);\n            o.Occlusion = lerp(ao, o.Occlusion, h);\n        }\n      #endif\n   }\n\n\n\n\n    #if _RAINDROPS\n       TEXTURE2D(_RainDropTexture);\n       SAMPLER(sampler_RainDropTexture);\n       half _Global_RainIntensity;\n    #endif\n\n    #if _WETNESS\n       half2 _Global_WetnessParams; // global, not in cbuffer\n    #endif\n   \n    #if _RAINDROPS\n    half2 ComputeRipple(float2 uv, half time, half weight)\n    {\n        half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_RainDropTexture, uv);\n        COUNTSAMPLE\n        ripple.yz = ripple.yz * 2 - 1;\n\n        half dropFrac = frac(ripple.w + time);\n        half timeFrac = dropFrac - 1.0 + ripple.x;\n        half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);\n        half finalFactor = dropFactor * ripple.x * \n                                sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);\n\n        return half2(ripple.yz * finalFactor);\n    }\n    #endif\n\n    half2 DoRain(half2 waterNorm, float2 uv, out half2 ripple)\n    {\n        #if _RAINDROPS\n            float rainIntensity = _RainIntensityScale.x;\n            if (_RainMode > 1)\n            {\n                rainIntensity = _Global_RainIntensity;\n            }\n\n            half dropStrength = rainIntensity;\n            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); \n            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);\n            half4 times = _Time.yyyy;\n            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);\n\n            float2 ruv1 = uv * _RainIntensityScale.yy;\n            float2 ruv2 = ruv1;\n\n            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);\n            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);\n            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);\n            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);\n            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);\n            weights = saturate(weights * 4);\n\n            half2 rippleNormal = half2( weights.x * ripple1.xy +\n                        weights.y * ripple2.xy + \n                        weights.z * ripple3.xy + \n                        weights.w * ripple4.xy);\n\n            ripple = rippleNormal * dropStrength * rainIntensity;\n            waterNorm = lerp(waterNorm, normalize(half3(rippleNormal.xy + rippleNormal.xy, 1)).xy, rainIntensity * dropStrength); \n            return waterNorm;                        \n        #else\n            return waterNorm;\n        #endif\n    }\n\n   half2 _Global_PuddleParams;   // this is a global, so keep it out of the cbuffer\n   void GetPuddleParams(ShaderData d, inout float puddleMask, inout float pudHeight)\n   {\n      #if _PUDDLES || _GLOBALPUDDLES\n          pudHeight = _PuddleAmount;\n          if (_PuddleMode > 0)\n             pudHeight = _Global_PuddleParams.x;    \n      \n\n          half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t      dt -= _PuddleAngleMin;\n          dt = saturate(dt * _PuddleFalloff);\n          puddleMask *= dt;\n      #endif\n   }\n   \n   void Ext_ModifyTessellatedVertex7 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _PUDDLES && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n         half mask = 1;\n         half pudHeight = 1;\n\n         // save some ops by doing this in 2d\n         #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2DLOD(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2DLOD(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #else\n                mask = (FBM2DLOD(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n         #endif\n\n         GetPuddleParams(d, mask, pudHeight);\n         float height = pudHeight * mask;\n         if (e.blackboard.vertexHeightOffset < height)\n         {\n            e.blackboard.vertexHeightOffset = height;\n            height -= _TessellationOffset; \n            // dampen cracks\n            height *= 1 - v.texcoord0.z;\n            height *= _TessellationDisplacement;\n            v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n            \n        }\n      #endif\n   }\n\n\n#if _WETNESS\n\n   float GetWetnessLevel(Surface o, ShaderData d, float wetnessMask)\n   {\n      float wetLevel = clamp(_WetnessAmount, _WetnessMin, _WetnessMax);\n      \n      if (_WetnessMode > 0)\n         wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);\n\n      wetLevel = saturate(wetLevel + (1 - saturate(d.worldSpacePosition.y - _WetnessShoreline)));\n      float3x3 tbn = float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal);\n      float dt = dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0));\n      dt -= _WetnessAngleMin;\n      dt = saturate(dt * _WetnessFalloff * wetLevel);\n      dt *= wetnessMask;\n      return dt;\n   }\n#endif\n   \n\n   void Ext_SurfaceFunction7 (inout Surface o, ShaderData d)\n   {\n      half wetnessLevel = 0;\n      #if _WETNESS\n          wetnessLevel = GetWetnessLevel(o, d, 1); // mask one day?\n      #endif\n\n      half depthMask = 0;\n      half depth = 0;\n\n      #if _PUDDLES\n          half mask = 1;\n          half pudHeight = 1;\n          #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2D(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2D(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);      \n            #else\n                mask = (FBM2D(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n          #endif\n\n          GetPuddleParams(d, mask, pudHeight);\n          pudHeight *= mask;\n          depth = pudHeight - o.Height;\n          depthMask = saturate(depth * _PuddleFalloff);\n          depthMask *= _PuddleColor.a;\n          depth = o.Height - pudHeight;\n\n          // extend wetness slighting higher than the puddle\n          half wetmask = saturate((pudHeight + 0.05 - o.Height) * _PuddleFalloff);\n          wetnessLevel = max(wetmask, wetnessLevel);\n       #endif\n\n       \n       #if _WETNESS || _PUDDLES\n          half3 waterNorm = half3(0,0,1);\n          half3 wetAlbedo = o.Albedo;\n          half wetSmoothness = o.Smoothness;\n          #if _PUDDLES\n             wetAlbedo *= _PuddleColor.rgb;\n          #endif\n          WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetnessLevel, _Porosity);\n\n          half ri = 0;\n          half2 ripple = 0;\n          #if (_RAINDROPS || _GLOBALRAIN) && (_PUDDLES || _GLOBALPUDDLES)\n             ri = _RainIntensityScale.z;\n             waterNorm.xy = DoRain(waterNorm.xy, d.texcoord0.xy, ripple) * depthMask;\n          #endif\n\n          o.Normal = lerp(o.Normal, waterNorm, depthMask);\n          o.Normal = lerp(o.Normal, LitBlendDetailNormal(o.Normal, half3(ripple.xy, 1)), saturate(ri - depthMask) * wetnessLevel);\n          o.Occlusion = lerp(o.Occlusion, 1, depthMask);\n          o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetnessLevel);\n          o.Albedo = lerp(o.Albedo, wetAlbedo, wetnessLevel);\n          o.Emission *= 1 + depth;\n          o.Metallic *= 1 + depth;\n          o.Specular *= 1 + depth;\n\n       #endif\n\n   }\n\n\n\n\n    #if _SNOW\n       TEXTURE2D(_SnowAlbedo);\n       SAMPLER(sampler_SnowAlbedo);\n       TEXTURE2D(_SnowNormal);\n       TEXTURE2D(_SnowMaskMap);\n       #if _TRAX_ON\n          TEXTURE2D(_SnowTraxAlbedo);\n          TEXTURE2D(_SnowTraxNormal);\n          TEXTURE2D(_SnowTraxMaskMap);\n       #endif\n    #endif\n\n   float _Global_SnowLevel;\n\n\n   void Ext_ModifyVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n    #if (_SNOW)\n        float amount = _SnowAmount;\n        if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n        float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n        float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n        snowAmount -= _SnowAngle;\n        snowAmount *= _SnowContrast * 0.5;\n        snowAmount = saturate(snowAmount) * amount;\n        float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n        if (_SnowWorldFade.z > 0)\n        {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n        }\n        #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n        #endif\n        snowAmount = saturate(snowAmount);\n\n        #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n        #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n        #endif\n\n        float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n        v.vertex.xyz = v.vertex.xyz + displacementVec * snowAmount * snowAmount * _SnowVertexHeight;\n    #endif\n   }\n\n   void Ext_ModifyTessellatedVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _SNOW && _HAS_LIT_TESSELLATION\n         float amount = _SnowAmount;\n         if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n         float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n         float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n         snowAmount -= _SnowAngle;\n         snowAmount *= _SnowContrast * 0.5;\n         float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n         if (_SnowWorldFade.z > 0)\n         {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n         }\n\n         snowAmount = saturate(snowAmount) * amount;\n\n         #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n         #endif\n         snowAmount = saturate(snowAmount);\n\n         #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n         #endif\n\n         float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n         half heightMap = SAMPLE_TEXTURE2D_LOD(_SnowAlbedo, sampler_SnowAlbedo, worldPos.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw, 2);\n\n         float height = max(_SnowVertexHeight * 3 * snowAmount + snowAmount * heightMap, e.blackboard.vertexHeightOffset);\n         #if _TRAX_ON\n            height *= e.blackboard.traxBuffer;\n         #endif\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n\n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n         \n      #endif\n\n   }\n\n   void SampleSnowSurface(TEXTURE2D_PARAM(alb, ss), TEXTURE2D_PARAM(norm, ss2), TEXTURE2D_PARAM(mask, ss3),\n        ShaderData d, float2 uv, float2 dx, float2 dy, out half4 albedo, out half3 normal, out half2 smoothAO)\n   {\n      #if _SNOWSTOCHASTIC\n         float w1, w2, w3;\n         int2 vertex1, vertex2, vertex3;\n         TriangleGrid(uv, _SnowStochasticScale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n         // Assign random offset to each triangle vertex\n         float2 uv0 = uv;\n         float2 uv1 = uv;\n         float2 uv2 = uv;\n   \n         uv0.xy += SimpleHash2(vertex1);\n         uv1.xy += SimpleHash2(vertex2);\n         uv2.xy += SimpleHash2(vertex3);\n         half3 weights = half3(w1, w2, w3);\n\n         half4 albedo0 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv0, dx, dy);\n         half4 albedo1 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv1, dx, dy);\n         half4 albedo2 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv2, dx, dy);\n         COUNTSAMPLE\n         COUNTSAMPLE\n         COUNTSAMPLE\n         weights = BaryWeightBlend(weights, albedo0.a, albedo1.a, albedo2.a, _SnowStochasticContrast);\n         albedo = albedo0 * weights.x + albedo1 * weights.y + albedo2 * weights.z;\n\n         normal = half3(0,0,1);\n         smoothAO = half2(0, 1);\n\n         #if !_AUTONORMAL\n            half4 n0 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv0, dx, dy);\n            half4 n1 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv1, dx, dy);\n            half4 n2 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n            half4 snowNormSamp = n0 * weights.x + n1 * weights.y + n2 * weights.z;\n\n            normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n                \n            #if _PACKEDFAST\n               smoothAO.x = snowNormSamp.r;\n               smoothAO.y = snowNormSamp.b;\n            #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask0 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv0, dx, dy);\n            half4 snowMask1 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv1, dx, dy);\n            half4 snowMask2 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n            half4 snowMask = snowMask0 * weights.x + snowMask1 * weights.y + snowMask2 * weights.z;\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n      #else // not stochastic\n          albedo = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv, dx, dy);\n          COUNTSAMPLE\n\n          normal = half3(0,0,1);\n          smoothAO = half2(0, 1);\n\n          #if !_AUTONORMAL\n             half4 snowNormSamp = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv, dx, dy);\n             COUNTSAMPLE\n             normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n             #if _SURFACEGRADIENT\n                normal = ConvertNormalToGradient(d, normal);\n             #endif\n                 \n             #if _PACKEDFAST\n                smoothAO.x = snowNormSamp.r;\n                smoothAO.y = snowNormSamp.b;\n             #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv, dx, dy);\n            COUNTSAMPLE\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n     #endif // stochastic\n   }\n\n   \n   void Ext_SurfaceFunction8 (inout Surface o, ShaderData d)\n   {\n      #if _SNOW\n          float amount = _SnowAmount;\n          if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n          float snowAmount = lerp(dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), dot(d.worldSpaceNormal, float3(0,1,0)), amount * 0.8) + 1;\n          snowAmount -= _SnowAngle;\n          snowAmount *= _SnowContrast;\n          snowAmount = saturate(snowAmount) - (1-amount) * (1-amount);\n\n          if (_SnowWorldFade.z > 0)\n          {\n             float worldFade = saturate((d.worldSpacePosition.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n             snowAmount *= worldFade;\n          }\n\n          #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(d.worldSpacePosition.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n          #endif\n          snowAmount = saturate(snowAmount);\n\n          float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw;\n          float2 dx = ddx(uv);\n          float2 dy = ddy(uv);\n\n          #if _TRAX_ON\n              float2 tuv = d.worldSpacePosition.xz * float2(1, -1) * _SnowTraxAlbedo_ST.xy + _SnowTraxAlbedo_ST.zw;\n              float2 tdx = ddx(uv);\n              float2 tdy = ddy(uv);\n          #endif\n\n          #if _LAYERVERTEXMASK\n              snowAmount *= d.vertexColor.a;\n          #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n              snowAmount *= d.blackboard.weightTextureMask.a;\n          #endif\n\n          UNITY_BRANCH\n          if (snowAmount > 0)\n          {\n             half4 snowAlbedo;\n             half3 snowNormal;\n             half2 snowSmoothAO;\n             SampleSnowSurface(TEXTURE2D_ARGS(_SnowAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowNormal, sampler_SnowAlbedo),\n                    TEXTURE2D_ARGS(_SnowMaskMap, sampler_SnowAlbedo), d, uv, dx, dy, snowAlbedo, snowNormal, snowSmoothAO);\n\n             snowAlbedo.rgb *= _SnowTint.rgb;\n\n             #if _TRAX_ON\n                half traxBuffer = 1 - d.blackboard.traxBuffer;\n                UNITY_BRANCH\n                if (traxBuffer > 0)\n                {\n                    half4 tsnowAlbedo;\n                    half3 tsnowNormal;\n                    half2 tsnowSmoothAO;\n                    SampleSnowSurface(TEXTURE2D_ARGS(_SnowTraxAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowTraxNormal, sampler_SnowAlbedo),\n                        TEXTURE2D_ARGS(_SnowTraxMaskMap, sampler_SnowAlbedo), d, tuv, tdx, tdy, tsnowAlbedo, tsnowNormal, tsnowSmoothAO);\n\n                    tsnowAlbedo.rgb *= _SnowTraxTint;\n                    half h = HeightBlend(snowAlbedo.a, tsnowAlbedo.a, traxBuffer, 0.5);\n                    snowAlbedo = lerp(snowAlbedo, tsnowAlbedo, h);\n                    snowNormal = lerp(snowNormal, tsnowNormal, h);\n                    snowSmoothAO = lerp(snowSmoothAO, tsnowSmoothAO, h);\n                }\n             #endif\n\n             #if !_AUTONORMAL\n                o.Normal = lerp(o.Normal, snowNormal, snowAmount);\n             #endif\n             o.Albedo = lerp(o.Albedo, snowAlbedo.rgb, snowAmount);\n             o.Alpha = lerp(o.Alpha, snowAlbedo.a, snowAmount);\n             o.Smoothness = lerp(o.Smoothness, snowSmoothAO.x, snowAmount);\n             o.Occlusion = lerp(o.Occlusion, snowSmoothAO.y, snowAmount);\n             o.Height = o.Alpha;\n\n          }\n      #endif\n   }\n\n   \n\n\n\n\n\n   TEXTURE2D(_WindParticulate);\n   SAMPLER(sampler_WindParticulate);\n\n// In case we want to read it more than once..\n\n#ifndef __STACKABLE_WIND_INCLUDES__\n#define __STACKABLE_WIND_INCLUDES__\n\n\n   half FilterRange(float4 range, float y)\n   {\n      half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));\n      w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));\n      return w;\n   }\n\n   \n   float2 RotateUV(float2 uv, float amt)\n   {\n      uv -=0.5;\n      float s = sin ( amt);\n      float c = cos ( amt );\n      float2x2 mtx = float2x2( c, -s, s, c);\n      mtx *= 0.5;\n      mtx += 0.5;\n      mtx = mtx * 2-1;\n      uv = mul ( uv, mtx );\n      uv += 0.5;\n      return uv;\n   }\n\n\n   half FilterWindParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)\n   {\n      float2 windDir = RotateUV(float2(1, 0), windRot);\n      float2 flow = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));\n      float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill\n      return FilterRange(range, cofacing);\n   }\n\n   half ProcessWindParticulateMask(inout half mask, float contrast)\n   {\n      mask = pow(abs(mask), abs(contrast));\n      half invMask = 1.0 - mask;\n      invMask *= invMask; \n      invMask *= invMask;\n      return invMask;\n   }\n#endif // include guard\n\n   void Ext_SurfaceFunction9 (inout Surface o, ShaderData d)\n   {\n      #if _WIND_ON && !_PASSMETA\n   \n         float3 upVector = float3(0,0,1);\n\n         half upDot = max(0.0, dot(d.worldSpaceNormal, float3(0, 1, 0)));\n\n         float2 uv = d.worldSpacePosition.xz;\n         if (_WindParticulateSpace > 0.5)\n            uv = d.texcoord0.xy;\n         float windRotation = _WindParticulateRotation;\n         float windStrength = _WindParticulateStrength;\n\n         float2 wuv = RotateUV(uv, windRotation);\n\n         half windBlend = 1.0;\n\n         float windWorldMask = FilterRange(_WindParticulateWorldHeightMask, d.worldSpacePosition.y);\n         windWorldMask *= FilterRange(_WindParticulateAngleMask, upDot);\n\n         // compute mask\n         wuv *= float2(_WindParticulate_ST.x, 1) * _WindParticulate_ST.y + _WindParticulate_ST.zw;\n         float speed = _Time.x * _WindParticulateSpeed;\n         half w1 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv * 3 + speed * float2(1,0)).g;\n         half w2 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv + speed * float2(1.1,0)).a;\n         half windMask = (w1 * w2);\n\n         windMask *= windStrength * windBlend * windWorldMask;\n         windMask *= saturate((_WindParticulateTextureHeight - o.Height) * 10);\n\n         half windInvMask = ProcessWindParticulateMask(windMask, _WindParticulatePower);\n    \n         o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);\n         o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindParticulateEmissive.rgb;\n         o.Normal.xy *= windInvMask;\n         o.Smoothness *= windInvMask;\n         o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;\n         o.Metallic *= windInvMask;\n      #endif\n\n   }\n\n\n\n\n\tvoid Ext_SurfaceFunction10 (inout Surface o, ShaderData d)\n\t{\n        if (_DoubleSidedNormalMode == 0)\n        {\n           o.Normal *= d.isFrontFace ? 1 : -1;\n        }\n        else if (_DoubleSidedNormalMode == 1)\n        {\n\t\t   o.Normal.z *= d.isFrontFace ? 1 : -1;\n        }\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction11 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _SURFACEGRADIENT\n\t\t\to.Normal = ResolveNormalFromSurfaceGradient(d, o.Normal);\n\t    #elif _AUTONORMAL\n\t        float3 dx = ddx(d.worldSpacePosition);\n\t\t\tfloat3 dy = ddy(d.worldSpacePosition);\n\t\t\tfloat3 crossX = cross(float3(0,1,0), dx);\n\t\t\tfloat3 crossY = cross(float3(0,1,0), dy);\n\t\t\tfloat3 dt = abs(dot(crossY, dx));\n\t\t\tfloat height = _AutoNormalStrength * 0.5 * o.Alpha;\n\t\t\tfloat3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n\t\t\tn.y *= -1.0;\n\t\t\to.Normal = normalize((dt * float3(0,1,0)) - n).xzy;\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#else\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#endif\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction12 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DEBUG_SAMPLECOUNT\n\t\t\tif (_sampleCount > _DebugSampleCountThreshold)\n\t\t\t{\n\t\t\t\to.Albedo.r = 1;\n\t\t\t\to.Albedo.gb *= 0.2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\to.Albedo.b = 1;\n\t\t\t}\n\n        #endif\n\t}\n\n\n\n\n\tSAMPLER(sampler_DissolveTexture);\n\tTEXTURE2D(_DissolveTexture);\n\tTEXTURE2D(_DissolveGradient);\n\n\tvoid Ext_SurfaceFunction13 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DISSOLVE\n\t\tfloat2 uv = d.texcoord0.xy * _DissolveTexture_ST.xy + _DissolveTexture_ST.zw;\n\t\tfloat2 dx = ddx(uv);\n\t\tfloat2 dy = ddy(uv);\n\n\t\tUNITY_BRANCH\n\t\tif (_DissolveAmount > 0)\n\t\t{\n\t\t\thalf dissolve = SAMPLE_TEXTURE2D_GRAD(_DissolveTexture, sampler_DissolveTexture, uv, dx, dy).g;\n\t\t\thalf cp =  saturate(_DissolveAmount - (dissolve - _DissolveAmount) * _DissolveEdgeContrast) + _DissolveAmount;\n\t\t\thalf cp2 = saturate(1.0 - abs((dissolve - _DissolveAmount) * _DissolveEdgeContrast));\n\t\t\tclip(1.0 - cp);\n\t\t\tfloat2 fuv = float2(cp2, 0.5);\n\t\t\thalf3 col = SAMPLE_TEXTURE2D_LOD(_DissolveGradient, sampler_DissolveTexture, fuv, 0).rgb;\n\t\t\t\t\n\t\t\to.Albedo = lerp(o.Albedo, col, _DissolveColoration * cp2);\n\t\t\to.Emission = lerp(o.Emission, col * _DissolveEmissiveStr, _DissolveColoration * cp2);\n\t\t}\n\t\t#endif\n\t}\n\n\n\n\n    float Dither8x8Bayer( int x, int y )\n    {\n        const float dither[ 64 ] = {\n                1, 49, 13, 61,  4, 52, 16, 64,\n            33, 17, 45, 29, 36, 20, 48, 32,\n                9, 57,  5, 53, 12, 60,  8, 56,\n            41, 25, 37, 21, 44, 28, 40, 24,\n                3, 51, 15, 63,  2, 50, 14, 62,\n            35, 19, 47, 31, 34, 18, 46, 30,\n            11, 59,  7, 55, 10, 58,  6, 54,\n            43, 27, 39, 23, 42, 26, 38, 22};\n        int r = y * 8 + x;\n        return dither[r] / 64; \n    }\n\n    void ApplyDitherCrossFadeVSP(float2 vpos, float fadeValue)\n    {\n        float dither = Dither8x8Bayer( fmod(vpos.x, 8), fmod(vpos.y, 8) );\n        float sgn = fadeValue > 0 ? 1.0f : -1.0f;\n        clip(dither - (1-fadeValue) * sgn);\n    }\n    \n\n\tvoid Ext_SurfaceFunction14 (inout Surface o, ShaderData d)\n\t{\n\t\t#if LOD_FADE_CROSSFADE\n            float4 screenPosNorm = d.screenPos / d.screenPos.w;\n            screenPosNorm.z = ( UNITY_NEAR_CLIP_VALUE >= 0 ) ? screenPosNorm.z : screenPosNorm.z * 0.5 + 0.5;\n            float2 clipScreen = screenPosNorm.xy * _ScreenParams.xy;\n            ApplyDitherCrossFadeVSP(clipScreen,unity_LODFade.x);\n        #endif\n\t}\n\n\n\n\n\n\n// declare outside of CBuffer\n\nfloat4x4 _GlobalVolumeMatrix;\nfloat4x4 _VolumeMatrix;\nfloat3 _VolumeMin;\nfloat3 _VolumeInvSize;\nfloat3 _GlobalVolumeMin;\nfloat3 _GlobalVolumeInvSize;\n\n// I inlined a section of your include. You can use includes in better shaders, but doing it via a subshader or this way\n// is much better. The reason is that this allows your shader to be all inclusive, and packed up for asset store distribition,\n// without requiring specific paths to other files, etc.\n//\n\n#ifndef BAKERY_INCLUDED\n#define BAKERY_INCLUDED\n\n#define BAKERYMODE_DEFAULT 0\n#define BAKERYMODE_VERTEXLM 1.0f\n#define BAKERYMODE_RNM 2.0f\n#define BAKERYMODE_SH 3.0f\n\n\n// can't fit vertexLM SH to sm3_0 interpolators\n#ifndef SHADER_API_D3D11\n    #undef _LIGHTMAPMODE_VERTEXSH\n#endif\n\n// can't do stuff on sm2_0 due to standard shader alrady taking up all instructions\n#if SHADER_TARGET < 30\n    #undef BAKERY_BICUBIC\n    #undef BAKERY_LMSPEC\n\n    #undef _LIGHTMAPMODE_RNM\n    #undef _LIGHTMAPMODE_SH\n    #undef _LIGHTMAPMODE_VERTEX\n#endif\n\n#define lumaConv float3(0.2125f, 0.7154f, 0.0721f)\n\n#ifdef BAKERY_VOLUME\n    #ifdef BAKERY_COMPRESSED_VOLUME\n        Texture3D _Volume3;\n    #endif\n#endif\n\n\nhalf3 LinearToGamma (half3 linRGB)\n{\n    linRGB = max(linRGB, half3(0.h, 0.h, 0.h));\n    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n    return max(1.055h * pow(linRGB, 0.416666667h) - 0.055h, 0.h);\n}\n\nfloat shEvaluateDiffuseL1Geomerics(float L0, float3 L1, float3 n)\n{\n    // average energy\n    float R0 = L0;\n\n    // avg direction of incoming light\n    float3 R1 = 0.5f * L1;\n\n    // directional brightness\n    float lenR1 = length(R1);\n\n    // linear angle between normal and direction 0-1\n    //float q = 0.5f * (1.0f + dot(R1 / lenR1, n));\n    //float q = dot(R1 / lenR1, n) * 0.5 + 0.5;\n    float q = dot(normalize(R1), n) * 0.5 + 0.5;\n\n    // power for q\n    // lerps from 1 (linear) to 3 (cubic) based on directionality\n    float p = 1.0f + 2.0f * lenR1 / R0;\n\n    // dynamic range constant\n    // should vary between 4 (highly directional) and 0 (ambient)\n    float a = (1.0f - lenR1 / R0) / (1.0f + lenR1 / R0);\n\n    return R0 * (a + (1.0f - a) * (p + 1.0f) * pow(q, p));\n}\n\n#ifdef BAKERY_VERTEXLMMASK\n    float4 unpack4NFloats(float src)\n\t{\n        //return fmod(float4(src / 262144.0, src / 4096.0, src / 64.0, src), 64.0)/64.0;\n        return frac(float4(src / (262144.0*64), src / (4096.0*64), src / (64.0*64), src));\n    }\n#endif\n\n#if defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n    float3 unpack3NFloats(float src)\n\t{\n        float r = frac(src);\n        float g = frac(src * 256.0);\n        float b = frac(src * 65536.0);\n        return float3(r, g, b);\n    }\n#endif\n\n// Unity defines these under different names in each SRP, so use our own\ninline float3 Bakery_SafeNormalize(float3 inVec)\n{\n    float dp3 = max(0.001f, dot(inVec, inVec));\n    return inVec * rsqrt(dp3);\n}\n\n#if _URP || _HDRP\n\nfloat SmoothnessToPerceptualRoughness(float smoothness)\n{\n    return (1 - smoothness);\n}\n#endif\n\n#if !_STANDARD\nhalf4 unity_Lightmap_HDR;\ninline half3 DecodeLightmap( half4 color )\n{\n    return DecodeLightmap( color, unity_Lightmap_HDR );\n}\n\n#define UNITY_INV_PI        0.31830988618f\ninline float GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return UNITY_INV_PI * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n    void BakeryVertexLMDirection(inout float3 diffuseColor, inout float3 specularColor, float3 lightDirection, float3 vertexNormalWorld, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 dominantDir = Bakery_SafeNormalize(lightDirection);\n        half halfLambert = dot(normalWorld, dominantDir) * 0.5 + 0.5;\n        half flatNormalHalfLambert = dot(vertexNormalWorld, dominantDir) * 0.5 + 0.5;\n\n        #ifdef BAKERY_LMSPEC\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = spec * diffuseColor;\n        #endif\n\n        diffuseColor *= halfLambert / max(1e-4h, flatNormalHalfLambert);\n    }\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXSH\n    void BakeryVertexLMSH(inout float3 diffuseColor, inout float3 specularColor, float3 shL1x, float3 shL1y, float3 shL1z, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 L0 = diffuseColor;\n        float3 nL1x = shL1x;\n        float3 nL1y = shL1y;\n        float3 nL1z = shL1z;\n        float3 L1x = nL1x * L0 * 2;\n        float3 L1y = nL1y * L0 * 2;\n        float3 L1z = nL1z * L0 * 2;\n\n        float3 sh;\n    #if BAKERY_SHNONLINEAR\n        //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n        //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n        //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n        float lumaL0 = dot(L0, 1);\n        float lumaL1x = dot(L1x, 1);\n        float lumaL1y = dot(L1y, 1);\n        float lumaL1z = dot(L1z, 1);\n        float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n        float regularLumaSH = dot(sh, 1);\n        //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n        sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    #else\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    #endif\n\n        diffuseColor = max(sh, 0.0);\n\n        #ifdef BAKERY_LMSPEC\n            float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n            float focus = saturate(length(dominantDir));\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = max(spec * sh, 0.0);\n        #endif\n    }\n#endif\n\n\n\n#ifdef BAKERY_BICUBIC\nfloat BakeryBicubic_w0(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-a + 3.0f) - 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w1(float a)\n{\n    return (1.0f/6.0f)*(a*a*(3.0f*a - 6.0f) + 4.0f);\n}\n\nfloat BakeryBicubic_w2(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-3.0f*a + 3.0f) + 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w3(float a)\n{\n    return (1.0f/6.0f)*(a*a*a);\n}\n\nfloat BakeryBicubic_g0(float a)\n{\n    return BakeryBicubic_w0(a) + BakeryBicubic_w1(a);\n}\n\nfloat BakeryBicubic_g1(float a)\n{\n    return BakeryBicubic_w2(a) + BakeryBicubic_w3(a);\n}\n\nfloat BakeryBicubic_h0(float a)\n{\n    return -1.0f + BakeryBicubic_w1(a) / (BakeryBicubic_w0(a) + BakeryBicubic_w1(a)) + 0.5f;\n}\n\nfloat BakeryBicubic_h1(float a)\n{\n    return 1.0f + BakeryBicubic_w3(a) / (BakeryBicubic_w2(a) + BakeryBicubic_w3(a)) + 0.5f;\n}\n#endif\n\n\n#if defined(_LIGHTMAPMODE_RNM) || defined(_LIGHTMAPMODE_SH)\nTexture2D _RNM0, _RNM1, _RNM2;\n#endif\n\n#ifdef BAKERY_VOLUME\nTexture3D _Volume0, _Volume1, _Volume2, _VolumeMask;\nSamplerState sampler_Volume0;\n#endif\n\n#if defined(BAKERY_BICUBIC) && defined(LIGHTMAP_ON) && defined(SHADER_API_D3D11)\n    // Bicubic\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\tfloat width, height;\n\t\ttex.GetDimensions(width, height);\n\t\tfloat texelSize = 1.0f / width;\n\n        float x = uv.x * width;\n        float y = uv.y * width;\n\n        x -= 0.5f;\n        y -= 0.5f;\n\n        float px = floor(x);\n        float py = floor(y);\n\n        float fx = x - px;\n        float fy = y - py;\n\n        float g0x = BakeryBicubic_g0(fx);\n        float g1x = BakeryBicubic_g1(fx);\n        float h0x = BakeryBicubic_h0(fx);\n        float h1x = BakeryBicubic_h1(fx);\n        float h0y = BakeryBicubic_h0(fy);\n        float h1y = BakeryBicubic_h1(fy);\n\n        return     BakeryBicubic_g0(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h0y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h0y) * texelSize))) +\n\n                   BakeryBicubic_g1(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h1y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h1y) * texelSize)));\n    }\n#else\n    // Bilinear\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\t#ifdef LIGHTMAP_ON\n\t\t\treturn tex.Sample(samplerunity_Lightmap, uv);\n\t\t#else\n\t\t\treturn float4(1,0,0,1);\n\t\t#endif\n    }\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\n#ifdef BAKERY_LMSPEC\nfloat BakeryDirectionalLightmapSpecular(float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 dominantDir = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap, lmUV).xyz * 2 - 1;\n    half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n    half nh = saturate(dot(normalWorld, halfDir));\n    half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n    half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n    half spec = GGXTerm(nh, roughness);\n    return spec;\n}\n#endif\n#endif\n\n\n\n#ifdef _LIGHTMAPMODE_RNM\nvoid BakeryRNM(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalMap, float smoothness, float3 viewDirT)\n{\n    const float3 rnmBasis0 = float3(0.816496580927726f, 0, 0.5773502691896258f);\n    const float3 rnmBasis1 = float3(-0.4082482904638631f, 0.7071067811865475f, 0.5773502691896258f);\n    const float3 rnmBasis2 = float3(-0.4082482904638631f, -0.7071067811865475f, 0.5773502691896258f);\n\n    float3 rnm0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 rnm1 = DecodeLightmap(BakeryTex2D(_RNM1, lmUV));\n    float3 rnm2 = DecodeLightmap(BakeryTex2D(_RNM2, lmUV));\n\n    #ifdef BAKERY_SSBUMP\n        diffuseColor = normalMap.x * rnm0\n                     + normalMap.z * rnm1\n                     + normalMap.y * rnm2;\n         diffuseColor *= 2;\n    #else\n        diffuseColor = saturate(dot(rnmBasis0, normalMap)) * rnm0\n                     + saturate(dot(rnmBasis1, normalMap)) * rnm1\n                     + saturate(dot(rnmBasis2, normalMap)) * rnm2;\n    #endif\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDirT = rnmBasis0 * dot(rnm0, lumaConv) +\n                              rnmBasis1 * dot(rnm1, lumaConv) +\n                              rnmBasis2 * dot(rnm2, lumaConv);\n\n        float3 dominantDirTN = normalize(dominantDirT);\n        float3 specColor = saturate(dot(rnmBasis0, dominantDirTN)) * rnm0 +\n                           saturate(dot(rnmBasis1, dominantDirTN)) * rnm1 +\n                           saturate(dot(rnmBasis2, dominantDirTN)) * rnm2;\n\n        half3 halfDir = Bakery_SafeNormalize(dominantDirTN - viewDirT);\n        half nh = saturate(dot(normalMap, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n        specularColor = spec * specColor;\n    #endif\n}\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\ninline half3 Unity_DecodeDirectionalLightmap(half3 color, half4 dirTex, half3 normalWorld)\n{\n    // In directional (non-specular) mode Enlighten bakes dominant light direction\n    // in a way, that using it for half Lambert and then dividing by a \"rebalancing coefficient\"\n    // gives a result close to plain diffuse response lightmaps, but normalmapped.\n\n    // Note that dir is not unit length on purpose. Its length is \"directionality\", like\n    // for the directional specular lightmaps.\n\n    half halfLambert = dot(normalWorld, dirTex.xyz - 0.5) + 0.5;\n\n    return color * halfLambert / max(1e-4h, dirTex.w);\n}\n#endif\n\n#ifdef _LIGHTMAPMODE_SH\nvoid BakerySH(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 L0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 nL1x = BakeryTex2D(_RNM0, lmUV) * 2 - 1;\n    float3 nL1y = BakeryTex2D(_RNM1, lmUV) * 2 - 1;\n    float3 nL1z = BakeryTex2D(_RNM2, lmUV) * 2 - 1;\n    float3 L1x = nL1x * L0 * 2;\n    float3 L1y = nL1y * L0 * 2;\n    float3 L1z = nL1z * L0 * 2;\n\n    float3 sh;\n#if BAKERY_SHNONLINEAR\n    float lumaL0 = dot(L0, 1);\n    float lumaL1x = dot(L1x, 1);\n    float lumaL1y = dot(L1y, 1);\n    float lumaL1z = dot(L1z, 1);\n    float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    float regularLumaSH = dot(sh, 1);\n    //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n    sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n    //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n    //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n#else\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n#endif\n\n    diffuseColor = max(sh, 0.0);\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n        float focus = saturate(length(dominantDir));\n        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n        half nh = saturate(dot(normalWorld, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n\n        sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n\n        specularColor = max(spec * sh, 0.0);\n    #endif\n}\n#endif\n\n#endif // include guards\n\n\n    void Ext_ModifyVertex15 (inout VertexData v, inout ExtraV2F e)\n    {\n        #if _USEBAKERY\n\t\t    #if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\t\t\t    // Unpack from RGBM\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.a * 8.0f;\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.rgb;\n\n\t\t\t    #ifdef BAKERY_VERTEXLMMASK\n\t\t\t\t    e.extraV2F4.xyzw = unpack4NFloats(v.texcoord1);\n\t\t\t    #endif\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXSH\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n                e.extraV2F6.xyz = unpack3NFloats(v.texcoord3.x) * 2 - 1;\n                e.extraV2F7.xyz = unpack3NFloats(v.texcoord3.y) * 2 - 1;\n            #endif\n       #endif\n    }\n\n#if _HDRP || _URP\n    half3 SHEvalLinearL0L1 (half4 normal)\n    {\n        half3 x;\n\n        // Linear (L1) + constant (L0) polynomial terms\n        x.r = dot(unity_SHAr,normal);\n        x.g = dot(unity_SHAg,normal);\n        x.b = dot(unity_SHAb,normal);\n\n        return x;\n    }\n\n    // normal should be normalized, w=1.0\n    half3 SHEvalLinearL2 (half4 normal)\n    {\n        half3 x1, x2;\n        // 4 of the quadratic (L2) polynomials\n        half4 vB = normal.xyzz * normal.yzzx;\n        x1.r = dot(unity_SHBr,vB);\n        x1.g = dot(unity_SHBg,vB);\n        x1.b = dot(unity_SHBb,vB);\n\n        // Final (5th) quadratic (L2) polynomial\n        half vC = normal.x*normal.x - normal.y*normal.y;\n        x2 = unity_SHC.rgb * vC;\n\n        return x1 + x2;\n    }\n\n    half3 ShadeSH9 (half4 normal)\n    {\n        // Linear + constant polynomial terms\n        half3 res = SHEvalLinearL0L1 (normal);\n\n        // Quadratic polynomials\n        res += SHEvalLinearL2 (normal);\n\n        #ifdef UNITY_COLORSPACE_GAMMA\n            res = LinearToGamma (res);\n        #endif\n\n        return res;\n\n    }\n#endif\n\n\n\n\tvoid DoBakeryStuff(inout float3 indDif, inout float3 indSpec, inout float4 shadowmask, float3 tangentNormal, float smoothness, ShaderData d)\n\t{\n\t\t// Quality!\n\t\tindDif = 1;\n\t\tindSpec = 0;\n\n        #if defined(_PASSFORWARD) || defined(_PASSGBUFFER) // forward pass on URP/Standard/HDRP + built-in deferred\n\n            float3 normalWorld = mul(tangentNormal, d.TBNMatrix);\n\n\t\t\t#ifdef LIGHTMAP_ON\n\n                // Static\n\n\t\t\t\tfloat2 lmUV = d.texcoord1 * unity_LightmapST.xy + unity_LightmapST.zw;\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_STANDARD\n\t\t\t\t\tindDif = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n\n\t\t\t\t\t#ifdef DIRLIGHTMAP_COMBINED\n\t\t\t\t\t\tfloat4 dirMap = BakeryTex2D(unity_LightmapInd, lmUV);\n\t\t\t\t\t\tindDif = Unity_DecodeDirectionalLightmap(indDif, dirMap, normalWorld);\n\n\t\t\t\t\t\t#ifdef BAKERY_LMSPEC\n\t\t\t\t\t\t\tindSpec = BakeryDirectionalLightmapSpecular(lmUV, normalWorld, -d.worldSpaceViewDir, smoothness) * indDif;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\n\t\t\t\t\tindDif = d.vertexColor;\n\n                    #ifdef BAKERY_VERTEXLMMASK\n                        shadowmask = d.extraV2F4;\n                    #endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n\t\t\t\t\t\t// worldSpaceNormal is per-vertex\n\t\t\t\t\t\t// normalWorld is per-pixel\n\t\t\t\t\t\tfloat3 bakedLightDirection = d.extraV2F5;\n\t\t\t\t\t\tBakeryVertexLMDirection(indDif, indSpec, bakedLightDirection, d.worldSpaceNormal, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXSH\n\t\t\t\t\t\tBakeryVertexLMSH(indDif, indSpec, d.extraV2F5, d.extraV2F6, d.extraV2F7, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_RNM\n\t\t\t\t\tBakeryRNM(indDif, indSpec, lmUV, tangentNormal, smoothness, -d.tangentSpaceViewDir);\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_SH\n\t\t\t\t\tBakerySH(indDif, indSpec, lmUV, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t#endif\n\n            #else\n\n                // Dynamic\n\n                #ifdef BAKERY_VOLUME\n\n                    bool isGlobal = dot(abs(_VolumeInvSize),1) == 0;\n                    float3 volViewDir = -d.worldSpaceViewDir;\n                    #ifdef BAKERY_VOLROTATION\n                        float4x4 volMatrix = (isGlobal ? _GlobalVolumeMatrix : _VolumeMatrix);\n                        float3 volInvSize = (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 lpUV = mul(volMatrix, float4(d.worldSpacePosition,1)).xyz * volInvSize + 0.5f;\n                        float3 volNormal = mul((float3x3)volMatrix, normalWorld);\n                        #ifdef BAKERY_LMSPEC\n                            volViewDir = mul((float3x3)volMatrix, volViewDir);\n                        #endif\n                    #else\n                        float3 lpUV = (d.worldSpacePosition - (isGlobal ? _GlobalVolumeMin : _VolumeMin)) * (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 volNormal = normalWorld;\n                    #endif\n\n                    #ifdef BAKERY_COMPRESSED_VOLUME\n                        float4 tex0, tex1, tex2, tex3;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex3 = _Volume3.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz * L0;\n                        L1y = tex2.xyz * L0;\n                        L1z = tex3.xyz * L0;\n                    #else\n                        float4 tex0, tex1, tex2;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV);\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV);\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz;\n                        L1y = tex2.xyz;\n                        L1z = float3(tex0.w, tex1.w, tex2.w);\n                    #endif\n                    indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), volNormal);\n                    indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), volNormal);\n                    indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), volNormal);\n\n                    #ifdef UNITY_COLORSPACE_GAMMA\n                        indDif = pow(indDif, 1.0f / 2.2f);\n                    #endif\n\n                    #ifdef BAKERY_LMSPEC\n                        float3 nL1x = L1x / L0;\n                        float3 nL1y = L1y / L0;\n                        float3 nL1z = L1z / L0;\n                        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n                        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - volViewDir);\n                        half nh = saturate(dot(volNormal, halfDir));\n                        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n                        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n                        half spec = GGXTerm(nh, roughness);\n                        float3 sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n                        indSpec = max(spec * sh, 0.0);\n                    #endif\n\n                    shadowmask = _VolumeMask.Sample(sampler_Volume0, lpUV);\n\n                #else\n\n                    #ifdef BAKERY_SHNONLINEAR\n                        float3 L0 = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);\n                        indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, unity_SHAr.xyz, normalWorld);\n                        indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, unity_SHAg.xyz, normalWorld);\n                        indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, unity_SHAb.xyz, normalWorld);\n                    #else\n                        indDif = ShadeSH9(float4(normalWorld,1));\n                    #endif\n\n                #endif\n\n\t\t\t#endif\n\n        #endif\n\t}\n\n\t// this is the main surface function. Surface is like a surface shader output structure, but\n\t// with our new outputs as well.\n\tvoid Ext_SurfaceFunction15 (inout Surface o, ShaderData d)\n\t{\n        #if _USEBAKERY\n\t\t    float3 indDif;\n\t\t    float3 indSpec;\n            float4 shadowmask = 1;\n\t\t    DoBakeryStuff(indDif, indSpec, shadowmask, o.Normal, o.Smoothness, d);\n\t\t    o.DiffuseGI = indDif;\n\t\t    o.BackDiffuseGI = indDif;\n\t\t    o.SpecularGI = indSpec;\n            o.ShadowMask = shadowmask;\n        #endif\n\t}\n\n\n\n\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                  Ext_SurfaceFunction1(l, d);\n                  Ext_SurfaceFunction2(l, d);\n                  Ext_SurfaceFunction3(l, d);\n                  Ext_SurfaceFunction4(l, d);\n                  Ext_SurfaceFunction5(l, d);\n                  Ext_SurfaceFunction6(l, d);\n                  Ext_SurfaceFunction7(l, d);\n                  Ext_SurfaceFunction8(l, d);\n                  Ext_SurfaceFunction9(l, d);\n\t\t            Ext_SurfaceFunction10(l, d);\n                  Ext_SurfaceFunction11(l, d);\n                  Ext_SurfaceFunction12(l, d);\n                  Ext_SurfaceFunction13(l, d);\n                  Ext_SurfaceFunction14(l, d);\n                  Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraV2F d;\n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                  Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                  Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                  #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                  v2p.extraV2F4 = d.extraV2F4;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                  v2p.extraV2F5 = d.extraV2F5;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F6 = d.extraV2F6;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F7 = d.extraV2F7;\n                  #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                d.extraV2F4 = v2p.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                d.extraV2F5 = v2p.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F6 = v2p.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F7 = v2p.extraV2F7;\n                #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n                Ext_ModifyTessellatedVertex2(v, d);\n                Ext_ModifyTessellatedVertex3(v, d);\n                Ext_ModifyTessellatedVertex4(v, d);\n                Ext_ModifyTessellatedVertex5(v, d);\n                Ext_ModifyTessellatedVertex6(v, d);\n                Ext_ModifyTessellatedVertex7(v, d);\n                Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                v2p.extraV2F4 = d.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                v2p.extraV2F5 = d.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F6 = d.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F7 = d.extraV2F7;\n                #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n            // d.texcoord3 = i.texcoord3;\n             #endif\n\n             d.isFrontFace = facing;\n             #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n             d.vertexColor = i.vertexColor;\n             #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(i.worldPos, 1)).xyz;\n            #endif\n             d.localSpaceNormal = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n             #if LOD_FADE_CROSSFADE\n             d.screenPos = i.screenPos;\n             d.screenUV = (i.screenPos.xy / i.screenPos.w);\n             #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n             #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n             d.extraV2F4 = i.extraV2F4;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n             d.extraV2F5 = i.extraV2F5;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F6 = i.extraV2F6;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F7 = i.extraV2F7;\n             #endif\n\n            return d;\n         }\n         \n\n            \n\nstruct VaryingsToPS\n{\n   VertexToPixel vmesh;\n   #ifdef VARYINGS_NEED_PASS\n      VaryingsPassToPS vpass;\n   #endif\n};\n\nstruct PackedVaryingsToPS\n{\n   #ifdef VARYINGS_NEED_PASS\n      PackedVaryingsPassToPS vpass;\n   #endif\n   VertexToPixel vmesh;\n\n   UNITY_VERTEX_OUTPUT_STEREO\n};\n\nPackedVaryingsToPS PackVaryingsToPS(VaryingsToPS input)\n{\n   PackedVaryingsToPS output = (PackedVaryingsToPS)0;\n   output.vmesh = input.vmesh;\n   #ifdef VARYINGS_NEED_PASS\n      output.vpass = PackVaryingsPassToPS(input.vpass);\n   #endif\n\n   UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n   return output;\n}\n\n\n\n\nVertexToPixel VertMesh(VertexData input)\n{\n    VertexToPixel output = (VertexToPixel)0;\n\n    UNITY_SETUP_INSTANCE_ID(input);\n    UNITY_TRANSFER_INSTANCE_ID(input, output);\n\n    \n    ChainModifyVertex(input, output);\n\n\n    // This return the camera relative position (if enable)\n    float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n    float3 normalWS = TransformObjectToWorldNormal(input.normal);\n    float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n    output.worldPos = GetAbsolutePositionWS(positionRWS);\n    output.pos = TransformWorldToHClip(positionRWS);\n    output.worldNormal = normalWS;\n    output.worldTangent = tangentWS;\n\n\n    output.texcoord0 = input.texcoord0;\n    output.texcoord1 = input.texcoord1;\n    output.texcoord2 = input.texcoord2;\n     #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n    // output.texcoord3 = input.texcoord3;\n     #endif\n\n     #if LOD_FADE_CROSSFADE\n     output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n     #endif\n\n     #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n     output.vertexColor = input.vertexColor;\n     #endif\n    return output;\n}\n\n\n#if (SHADERPASS == SHADERPASS_DBUFFER_MESH)\nvoid MeshDecalsPositionZBias(inout VaryingsToPS input)\n{\n#if defined(UNITY_REVERSED_Z)\n    input.vmesh.pos.z -= _DecalMeshDepthBias;\n#else\n    input.vmesh.pos.z += _DecalMeshDepthBias;\n#endif\n}\n#endif\n\n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n// This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\nfloat unity_OneOverOutputBoost;\nfloat unity_MaxOutputValue;\n\nCBUFFER_START(UnityMetaPass)\n// x = use uv1 as raster position\n// y = use uv2 as raster position\nbool4 unity_MetaVertexControl;\n\n// x = return albedo\n// y = return normal\nbool4 unity_MetaFragmentControl;\nCBUFFER_END\n\nPackedVaryingsToPS Vert(VertexData inputMesh)\n{\n    VaryingsToPS output = (VaryingsToPS)0;\n    output.vmesh = (VertexToPixel)0;\n\n    UNITY_SETUP_INSTANCE_ID(inputMesh);\n    UNITY_TRANSFER_INSTANCE_ID(inputMesh, output.vmesh);\n\n    // Output UV coordinate in vertex shader\n    float2 uv = float2(0.0, 0.0);\n\n    if (unity_MetaVertexControl.x)\n    {\n        uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n    }\n    else if (unity_MetaVertexControl.y)\n    {\n        uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n    }\n\n    // OpenGL right now needs to actually use the incoming vertex position\n    // so we create a fake dependency on it here that haven't any impact.\n    output.vmesh.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n#ifdef VARYINGS_NEED_POSITION_WS\n    output.vmesh.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz);\n#endif\n\n#ifdef VARYINGS_NEED_TANGENT_TO_WORLD\n    // Normal is required for triplanar mapping\n    output.vmesh.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n    // Not required but assign to silent compiler warning\n    output.vmesh.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n#endif\n\n    output.vmesh.texcoord0 = inputMesh.texcoord0;\n    output.vmesh.texcoord1 = inputMesh.texcoord1;\n    output.vmesh.texcoord2 = inputMesh.texcoord2;\n     #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n    // output.vmesh.texcoord3 = inputMesh.texcoord3;\n     #endif\n\n     #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n     output.vmesh.vertexColor = inputMesh.vertexColor;\n     #endif\n\n    return PackVaryingsToPS(output);\n}\n#else\n\nPackedVaryingsToPS Vert(VertexData inputMesh)\n{\n    VaryingsToPS varyingsType;\n    varyingsType.vmesh = VertMesh(inputMesh);\n    #if (SHADERPASS == SHADERPASS_DBUFFER_MESH)\n       MeshDecalsPositionZBias(varyingsType);\n    #endif\n    return PackVaryingsToPS(varyingsType);\n}\n\n#endif\n\n\n\n            \n\n            \n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n            \n                    output.positionRWS = input.worldPos;\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n            \n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n        \n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n        \n           #ifdef _HAS_REFRACTION\n                   if (_EnableSSRefraction)\n                   {\n                       // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                       // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                       // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n        \n                       surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                       surfaceDescription.Alpha = 1.0;\n                   }\n                   else\n                   {\n                       surfaceData.ior = 1.0;\n                       surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                       surfaceData.atDistance = 1.0;\n                       surfaceData.transmittanceMask = 0.0;\n                       surfaceDescription.Alpha = 1.0;\n                   }\n           #else\n                   surfaceData.ior = 1.0;\n                   surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                   surfaceData.atDistance = 1.0;\n                   surfaceData.transmittanceMask = 0.0;\n           #endif\n                \n                   // These static material feature allow compile time optimization\n                   surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n           #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n           #endif\n           #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n           #endif\n           #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n           #endif\n                   // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n        \n           #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n           #endif\n           #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n           #endif\n        \n           #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                   // Require to have setup baseColor\n                   // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                   surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n           #endif\n\n        \n                   // tangent-space normal\n                   float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                   normalTS = surfaceDescription.Normal;\n        \n                   // compute world space normal\n                   #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(normalTS, fragInputs.tangentToWorld);\n                   #else\n                      surfaceData.normalWS = normalTS;  \n                   #endif\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                   // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent, fragInputs.tangentToWorld);\n        \n           #if HAVE_DECALS\n                   if (_EnableDecals)\n                   {\n                       #if VERSION_GREATER_EQUAL(10,2)\n                          DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput,  surfaceData.geomNormalWS, surfaceDescription.Alpha);\n                          ApplyDecalToSurfaceData(decalSurfaceData,  surfaceData.geomNormalWS, surfaceData);\n                       #else\n                          DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                          ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                       #endif\n                   }\n           #endif\n        \n                   bentNormalWS = surfaceData.normalWS;\n               \n                   surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n        \n        \n                   // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                   // If user provide bent normal then we process a better term\n           #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                   // Just use the value passed through via the slot (not active otherwise)\n           #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                   // If we have bent normal and ambient occlusion, process a specular occlusion\n                   surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n           #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                   surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n           #endif\n        \n           #ifdef _ENABLE_GEOMETRIC_SPECULAR_AA\n                   surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n           #endif\n        \n           #ifdef DEBUG_DISPLAY\n                   if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                   {\n                       // TODO: need to update mip info\n                       surfaceData.metallic = 0;\n                   }\n        \n                   // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                   // as it can modify attribute use for static lighting\n                   ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n           #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //    uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to _ScreenSize values\n                 //    LODDitheringTransition(fadeMaskSeed, unity_LODFade.x);\n                 //#endif\n        \n                 d = CreateShaderData(m2ps\n                  #if NEED_FACING\n                    , facing\n                  #endif\n                 );\n\n                 \n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #ifdef _DEPTHOFFSET_ON\n                    l.outputDepth = posInput.deviceDepth;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #ifdef _DEPTHOFFSET_ON\n                    posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n        \n                 #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     //builtinData.distortion = surfaceDescription.Distortion;\n                     //builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                     builtinData.distortion = float2(0.0, 0.0);\n                     builtinData.distortionBlur = 0.0;\n                 #else\n                     builtinData.distortion = float2(0.0, 0.0);\n                     builtinData.distortionBlur = 0.0;\n                 #endif\n        \n                   PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n               }\n        \n\n            \n            void Frag(  PackedVaryingsToPS packedInput\n            #ifdef WRITE_NORMAL_BUFFER\n            , out float4 outNormalBuffer : SV_Target0\n                #ifdef WRITE_MSAA_DEPTH\n                , out float1 depthColor : SV_Target1\n                #endif\n            #elif defined(WRITE_MSAA_DEPTH) // When only WRITE_MSAA_DEPTH is define and not WRITE_NORMAL_BUFFER it mean we are Unlit and only need depth, but we still have normal buffer binded\n            , out float4 outNormalBuffer : SV_Target0\n            , out float1 depthColor : SV_Target1\n            #elif defined(SCENESELECTIONPASS)\n            , out float4 outColor : SV_Target0\n            #endif\n\n            #ifdef _DEPTHOFFSET_ON\n            , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n            , bool facing : SV_IsFrontFace\n            #endif\n        )\n         {\n             UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(packedInput);\n             FragInputs input = BuildFragInputs(packedInput.vmesh);\n\n             // input.positionSS is SV_Position\n             PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n         #ifdef VARYINGS_NEED_POSITION_WS\n             float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n         #else\n             // Unused\n             float3 V = float3(1.0, 1.0, 1.0); // Avoid the division by 0\n         #endif\n\n            SurfaceData surfaceData;\n            BuiltinData builtinData;\n            Surface l;\n            ShaderData d;\n            GetSurfaceAndBuiltinData(packedInput.vmesh, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n\n\n         #ifdef _DEPTHOFFSET_ON\n             outputDepth = posInput.deviceDepth;\n         #endif\n\n         #ifdef WRITE_NORMAL_BUFFER\n             EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), posInput.positionSS, outNormalBuffer);\n             #ifdef WRITE_MSAA_DEPTH\n             // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer\n             depthColor = packedInput.vmesh.pos.z;\n             #endif\n         #elif defined(WRITE_MSAA_DEPTH) // When we are MSAA depth only without normal buffer\n             // Due to the binding order of these two render targets, we need to have them both declared\n             outNormalBuffer = float4(0.0, 0.0, 0.0, 1.0);\n             // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer\n             depthColor = packedInput.vmesh.pos.z;\n         #elif defined(SCENESELECTIONPASS)\n             // We use depth prepass for scene selection in the editor, this code allow to output the outline correctly\n             outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);\n         #endif\n         }\n\n         ENDHLSL\n     }\n\n        \n      \n      \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   }\n   \n   \n   CustomEditor \"JBooth.BetterLit.LitBaseMaterialEditor\"\n}\n"},{"srpTarget":0,"UnityVersionMin":20194,"UnityVersionMax":30000,"shader":{"instanceID":0},"shaderSrc":"////////////////////////////////////////\n// Generated with Better Shaders\n//\n// Auto-generated shader code, don't hand edit!\n//\n//   Unity Version: 2020.3.0f1\n//   Render Pipeline: Standard\n//   Platform: OSXEditor\n////////////////////////////////////////\n\n\nShader \"Hidden/Better Lit/Lit Alpha\"\n{\n   Properties\n   {\n      \n   [HideInInspector]_NoiseTex(\"Noise Texture\", 2D) = \"black\" {}\n\n\n    [HideInInspector]_MainTex(\"Unity Standard Shader Hack Property\", 2D) = \"white\" {} // use this to do material conversion.\n    [HideInInspector]_BaseColor(\"Unity HDRP/URP Shader Hack Property\", 2D) = \"white\" {} // use this to do material conversion.\n    [HideInInspector]_BumpMap(\"Unity Standard Shader Hack Property\", 2D) = \"bump\" {} // use this to do material conversion.\n    [HideInInspector]_IsConverted(\"Have we done one time conversion yet?\", Float) = 0\n    \n    _TriplanarSpace (\"Triplanar Space\", Float) = 0\n    _TriplanarContrast (\"Triplanar Contrast\", Range(1, 10)) = 4\n    _UVSource(\"UV Source\", Float) = 0\n    _AlbedoMap(\"Albedo/Height\", 2D) = \"white\" {}\n    _Tint (\"Tint\", Color) = (1, 1, 1, 1)\n    _AlbedoBrightness(\"Brightness\", Range(-1, 1)) = 0\n    _AlbedoContrast(\"Contrast\", Range(0,2)) = 1\n    _AlphaThreshold(\"Alpha Threshold\", Range(0,1)) = 0.0\n    _Cutoff(\"Unity Lightmapper sucks\", Range(0, 1)) = 0.0\n    _NormalMap(\"Normal\", 2D) = \"bump\" {}\n    _NormalStrength(\"Normal Strength\", Range(0,2)) = 1\n    \n    _MaskMap(\"Mask Map\", 2D) = \"black\" {}\n    _Smoothness(\"Smoothness\", Range(0,1)) = 0\n    _Metallic(\"Metallic\", Range(0,1)) = 0\n    _SpecularMap(\"Specular Map\", 2D) = \"black\" {}\n\n    _EmissionMap(\"Emission Map\", 2D) = \"black\" {}\n    _EmissionColor(\"Emission Strength\", Color) = (0,0,0,0)\n\n    _SmoothnessRemap(\"Smoothness Remap\", Vector) = (0, 1, 0, 0)\n    _AORemap(\"AO Remap\", Vector) = (0, 1, 0, 0)\n    _MetallicRemap(\"Metallic Remap\", Vector) = (0, 1, 0, 0)\n    _HeightRemap(\"Height Remap\", Vector) = (0, 1, 0, 0)\n\n    _DetailUVSource(\"Detail UV Source\", Float) = 0\n    _DetailMap(\"Detail Map\", 2D) = \"white\" {}\n    _DetailAlbedoStrength(\"Detail Albedo Strength\", Range(0, 2)) = 1\n    _DetailNormalStrength(\"Detail Normal Strength\", Range(0, 2)) = 1\n    _DetailSmoothnessStrength(\"Detail Smoothness Strength\", Range(0, 2)) = 1\n    _DetailTriplanarSpace (\"Triplanar Space\", Float) = 0\n    _DetailTriplanarContrast (\"Triplanar Contrast\", Range(1, 10)) = 4\n    _DetailStochasticContrast(\"Stochastic Contrast\", Range(0.01,0.999)) = 0.7\n    _DetailStochasticScale(\"Stochastic Contrast\", Range(0.2,1.5)) = 0.5\n    _FlatShadingBlend(\"Flat Shading Blend\", Range(0,4)) = 1\n    _StochasticContrast(\"Stochastic Contrast\", Range(0.01,0.999)) = 0.7\n    _StochasticScale(\"Stochastic Contrast\", Range(0.2,1.5)) = 0.5\n    _ParallaxHeight(\"Parallax Height\", Range(0, 0.25)) = 0\n\n    _MicroShadowStrength(\"Micro Shadow Strength\", Range(0, 2)) = 0\n    _FuzzyShadingOn(\"FuzzyShadingToggle\", Float) = 0\n    _FuzzyShadingColor(\"Fuzzy Shading Color\", Color) = (1,1,1,1)\n    _FuzzyShadingParams(\"Fuzzy Shading Params\", Vector) = (0.3,1,1.5,1) // coreMult, edgeMult, power\n\n    //_POMMaxSamples (\"POM Max Samples\", Range(4, 32)) = 8\n    //_POMMin (\"POM Min Distance\", Float) = 25\n    //_POMFade (\"Pom Fade Range\", Float) = 25\n\n\n\n\t_TintMask(\"Tint Mask\", 2D) = \"white\" {}\n\t_RColor(\"R Color\", Color) = (0.5,0.5,0.5,1)\n\t_GColor(\"G Color\", Color) = (0.5,0.5,0.5,1)\n\t_BColor(\"B Color\", Color) = (0.5,0.5,0.5,1)\n\t_AColor(\"A Color\", Color) = (0.5,0.5,0.5,1)\n\n\n\t_LayerTextureMask(\"Layer Texture Mask\", 2D) = \"white\" {}\n    _LayerTextureMaskUVMode(\"Layer Texture Mask UV Mode\", Float) = 0\n\n\n\t_LayerUVSource(\"Detail UV Source\", Float) = 0\n    [Enum(Multiply2X, 0, AlphaBlend, 1, HeightBlend, 2)]_LayerBlendMode(\"Layer Blend Mode\", Float) = 0\n    _LayerStrength(\"Layer Strength\", Range(0,2)) = 1\n    _LayerAlbedoStrength(\"Detail Albedo Strength\", Range(0, 2)) = 1\n    _LayerNormalStrength(\"Detail Normal Strength\", Range(0, 2)) = 1\n    _LayerSmoothnessRemap(\"Smoothness Remap\", Vector) = (0, 1, 0, 0)\n    _LayerAORemap(\"Occlusion Remap\", Vector) = (0, 1, 0, 0)\n    _LayerMetallicRemap(\"Metallic Remap\", Vector) = (0, 1, 0, 0)\n    _LayerSmoothness(\"Smoothness\", Range(0,1)) = 0\n    _LayerSmoothnessStrength(\"Smoothness Strength\", Range(0,1)) = 1\n    _LayerHeightRemap(\"Height Remap\", Vector) = (0, 1, 0, 0)\n    _LayerHeightContrast(\"Height Contrast\", Range(0.01, 0.99)) = 0.5\n    _LayerMetallic(\"Metallic\", Range(0,1)) = 0\n    _LayerScale(\"Detail UV Scale\", Float) = 3\n    _LayerTriplanarSpace (\"Triplanar Space\", Float) = 0\n    _LayerTriplanarContrast (\"Triplanar Contrast\", Range(1, 10)) = 4\n    _LayerAlbedoMap(\"Albedo/Height\", 2D) = \"white\" {}\n    _LayerNormalMap(\"Normal\", 2D) = \"bump\" {}\n    _LayerMaskMap(\"Mask Map\", 2D) = \"black\" {}\n    _LayerNoiseFrequency(\"Noise Frequency\", Float) = 1\n    _LayerNoiseAmplitude(\"Noise Amplitude\", Range(0,10)) = 0.5\n    _LayerNoiseOffset(\"Noise Offset\", Float) = 0\n    _LayerNoiseCenter(\"Noise Center\", Range(-5, 5)) = 0\n    _LayerStochasticContrast(\"Stochastic Contrast\", Range(0.01,0.999)) = 0.7\n    _LayerStochasticScale(\"Stochastic Scale\", Range(0.2,1.5)) = 0.5\n    _LayerBlendTint(\"Layer Blend Tint\", Color) = (1,1,1,1)\n    _LayerBlendContrast(\"Layer Blend Contrast\", Range(0.5, 8)) = 2\n    _LayerTint(\"Layer Tint\", Color) = (1,1,1,1)\n    _LayerAlbedoBrightness(\"Layer Brightness\", Range(-1, 1)) = 0\n    _LayerAlbedoContrast(\"Layer Contrast\", Range(0, 2)) = 1\n    _LayerEmissionMap(\"Layer Emission Map\", 2D) = \"black\" {}\n    _LayerEmissionColor(\"Layer Emission Multiplier\", Color) = (0,0,0,0)\n    _LayerAngleMin(\"Angle Minimum\", Range(0,1)) = 0.1\n    _LayerVertexNormalBlend(\"Vertex->Normal Filter\", Range(0,1)) = 0.8\n    _LayerHeight(\"Height Filter\", Range(0,1)) = 0\n    [Enum(Top,0,Bottom,1)] _LayerInvertHeight (\"Layer on\", Float) = 0\n    _LayerFalloff(\"Angle Falloff Contrast\", Range(2, 40)) = 8\n    _LayerTessStrength(\"Displacement Strength\", Range(0,1)) = 1\n    _LayerWeightOverDistance(\"Weight Over Distance\", Vector) = (1,1,1,1) // start distance/weight, end fade range/weight\n    _LayerMicroShadowStrength(\"Micro Shadow Strength\", Range(0,2)) = 0\n    _LayerFuzzyShadingOn(\"FuzzyShadingToggle\", Float) = 0\n    _LayerFuzzyShadingColor(\"Fuzzy Shading Color\", Color) = (1,1,1,1)\n    _LayerFuzzyShadingParams(\"Fuzzy Shading Params\", Vector) = (0.3,1,1.5,1) // coreMult, edgeMult, power\n\n\n\n\n\t_LayerUVSource_Ext_1(\"Detail UV Source\", Float) = 0\n    [Enum(Multiply2X, 0, AlphaBlend, 1, HeightBlend, 2)]_LayerBlendMode_Ext_1(\"Layer Blend Mode\", Float) = 0\n    _LayerStrength_Ext_1(\"Layer Strength\", Range(0,2)) = 1\n    _LayerAlbedoStrength_Ext_1(\"Detail Albedo Strength\", Range(0, 2)) = 1\n    _LayerNormalStrength_Ext_1(\"Detail Normal Strength\", Range(0, 2)) = 1\n    _LayerSmoothnessRemap_Ext_1(\"Smoothness Remap\", Vector) = (0, 1, 0, 0)\n    _LayerAORemap_Ext_1(\"Occlusion Remap\", Vector) = (0, 1, 0, 0)\n    _LayerMetallicRemap_Ext_1(\"Metallic Remap\", Vector) = (0, 1, 0, 0)\n    _LayerSmoothness_Ext_1(\"Smoothness\", Range(0,1)) = 0\n    _LayerSmoothnessStrength_Ext_1(\"Smoothness Strength\", Range(0,1)) = 1\n    _LayerHeightRemap_Ext_1(\"Height Remap\", Vector) = (0, 1, 0, 0)\n    _LayerHeightContrast_Ext_1(\"Height Contrast\", Range(0.01, 0.99)) = 0.5\n    _LayerMetallic_Ext_1(\"Metallic\", Range(0,1)) = 0\n    _LayerScale_Ext_1(\"Detail UV Scale\", Float) = 3\n    _LayerTriplanarSpace_Ext_1 (\"Triplanar Space\", Float) = 0\n    _LayerTriplanarContrast_Ext_1 (\"Triplanar Contrast\", Range(1, 10)) = 4\n    _LayerAlbedoMap_Ext_1(\"Albedo/Height\", 2D) = \"white\" {}\n    _LayerNormalMap_Ext_1(\"Normal\", 2D) = \"bump\" {}\n    _LayerMaskMap_Ext_1(\"Mask Map\", 2D) = \"black\" {}\n    _LayerNoiseFrequency_Ext_1(\"Noise Frequency\", Float) = 1\n    _LayerNoiseAmplitude_Ext_1(\"Noise Amplitude\", Range(0,10)) = 0.5\n    _LayerNoiseOffset_Ext_1(\"Noise Offset\", Float) = 0\n    _LayerNoiseCenter_Ext_1(\"Noise Center\", Range(-5, 5)) = 0\n    _LayerStochasticContrast_Ext_1(\"Stochastic Contrast\", Range(0.01,0.999)) = 0.7\n    _LayerStochasticScale_Ext_1(\"Stochastic Scale\", Range(0.2,1.5)) = 0.5\n    _LayerBlendTint_Ext_1(\"Layer Blend Tint\", Color) = (1,1,1,1)\n    _LayerBlendContrast_Ext_1(\"Layer Blend Contrast\", Range(0.5, 8)) = 2\n    _LayerTint_Ext_1(\"Layer Tint\", Color) = (1,1,1,1)\n    _LayerAlbedoBrightness_Ext_1(\"Layer Brightness\", Range(-1, 1)) = 0\n    _LayerAlbedoContrast_Ext_1(\"Layer Contrast\", Range(0, 2)) = 1\n    _LayerEmissionMap_Ext_1(\"Layer Emission Map\", 2D) = \"black\" {}\n    _LayerEmissionColor_Ext_1(\"Layer Emission Multiplier\", Color) = (0,0,0,0)\n    _LayerAngleMin_Ext_1(\"Angle Minimum\", Range(0,1)) = 0.1\n    _LayerVertexNormalBlend_Ext_1(\"Vertex->Normal Filter\", Range(0,1)) = 0.8\n    _LayerHeight_Ext_1(\"Height Filter\", Range(0,1)) = 0\n    [Enum(Top,0,Bottom,1)] _LayerInvertHeight_Ext_1 (\"Layer on\", Float) = 0\n    _LayerFalloff_Ext_1(\"Angle Falloff Contrast\", Range(2, 40)) = 8\n    _LayerTessStrength_Ext_1(\"Displacement Strength\", Range(0,1)) = 1\n    _LayerWeightOverDistance_Ext_1(\"Weight Over Distance\", Vector) = (1,1,1,1) // start distance/weight, end fade range/weight\n    _LayerMicroShadowStrength_Ext_1(\"Micro Shadow Strength\", Range(0,2)) = 0\n    _LayerFuzzyShadingOn_Ext_1(\"FuzzyShadingToggle\", Float) = 0\n    _LayerFuzzyShadingColor_Ext_1(\"Fuzzy Shading Color\", Color) = (1,1,1,1)\n    _LayerFuzzyShadingParams_Ext_1(\"Fuzzy Shading Params\", Vector) = (0.3,1,1.5,1) // coreMult, edgeMult, power\n\n\n\n\n\t_LayerUVSource_Ext_2(\"Detail UV Source\", Float) = 0\n    [Enum(Multiply2X, 0, AlphaBlend, 1, HeightBlend, 2)]_LayerBlendMode_Ext_2(\"Layer Blend Mode\", Float) = 0\n    _LayerStrength_Ext_2(\"Layer Strength\", Range(0,2)) = 1\n    _LayerAlbedoStrength_Ext_2(\"Detail Albedo Strength\", Range(0, 2)) = 1\n    _LayerNormalStrength_Ext_2(\"Detail Normal Strength\", Range(0, 2)) = 1\n    _LayerSmoothnessRemap_Ext_2(\"Smoothness Remap\", Vector) = (0, 1, 0, 0)\n    _LayerAORemap_Ext_2(\"Occlusion Remap\", Vector) = (0, 1, 0, 0)\n    _LayerMetallicRemap_Ext_2(\"Metallic Remap\", Vector) = (0, 1, 0, 0)\n    _LayerSmoothness_Ext_2(\"Smoothness\", Range(0,1)) = 0\n    _LayerSmoothnessStrength_Ext_2(\"Smoothness Strength\", Range(0,1)) = 1\n    _LayerHeightRemap_Ext_2(\"Height Remap\", Vector) = (0, 1, 0, 0)\n    _LayerHeightContrast_Ext_2(\"Height Contrast\", Range(0.01, 0.99)) = 0.5\n    _LayerMetallic_Ext_2(\"Metallic\", Range(0,1)) = 0\n    _LayerScale_Ext_2(\"Detail UV Scale\", Float) = 3\n    _LayerTriplanarSpace_Ext_2 (\"Triplanar Space\", Float) = 0\n    _LayerTriplanarContrast_Ext_2 (\"Triplanar Contrast\", Range(1, 10)) = 4\n    _LayerAlbedoMap_Ext_2(\"Albedo/Height\", 2D) = \"white\" {}\n    _LayerNormalMap_Ext_2(\"Normal\", 2D) = \"bump\" {}\n    _LayerMaskMap_Ext_2(\"Mask Map\", 2D) = \"black\" {}\n    _LayerNoiseFrequency_Ext_2(\"Noise Frequency\", Float) = 1\n    _LayerNoiseAmplitude_Ext_2(\"Noise Amplitude\", Range(0,10)) = 0.5\n    _LayerNoiseOffset_Ext_2(\"Noise Offset\", Float) = 0\n    _LayerNoiseCenter_Ext_2(\"Noise Center\", Range(-5, 5)) = 0\n    _LayerStochasticContrast_Ext_2(\"Stochastic Contrast\", Range(0.01,0.999)) = 0.7\n    _LayerStochasticScale_Ext_2(\"Stochastic Scale\", Range(0.2,1.5)) = 0.5\n    _LayerBlendTint_Ext_2(\"Layer Blend Tint\", Color) = (1,1,1,1)\n    _LayerBlendContrast_Ext_2(\"Layer Blend Contrast\", Range(0.5, 8)) = 2\n    _LayerTint_Ext_2(\"Layer Tint\", Color) = (1,1,1,1)\n    _LayerAlbedoBrightness_Ext_2(\"Layer Brightness\", Range(-1, 1)) = 0\n    _LayerAlbedoContrast_Ext_2(\"Layer Contrast\", Range(0, 2)) = 1\n    _LayerEmissionMap_Ext_2(\"Layer Emission Map\", 2D) = \"black\" {}\n    _LayerEmissionColor_Ext_2(\"Layer Emission Multiplier\", Color) = (0,0,0,0)\n    _LayerAngleMin_Ext_2(\"Angle Minimum\", Range(0,1)) = 0.1\n    _LayerVertexNormalBlend_Ext_2(\"Vertex->Normal Filter\", Range(0,1)) = 0.8\n    _LayerHeight_Ext_2(\"Height Filter\", Range(0,1)) = 0\n    [Enum(Top,0,Bottom,1)] _LayerInvertHeight_Ext_2 (\"Layer on\", Float) = 0\n    _LayerFalloff_Ext_2(\"Angle Falloff Contrast\", Range(2, 40)) = 8\n    _LayerTessStrength_Ext_2(\"Displacement Strength\", Range(0,1)) = 1\n    _LayerWeightOverDistance_Ext_2(\"Weight Over Distance\", Vector) = (1,1,1,1) // start distance/weight, end fade range/weight\n    _LayerMicroShadowStrength_Ext_2(\"Micro Shadow Strength\", Range(0,2)) = 0\n    _LayerFuzzyShadingOn_Ext_2(\"FuzzyShadingToggle\", Float) = 0\n    _LayerFuzzyShadingColor_Ext_2(\"Fuzzy Shading Color\", Color) = (1,1,1,1)\n    _LayerFuzzyShadingParams_Ext_2(\"Fuzzy Shading Params\", Vector) = (0.3,1,1.5,1) // coreMult, edgeMult, power\n\n\n\n\n    [Toggle] _Trax(\"Enable Trax\", Float) = 0\n    _TraxAlbedo(\"Trax Albedo\", 2D) = \"white\" {}\n    _TraxPackedNormal(\"Trax Packed Normal\", 2D) = \"bump\" {}\n    _TraxNormalStrength(\"Normal Strength\", Range(0,2)) = 1\n    _TraxDisplacementDepth(\"Trax Depression Depth\", Float) = 0.1\n    _TraxDisplacementStrength(\"Trax Displacement\", Range(0,3)) = 0.2\n    _TraxMipBias(\"Trax Mip Bias\", Range(0, 5)) = 3\n    _TraxInterpContrast(\"Interpolation Contrast\", Range(0,1)) = 0.9\n    _TraxHeightContrast(\"Height Contrast\", Range(0,1)) = 0.5\n    _TraxTint(\"Tint Color\", Color) = (1,1,1,1)\n\n\n   _WetnessMode(\"Wetness Mode\", Int) = 0\n   _PuddleMode(\"Puddle Mode\", Int) = 0\n   _RainMode(\"Rain Mode\", Int) = 0\n   _WetnessAmount(\"Wetness Amount\", Range(0,1)) = 0\n   _Porosity(\"Porosity\", Range(0,1)) = 0.4\n   _WetnessMin(\"Minimum Wetness\", Range(0,1)) = 0\n   _WetnessMax(\"Maximum Wetness\", Range(0,1)) = 1\n   _WetnessFalloff(\"Angle Falloff\", Range(0,1)) = 1\n   _WetnessAngleMin(\"Wetness Minimum Angle\", Range(-1,1)) = -1\n   _PuddleAmount(\"Puddle Amount\", Range(0,1)) = 0\n   _PuddleFalloff(\"Puddle Contrast\", Range(2, 50)) = 12\n   _PuddleAngleMin(\"Moss Angle Minimum\", Range(0,1)) = 0.1\n   _PuddleColor(\"Puddle Color\", Color) = (0.2, 0.2, 0.2, 0.7)\n   _PuddleNoiseFrequency(\"Noise Frequency\", Float) = 1\n   _PuddleNoiseAmplitude(\"Noise Amplitude\", Range(0,10)) = 0.5\n   _PuddleNoiseCenter(\"Noise Center\", Range(-5, 5)) = 0\n   _PuddleNoiseOffset(\"Noise Offset\", Float) = 0\n   _RainDropTexture(\"RainDrop Texture\", 2D) = \"white\" {}\n   _RainIntensityScale(\"Intensity/Scale/MinWet\", Vector) = (1, 25, 0, 0)\n   _WetnessShoreline(\"Wetness Shore Height\", Float) = -99999\n\n\n    _SnowMode(\"Snow Mode\", Int) = 0\n    _SnowAlbedo(\"Snow Albedo\", 2D) = \"white\" {}\n    _SnowTint(\"Snow Trax Albedo\", Color) = (1,1,1,1)\n    _SnowNormal(\"Snow Normal\", 2D) = \"bump\" {}\n    _SnowMaskMap(\"Snow Mask Map\", 2D) = \"black\" {}\n    _SnowAmount(\"Snow Amount\", Range(0,1)) = 1\n    _SnowAngle(\"Snow Angle Falloff\", Range(0,2)) = 1\n    _SnowContrast(\"Snow Contrast\", Range(0.5, 4)) = 1.5\n    _SnowVertexHeight(\"Snow Vertex Height\", Range(0,1)) = 0.05\n    _SnowWorldFade(\"Snow Height Fade\", Vector) = (100, 50, 0, 0)\n    _SnowTraxAlbedo(\"Snow Trax Albedo\", 2D) = \"white\" {}\n    _SnowTraxTint(\"Snow Trax Albedo\", Color) = (1,1,1,1)\n    _SnowTraxNormal(\"Snow Trax Normal\", 2D) = \"bump\" {}\n    _SnowTraxMaskMap(\"Snow Trax Mask Map\", 2D) = \"black\" {}\n    _SnowNoiseFreq(\"Snow Noise Frequency\", Float) = 1\n    _SnowNoiseAmp(\"Snow Noise Amplitude\", Float) = 1\n    _SnowNoiseOffset(\"Snow Noise Offset\", Float) = 0\n    _SnowStochasticContrast(\"Snow Stochastic Contrast\", Range(0.01, 0.99)) = 0.7\n    _SnowStochasticScale(\"Snow Stochastic Scale\", Range(0,2)) = 1\n\n\n   [BetterHeader(Wind Particulate)]\n   [Toggle] _Wind(\"Enable Wind\", Float) = 0\n   [Enum(World, 0, UV, 1)]_WindParticulateSpace(\"Wind UV Source\", Float) = 0\n   _WindParticulate(\"Wind Texture\", 2D) = \"black\" {}\n   _WindParticulateStrength(\"Strength\", Range(0, 3)) = 2\n   _WindParticulateSpeed(\"Speed\", Float) = 1\n   _WindParticulatePower(\"Contrast\", Range(0.2, 6)) = 1\n   _WindParticulateRotation(\"Rotation\", Float) = 0\n   _WindParticulateColor(\"Color, strength\", Color) = (1, 1, 1, 1)\n   _WindParticulateWorldHeightMask(\"Wind Height Mask\", Vector) = (-99999, -99999, 99999, 99999)\n   _WindParticulateTextureHeight(\"Wind Texture Height\", Range(0,1)) = 1\n   _WindParticulateAngleMask(\"Wind Angle Mask\", Vector) = (-1, -1, 1, 1)\n   _WindParticulateOcclusionStrength(\"Wind Occlusion Strength\", Range(0,1)) = 1\n   _WindParticulateEmissive(\"Wind Emissive\", Color) = (0,0,0,0)\n\n\n   [Enum(Off,0,Front,1,Back,2)]_CullMode(\"Culling Mode\", Float) = 2\n   [Enum(Flip, 0, Mirror, 1, None, 2)] _DoubleSidedNormalMode(\"Double sided normal mode\", Float) = 1\n\n\n   _AutoNormalStrength(\"Auto Normal Strength\", Range(0,2)) = 0.5\n\n\n\t_DebugSampleCountThreshold (\"Debug Sample Threshold\", Int) = 12\n\n\n\t[Toggle(_DISSOLVE)] _DissolveEnabled (\"Enable Dissolve\", Float) = 0\n    _DissolveAmount(\"Dissolve Amount\", Range(0,1)) = 0\n\t_DissolveTexture(\"Dissolve Texture\", 2D) = \"black\" {}\n    _DissolveGradient(\"Dissolve Gradient\", 2D) = \"white\" {}\n\t_DissolveColoration(\"Dissolve Coloration\", Range(0,1)) = 1\n\t_DissolveEdgeContrast(\"Dissolve Edge Contrast\", Range(2, 128)) = 10\n    _DissolveEmissiveStr(\"Dissolve Emissive Strength\", Range(0,4)) = 0\n\n\n\n\n\n\n\t[BetterHeader(Bakery)]\n    [Toggle(USEBAKERY)] _USEBAKERY (\"Enabled Bakery\", Float) = 0\n\t[KeywordEnum(Standard, RNM, SH, Vertex, VertexDirectional, VertexSH)] _LightmapMode (\"Lightmapping mode\", Float) = 0\n    [Toggle(BAKERY_VERTEXLMMASK)] _BAKERY_VERTEXLMMASK (\"Enable vertex shadowmask\", Float) = 0\n    [Toggle(BAKERY_SHNONLINEAR)] _BAKERY_SHNONLINEAR (\"SH non-linear mode\", Float) = 1\n    [Toggle(BAKERY_LMSPEC)] _BAKERY_LMSPEC (\"Enable Lightmap Specular\", Float) = 0\n    [Toggle(BAKERY_BICUBIC)] _BAKERY_BICUBIC (\"Enable Bicubic Filter\", Float) = 0\n    [Toggle(BAKERY_VOLUME)] _BAKERY_VOLUME (\"Use volumes\", Float) = 0\n    [Toggle(BAKERY_VOLROTATION)] _BAKERY_VOLROTATION (\"Allow volume rotation\", Float) = 0\n\n\n\n\n\n   _IsAlpha(\"Not Used or set, just so the editor knows we are an alpha shader\", Float) = 0\n\n\n   }\n   SubShader\n   {\n      Tags { \"RenderType\" = \"Transparent\" \"Queue\" = \"Transparent\" }\n\n      \n      \nZWrite Off ColorMask RGB\n\n\n      Pass\n      {\n\t\t   Name \"FORWARD\"\n\t\t   Tags { \"LightMode\" = \"ForwardBase\" }\n         Blend SrcAlpha OneMinusSrcAlpha\n            Cull [_CullMode]\n\n\n         CGPROGRAM\n         // compile directives\n            #pragma vertex Vert\n   #pragma fragment Frag\n\n         #pragma target 3.0\n         #pragma multi_compile_instancing\n         #pragma multi_compile_fog\n         #pragma multi_compile_fwdbase\n         #include \"HLSLSupport.cginc\"\n         #define UNITY_INSTANCED_LOD_FADE\n         #define UNITY_INSTANCED_SH\n         #define UNITY_INSTANCED_LIGHTMAPSTS\n\n         #include \"UnityShaderVariables.cginc\"\n         #include \"UnityShaderUtilities.cginc\"\n         // -------- variant for: <when no other keywords are defined>\n\n         #include \"UnityCG.cginc\"\n         #include \"Lighting.cginc\"\n         #include \"UnityPBSLighting.cginc\"\n         #include \"AutoLight.cginc\"\n         #define SHADER_PASS SHADERPASS_FORWARD\n         #define _PASSFORWARD 1\n\n         \n\n\n   #pragma shader_feature_local_fragment _ _PACKEDFAST\n   #pragma shader_feature_local _ _TRIPLANAR\n   #pragma shader_feature_local_fragment _ _NORMALMAP \n   #pragma shader_feature_local_fragment _ _MASKMAP\n   #pragma shader_feature_local_fragment _ _DETAIL\n   #pragma shader_feature_local_fragment _ _DETAILTRIPLANAR\n   #pragma shader_feature_local_fragment _ _DETAILSTOCHASTIC\n   #pragma shader_feature_local_fragment _ _EMISSION\n   #pragma shader_feature_local_fragment _ _FLATSHADE\n   #pragma shader_feature_local _ _STOCHASTIC\n   #pragma shader_feature_local_fragment _ _PARALLAX //_POM\n   #pragma shader_feature_local_fragment _ _SPECULAR\n   #pragma shader_feature_local _ _NOISEWORLD _NOISELOCAL\n   #pragma shader_feature_local _ _NOISEHQ _NOISETEXTURE _NOISEWORLEY\n   // only for URP/Standard Forward\n   #pragma shader_feature_local_fragment _ _SIMPLELIT\n\n\n   #pragma shader_feature_local_fragment _ _TINTMASK\n\n\n    #pragma shader_feature_local _ _LAYERVERTEXMASK _LAYERTEXTUREMASK\n\n    #define _HAS_WEIGHTTEXTURE_MASK 1\n\n\n   #pragma shader_feature_local _ _USELAYER\n   #pragma shader_feature_local _ _LAYERTRIPLANAR\n   #pragma shader_feature_local _ _LAYERALBEDO\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL\n   #pragma shader_feature_local _ _LAYERMASK\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION\n   #pragma shader_feature_local _ _LAYERNOISE\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC\n   #pragma shader_feature_local _ _LAYERANGLEFILTER\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_1\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_1\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_1\n   #pragma shader_feature_local _ _LAYERMASK_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_1\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_1\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_1\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_1\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_2\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_2\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_2\n   #pragma shader_feature_local _ _LAYERMASK_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_2\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_2\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_2\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_2\n\n\n   #pragma shader_feature_local _ _TRAX_ON\n\n\n   #pragma shader_feature_local_fragment _ _WETNESS\n   #pragma shader_feature_local_fragment _ _PUDDLES\n   #pragma shader_feature_local_fragment _ _PUDDLENOISE\n   #pragma shader_feature_local_fragment _ _RAINDROPS\n\n\n   #pragma shader_feature_local _ _SNOW\n   #pragma shader_feature_local _ _SNOWMASKMAP\n   #pragma shader_feature_local _ _SNOWNOISE\n   #pragma shader_feature_local_fragment _SNOWSTOCHASTIC\n\n\n   #pragma shader_feature_local_fragment _ _WIND_ON\n\n\n\n\n   #pragma shader_feature_local_fragment _ _SURFACEGRADIENT _AUTONORMAL\n   #define _WORLDSPACENORMAL 1\n\n\n   #pragma shader_feature_local _ _DEBUG_SAMPLECOUNT\n\n\n\t#pragma shader_feature_local_fragment _ _DISSOLVE\n\n\n   #pragma multi_compile_local  LOD_FADE_CROSSFADE\n\n\n\n#pragma instancing_options procedural:setupVSPro forwardadd\n\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\nstruct IndirectShaderData\n{\n\tfloat4x4 PositionMatrix;\n\tfloat4x4 InversePositionMatrix;\n\tfloat4 ControlData;\n};\n\n#if defined(SHADER_API_GLCORE) || defined(SHADER_API_D3D11) || defined(SHADER_API_GLES3) || defined(SHADER_API_METAL) || defined(SHADER_API_VULKAN) || defined(SHADER_API_PSSL) || defined(SHADER_API_XBOXONE)\n\tuniform StructuredBuffer<IndirectShaderData> VisibleShaderDataBuffer;\n#endif\n\n#endif\n\nfloat VSPRenderingLayerMask;\n\nvoid setupVSPro()\n{\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\n    #if _HDRP\n\t    unity_RenderingLayer.x = VSPRenderingLayerMask;\n    #endif\n\n\t#ifdef unity_ObjectToWorld\n\t#undef unity_ObjectToWorld\n\t#endif\n\n\t#ifdef unity_WorldToObject\n\t#undef unity_WorldToObject\n\t#endif\n\n\tunity_ObjectToWorld = VisibleShaderDataBuffer[unity_InstanceID].PositionMatrix;\n\tunity_WorldToObject = VisibleShaderDataBuffer[unity_InstanceID].InversePositionMatrix;\n#endif\n\n}\n\n\n\t#pragma multi_compile _LIGHTMAPMODE_STANDARD _LIGHTMAPMODE_RNM _LIGHTMAPMODE_SH _LIGHTMAPMODE_VERTEX _LIGHTMAPMODE_VERTEXDIRECTIONAL _LIGHTMAPMODE_VERTEXSH\n\n    #pragma shader_feature USEBAKERY\n    #pragma shader_feature BAKERY_VERTEXLMMASK\n    #pragma shader_feature BAKERY_SHNONLINEAR\n    #pragma shader_feature BAKERY_LMSPEC\n    #pragma shader_feature BAKERY_BICUBIC\n    #pragma shader_feature BAKERY_VOLUME\n    #pragma shader_feature BAKERY_VOLROTATION\n    #pragma shader_feature BAKERY_COMPRESSED_VOLUME\n\n    #if _USEBAKERY\n\t    #define _OVERRIDE_BAKEDGI\n        #if BAKERY_VOLUME || (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)) && defined(BAKERY_VERTEXLMMASK)\n            #define _OVERRIDE_SHADOWMASK\n        #endif\n    #endif\n\n\n\n\n\n\n\n\n   #define _STANDARD 1\n\n   #define _ALPHABLEND_ON 1\n// If your looking in here and thinking WTF, yeah, I know. These are taken from the SRPs, to allow us to use the same\n// texturing library they use. However, since they are not included in the standard pipeline by default, there is no\n// way to include them in and they have to be inlined, since someone could copy this shader onto another machine without\n// Better Shaders installed. Unfortunate, but I'd rather do this and have a nice library for texture sampling instead\n// of the patchy one Unity provides being inlined/emulated in HDRP/URP. Strangely, PSSL and XBoxOne libraries are not\n// included in the standard SRP code, but they are in tons of Unity own projects on the web, so I grabbed them from there.\n\n\n#if defined(SHADER_API_XBOXONE)\n\t\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n\n#elif defined(SHADER_API_PSSL)\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.GetLOD(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RW_Texture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RW_Texture2D_Array<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RW_Texture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n\n\n#elif defined(SHADER_API_D3D11)\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_METAL)\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)          Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)           Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)           Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_VULKAN)\n// This file assume SHADER_API_VULKAN is defined\n\t// TODO: This is a straight copy from D3D11.hlsl. Go through all this stuff and adjust where needed.\n\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)          Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)           Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)           Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_SWITCH)\n\t// This file assume SHADER_API_SWITCH is defined\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)          Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)           Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)           Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                       textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)              textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)     textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)          textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod) textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                       textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)              textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_GLCORE)\n\n\t// OpenGL 4.1 SM 5.0 https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html\n\t#if (SHADER_TARGET >= 46)\n\t#define OPENGL4_1_SM5 1\n\t#else\n\t#define OPENGL4_1_SM5 0\n\t#endif\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                  Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)            Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)                TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)          TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                  Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)            TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)      TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)          TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)    TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)            TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)             TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)       TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)           TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)     TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)             TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)   TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)         RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)   RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)         RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                    SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)                SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)                textureName.SampleGrad(samplerName, coord2, ddx, ddy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#ifdef UNITY_NO_CUBEMAP_ARRAY\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, bias) ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#else\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#endif\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                          textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                 textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                   textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)      textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                 textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)    textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\n\t#if OPENGL4_1_SM5\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   textureName.Gather(samplerName, float4(coord3, index))\n\t#else\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#endif\n\n\n\t#elif defined(SHADER_API_GLES3)\n\n\t// GLES 3.1 + AEP shader feature https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html\n\t#if (SHADER_TARGET >= 40)\n\t#define GLES3_1_AEP 1\n\t#else\n\t#define GLES3_1_AEP 0\n\t#endif\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                  Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)            Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)                TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)          TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                  Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)            Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)      Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)          TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)    TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)            Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)             Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)       Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)           TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)     TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)             Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)   TEXTURECUBE_ARRAY(textureName)\n\n\t#if GLES3_1_AEP\n\t#define RW_TEXTURE2D(type, textureName)         RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)   RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)         RWTexture3D<type> textureName\n\t#else\n\t#define RW_TEXTURE2D(type, textureName)         ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2D)\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)   ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2DArray)\n\t#define RW_TEXTURE3D(type, textureName)         ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture3D)\n\t#endif\n\n\t#define SAMPLER(samplerName)                    SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)                SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)                textureName.SampleGrad(samplerName, coord2, ddx, ddy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\n\t#ifdef UNITY_NO_CUBEMAP_ARRAY\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_BIAS)\n\t#else\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#endif\n\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                          textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                 textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                   textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)      textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                 textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)    textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                       textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                              textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                     textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                          textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)        textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)                 textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                       textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                              textureName.Load(int4(unCoord3, lod))\n\n\t#if GLES3_1_AEP\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherAlpha(samplerName, coord2)\n\t#else\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_RED_TEXTURE2D)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_GREEN_TEXTURE2D)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_BLUE_TEXTURE2D)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_ALPHA_TEXTURE2D)\n\t#endif\n\n\n#elif defined(SHADER_API_GLES)\n\n\n\t#define uint int\n\n\t#define rcp(x) 1.0 / (x)\n\t#define ddx_fine ddx\n\t#define ddy_fine ddy\n\t#define asfloat\n\t#define asuint(x) asint(x)\n\t#define f32tof16\n\t#define f16tof32\n\n\t#define ERROR_ON_UNSUPPORTED_FUNCTION(funcName) #error #funcName is not supported on GLES 2.0\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) #error calculate Level of Detail not supported in GLES2\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                          sampler2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)                    samplerCUBE textureName // No support to texture2DArray\n\t#define TEXTURECUBE(textureName)                        samplerCUBE textureName\n\t#define TEXTURECUBE_ARRAY(textureName)                  samplerCUBE textureName // No supoport to textureCubeArray and can't emulate with texture2DArray\n\t#define TEXTURE3D(textureName)                          sampler3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)                    sampler2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)              TEXTURECUBE_FLOAT(textureName) // No support to texture2DArray\n\t#define TEXTURECUBE_FLOAT(textureName)                  samplerCUBE_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)            TEXTURECUBE_FLOAT(textureName) // No support to textureCubeArray\n\t#define TEXTURE3D_FLOAT(textureName)                    sampler3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)                     sampler2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)               TEXTURECUBE_HALF(textureName) // No support to texture2DArray\n\t#define TEXTURECUBE_HALF(textureName)                   samplerCUBE_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)             TEXTURECUBE_HALF(textureName) // No support to textureCubeArray\n\t#define TEXTURE3D_HALF(textureName)                     sampler3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)                   SHADOW2D_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)             TEXTURECUBE_SHADOW(textureName) // No support to texture array\n\t#define TEXTURECUBE_SHADOW(textureName)                 SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)           TEXTURECUBE_SHADOW(textureName) // No support to texture array\n\n\t#define RW_TEXTURE2D(type, textureNam)                  ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2D)\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)           ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2DArray)\n\t#define RW_TEXTURE3D(type, textureNam)                  ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture3D)\n\n\t#define SAMPLER(samplerName)\n\t#define SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                sampler2D textureName\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)          samplerCUBE textureName\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)              samplerCUBE textureName\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        samplerCUBE textureName\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                sampler3D textureName\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)         SHADOW2D_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)   SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)       SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)               textureName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)         textureName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)             textureName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)       textureName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)               textureName\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)        textureName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)  textureName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)      textureName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2) tex2D(textureName, coord2)\n\n\t#if (SHADER_TARGET >= 30)\n\t    #define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod) tex2Dlod(textureName, float4(coord2, 0, lod))\n\t#else\n\t    // No lod support. Very poor approximation with bias.\n\t    #define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod) SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, lod)\n\t#endif\n\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                       tex2Dbias(textureName, float4(coord2, 0, bias))\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)                   SAMPLE_TEXTURE2D(textureName, samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                     ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY)\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)            ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_LOD)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)          ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_BIAS)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy)    ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_GRAD)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                                texCUBE(textureName, coord3)\n\t// No lod support. Very poor approximation with bias.\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                       SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                     texCUBEbias(textureName, float4(coord3, bias))\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                   ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)          ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)        ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_BIAS)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                                  tex3D(textureName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                         ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE3D_LOD)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                           SHADOW2D_SAMPLE(textureName, samplerName, coord3)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)              ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_SHADOW)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                         SHADOWCUBE_SAMPLE(textureName, samplerName, coord4)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)            ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_SHADOW)\n\n\n\t// Not supported. Can't define as error because shader library is calling these functions.\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                               half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                                      half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                             half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                                  half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)                half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)                         half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                               ERROR_ON_UNSUPPORTED_FUNCTION(LOAD_TEXTURE3D)\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                                      ERROR_ON_UNSUPPORTED_FUNCTION(LOAD_TEXTURE3D_LOD)\n\n\t// Gather not supported. Fallback to regular texture sampling.\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_RED_TEXTURE2D)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_GREEN_TEXTURE2D)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_BLUE_TEXTURE2D)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_ALPHA_TEXTURE2D)\n\n#else\n#error unsupported shader api\n#endif\n\n\n\n\n// default flow control attributes\n#ifndef UNITY_BRANCH\n#   define UNITY_BRANCH\n#endif\n#ifndef UNITY_FLATTEN\n#   define UNITY_FLATTEN\n#endif\n#ifndef UNITY_UNROLL\n#   define UNITY_UNROLL\n#endif\n#ifndef UNITY_UNROLLX\n#   define UNITY_UNROLLX(_x)\n#endif\n#ifndef UNITY_LOOP\n#   define UNITY_LOOP\n#endif\n\n\n\n#define NEED_FACING 1\n\n         // data across stages, stripped like the above.\n         struct VertexToPixel\n         {\n            UNITY_POSITION(pos);\n            float3 worldPos : TEXCOORD0;\n            float3 worldNormal : TEXCOORD1;\n            float4 worldTangent : TEXCOORD2;\n             float4 texcoord0 : TEXCCOORD3;\n             float4 texcoord1 : TEXCCOORD4;\n            // float4 texcoord2 : TEXCCOORD5;\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n            // float4 texcoord3 : TEXCCOORD6;\n             #endif\n\n             #if LOD_FADE_CROSSFADE\n             float4 screenPos : TEXCOORD7;\n             #endif\n\n            float4 lmap : TEXCOORD8;\n            #if UNITY_SHOULD_SAMPLE_SH\n               half3 sh : TEXCOORD9; // SH\n            #endif\n            #ifdef LIGHTMAP_ON\n               UNITY_LIGHTING_COORDS(10,11)\n               UNITY_FOG_COORDS(12)\n            #else\n               UNITY_FOG_COORDS(10)\n               UNITY_SHADOW_COORDS(11)\n            #endif\n\n             #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n             float4 vertexColor : COLOR_centroid;\n             #endif\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // float4 extraV2F0 : TEXCOORD13;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // float4 extraV2F1 : TEXCOORD14;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // float4 extraV2F2 : TEXCOORD15;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // float4 extraV2F3 : TEXCOORD16;\n            // #endif\n\n             #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n             float4 extraV2F4 : TEXCOORD17_centroid;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n             float4 extraV2F5 : TEXCOORD18_centroid;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             float4 extraV2F6 : TEXCOORD19_centroid;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             float4 extraV2F7 : TEXCOORD20_centroid;\n             #endif\n\n\n            UNITY_VERTEX_INPUT_INSTANCE_ID\n            UNITY_VERTEX_OUTPUT_STEREO\n         };\n\n         \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n   half4 weightTextureMask;\n   \n\n\n   float traxBuffer;\n\n\n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // would love to strip these, but they are used in certain\n               // combinations of the lighting system, and may be used\n               // by the user as well, so no easy way to strip them.\n\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR_centroid;\n                #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                float4 extraV2F4 : TEXCOORD9_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                float4 extraV2F5 : TEXCOORD10_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F6 : TEXCOORD11_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F7 : TEXCOORD12_centroid;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef UNITY_MATRIX_M\n               #undef UNITY_MATRIX_I_M\n               #undef UNITY_MATRIX_V\n               #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n               #undef UNITY_MATRIX_VP\n               #undef UNITY_MATRIX_MV\n               #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n               #undef UNITY_MATRIX_MVP\n\n               #define UNITY_MATRIX_M     unity_ObjectToWorld\n               #define UNITY_MATRIX_I_M   unity_WorldToObject\n               #define UNITY_MATRIX_V     unity_MatrixV\n               #define UNITY_MATRIX_I_V   unity_MatrixInvV\n               #define UNITY_MATRIX_P     OptimizeProjectionMatrix(glstate_matrix_projection)\n               #define UNITY_MATRIX_VP    unity_MatrixVP\n               #define UNITY_MATRIX_MV    mul(UNITY_MATRIX_V, UNITY_MATRIX_M)\n               #define UNITY_MATRIX_T_MV  transpose(UNITY_MATRIX_MV)\n               #define UNITY_MATRIX_IT_MV transpose(mul(UNITY_MATRIX_I_M, UNITY_MATRIX_I_V))\n               #define UNITY_MATRIX_MVP   mul(UNITY_MATRIX_VP, UNITY_MATRIX_M)\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)UNITY_MATRIX_M, transpose(mul(UNITY_MATRIX_I_M, UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)UNITY_MATRIX_V, norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n               #endif\n               #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n         \n\n\n   half4 _Tint;\n   half _UVSource;\n   half _TriplanarContrast;\n   half _AlbedoContrast;\n   half _AlbedoBrightness;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half3 _EmissionColor;\n   float _DetailUVSource;\n   half _StochasticScale;\n   half _DetailStochasticScale;\n   half _Smoothness;\n   half _Metallic;\n   half2 _SmoothnessRemap;\n   half2 _AORemap;\n   half2 _MetallicRemap;\n   half2 _HeightRemap;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n   half _AlphaThreshold;\n   half _Cutoff; // for Unity's light mapper\n   half _TriplanarSpace;\n   half _DetailTriplanarSpace;\n   half _DetailTriplanarContrast;\n   half _MicroShadowStrength;\n   half3 _FuzzyShadingColor;\n   half _FuzzyShadingOn;\n   half3 _FuzzyShadingParams;\n\n   //int _POMMaxSamples;\n   //float _POMMin;\n   //float _POMFade;\n#if _FLATSHADE\n   half _FlatShadingBlend;\n#endif\n\n   half _StochasticContrast;\n   half _DetailStochasticContrast;\n\n#if _PARALLAX || _POM\n   half _ParallaxHeight;\n#endif\n\n\n\n\tfloat4 _TintMask_ST;\n\thalf3 _RColor;\n\thalf3 _GColor;\n\thalf3 _BColor;\n\thalf3 _AColor;\n\n\n\thalf _LayerTextureMaskUVMode;\n    float4 _LayerTextureMask_ST;\n\n\n   //#if _USELAYER\n       float4 _LayerAlbedoMap_ST;\n       half3 _LayerTint;\n       half _LayerBlendMode;\n       float _LayerUVSource;\n       half _LayerAlbedoBrightness;\n       half _LayerAlbedoContrast;\n       half _LayerHeightContrast;\n       half _LayerStrength;\n       half _LayerAlbedoStrength;\n       half _LayerNormalStrength;\n       half _LayerSmoothnessStrength;\n       half _LayerSmoothness;\n       half _LayerMetallic;\n       half _LayerStochasticScale;\n       half2 _LayerSmoothnessRemap;\n       half2 _LayerAORemap;\n       half2 _LayerMetallicRemap;\n       half2 _LayerHeightRemap;\n       float4 _LayerWeightOverDistance;\n       half _LayerMicroShadowStrength;\n       //#if _LAYERNOISE\n           float _LayerNoiseFrequency;\n           float _LayerNoiseAmplitude;\n           float _LayerNoiseOffset;\n           float _LayerNoiseCenter;\n           half3 _LayerBlendTint;\n       //#endif\n       //#if _LAYERANGLEFILTER\n           half _LayerFalloff;\n           half _LayerAngleMin;\n           half _LayerHeight;\n           half _LayerInvertHeight;\n           half _LayerVertexNormalBlend;\n       //#endif\n       half _LayerTriplanarSpace;\n       half _LayerTriplanarContrast;\n       half _LayerBlendContrast;\n       half3 _LayerEmissionColor;\n       half _LayerStochasticContrast;\n       half _LayerTessStrength;\n       half3 _LayerFuzzyShadingColor;\n       half _LayerFuzzyShadingOn;\n       half3 _LayerFuzzyShadingParams;\n   //#endif\n\n\n   //#if _USELAYER_DEF_1\n       float4 _LayerAlbedoMap_Ext_1_ST;\n       half3 _LayerTint_Ext_1;\n       half _LayerBlendMode_Ext_1;\n       float _LayerUVSource_Ext_1;\n       half _LayerAlbedoBrightness_Ext_1;\n       half _LayerAlbedoContrast_Ext_1;\n       half _LayerHeightContrast_Ext_1;\n       half _LayerStrength_Ext_1;\n       half _LayerAlbedoStrength_Ext_1;\n       half _LayerNormalStrength_Ext_1;\n       half _LayerSmoothnessStrength_Ext_1;\n       half _LayerSmoothness_Ext_1;\n       half _LayerMetallic_Ext_1;\n       half _LayerStochasticScale_Ext_1;\n       half2 _LayerSmoothnessRemap_Ext_1;\n       half2 _LayerAORemap_Ext_1;\n       half2 _LayerMetallicRemap_Ext_1;\n       half2 _LayerHeightRemap_Ext_1;\n       float4 _LayerWeightOverDistance_Ext_1;\n       half _LayerMicroShadowStrength_Ext_1;\n       //#if _LAYERNOISE_DEF_1\n           float _LayerNoiseFrequency_Ext_1;\n           float _LayerNoiseAmplitude_Ext_1;\n           float _LayerNoiseOffset_Ext_1;\n           float _LayerNoiseCenter_Ext_1;\n           half3 _LayerBlendTint_Ext_1;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_1\n           half _LayerFalloff_Ext_1;\n           half _LayerAngleMin_Ext_1;\n           half _LayerHeight_Ext_1;\n           half _LayerInvertHeight_Ext_1;\n           half _LayerVertexNormalBlend_Ext_1;\n       //#endif\n       half _LayerTriplanarSpace_Ext_1;\n       half _LayerTriplanarContrast_Ext_1;\n       half _LayerBlendContrast_Ext_1;\n       half3 _LayerEmissionColor_Ext_1;\n       half _LayerStochasticContrast_Ext_1;\n       half _LayerTessStrength_Ext_1;\n       half3 _LayerFuzzyShadingColor_Ext_1;\n       half _LayerFuzzyShadingOn_Ext_1;\n       half3 _LayerFuzzyShadingParams_Ext_1;\n   //#endif\n\n\n   //#if _USELAYER_DEF_2\n       float4 _LayerAlbedoMap_Ext_2_ST;\n       half3 _LayerTint_Ext_2;\n       half _LayerBlendMode_Ext_2;\n       float _LayerUVSource_Ext_2;\n       half _LayerAlbedoBrightness_Ext_2;\n       half _LayerAlbedoContrast_Ext_2;\n       half _LayerHeightContrast_Ext_2;\n       half _LayerStrength_Ext_2;\n       half _LayerAlbedoStrength_Ext_2;\n       half _LayerNormalStrength_Ext_2;\n       half _LayerSmoothnessStrength_Ext_2;\n       half _LayerSmoothness_Ext_2;\n       half _LayerMetallic_Ext_2;\n       half _LayerStochasticScale_Ext_2;\n       half2 _LayerSmoothnessRemap_Ext_2;\n       half2 _LayerAORemap_Ext_2;\n       half2 _LayerMetallicRemap_Ext_2;\n       half2 _LayerHeightRemap_Ext_2;\n       float4 _LayerWeightOverDistance_Ext_2;\n       half _LayerMicroShadowStrength_Ext_2;\n       //#if _LAYERNOISE_DEF_2\n           float _LayerNoiseFrequency_Ext_2;\n           float _LayerNoiseAmplitude_Ext_2;\n           float _LayerNoiseOffset_Ext_2;\n           float _LayerNoiseCenter_Ext_2;\n           half3 _LayerBlendTint_Ext_2;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_2\n           half _LayerFalloff_Ext_2;\n           half _LayerAngleMin_Ext_2;\n           half _LayerHeight_Ext_2;\n           half _LayerInvertHeight_Ext_2;\n           half _LayerVertexNormalBlend_Ext_2;\n       //#endif\n       half _LayerTriplanarSpace_Ext_2;\n       half _LayerTriplanarContrast_Ext_2;\n       half _LayerBlendContrast_Ext_2;\n       half3 _LayerEmissionColor_Ext_2;\n       half _LayerStochasticContrast_Ext_2;\n       half _LayerTessStrength_Ext_2;\n       half3 _LayerFuzzyShadingColor_Ext_2;\n       half _LayerFuzzyShadingOn_Ext_2;\n       half3 _LayerFuzzyShadingParams_Ext_2;\n   //#endif\n\n\n    half _TraxDisplacementDepth;\n    half _TraxDisplacementStrength;\n    half _TraxMipBias;\n    half _TraxNormalStrength;\n    float4 _TraxAlbedo_ST;\n    half _TraxInterpContrast;\n    half _TraxHeightContrast;\n    half3 _TraxTint;\n\n\n\n    half _Porosity;\n    int _WetnessMode;\n    int _PuddleMode;\n\n    half  _PuddleAmount;\n    half  _PuddleFalloff;\n    half4 _PuddleColor;\n    half _PuddleNoiseFrequency;\n    half _PuddleNoiseAmplitude;\n    half _PuddleNoiseOffset;\n    half _PuddleNoiseCenter;\n    half _PuddleAngleMin;\n\n    half _WetnessAmount;\n\thalf _WetnessMin;\n    half _WetnessMax;\n    half _WetnessFalloff;\n\thalf _WetnessAngleMin;\n    float _WetnessShoreline;\n\n    int _RainMode;\n    half3 _RainIntensityScale;\n\n\n\n\n    float4 _SnowAlbedo_ST;\n    half3 _SnowTint;\n    half _SnowAmount;\n    half _SnowAngle;\n    half _SnowContrast;\n    half _SnowVertexHeight;\n    half _SnowMode;\n    half3 _SnowWorldFade; // z is on/off\n    float4 _SnowTraxAlbedo_ST;\n    half3 _SnowTraxTint;\n\n    half _SnowNoiseFreq; \n    half _SnowNoiseAmp;\n    half _SnowNoiseOffset;\n    half _SnowStochasticContrast;\n    half _SnowStochasticScale;\n\n\n    half     _WindParticulateSpace;\n    half     _WindParticulateRotation;\n    half      _WindParticulateSpeed;\n    float4     _WindParticulate_ST;\n    half      _WindParticulatePower;\n    half4    _WindParticulateColor;\n    half4    _WindParticulateWorldHeightMask;\n    half4    _WindParticulateAngleMask;\n    half      _WindParticulateOcclusionStrength;\n    half      _WindParticulateStrength;\n    half4    _WindParticulateEmissive;\n    half     _WindParticulateTextureHeight;\n\n\n   float _DoubleSidedNormalMode;\n\n\n\thalf _AutoNormalStrength;\n\n\n\tint _DebugSampleCountThreshold;\n\n\n\thalf _DissolveAmount;\n\thalf _DissolveEmissiveStr;\n\thalf _DissolveEdgeContrast;\n\thalf _DissolveColoration;\n\tfloat4 _DissolveTexture_ST;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n         \n\n         \n\n         \n\n#ifndef __STACKABLEFUNCLIBRARY_INCLUDES__\n#define __STACKABLEFUNCLIBRARY_INCLUDES__\n\n   #if _DEBUG_SAMPLECOUNT\n      int _sampleCount;\n      #define COUNTSAMPLE { _sampleCount++; }\n   #else\n      #define COUNTSAMPLE\n   #endif\n\n   TEXTURE2D(_NoiseTex);\n   SAMPLER(sampler_NoiseTex);\n\n\n\n   half3 AdjustContrast(half3 color, half contrast)\n   {\n       half3 comp = 0.5;\n   #if !UNITY_COLORSPACE_GAMMA\n       comp = 0.22;\n   #endif\n       color = saturate(lerp(comp, color, contrast));\n       return color;\n   }\n\n   float2 DoParallaxOffset( half h, half height, half3 viewDir)\n   {\n      h = h * height - height/2.0;\n      float3 v = normalize(viewDir);\n      v.z += 0.42;\n      return h * (v.xy / v.z);\n   }\n\n\n\n   #define SAMPLEBARY SampleTexBary\n\n   struct SampleConfig\n   {\n      float2 uv0;\n      float2 uv1;\n      float2 uv2;\n      float2 dx0;\n      float2 dy0;\n      float2 dx1;\n      float2 dy1;\n      float2 dx2;\n      float2 dy2;\n      float3 weights;\n      float3 origWeights;\n   };\n\n   struct Config\n   {\n      float2 origUV; // unscaled uv\n      float2 origScale;\n      float2 uv;        // no stocastic or triplanar\n      float2 dx;\n      float2 dy;\n      SampleConfig uvT; // just stochastic, or just triplanar\n      SampleConfig uvX; // stochastic and triplanar\n      SampleConfig uvY;\n      SampleConfig uvZ;\n\n      \n      float3 absVertNormal;\n      half3 axisSign;\n      float3 normal;\n   };\n\n\n    float2 Hash2D( float2 x )\n    {\n        float2 k = float2( 0.3183099, 0.3678794 );\n        x = x*k + k.yx;\n        return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );\n    }\n\n    float Noise2D(float2 p )\n    {\n        float2 i = floor( p );\n        float2 f = frac( p );\n         \n        float2 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), \n                        dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),\n                    lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), \n                        dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);\n    }\n      \n\n    float2 WorleyHash2D(float2 p)\n    {\n \t    return frac(cos(mul(p, float2x2(-64.2,71.3,81.4,-29.8)))*8321.3); \n    }\n    float WorleyNoise2D(float2 p)\n    {\n        float dist = 1;\n        float2 i = floor(p);\n        float2 f = frac(p);\n    \n        for(int x = -1;x<=1;x++)\n        {\n            for(int y = -1;y<=1;y++)\n            {\n                float d = distance(WorleyHash2D(i+float2(x,y))+float2(x,y),f);\n                dist = min(dist,d);\n            }\n        }\n        return dist;\n\t\n    }\n\n#ifndef PI\n    #define PI 3.14159265359\n#endif\n\n    float GetIntegerNoise(float2 p)\n    {\n        p  = 53.7 * frac( (p*0.3183099) + float2(0.71,0.113));\n        return frac( p.x*p.y*(p.x+p.y) );\n    }\n\n    float WorleyHash3D(float f)\n    {\n        return frac(sin(f)*43758.5453);\n    }\n\n    float WorleyHash31(float3 v)\n    {\n        return WorleyHash3D(dot(v, float3(253.14, 453.74, 183.3)));\n    }\n\n    float3 WorleyRandom3D( float3 p )\n    {\n        return frac(sin(float3(dot(p,float3(127.1,311.7,217.3)),dot(p,float3(269.5,183.3,431.1)), dot(p,float3(365.6,749.9,323.7))))*437158.5453);\n    }\n\n    float WorleyNoise3D(float3 uvw)\n    {\n        float noise = 0.0;\n    \n        float3 p = floor(uvw);\n        float3 f = frac(uvw);\n    \n        float4 res = 1;\n        for(int x = -1; x <=1; ++x)\n        {\n            for(int y = -1; y <=1; ++y)\n            {\n                for(int z = -1; z <=1; ++z)\n                {\n                    float3 gp = p + float3(x, y, z);\n\n                    float3 v = WorleyRandom3D(gp);\n\n\t\t\t\t    float3 diff = gp + v - uvw;\n                \n                    float d = length(diff);\n                \n                    if(d < res.x)\n                    {\n                        res.xyz = float3(d, res.x, res.y);\n                    }\n                    else if(d < res.y)\n                    {\n                        res.xyz = float3(res.x, d, res.y);\n                    }\n                    else if(d < res.z)\n                    {\n                        res.z = d;\n                    }\n                \n                    res.w = WorleyHash31(gp);\n                }\n            }\n        }\n\n        return res.x;\n    }\n    \n      \n    float3 Hash3D( float3 p )\n    {\n        p = float3( dot(p,float3(127.1,311.7, 74.7)),\n                dot(p,float3(269.5,183.3,246.1)),\n                dot(p,float3(113.5,271.9,124.6)));\n\n        return -1.0 + 2.0*frac(sin(p)*437.5453123);\n    }\n\n    float Noise3D( float3 p )\n    {\n        float3 i = floor( p );\n        float3 f = frac( p );\n         \n        float3 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),\n                    lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n    }\n\n    \n    float FBM2D(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           return SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n\n    }\n      \n    float FBM3D(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           half A = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.zy).g;\n           half B = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33).g;\n           half C = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoise(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3D(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3D(d.localSpacePosition * frequency+ offset, d.localSpaceNormal);\n        #else\n           return FBM2D(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n    \n    #if _SURFACEGRADIENT  \n\n    #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)\n\n      \n      \n    half3 SurfaceGradientFromTBN(ShaderData d, half2 deriv)\n    {\n        return deriv.x * d.TBNMatrix[0] + deriv.y * d.TBNMatrix[1];\n    }\n\n    half2 TspaceNormalToDerivative(half3 vM)\n    {\n        const half scale = 1.0/128.0;\n        const half3 vMa = abs(vM);\n        const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));\n\n        return -half2(vM.x, vM.y)/z_ma;\n    }\n\n    half3 SurfgradFromVolumeGradient(ShaderData d, half3 grad)\n    {\n        return grad - dot(d.worldSpaceNormal, grad) * d.worldSpaceNormal;\n    }\n\n    half3 SurfgradFromTriplanarProjection(ShaderData d, half3 pN, half3 xN, half3 yN, half3 zN)\n    {\n        const half w0 = pN.x;\n        const half w1 = pN.y;\n        const half w2 = pN.z;\n\n        half2 xD = TspaceNormalToDerivative(xN);\n        half2 yD = TspaceNormalToDerivative(yN);\n        half2 zD = TspaceNormalToDerivative(zN);\n\n        half3 volumeGrad = half3(w2 * zD.x + w1 * yD.y, w2 * zD.y + w0 * xD.y, w0 * xD.x + w1 * yD.x);\n\n        return SurfgradFromVolumeGradient(d, volumeGrad);\n    }\n\n    half3 ConvertNormalToGradient(ShaderData d, half3 normal)\n    {\n        half2 deriv = TspaceNormalToDerivative(normal);\n\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n    half3 ConvertNormal2ToGradient(ShaderData d, half2 packedNormal)\n    {\n        half2 tNormal = packedNormal;\n        half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF\n        half2 deriv = tNormal * -rcpZ;\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n\n    half3 ResolveNormalFromSurfaceGradient(ShaderData d, half3 gradient)\n    {\n        return normalize(d.worldSpaceNormal - gradient);\n    }\n\n    #endif // _SURFACEGRADIENT\n\n\n    // normals are in surface gradient or world space depending on settings, and can also be generated by height\n    half3 GetWorldSpaceNormal(ShaderData d, half3 normal, half pheight)\n    {\n       #if _SURFACEGRADIENT\n          return ResolveNormalFromSurfaceGradient(d, normal);\n       #elif _AUTONORMAL\n          float3 dx = ddx(d.worldSpacePosition);\n          float3 dy = ddy(d.worldSpacePosition);\n          float3 crossX = cross(float3(0,1,0), dx);\n          float3 crossY = cross(float3(0,1,0), dy);\n          float3 dt = abs(dot(crossY, dx));\n          float height = _AutoNormalStrength * 0.5 * pheight;\n          float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n          n.y *= -1.0;\n          return TangentToWorldSpace(d, normalize((dt * float3(0,1,0)) - n).xzy);\n       #else\n          return TangentToWorldSpace(d, normal);\n          \n       #endif\n       \n    }\n\n   void WaterBRDF (inout half3 albedo, inout half smoothness, half metallic, half wetFactor, half surfPorosity) \n   {\n      half porosity = saturate((( (1 - smoothness) - 0.5)) / max(surfPorosity, 0.001));\n      half factor = lerp(1, 0.2, (1 - metallic) * porosity);\n      albedo *= lerp(1.0, factor, wetFactor);\n      smoothness = lerp(smoothness, 0.92f, wetFactor);\n   }\n\n   void OffsetUV(inout Config c, float2 offset)\n   {\n       c.uv += offset;\n       c.uvT.uv0 += offset;\n       c.uvT.uv1 += offset;\n       c.uvT.uv2 += offset;\n       c.uvX.uv0 += offset;\n       c.uvX.uv1 += offset;\n       c.uvX.uv2 += offset;\n       c.uvY.uv0 += offset;\n       c.uvY.uv1 += offset;\n       c.uvY.uv2 += offset;\n       c.uvZ.uv0 += offset;\n       c.uvZ.uv1 += offset;\n       c.uvZ.uv2 += offset;\n   }\n\n\n    void TriangleGrid(float2 uv, float scale,\n       out float w1, out float w2, out float w3,\n       out int2 vertex1, out int2 vertex2, out int2 vertex3)\n    {\n       // Scaling of the input\n       uv *= 3.464 * scale; // 2 * sqrt(3)\n\n       // Skew input space into simplex triangle grid\n       const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);\n       float2 skewedCoord = mul(gridToSkewedGrid, uv);\n\n       // Compute local triangle vertex IDs and local barycentric coordinates\n       int2 baseId = int2(floor(skewedCoord));\n       float3 temp = float3(frac(skewedCoord), 0);\n       temp.z = 1.0 - temp.x - temp.y;\n       if (temp.z > 0.0)\n       {\n          w1 = temp.z;\n          w2 = temp.y;\n          w3 = temp.x;\n          vertex1 = baseId;\n          vertex2 = baseId + int2(0, 1);\n          vertex3 = baseId + int2(1, 0);\n       }\n       else\n       {\n          w1 = -temp.z;\n          w2 = 1.0 - temp.y;\n          w3 = 1.0 - temp.x;\n          vertex1 = baseId + int2(1, 1);\n          vertex2 = baseId + int2(1, 0);\n          vertex3 = baseId + int2(0, 1);\n       }\n    }\n\n    // Fast random hash function\n    float2 SimpleHash2(float2 p)\n    {\n       return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 43758.5453);\n    }\n\n\n    half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)\n    {\n        // compute weight with height map\n        const half epsilon = 1.0f / 1024.0f;\n        half3 weights = half3(iWeights.x * (tex0 + epsilon), \n                                 iWeights.y * (tex1 + epsilon),\n                                 iWeights.z * (tex2 + epsilon));\n\n        // Contrast weights\n        half maxWeight = max(weights.x, max(weights.y, weights.z));\n        half transition = contrast * maxWeight;\n        half threshold = maxWeight - transition;\n        half scale = 1.0f / transition;\n        weights = saturate((weights - threshold) * scale);\n        // Normalize weights.\n        half weightScale = 1.0f / (weights.x + weights.y + weights.z);\n        weights *= weightScale;\n        return weights;\n    }\n\n\n    half3 PackedUnpackScaleNormal(half4 packedNormal, float scale)\n   {\n       #if _PACKEDFAST\n          half3 normal;\n          normal.xy = (packedNormal.ag * 2 - 1) * scale;\n          normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n          return normal;  \n       #endif\n       return UnpackScaleNormal(packedNormal, scale);\n   }\n\n    void InitStochasticDxDy(inout SampleConfig c, Config cfg)\n    {\n      c.dx0 = ddx(cfg.origUV) * cfg.origScale;\n      c.dy0 = ddy(cfg.origUV) * cfg.origScale;\n      c.dx1 = c.dx0; c.dx1 = c.dx0;\n      c.dx2 = c.dy0; c.dy2 = c.dy0;\n    }\n\n    void PrepareStochasticUVs(float scale, float2 uv, out SampleConfig c)\n    {\n       // Get triangle info\n       ZERO_INITIALIZE(SampleConfig, c);\n       float w1, w2, w3;\n       int2 vertex1, vertex2, vertex3;\n       TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n       // Assign random offset to each triangle vertex\n       c.uv0 = uv;\n       c.uv1 = uv;\n       c.uv2 = uv;\n   \n       c.uv0.xy += SimpleHash2(vertex1);\n       c.uv1.xy += SimpleHash2(vertex2);\n       c.uv2.xy += SimpleHash2(vertex3);\n       c.weights = half3(w1, w2, w3);\n       c.origWeights = half3(w1, w2, w3);\n    }\n\n\n   half3 LitBlendDetailNormal(half3 n1, half3 n2)\n   {\n      #if _SURFACEGRADIENT\n         return n1 + n2;\n      #else\n         return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n      #endif\n   }\n\n   float3 TriplanarBlendUnpackedRNM(float3 n1, float3 n2)\n   {\n       n1.z += 1;\n       n2.xy = -n2.xy;\n       return n1 * dot(n1, n2) / n1.z - n2;\n   }\n\n   void InitConfigDxDy(inout Config c)\n   {\n      c.uvT.dx0 = ddx(c.uvT.uv0);\n      c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1);\n      c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2);\n      c.uvT.dy2 = ddy(c.uvT.uv2);\n   }\n\n   Config CreateConfig(ShaderData d, float4 scale, float space, int uvsource, half triplanarContrast)\n   {\n      Config c;\n      ZERO_INITIALIZE(Config, c);\n\n      float3 pos = d.worldSpacePosition;\n      float3 normal = d.worldSpaceNormal;\n      if (space > 0)\n      {\n         pos = d.localSpacePosition;\n         normal = d.localSpaceNormal;\n      }\n\n      c.uv = d.texcoord0.xy;\n      \n      if (uvsource == 1)\n        c.uv = d.texcoord1.xy;\n      else if (uvsource == 2)\n        c.uv = pos.yz * float2(1, -1);\n      else if (uvsource == 3)\n        c.uv = pos.xz * float2(1, -1);\n      else if (uvsource == 4)\n        c.uv = pos.xy * float2(1, -1);\n\n      c.origUV = c.uv;\n      c.origScale = scale.xy;\n\n      c.uv = c.uv * scale.xy + scale.zw;\n      c.dx = ddx(c.uv);\n      c.dy = ddy(c.uv);\n\n      c.normal = normal;\n      c.uvT.uv0 = pos.zy * scale.xy + scale.zw;\n      c.uvT.uv1 = pos.xz * scale.xy + scale.zw;\n      c.uvT.uv2 = pos.xy * scale.xy + scale.zw;\n        \n      c.uvT.uv1 += 0.33;\n      c.uvT.uv2 += 0.67;\n\n      c.uvT.dx0 = ddx(c.uvT.uv0); c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1); c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2); c.uvT.dy2 = ddy(c.uvT.uv2);\n\n      half3 triblend = saturate(pow(abs(c.normal), triplanarContrast));\n      triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n      c.uvT.weights = triblend;\n      c.uvT.origWeights = triblend;\n      c.axisSign = d.worldSpaceNormal < 0 ? -1 : 1;\n      c.absVertNormal = abs(d.worldSpaceNormal);\n     \n\n      return c;\n   }\n\n\n   half4 TriSample(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0) * c.weights.x;\n      }\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1) * c.weights.y;\n      }  \n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2) * c.weights.z;\n      }\n\n      return res;\n   }\n\n   half4 TriSampleBary(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      c.weights = BaryWeightBlend(c.origWeights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   half4 TriSampleGrad(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvX, contrast, d) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvY, contrast, d) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n           res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvZ, contrast, d) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   \n   half4 SampleTexBaryStochastic(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   half4 SampleTexBaryTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleGrad(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   \n   half4 SampleTexBary(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        COUNTSAMPLE\n        return SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv, c.dx, c.dy);\n   }\n\n   half4 SampleTexStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ) * c.uvT.weights.z;\n\n        return res;     \n   }\n\n   \n   half4 SampleTexStochastic(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n\n   half4 SampleTexTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n   \n   half4 SampleTex(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       COUNTSAMPLE\n       return SAMPLE_TEXTURE2D(tex, ss, c.uv);\n   }\n   \n\n \n   half3 SampleNormalStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n         dataX = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n         dataY = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n         dataZ = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ));\n\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n\n          return WorldToTangentSpace(d, worldNormal);\n       #endif\n   }\n\n\n   half3 SampleNormalTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n      {\n          COUNTSAMPLE\n          dataX = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv0, c.uvT.dx0, c.uvT.dy0));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n      {\n          COUNTSAMPLE\n          dataY = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv1, c.uvT.dx1, c.uvT.dy1));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n      {\n         COUNTSAMPLE\n         dataZ = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv2, c.uvT.dx2, c.uvT.dy2));\n      }\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n          return WorldToTangentSpace(d, worldNormal);\n      #endif\n   }\n\n   half3 SampleNormalStochastic(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n     half4 normal = TriSample(tex, ss, c.uvT);\n     #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half3 SampleNormal(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 normal = SAMPLE_TEXTURE2D(tex, ss, c.uv);\n      #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half HeightBlend(half h1, half h2, half slope, half contrast)\n   {\n      h2 = 1 - h2;\n      half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); \n      half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));\n      return blend;\n   }\n\n\n    #if _POM\n    float2 POM(TEXTURE2D_PARAM(tex, ss), Config c, float contrast, ShaderData d)\n    {\n       float2 curv = float2(0, 0);\n       float refPlane = 0;\n\n       float result = 0;\n       int stepIndex = 0;\n       int maxSamples = _POMMaxSamples;\n       int minSamples = 4;\n       float camDist = distance(_WorldSpaceCameraPos, d.worldSpacePosition);\n       float distanceFade = 1 - saturate((camDist - _POMMin) / max(1, _POMFade));\n       int numSteps = ( int )lerp( maxSamples, minSamples, dot( d.worldSpaceNormal, d.worldSpaceViewDir )) * distanceFade;\n       if (numSteps < 1)\n           numSteps = 1;\n       float layerHeight = 1.0 / numSteps;\n       float2 plane = _ParallaxHeight * ( d.tangentSpaceViewDir.xy / d.tangentSpaceViewDir.z ) * distanceFade;\n       OffsetUV(c, refPlane * plane);\n       float2 deltaTex = -plane * layerHeight;\n       float2 prevTexOffset = 0;\n       float prevRayZ = 1.0f;\n       float prevHeight = 0.0f;\n       float2 currTexOffset = deltaTex;\n       float currRayZ = 1.0f - layerHeight;\n       float currHeight = 0.0f;\n       float intersection = 0;\n       float2 finalTexOffset = 0;\n\n       while ( stepIndex < numSteps + 1 )\n       {\n          result = dot( curv, currTexOffset * currTexOffset );\n          Config cfg = c;\n          OffsetUV(cfg, currTexOffset);\n          currHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( currHeight > currRayZ )\n          {\n             stepIndex = numSteps + 1;\n          }\n          else\n          {\n             stepIndex++;\n             prevTexOffset = currTexOffset;\n             prevRayZ = currRayZ;\n             prevHeight = currHeight;\n             currTexOffset += deltaTex;\n             currRayZ -= layerHeight * ( 1 - result );\n          }\n       }\n       int sectionSteps = 10;\n       int sectionIndex = 0;\n       float newZ = 0;\n       float newHeight = 0;\n       while ( sectionIndex < sectionSteps )\n       {\n          intersection = ( prevHeight - prevRayZ ) / ( prevHeight - currHeight + currRayZ - prevRayZ );\n          finalTexOffset = prevTexOffset + intersection * deltaTex;\n          newZ = prevRayZ - intersection * layerHeight;\n          Config cfg = c;\n          OffsetUV(cfg, finalTexOffset);\n          newHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( newHeight > newZ )\n          {\n             currTexOffset = finalTexOffset;\n             currHeight = newHeight;\n             currRayZ = newZ;\n             deltaTex = intersection * deltaTex;\n             layerHeight = intersection * layerHeight;\n          }\n          else\n          {\n             prevTexOffset = finalTexOffset;\n             prevHeight = newHeight;\n             prevRayZ = newZ;\n             deltaTex = ( 1 - intersection ) * deltaTex;\n             layerHeight = ( 1 - intersection ) * layerHeight;\n          }\n          sectionIndex++;\n       }\n       #if _PASSHADOWS\n       if ( unity_LightShadowBias.z == 0.0 )\n       {\n       #endif\n          if ( result > 1 )\n             clip( -1 );\n       #if _PASSHADOWS\n       }\n       #endif\n       return finalTexOffset;\n    }\n    #endif\n\n   \n\n   // tess versions\n   #if _TESSELLATION_ON\n   half4 TriSampleLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias) * c.weights.x;\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias) * c.weights.y;\n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias) * c.weights.z;\n\n      return res;\n   }\n\n   half4 TriSampleBaryLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias, float contrast)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias);\n      half4 r2 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias);\n      half4 r3 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias);\n      c.weights = BaryWeightBlend(c.weights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryLODStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvX, bias, contrast) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvY, bias, contrast) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvZ, bias, contrast) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   half4 SampleTexBaryLODStochastic(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n       return TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias, contrast);\n   }\n\n   half4 SampleTexBaryLODTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return TriSampleLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias);\n   }\n\n   half4 SampleTexBaryLOD(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv, bias);\n   }\n\n\n    float FBM2DLOD(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           return SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv, _TessellationMipBias).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n        \n        \n    }\n\n    float FBM3DLOD(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           half A = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.zy, _TessellationMipBias).g;\n           half B = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33, _TessellationMipBias).g;\n           half C = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67, _TessellationMipBias).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoiseLOD(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3DLOD(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3DLOD(d.localSpacePosition * frequency + offset, d.localSpaceNormal);\n        #else\n           return FBM2DLOD(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n   #endif //_TESSELLATION_ON\n\n\n    half3 FuzzyShade(ShaderData d, half height, half3 color, half3 normal, half coreMult, half edgeMult, half power)\n    {\n        float3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half dt = saturate(dot(d.worldSpaceViewDir, worldNormal));\n        half dark = 1.0 - (coreMult * dt);\n        half edge = pow(1-dt, abs(power)) * edgeMult;\n        return color * (dark + edge);\n    }\n\n\thalf MicroShadow(ShaderData d, half3 normal, half height, half ao, half strength)\n\t{\n        float3 sun;\n\t\tfloat3 sunColor;\n\t\tGetSun(sun, sunColor);\n\t\tfloat3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half shadow = saturate(abs(dot(worldNormal, sun)) + (ao * ao * 2.0) - 1.0);\n        return 1 - ((1-shadow) * strength);\n\t}\n\n\n#endif\n\n\n\n   #if defined(_SPECULAR)\n      #define _USESPECULAR 1\n      #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n   #endif\n\n   \n   TEXTURE2D(_AlbedoMap);\n   SAMPLER(sampler_AlbedoMap);\n   TEXTURE2D(_NormalMap);\n   SAMPLER(sampler_NormalMap);\n   TEXTURE2D(_MaskMap);\n   TEXTURE2D(_DetailMap);\n   TEXTURE2D(_EmissionMap);\n\n   #if _SPECULAR\n       TEXTURE2D(_SpecularMap);\n   #endif\n\n   \n   \n   void Ext_SurfaceFunction0 (inout Surface o, inout ShaderData d)\n   {\n      // define samplers based on settings\n      #undef SAMPLEBARY\n      #undef SAMPLE\n      #undef SAMPLENORMAL\n      #if _STOCHASTIC && _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n        #define SAMPLE     SampleTexStochasticTriplanar\n        #define SAMPLENORMAL SampleNormalStochasticTriplanar\n      #elif _STOCHASTIC\n        #define SAMPLEBARY SampleTexBaryStochastic\n        #define SAMPLE     SampleTexStochastic\n        #define SAMPLENORMAL SampleNormalStochastic\n      #elif _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryTriplanar\n        #define SAMPLE     SampleTexTriplanar\n        #define SAMPLENORMAL SampleNormalTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBary\n        #define SAMPLE     SampleTex\n        #define SAMPLENORMAL SampleNormal\n      #endif\n\n      Config c = CreateConfig(d, _AlbedoMap_ST, _TriplanarSpace, _UVSource, _TriplanarContrast);\n      InitConfigDxDy(c);\n      #if _STOCHASTIC && !_TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uv, c.uvT);\n         InitStochasticDxDy(c.uvT, c);\n      #elif _STOCHASTIC && _TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv0, c.uvX);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv1, c.uvY);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv2, c.uvZ);\n         InitStochasticDxDy(c.uvX, c);\n         InitStochasticDxDy(c.uvY, c);\n         InitStochasticDxDy(c.uvZ, c);\n      #endif\n\n      #if _POM\n          // would need to handle height remapping if we ever want to ship this\n          float2 pomOffset = POM(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n          OffsetUV(c, pomOffset);\n      #endif\n\n      half4 albedo = SAMPLEBARY(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n      \n      #if _PARALLAX\n         float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n         OffsetUV(c, offset);\n         albedo = SAMPLE(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c);\n         \n      #endif\n      albedo.a = lerp(_HeightRemap.x, _HeightRemap.y, albedo.a);\n      albedo.rgb *= _Tint.rgb;\n\n      albedo.rgb = AdjustContrast(albedo.rgb, _AlbedoContrast);\n      albedo.rgb += _AlbedoBrightness;\n\n\n      if (_AlphaThreshold > 0)\n      {\n         clip(albedo.a - _AlphaThreshold);\n      }\n\n      #if defined(_FLATSHADE)\n\t\t     float3 dx = ddx(d.worldSpacePosition);\n\t\t     float3 dy = ddy(d.worldSpacePosition);\n\t\t     float3 worldNormal = normalize(cross(dy, dx));\n\t\t     worldNormal = lerp(d.worldSpaceNormal, worldNormal, _FlatShadingBlend);\n\t\t     d.worldSpaceNormal = worldNormal;\n\t\t     d.TBNMatrix[2] = worldNormal;\n      #endif\n\n\n\n      o.Albedo = albedo.rgb;\n      o.Alpha = albedo.a;\n\n      float smoothness = _Smoothness;\n      float ao = 1;\n\n      #if defined(_NORMALMAP) && !defined(_AUTONORMAL)\n         o.Normal = SAMPLENORMAL(TEXTURE2D_ARGS(_NormalMap, sampler_NormalMap), c, d, _NormalStrength, smoothness, ao);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, ao);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n      #endif\n\n      half detailMask = 1;\n      o.Smoothness = smoothness;\n      o.Occlusion = ao;\n      o.Metallic = _Metallic;\n      #if defined(_MASKMAP) && !_PACKEDFAST\n         // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = SampleTex(TEXTURE2D_ARGS(_MaskMap, sampler_AlbedoMap), c);\n         o.Metallic = lerp(_MetallicRemap.x, _MetallicRemap.y, mask.r);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, mask.g);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, mask.a);\n         detailMask = mask.b;\n      #endif // separate maps\n\n      #if _SPECULAR\n         o.Specular = SAMPLE(TEXTURE2D_ARGS(_SpecularMap, sampler_AlbedoMap), c).rgb;\n      #endif\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = SAMPLE(TEXTURE2D_ARGS(_EmissionMap, sampler_AlbedoMap), c).rgb * _EmissionColor;\n      #endif\n\n      if (_FuzzyShadingOn > 0)\n      {\n        o.Albedo *= FuzzyShade(d, albedo.a, _FuzzyShadingColor, o.Normal, _FuzzyShadingParams.x, _FuzzyShadingParams.y, _FuzzyShadingParams.z);\n      }\n\n\n      // HDRP style detail texturing\n\n      #if defined(_DETAIL)\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _DETAILSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n         Config dc = CreateConfig(d, _DetailMap_ST, _DetailTriplanarSpace, _DetailUVSource, _DetailTriplanarContrast);\n         InitConfigDxDy(dc);\n         #if _DETAILSTOCHASTIC && !_DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uv, dc.uvT);\n             InitStochasticDxDy(dc.uvT, dc);\n         #elif _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv0, dc.uvX);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv1, dc.uvY);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv2, dc.uvZ);\n             InitStochasticDxDy(dc.uvX, dc);\n             InitStochasticDxDy(dc.uvY, dc);\n             InitStochasticDxDy(dc.uvZ, dc);\n         #endif\n\n         half4 detailSample = SAMPLEBARY(TEXTURE2D_ARGS(_DetailMap, sampler_AlbedoMap), dc, _DetailStochasticContrast, d);\n         smoothness = detailSample.z;\n         #if !_AUTONORMAL\n            half3 dnormal = float3(detailSample.ag * 2 - 1, 1) * detailMask * _DetailNormalStrength;\n            dnormal.z = sqrt(1 - dnormal.x * dnormal.x - dnormal.y * dnormal.y);\n            #if _SURFACEGRADIENT\n               dnormal = ConvertNormalToGradient(d, dnormal);\n            #endif\n            o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n         #endif\n     \n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * smoothness, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n      if (_MicroShadowStrength > 0)\n      {\n        o.Occlusion *= MicroShadow(d, o.Normal, o.Alpha, o.Occlusion, _MicroShadowStrength);\n      }\n  \n      // in case something needs height in the stack..\n      o.Height = o.Alpha;\n\n\n      \n   }\n\n\n\n\t#if _TINTMASK\n\t\tTEXTURE2D(_TintMask);\n\t\tSAMPLER(sampler_TintMask);\n\t#endif\n\n\tvoid Ext_SurfaceFunction1 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _TINTMASK\n\t\t   half4 w = SAMPLE_TEXTURE2D(_TintMask, sampler_TintMask, d.texcoord0.xy * _TintMask_ST.xy + _TintMask_ST.zw);\n\t\t   // allow black to be no tint..\n\t\t   half3 tint = o.Albedo * (_RColor.rgb * 2 * w.r + _GColor.rgb * 2 * w.g + _BColor.rgb * 2 * w.b + _AColor.rgb * 2 * w.a);\n\t\t   o.Albedo = lerp(o.Albedo, tint, saturate(w.r + w.g + w.b + w.a));\n\t\t#endif\n\t}\n\n\n\n\n\t#if _LAYERTEXTUREMASK\n       TEXTURE2D(_LayerTextureMask);\n       SAMPLER(sampler_LayerTextureMask); \n    #endif\n\n   void Ext_ModifyTessellatedVertex2 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON\n          float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n\n          #if _LAYERTEXTUREMASK\n               float2 layerUV = v.texcoord0.xy;\n               if (_LayerTextureMaskUVMode == 1)\n                  layerUV = v.texcoord1.xy;\n               else if (_LayerTextureMaskUVMode == 2)\n                  layerUV = worldSpacePosition.yz;\n               else if (_LayerTextureMaskUVMode == 3)\n                  layerUV = worldSpacePosition.xz;\n               else if (_LayerTextureMaskUVMode == 4)\n                  layerUV = worldSpacePosition.xy;\n\n              e.blackboard.weightTextureMask = SAMPLE_TEXTURE2D_LOD(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw, _TessellationMipBias);\n          #endif\n      #endif\n    }\n\n\n\tvoid Ext_SurfaceFunction2 (inout Surface o, inout ShaderData d)\n\t{\n\t\t#if _LAYERTEXTUREMASK\n           float2 layerUV = d.texcoord0.xy;\n           if (_LayerTextureMaskUVMode == 1)\n              layerUV = d.texcoord1.xy;\n           else if (_LayerTextureMaskUVMode == 2)\n              layerUV = d.worldSpacePosition.yz;\n           else if (_LayerTextureMaskUVMode == 3)\n              layerUV = d.worldSpacePosition.xz;\n           else if (_LayerTextureMaskUVMode == 4)\n              layerUV = d.worldSpacePosition.xy;\n\n          d.blackboard.weightTextureMask = SAMPLE_TEXTURE2D(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw);\n      #endif\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap);\n   SAMPLER(sampler_LayerAlbedoMap);\n   TEXTURE2D(_LayerNormalMap);\n   TEXTURE2D(_LayerMaskMap);\n   TEXTURE2D(_LayerEmissionMap);\n\n   \n\n   void Ext_ModifyTessellatedVertex3 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER) && defined(_LAYERALBEDO) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n         half detailMask = 1;\n         #if _LAYERNOISE\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency,  _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin;\n            dt = saturate(dt * _LayerFalloff);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight) * _LayerFalloff);\n            if (_LayerInvertHeight > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength;\n         detailMask *= _LayerTessStrength;\n\n         #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast).a;\n         albedo = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo);\n\n         if (_LayerBlendMode == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction3 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n            // noise up the mask\n            #if _LAYERNOISE\n               mask = DoNoise(d, _LayerNoiseFrequency, _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend);\n\t    \n                dt -= _LayerAngleMin;\n                dt = saturate(dt * _LayerFalloff);\n\n                float hf = saturate((o.Height - _LayerHeight) * _LayerFalloff);\n                if (_LayerInvertHeight > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 0\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 0\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength;\n\n            #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint, 0.5);\n            #if defined(_LAYERALBEDO)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c, _LayerStochasticContrast, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c);\n                #endif\n                albedo.rgb *= _LayerTint;\n                albedo.a = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL || _LAYERMASK\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap, sampler_LayerAlbedoMap, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast);\n            albedo.rgb += _LayerAlbedoBrightness;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap, sampler_LayerAlbedoMap), c, d, _LayerNormalStrength * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO)\n                if (_LayerFuzzyShadingOn > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor.rgb, dnormal,\n                                            _LayerFuzzyShadingParams.x, _LayerFuzzyShadingParams.y, _LayerFuzzyShadingParams.z);\n                }\n\n                if (_LayerBlendMode == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast);\n                else if (_LayerBlendMode == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE\n                      float maskDif = (_LayerBlendContrast * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength);\n                   #if _LAYERNOISE\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap, sampler_LayerAlbedoMap), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength);\n                }\n\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap, sampler_LayerAlbedoMap), c).rgb * _LayerEmissionColor;\n                #if _LAYERALBEDO\n                    if (_LayerBlendMode > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_1);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_1);\n   TEXTURE2D(_LayerNormalMap_Ext_1);\n   TEXTURE2D(_LayerMaskMap_Ext_1);\n   TEXTURE2D(_LayerEmissionMap_Ext_1);\n\n   \n\n   void Ext_ModifyTessellatedVertex4 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_1) && defined(_LAYERALBEDO_DEF_1) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_1\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_1,  _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_1\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_1;\n            dt = saturate(dt * _LayerFalloff_Ext_1);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n            if (_LayerInvertHeight_Ext_1 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_1;\n         detailMask *= _LayerTessStrength_Ext_1;\n\n         #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_1).a;\n         albedo = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo);\n\n         if (_LayerBlendMode_Ext_1 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_1);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_1 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction4 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_1)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_1\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_1, _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_1\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_1);\n\t    \n                dt -= _LayerAngleMin_Ext_1;\n                dt = saturate(dt * _LayerFalloff_Ext_1);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n                if (_LayerInvertHeight_Ext_1 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 01\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 01\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_1;\n\n            #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_1, 0.5);\n            #if defined(_LAYERALBEDO_DEF_1)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, _LayerStochasticContrast_Ext_1, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_1;\n                albedo.a = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_1 || _LAYERMASK_DEF_1\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_1);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_1;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, d, _LayerNormalStrength_Ext_1 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_1)\n                if (_LayerFuzzyShadingOn_Ext_1 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_1.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_1.x, _LayerFuzzyShadingParams_Ext_1.y, _LayerFuzzyShadingParams_Ext_1.z);\n                }\n\n                if (_LayerBlendMode_Ext_1 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_1);\n                else if (_LayerBlendMode_Ext_1 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_1 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_1);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_1\n                      float maskDif = (_LayerBlendContrast_Ext_1 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_1 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                   #if _LAYERNOISE_DEF_1\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_1));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_1 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_1);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_1) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_1 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_1);\n                }\n\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_1);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_1, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_1, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_1\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c).rgb * _LayerEmissionColor_Ext_1;\n                #if _LAYERALBEDO_DEF_1\n                    if (_LayerBlendMode_Ext_1 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_2);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_2);\n   TEXTURE2D(_LayerNormalMap_Ext_2);\n   TEXTURE2D(_LayerMaskMap_Ext_2);\n   TEXTURE2D(_LayerEmissionMap_Ext_2);\n\n   \n\n   void Ext_ModifyTessellatedVertex5 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_2) && defined(_LAYERALBEDO_DEF_2) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_2\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_2,  _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_2\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_2;\n            dt = saturate(dt * _LayerFalloff_Ext_2);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n            if (_LayerInvertHeight_Ext_2 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_2;\n         detailMask *= _LayerTessStrength_Ext_2;\n\n         #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_2).a;\n         albedo = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo);\n\n         if (_LayerBlendMode_Ext_2 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_2);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_2 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction5 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_2)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_2\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_2, _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_2\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_2);\n\t    \n                dt -= _LayerAngleMin_Ext_2;\n                dt = saturate(dt * _LayerFalloff_Ext_2);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n                if (_LayerInvertHeight_Ext_2 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 02\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 02\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_2;\n\n            #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_2, 0.5);\n            #if defined(_LAYERALBEDO_DEF_2)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, _LayerStochasticContrast_Ext_2, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_2;\n                albedo.a = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_2 || _LAYERMASK_DEF_2\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_2);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_2;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, d, _LayerNormalStrength_Ext_2 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_2)\n                if (_LayerFuzzyShadingOn_Ext_2 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_2.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_2.x, _LayerFuzzyShadingParams_Ext_2.y, _LayerFuzzyShadingParams_Ext_2.z);\n                }\n\n                if (_LayerBlendMode_Ext_2 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_2);\n                else if (_LayerBlendMode_Ext_2 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_2 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_2);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_2\n                      float maskDif = (_LayerBlendContrast_Ext_2 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_2 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                   #if _LAYERNOISE_DEF_2\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_2));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_2 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_2);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_2) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_2 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_2);\n                }\n\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_2);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_2, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_2, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_2\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c).rgb * _LayerEmissionColor_Ext_2;\n                #if _LAYERALBEDO_DEF_2\n                    if (_LayerBlendMode_Ext_2 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   #if _TRAX_ON\n   TEXTURE2D(_TraxAlbedo);\n   SAMPLER(sampler_TraxAlbedo);\n   TEXTURE2D(_TraxPackedNormal);\n   TEXTURE2D(_TraxMask);\n\n   sampler2D_float _GMSTraxBuffer;\n\n   float4 _GMSTraxBuffer_TexelSize;\n   float3 _GMSTraxBufferPosition;\n   float _GMSTraxBufferWorldSize;\n   float _GMSTraxFudgeFactor;\n\n   float SampleTraxBufferLOD(float3 worldPos)\n   {    \n      // generate UVs for the buffer, which is moving\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 8);\n      uv *= 0.5;\n      uv += 0.5;\n            \n      float s =  tex2Dlod(_GMSTraxBuffer, float4(uv, 0, 0)).r;\n\n      return 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n   }\n         \n        \n   float SampleTraxBuffer(float3 worldPos, out float3 norm)\n   {\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 3);\n      uv *= 0.5;\n      uv += 0.5;\n            \n\n      float2 offset = _GMSTraxBuffer_TexelSize.xy;\n\n      float s = tex2D(_GMSTraxBuffer, uv).r;\n               \n      float s1 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, -1)).r;\n      float s2 = tex2D(_GMSTraxBuffer, uv + offset * float2(-1, 0)).r;\n      float s3 = tex2D(_GMSTraxBuffer, uv + offset * float2(1, 0)).r;\n      float s4 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, 1)).r;\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      float r = 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n \n      // generate normals\n      norm.x = (s1 - s4) * 0.25; \n      norm.y = (s2 - s3) * 0.25;\n      norm.z = 2;\n      norm = normalize(norm);\n     \n      norm.xy *= 1 - r;\n            \n      return r;\n   }\n   #endif\n\n   void Ext_ModifyTessellatedVertex6 (inout VertexData v, inout ExtraV2F d)\n   {\n       #if _TESSELLATION_ON && _TRAX_ON && _HAS_LIT_TESSELLATION\n          \n           float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n           float3 worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n           float traxBuffer = SampleTraxBufferLOD(worldSpacePosition);\n           d.blackboard.traxBuffer = traxBuffer;\n           float2 uv = worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n           half albedo = SAMPLE_TEXTURE2D_LOD(_TraxAlbedo, sampler_TraxAlbedo, uv, _TraxMipBias).a;\n\n           float traxOffset = albedo * _TraxDisplacementStrength;\n           traxOffset *= 1 - v.texcoord0.z;\n           traxOffset *= _TessellationDisplacement;\n           float dig = _TraxDisplacementDepth * (1 - v.texcoord0.z);\n           float3 traxVertex = d.blackboard.originalVertexPosition + (v.normal * (traxOffset - dig));\n           v.vertex.xyz = lerp(traxVertex, v.vertex.xyz, traxBuffer);\n\n           d.blackboard.vertexHeightOffset = lerp(traxOffset-dig, d.blackboard.vertexHeightOffset, traxBuffer);\n\n       #endif\n\n   }\n\n   void Ext_SurfaceFunction6 (inout Surface o, inout ShaderData d)\n   {\n      #if _TRAX_ON\n        float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n        float2 fsdx = ddx(uv);\n        float2 fsdy = ddy(uv);\n\n        float3 traxNormal;\n        float traxBuffer = SampleTraxBuffer(d.worldSpacePosition, traxNormal);\n        \n        #if _TESSELLATION_ON\n            traxBuffer -= _TraxDisplacementDepth;\n        #endif\n\n        d.blackboard.traxBuffer = traxBuffer;\n\n        UNITY_BRANCH\n        if (traxBuffer > 0)\n        {\n            half4 albedo = SAMPLE_TEXTURE2D_GRAD(_TraxAlbedo, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            albedo.rgb *= _TraxTint.rgb;\n            half4 normalSample = SAMPLE_TEXTURE2D_GRAD(_TraxPackedNormal, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n\n            half smoothness = normalSample.r;\n            half ao = normalSample.b;\n            half3 normal;\n            normal.xy = (normalSample.ag * 2 - 1) * _TraxNormalStrength;\n            normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n\n            \n            half h = HeightBlend(albedo.a, o.Alpha, traxBuffer, _TraxHeightContrast);\n\n            h = lerp(traxBuffer, h, _TraxInterpContrast);\n\n            o.Albedo = lerp(albedo, o.Albedo, h);\n\n            #if _SURFACEGRADIENT\n                o.Normal = lerp(normal, o.Normal, h);\n            #else\n                o.Normal = lerp(normal + traxNormal, o.Normal, h);\n            #endif\n        \n            o.Smoothness = lerp(smoothness, o.Smoothness, h);\n            o.Occlusion = lerp(ao, o.Occlusion, h);\n        }\n      #endif\n   }\n\n\n\n\n    #if _RAINDROPS\n       TEXTURE2D(_RainDropTexture);\n       SAMPLER(sampler_RainDropTexture);\n       half _Global_RainIntensity;\n    #endif\n\n    #if _WETNESS\n       half2 _Global_WetnessParams; // global, not in cbuffer\n    #endif\n   \n    #if _RAINDROPS\n    half2 ComputeRipple(float2 uv, half time, half weight)\n    {\n        half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_RainDropTexture, uv);\n        COUNTSAMPLE\n        ripple.yz = ripple.yz * 2 - 1;\n\n        half dropFrac = frac(ripple.w + time);\n        half timeFrac = dropFrac - 1.0 + ripple.x;\n        half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);\n        half finalFactor = dropFactor * ripple.x * \n                                sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);\n\n        return half2(ripple.yz * finalFactor);\n    }\n    #endif\n\n    half2 DoRain(half2 waterNorm, float2 uv, out half2 ripple)\n    {\n        #if _RAINDROPS\n            float rainIntensity = _RainIntensityScale.x;\n            if (_RainMode > 1)\n            {\n                rainIntensity = _Global_RainIntensity;\n            }\n\n            half dropStrength = rainIntensity;\n            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); \n            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);\n            half4 times = _Time.yyyy;\n            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);\n\n            float2 ruv1 = uv * _RainIntensityScale.yy;\n            float2 ruv2 = ruv1;\n\n            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);\n            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);\n            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);\n            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);\n            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);\n            weights = saturate(weights * 4);\n\n            half2 rippleNormal = half2( weights.x * ripple1.xy +\n                        weights.y * ripple2.xy + \n                        weights.z * ripple3.xy + \n                        weights.w * ripple4.xy);\n\n            ripple = rippleNormal * dropStrength * rainIntensity;\n            waterNorm = lerp(waterNorm, normalize(half3(rippleNormal.xy + rippleNormal.xy, 1)).xy, rainIntensity * dropStrength); \n            return waterNorm;                        \n        #else\n            return waterNorm;\n        #endif\n    }\n\n   half2 _Global_PuddleParams;   // this is a global, so keep it out of the cbuffer\n   void GetPuddleParams(ShaderData d, inout float puddleMask, inout float pudHeight)\n   {\n      #if _PUDDLES || _GLOBALPUDDLES\n          pudHeight = _PuddleAmount;\n          if (_PuddleMode > 0)\n             pudHeight = _Global_PuddleParams.x;    \n      \n\n          half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t      dt -= _PuddleAngleMin;\n          dt = saturate(dt * _PuddleFalloff);\n          puddleMask *= dt;\n      #endif\n   }\n   \n   void Ext_ModifyTessellatedVertex7 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _PUDDLES && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n         half mask = 1;\n         half pudHeight = 1;\n\n         // save some ops by doing this in 2d\n         #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2DLOD(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2DLOD(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #else\n                mask = (FBM2DLOD(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n         #endif\n\n         GetPuddleParams(d, mask, pudHeight);\n         float height = pudHeight * mask;\n         if (e.blackboard.vertexHeightOffset < height)\n         {\n            e.blackboard.vertexHeightOffset = height;\n            height -= _TessellationOffset; \n            // dampen cracks\n            height *= 1 - v.texcoord0.z;\n            height *= _TessellationDisplacement;\n            v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n            \n        }\n      #endif\n   }\n\n\n#if _WETNESS\n\n   float GetWetnessLevel(Surface o, ShaderData d, float wetnessMask)\n   {\n      float wetLevel = clamp(_WetnessAmount, _WetnessMin, _WetnessMax);\n      \n      if (_WetnessMode > 0)\n         wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);\n\n      wetLevel = saturate(wetLevel + (1 - saturate(d.worldSpacePosition.y - _WetnessShoreline)));\n      float3x3 tbn = float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal);\n      float dt = dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0));\n      dt -= _WetnessAngleMin;\n      dt = saturate(dt * _WetnessFalloff * wetLevel);\n      dt *= wetnessMask;\n      return dt;\n   }\n#endif\n   \n\n   void Ext_SurfaceFunction7 (inout Surface o, ShaderData d)\n   {\n      half wetnessLevel = 0;\n      #if _WETNESS\n          wetnessLevel = GetWetnessLevel(o, d, 1); // mask one day?\n      #endif\n\n      half depthMask = 0;\n      half depth = 0;\n\n      #if _PUDDLES\n          half mask = 1;\n          half pudHeight = 1;\n          #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2D(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2D(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);      \n            #else\n                mask = (FBM2D(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n          #endif\n\n          GetPuddleParams(d, mask, pudHeight);\n          pudHeight *= mask;\n          depth = pudHeight - o.Height;\n          depthMask = saturate(depth * _PuddleFalloff);\n          depthMask *= _PuddleColor.a;\n          depth = o.Height - pudHeight;\n\n          // extend wetness slighting higher than the puddle\n          half wetmask = saturate((pudHeight + 0.05 - o.Height) * _PuddleFalloff);\n          wetnessLevel = max(wetmask, wetnessLevel);\n       #endif\n\n       \n       #if _WETNESS || _PUDDLES\n          half3 waterNorm = half3(0,0,1);\n          half3 wetAlbedo = o.Albedo;\n          half wetSmoothness = o.Smoothness;\n          #if _PUDDLES\n             wetAlbedo *= _PuddleColor.rgb;\n          #endif\n          WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetnessLevel, _Porosity);\n\n          half ri = 0;\n          half2 ripple = 0;\n          #if (_RAINDROPS || _GLOBALRAIN) && (_PUDDLES || _GLOBALPUDDLES)\n             ri = _RainIntensityScale.z;\n             waterNorm.xy = DoRain(waterNorm.xy, d.texcoord0.xy, ripple) * depthMask;\n          #endif\n\n          o.Normal = lerp(o.Normal, waterNorm, depthMask);\n          o.Normal = lerp(o.Normal, LitBlendDetailNormal(o.Normal, half3(ripple.xy, 1)), saturate(ri - depthMask) * wetnessLevel);\n          o.Occlusion = lerp(o.Occlusion, 1, depthMask);\n          o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetnessLevel);\n          o.Albedo = lerp(o.Albedo, wetAlbedo, wetnessLevel);\n          o.Emission *= 1 + depth;\n          o.Metallic *= 1 + depth;\n          o.Specular *= 1 + depth;\n\n       #endif\n\n   }\n\n\n\n\n    #if _SNOW\n       TEXTURE2D(_SnowAlbedo);\n       SAMPLER(sampler_SnowAlbedo);\n       TEXTURE2D(_SnowNormal);\n       TEXTURE2D(_SnowMaskMap);\n       #if _TRAX_ON\n          TEXTURE2D(_SnowTraxAlbedo);\n          TEXTURE2D(_SnowTraxNormal);\n          TEXTURE2D(_SnowTraxMaskMap);\n       #endif\n    #endif\n\n   float _Global_SnowLevel;\n\n\n   void Ext_ModifyVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n    #if (_SNOW)\n        float amount = _SnowAmount;\n        if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n        float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n        float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n        snowAmount -= _SnowAngle;\n        snowAmount *= _SnowContrast * 0.5;\n        snowAmount = saturate(snowAmount) * amount;\n        float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n        if (_SnowWorldFade.z > 0)\n        {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n        }\n        #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n        #endif\n        snowAmount = saturate(snowAmount);\n\n        #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n        #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n        #endif\n\n        float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n        v.vertex.xyz = v.vertex.xyz + displacementVec * snowAmount * snowAmount * _SnowVertexHeight;\n    #endif\n   }\n\n   void Ext_ModifyTessellatedVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _SNOW && _HAS_LIT_TESSELLATION\n         float amount = _SnowAmount;\n         if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n         float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n         float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n         snowAmount -= _SnowAngle;\n         snowAmount *= _SnowContrast * 0.5;\n         float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n         if (_SnowWorldFade.z > 0)\n         {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n         }\n\n         snowAmount = saturate(snowAmount) * amount;\n\n         #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n         #endif\n         snowAmount = saturate(snowAmount);\n\n         #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n         #endif\n\n         float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n         half heightMap = SAMPLE_TEXTURE2D_LOD(_SnowAlbedo, sampler_SnowAlbedo, worldPos.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw, 2);\n\n         float height = max(_SnowVertexHeight * 3 * snowAmount + snowAmount * heightMap, e.blackboard.vertexHeightOffset);\n         #if _TRAX_ON\n            height *= e.blackboard.traxBuffer;\n         #endif\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n\n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n         \n      #endif\n\n   }\n\n   void SampleSnowSurface(TEXTURE2D_PARAM(alb, ss), TEXTURE2D_PARAM(norm, ss2), TEXTURE2D_PARAM(mask, ss3),\n        ShaderData d, float2 uv, float2 dx, float2 dy, out half4 albedo, out half3 normal, out half2 smoothAO)\n   {\n      #if _SNOWSTOCHASTIC\n         float w1, w2, w3;\n         int2 vertex1, vertex2, vertex3;\n         TriangleGrid(uv, _SnowStochasticScale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n         // Assign random offset to each triangle vertex\n         float2 uv0 = uv;\n         float2 uv1 = uv;\n         float2 uv2 = uv;\n   \n         uv0.xy += SimpleHash2(vertex1);\n         uv1.xy += SimpleHash2(vertex2);\n         uv2.xy += SimpleHash2(vertex3);\n         half3 weights = half3(w1, w2, w3);\n\n         half4 albedo0 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv0, dx, dy);\n         half4 albedo1 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv1, dx, dy);\n         half4 albedo2 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv2, dx, dy);\n         COUNTSAMPLE\n         COUNTSAMPLE\n         COUNTSAMPLE\n         weights = BaryWeightBlend(weights, albedo0.a, albedo1.a, albedo2.a, _SnowStochasticContrast);\n         albedo = albedo0 * weights.x + albedo1 * weights.y + albedo2 * weights.z;\n\n         normal = half3(0,0,1);\n         smoothAO = half2(0, 1);\n\n         #if !_AUTONORMAL\n            half4 n0 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv0, dx, dy);\n            half4 n1 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv1, dx, dy);\n            half4 n2 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n            half4 snowNormSamp = n0 * weights.x + n1 * weights.y + n2 * weights.z;\n\n            normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n                \n            #if _PACKEDFAST\n               smoothAO.x = snowNormSamp.r;\n               smoothAO.y = snowNormSamp.b;\n            #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask0 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv0, dx, dy);\n            half4 snowMask1 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv1, dx, dy);\n            half4 snowMask2 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n            half4 snowMask = snowMask0 * weights.x + snowMask1 * weights.y + snowMask2 * weights.z;\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n      #else // not stochastic\n          albedo = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv, dx, dy);\n          COUNTSAMPLE\n\n          normal = half3(0,0,1);\n          smoothAO = half2(0, 1);\n\n          #if !_AUTONORMAL\n             half4 snowNormSamp = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv, dx, dy);\n             COUNTSAMPLE\n             normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n             #if _SURFACEGRADIENT\n                normal = ConvertNormalToGradient(d, normal);\n             #endif\n                 \n             #if _PACKEDFAST\n                smoothAO.x = snowNormSamp.r;\n                smoothAO.y = snowNormSamp.b;\n             #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv, dx, dy);\n            COUNTSAMPLE\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n     #endif // stochastic\n   }\n\n   \n   void Ext_SurfaceFunction8 (inout Surface o, ShaderData d)\n   {\n      #if _SNOW\n          float amount = _SnowAmount;\n          if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n          float snowAmount = lerp(dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), dot(d.worldSpaceNormal, float3(0,1,0)), amount * 0.8) + 1;\n          snowAmount -= _SnowAngle;\n          snowAmount *= _SnowContrast;\n          snowAmount = saturate(snowAmount) - (1-amount) * (1-amount);\n\n          if (_SnowWorldFade.z > 0)\n          {\n             float worldFade = saturate((d.worldSpacePosition.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n             snowAmount *= worldFade;\n          }\n\n          #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(d.worldSpacePosition.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n          #endif\n          snowAmount = saturate(snowAmount);\n\n          float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw;\n          float2 dx = ddx(uv);\n          float2 dy = ddy(uv);\n\n          #if _TRAX_ON\n              float2 tuv = d.worldSpacePosition.xz * float2(1, -1) * _SnowTraxAlbedo_ST.xy + _SnowTraxAlbedo_ST.zw;\n              float2 tdx = ddx(uv);\n              float2 tdy = ddy(uv);\n          #endif\n\n          #if _LAYERVERTEXMASK\n              snowAmount *= d.vertexColor.a;\n          #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n              snowAmount *= d.blackboard.weightTextureMask.a;\n          #endif\n\n          UNITY_BRANCH\n          if (snowAmount > 0)\n          {\n             half4 snowAlbedo;\n             half3 snowNormal;\n             half2 snowSmoothAO;\n             SampleSnowSurface(TEXTURE2D_ARGS(_SnowAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowNormal, sampler_SnowAlbedo),\n                    TEXTURE2D_ARGS(_SnowMaskMap, sampler_SnowAlbedo), d, uv, dx, dy, snowAlbedo, snowNormal, snowSmoothAO);\n\n             snowAlbedo.rgb *= _SnowTint.rgb;\n\n             #if _TRAX_ON\n                half traxBuffer = 1 - d.blackboard.traxBuffer;\n                UNITY_BRANCH\n                if (traxBuffer > 0)\n                {\n                    half4 tsnowAlbedo;\n                    half3 tsnowNormal;\n                    half2 tsnowSmoothAO;\n                    SampleSnowSurface(TEXTURE2D_ARGS(_SnowTraxAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowTraxNormal, sampler_SnowAlbedo),\n                        TEXTURE2D_ARGS(_SnowTraxMaskMap, sampler_SnowAlbedo), d, tuv, tdx, tdy, tsnowAlbedo, tsnowNormal, tsnowSmoothAO);\n\n                    tsnowAlbedo.rgb *= _SnowTraxTint;\n                    half h = HeightBlend(snowAlbedo.a, tsnowAlbedo.a, traxBuffer, 0.5);\n                    snowAlbedo = lerp(snowAlbedo, tsnowAlbedo, h);\n                    snowNormal = lerp(snowNormal, tsnowNormal, h);\n                    snowSmoothAO = lerp(snowSmoothAO, tsnowSmoothAO, h);\n                }\n             #endif\n\n             #if !_AUTONORMAL\n                o.Normal = lerp(o.Normal, snowNormal, snowAmount);\n             #endif\n             o.Albedo = lerp(o.Albedo, snowAlbedo.rgb, snowAmount);\n             o.Alpha = lerp(o.Alpha, snowAlbedo.a, snowAmount);\n             o.Smoothness = lerp(o.Smoothness, snowSmoothAO.x, snowAmount);\n             o.Occlusion = lerp(o.Occlusion, snowSmoothAO.y, snowAmount);\n             o.Height = o.Alpha;\n\n          }\n      #endif\n   }\n\n   \n\n\n\n\n\n   TEXTURE2D(_WindParticulate);\n   SAMPLER(sampler_WindParticulate);\n\n// In case we want to read it more than once..\n\n#ifndef __STACKABLE_WIND_INCLUDES__\n#define __STACKABLE_WIND_INCLUDES__\n\n\n   half FilterRange(float4 range, float y)\n   {\n      half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));\n      w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));\n      return w;\n   }\n\n   \n   float2 RotateUV(float2 uv, float amt)\n   {\n      uv -=0.5;\n      float s = sin ( amt);\n      float c = cos ( amt );\n      float2x2 mtx = float2x2( c, -s, s, c);\n      mtx *= 0.5;\n      mtx += 0.5;\n      mtx = mtx * 2-1;\n      uv = mul ( uv, mtx );\n      uv += 0.5;\n      return uv;\n   }\n\n\n   half FilterWindParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)\n   {\n      float2 windDir = RotateUV(float2(1, 0), windRot);\n      float2 flow = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));\n      float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill\n      return FilterRange(range, cofacing);\n   }\n\n   fixed ProcessWindParticulateMask(inout fixed mask, float contrast)\n   {\n      mask = pow(abs(mask), abs(contrast));\n      fixed invMask = 1.0 - mask;\n      invMask *= invMask; \n      invMask *= invMask;\n      return invMask;\n   }\n#endif // include guard\n\n   void Ext_SurfaceFunction9 (inout Surface o, ShaderData d)\n   {\n      #if _WIND_ON && !_PASSMETA\n   \n         float3 upVector = float3(0,0,1);\n\n         half upDot = max(0.0, dot(d.worldSpaceNormal, float3(0, 1, 0)));\n\n         float2 uv = d.worldSpacePosition.xz;\n         if (_WindParticulateSpace > 0.5)\n            uv = d.texcoord0.xy;\n         float windRotation = _WindParticulateRotation;\n         float windStrength = _WindParticulateStrength;\n\n         float2 wuv = RotateUV(uv, windRotation);\n\n         half windBlend = 1.0;\n\n         float windWorldMask = FilterRange(_WindParticulateWorldHeightMask, d.worldSpacePosition.y);\n         windWorldMask *= FilterRange(_WindParticulateAngleMask, upDot);\n\n         // compute mask\n         wuv *= float2(_WindParticulate_ST.x, 1) * _WindParticulate_ST.y + _WindParticulate_ST.zw;\n         float speed = _Time.x * _WindParticulateSpeed;\n         half w1 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv * 3 + speed * float2(1,0)).g;\n         half w2 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv + speed * float2(1.1,0)).a;\n         half windMask = (w1 * w2);\n\n         windMask *= windStrength * windBlend * windWorldMask;\n         windMask *= saturate((_WindParticulateTextureHeight - o.Height) * 10);\n\n         half windInvMask = ProcessWindParticulateMask(windMask, _WindParticulatePower);\n    \n         o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);\n         o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindParticulateEmissive.rgb;\n         o.Normal.xy *= windInvMask;\n         o.Smoothness *= windInvMask;\n         o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;\n         o.Metallic *= windInvMask;\n      #endif\n\n   }\n\n\n\n\n\tvoid Ext_SurfaceFunction10 (inout Surface o, ShaderData d)\n\t{\n        if (_DoubleSidedNormalMode == 0)\n        {\n           o.Normal *= d.isFrontFace ? 1 : -1;\n        }\n        else if (_DoubleSidedNormalMode == 1)\n        {\n\t\t   o.Normal.z *= d.isFrontFace ? 1 : -1;\n        }\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction11 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _SURFACEGRADIENT\n\t\t\to.Normal = ResolveNormalFromSurfaceGradient(d, o.Normal);\n\t    #elif _AUTONORMAL\n\t        float3 dx = ddx(d.worldSpacePosition);\n\t\t\tfloat3 dy = ddy(d.worldSpacePosition);\n\t\t\tfloat3 crossX = cross(float3(0,1,0), dx);\n\t\t\tfloat3 crossY = cross(float3(0,1,0), dy);\n\t\t\tfloat3 dt = abs(dot(crossY, dx));\n\t\t\tfloat height = _AutoNormalStrength * 0.5 * o.Alpha;\n\t\t\tfloat3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n\t\t\tn.y *= -1.0;\n\t\t\to.Normal = normalize((dt * float3(0,1,0)) - n).xzy;\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#else\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#endif\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction12 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DEBUG_SAMPLECOUNT\n\t\t\tif (_sampleCount > _DebugSampleCountThreshold)\n\t\t\t{\n\t\t\t\to.Albedo.r = 1;\n\t\t\t\to.Albedo.gb *= 0.2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\to.Albedo.b = 1;\n\t\t\t}\n\n        #endif\n\t}\n\n\n\n\n\tSAMPLER(sampler_DissolveTexture);\n\tTEXTURE2D(_DissolveTexture);\n\tTEXTURE2D(_DissolveGradient);\n\n\tvoid Ext_SurfaceFunction13 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DISSOLVE\n\t\tfloat2 uv = d.texcoord0.xy * _DissolveTexture_ST.xy + _DissolveTexture_ST.zw;\n\t\tfloat2 dx = ddx(uv);\n\t\tfloat2 dy = ddy(uv);\n\n\t\tUNITY_BRANCH\n\t\tif (_DissolveAmount > 0)\n\t\t{\n\t\t\thalf dissolve = SAMPLE_TEXTURE2D_GRAD(_DissolveTexture, sampler_DissolveTexture, uv, dx, dy).g;\n\t\t\thalf cp =  saturate(_DissolveAmount - (dissolve - _DissolveAmount) * _DissolveEdgeContrast) + _DissolveAmount;\n\t\t\thalf cp2 = saturate(1.0 - abs((dissolve - _DissolveAmount) * _DissolveEdgeContrast));\n\t\t\tclip(1.0 - cp);\n\t\t\tfloat2 fuv = float2(cp2, 0.5);\n\t\t\thalf3 col = SAMPLE_TEXTURE2D_LOD(_DissolveGradient, sampler_DissolveTexture, fuv, 0).rgb;\n\t\t\t\t\n\t\t\to.Albedo = lerp(o.Albedo, col, _DissolveColoration * cp2);\n\t\t\to.Emission = lerp(o.Emission, col * _DissolveEmissiveStr, _DissolveColoration * cp2);\n\t\t}\n\t\t#endif\n\t}\n\n\n\n\n    float Dither8x8Bayer( int x, int y )\n    {\n        const float dither[ 64 ] = {\n                1, 49, 13, 61,  4, 52, 16, 64,\n            33, 17, 45, 29, 36, 20, 48, 32,\n                9, 57,  5, 53, 12, 60,  8, 56,\n            41, 25, 37, 21, 44, 28, 40, 24,\n                3, 51, 15, 63,  2, 50, 14, 62,\n            35, 19, 47, 31, 34, 18, 46, 30,\n            11, 59,  7, 55, 10, 58,  6, 54,\n            43, 27, 39, 23, 42, 26, 38, 22};\n        int r = y * 8 + x;\n        return dither[r] / 64; \n    }\n\n    void ApplyDitherCrossFadeVSP(float2 vpos, float fadeValue)\n    {\n        float dither = Dither8x8Bayer( fmod(vpos.x, 8), fmod(vpos.y, 8) );\n        float sgn = fadeValue > 0 ? 1.0f : -1.0f;\n        clip(dither - (1-fadeValue) * sgn);\n    }\n    \n\n\tvoid Ext_SurfaceFunction14 (inout Surface o, ShaderData d)\n\t{\n\t\t#if LOD_FADE_CROSSFADE\n            float4 screenPosNorm = d.screenPos / d.screenPos.w;\n            screenPosNorm.z = ( UNITY_NEAR_CLIP_VALUE >= 0 ) ? screenPosNorm.z : screenPosNorm.z * 0.5 + 0.5;\n            float2 clipScreen = screenPosNorm.xy * _ScreenParams.xy;\n            ApplyDitherCrossFadeVSP(clipScreen,unity_LODFade.x);\n        #endif\n\t}\n\n\n\n\n\n\n// declare outside of CBuffer\n\nfloat4x4 _GlobalVolumeMatrix;\nfloat4x4 _VolumeMatrix;\nfloat3 _VolumeMin;\nfloat3 _VolumeInvSize;\nfloat3 _GlobalVolumeMin;\nfloat3 _GlobalVolumeInvSize;\n\n// I inlined a section of your include. You can use includes in better shaders, but doing it via a subshader or this way\n// is much better. The reason is that this allows your shader to be all inclusive, and packed up for asset store distribition,\n// without requiring specific paths to other files, etc.\n//\n\n#ifndef BAKERY_INCLUDED\n#define BAKERY_INCLUDED\n\n#define BAKERYMODE_DEFAULT 0\n#define BAKERYMODE_VERTEXLM 1.0f\n#define BAKERYMODE_RNM 2.0f\n#define BAKERYMODE_SH 3.0f\n\n\n// can't fit vertexLM SH to sm3_0 interpolators\n#ifndef SHADER_API_D3D11\n    #undef _LIGHTMAPMODE_VERTEXSH\n#endif\n\n// can't do stuff on sm2_0 due to standard shader alrady taking up all instructions\n#if SHADER_TARGET < 30\n    #undef BAKERY_BICUBIC\n    #undef BAKERY_LMSPEC\n\n    #undef _LIGHTMAPMODE_RNM\n    #undef _LIGHTMAPMODE_SH\n    #undef _LIGHTMAPMODE_VERTEX\n#endif\n\n#define lumaConv float3(0.2125f, 0.7154f, 0.0721f)\n\n#ifdef BAKERY_VOLUME\n    #ifdef BAKERY_COMPRESSED_VOLUME\n        Texture3D _Volume3;\n    #endif\n#endif\n\n\nhalf3 LinearToGamma (half3 linRGB)\n{\n    linRGB = max(linRGB, half3(0.h, 0.h, 0.h));\n    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n    return max(1.055h * pow(linRGB, 0.416666667h) - 0.055h, 0.h);\n}\n\nfloat shEvaluateDiffuseL1Geomerics(float L0, float3 L1, float3 n)\n{\n    // average energy\n    float R0 = L0;\n\n    // avg direction of incoming light\n    float3 R1 = 0.5f * L1;\n\n    // directional brightness\n    float lenR1 = length(R1);\n\n    // linear angle between normal and direction 0-1\n    //float q = 0.5f * (1.0f + dot(R1 / lenR1, n));\n    //float q = dot(R1 / lenR1, n) * 0.5 + 0.5;\n    float q = dot(normalize(R1), n) * 0.5 + 0.5;\n\n    // power for q\n    // lerps from 1 (linear) to 3 (cubic) based on directionality\n    float p = 1.0f + 2.0f * lenR1 / R0;\n\n    // dynamic range constant\n    // should vary between 4 (highly directional) and 0 (ambient)\n    float a = (1.0f - lenR1 / R0) / (1.0f + lenR1 / R0);\n\n    return R0 * (a + (1.0f - a) * (p + 1.0f) * pow(q, p));\n}\n\n#ifdef BAKERY_VERTEXLMMASK\n    float4 unpack4NFloats(float src)\n\t{\n        //return fmod(float4(src / 262144.0, src / 4096.0, src / 64.0, src), 64.0)/64.0;\n        return frac(float4(src / (262144.0*64), src / (4096.0*64), src / (64.0*64), src));\n    }\n#endif\n\n#if defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n    float3 unpack3NFloats(float src)\n\t{\n        float r = frac(src);\n        float g = frac(src * 256.0);\n        float b = frac(src * 65536.0);\n        return float3(r, g, b);\n    }\n#endif\n\n// Unity defines these under different names in each SRP, so use our own\ninline float3 Bakery_SafeNormalize(float3 inVec)\n{\n    float dp3 = max(0.001f, dot(inVec, inVec));\n    return inVec * rsqrt(dp3);\n}\n\n#if _URP || _HDRP\n\nfloat SmoothnessToPerceptualRoughness(float smoothness)\n{\n    return (1 - smoothness);\n}\n#endif\n\n#if !_STANDARD\nhalf4 unity_Lightmap_HDR;\ninline half3 DecodeLightmap( fixed4 color )\n{\n    return DecodeLightmap( color, unity_Lightmap_HDR );\n}\n\n#define UNITY_INV_PI        0.31830988618f\ninline float GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return UNITY_INV_PI * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n    void BakeryVertexLMDirection(inout float3 diffuseColor, inout float3 specularColor, float3 lightDirection, float3 vertexNormalWorld, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 dominantDir = Bakery_SafeNormalize(lightDirection);\n        half halfLambert = dot(normalWorld, dominantDir) * 0.5 + 0.5;\n        half flatNormalHalfLambert = dot(vertexNormalWorld, dominantDir) * 0.5 + 0.5;\n\n        #ifdef BAKERY_LMSPEC\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = spec * diffuseColor;\n        #endif\n\n        diffuseColor *= halfLambert / max(1e-4h, flatNormalHalfLambert);\n    }\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXSH\n    void BakeryVertexLMSH(inout float3 diffuseColor, inout float3 specularColor, float3 shL1x, float3 shL1y, float3 shL1z, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 L0 = diffuseColor;\n        float3 nL1x = shL1x;\n        float3 nL1y = shL1y;\n        float3 nL1z = shL1z;\n        float3 L1x = nL1x * L0 * 2;\n        float3 L1y = nL1y * L0 * 2;\n        float3 L1z = nL1z * L0 * 2;\n\n        float3 sh;\n    #if BAKERY_SHNONLINEAR\n        //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n        //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n        //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n        float lumaL0 = dot(L0, 1);\n        float lumaL1x = dot(L1x, 1);\n        float lumaL1y = dot(L1y, 1);\n        float lumaL1z = dot(L1z, 1);\n        float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n        float regularLumaSH = dot(sh, 1);\n        //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n        sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    #else\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    #endif\n\n        diffuseColor = max(sh, 0.0);\n\n        #ifdef BAKERY_LMSPEC\n            float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n            float focus = saturate(length(dominantDir));\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = max(spec * sh, 0.0);\n        #endif\n    }\n#endif\n\n\n\n#ifdef BAKERY_BICUBIC\nfloat BakeryBicubic_w0(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-a + 3.0f) - 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w1(float a)\n{\n    return (1.0f/6.0f)*(a*a*(3.0f*a - 6.0f) + 4.0f);\n}\n\nfloat BakeryBicubic_w2(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-3.0f*a + 3.0f) + 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w3(float a)\n{\n    return (1.0f/6.0f)*(a*a*a);\n}\n\nfloat BakeryBicubic_g0(float a)\n{\n    return BakeryBicubic_w0(a) + BakeryBicubic_w1(a);\n}\n\nfloat BakeryBicubic_g1(float a)\n{\n    return BakeryBicubic_w2(a) + BakeryBicubic_w3(a);\n}\n\nfloat BakeryBicubic_h0(float a)\n{\n    return -1.0f + BakeryBicubic_w1(a) / (BakeryBicubic_w0(a) + BakeryBicubic_w1(a)) + 0.5f;\n}\n\nfloat BakeryBicubic_h1(float a)\n{\n    return 1.0f + BakeryBicubic_w3(a) / (BakeryBicubic_w2(a) + BakeryBicubic_w3(a)) + 0.5f;\n}\n#endif\n\n\n#if defined(_LIGHTMAPMODE_RNM) || defined(_LIGHTMAPMODE_SH)\nTexture2D _RNM0, _RNM1, _RNM2;\n#endif\n\n#ifdef BAKERY_VOLUME\nTexture3D _Volume0, _Volume1, _Volume2, _VolumeMask;\nSamplerState sampler_Volume0;\n#endif\n\n#if defined(BAKERY_BICUBIC) && defined(LIGHTMAP_ON) && defined(SHADER_API_D3D11)\n    // Bicubic\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\tfloat width, height;\n\t\ttex.GetDimensions(width, height);\n\t\tfloat texelSize = 1.0f / width;\n\n        float x = uv.x * width;\n        float y = uv.y * width;\n\n        x -= 0.5f;\n        y -= 0.5f;\n\n        float px = floor(x);\n        float py = floor(y);\n\n        float fx = x - px;\n        float fy = y - py;\n\n        float g0x = BakeryBicubic_g0(fx);\n        float g1x = BakeryBicubic_g1(fx);\n        float h0x = BakeryBicubic_h0(fx);\n        float h1x = BakeryBicubic_h1(fx);\n        float h0y = BakeryBicubic_h0(fy);\n        float h1y = BakeryBicubic_h1(fy);\n\n        return     BakeryBicubic_g0(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h0y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h0y) * texelSize))) +\n\n                   BakeryBicubic_g1(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h1y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h1y) * texelSize)));\n    }\n#else\n    // Bilinear\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\t#ifdef LIGHTMAP_ON\n\t\t\treturn tex.Sample(samplerunity_Lightmap, uv);\n\t\t#else\n\t\t\treturn float4(1,0,0,1);\n\t\t#endif\n    }\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\n#ifdef BAKERY_LMSPEC\nfloat BakeryDirectionalLightmapSpecular(float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 dominantDir = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap, lmUV).xyz * 2 - 1;\n    half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n    half nh = saturate(dot(normalWorld, halfDir));\n    half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n    half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n    half spec = GGXTerm(nh, roughness);\n    return spec;\n}\n#endif\n#endif\n\n\n\n#ifdef _LIGHTMAPMODE_RNM\nvoid BakeryRNM(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalMap, float smoothness, float3 viewDirT)\n{\n    const float3 rnmBasis0 = float3(0.816496580927726f, 0, 0.5773502691896258f);\n    const float3 rnmBasis1 = float3(-0.4082482904638631f, 0.7071067811865475f, 0.5773502691896258f);\n    const float3 rnmBasis2 = float3(-0.4082482904638631f, -0.7071067811865475f, 0.5773502691896258f);\n\n    float3 rnm0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 rnm1 = DecodeLightmap(BakeryTex2D(_RNM1, lmUV));\n    float3 rnm2 = DecodeLightmap(BakeryTex2D(_RNM2, lmUV));\n\n    #ifdef BAKERY_SSBUMP\n        diffuseColor = normalMap.x * rnm0\n                     + normalMap.z * rnm1\n                     + normalMap.y * rnm2;\n         diffuseColor *= 2;\n    #else\n        diffuseColor = saturate(dot(rnmBasis0, normalMap)) * rnm0\n                     + saturate(dot(rnmBasis1, normalMap)) * rnm1\n                     + saturate(dot(rnmBasis2, normalMap)) * rnm2;\n    #endif\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDirT = rnmBasis0 * dot(rnm0, lumaConv) +\n                              rnmBasis1 * dot(rnm1, lumaConv) +\n                              rnmBasis2 * dot(rnm2, lumaConv);\n\n        float3 dominantDirTN = normalize(dominantDirT);\n        float3 specColor = saturate(dot(rnmBasis0, dominantDirTN)) * rnm0 +\n                           saturate(dot(rnmBasis1, dominantDirTN)) * rnm1 +\n                           saturate(dot(rnmBasis2, dominantDirTN)) * rnm2;\n\n        half3 halfDir = Bakery_SafeNormalize(dominantDirTN - viewDirT);\n        half nh = saturate(dot(normalMap, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n        specularColor = spec * specColor;\n    #endif\n}\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\ninline half3 Unity_DecodeDirectionalLightmap(half3 color, fixed4 dirTex, half3 normalWorld)\n{\n    // In directional (non-specular) mode Enlighten bakes dominant light direction\n    // in a way, that using it for half Lambert and then dividing by a \"rebalancing coefficient\"\n    // gives a result close to plain diffuse response lightmaps, but normalmapped.\n\n    // Note that dir is not unit length on purpose. Its length is \"directionality\", like\n    // for the directional specular lightmaps.\n\n    half halfLambert = dot(normalWorld, dirTex.xyz - 0.5) + 0.5;\n\n    return color * halfLambert / max(1e-4h, dirTex.w);\n}\n#endif\n\n#ifdef _LIGHTMAPMODE_SH\nvoid BakerySH(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 L0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 nL1x = BakeryTex2D(_RNM0, lmUV) * 2 - 1;\n    float3 nL1y = BakeryTex2D(_RNM1, lmUV) * 2 - 1;\n    float3 nL1z = BakeryTex2D(_RNM2, lmUV) * 2 - 1;\n    float3 L1x = nL1x * L0 * 2;\n    float3 L1y = nL1y * L0 * 2;\n    float3 L1z = nL1z * L0 * 2;\n\n    float3 sh;\n#if BAKERY_SHNONLINEAR\n    float lumaL0 = dot(L0, 1);\n    float lumaL1x = dot(L1x, 1);\n    float lumaL1y = dot(L1y, 1);\n    float lumaL1z = dot(L1z, 1);\n    float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    float regularLumaSH = dot(sh, 1);\n    //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n    sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n    //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n    //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n#else\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n#endif\n\n    diffuseColor = max(sh, 0.0);\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n        float focus = saturate(length(dominantDir));\n        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n        half nh = saturate(dot(normalWorld, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n\n        sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n\n        specularColor = max(spec * sh, 0.0);\n    #endif\n}\n#endif\n\n#endif // include guards\n\n\n    void Ext_ModifyVertex15 (inout VertexData v, inout ExtraV2F e)\n    {\n        #if _USEBAKERY\n\t\t    #if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\t\t\t    // Unpack from RGBM\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.a * 8.0f;\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.rgb;\n\n\t\t\t    #ifdef BAKERY_VERTEXLMMASK\n\t\t\t\t    e.extraV2F4.xyzw = unpack4NFloats(v.texcoord1);\n\t\t\t    #endif\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXSH\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n                e.extraV2F6.xyz = unpack3NFloats(v.texcoord3.x) * 2 - 1;\n                e.extraV2F7.xyz = unpack3NFloats(v.texcoord3.y) * 2 - 1;\n            #endif\n       #endif\n    }\n\n#if _HDRP || _URP\n    half3 SHEvalLinearL0L1 (half4 normal)\n    {\n        half3 x;\n\n        // Linear (L1) + constant (L0) polynomial terms\n        x.r = dot(unity_SHAr,normal);\n        x.g = dot(unity_SHAg,normal);\n        x.b = dot(unity_SHAb,normal);\n\n        return x;\n    }\n\n    // normal should be normalized, w=1.0\n    half3 SHEvalLinearL2 (half4 normal)\n    {\n        half3 x1, x2;\n        // 4 of the quadratic (L2) polynomials\n        half4 vB = normal.xyzz * normal.yzzx;\n        x1.r = dot(unity_SHBr,vB);\n        x1.g = dot(unity_SHBg,vB);\n        x1.b = dot(unity_SHBb,vB);\n\n        // Final (5th) quadratic (L2) polynomial\n        half vC = normal.x*normal.x - normal.y*normal.y;\n        x2 = unity_SHC.rgb * vC;\n\n        return x1 + x2;\n    }\n\n    half3 ShadeSH9 (half4 normal)\n    {\n        // Linear + constant polynomial terms\n        half3 res = SHEvalLinearL0L1 (normal);\n\n        // Quadratic polynomials\n        res += SHEvalLinearL2 (normal);\n\n        #ifdef UNITY_COLORSPACE_GAMMA\n            res = LinearToGamma (res);\n        #endif\n\n        return res;\n\n    }\n#endif\n\n\n\n\tvoid DoBakeryStuff(inout float3 indDif, inout float3 indSpec, inout float4 shadowmask, float3 tangentNormal, float smoothness, ShaderData d)\n\t{\n\t\t// Quality!\n\t\tindDif = 1;\n\t\tindSpec = 0;\n\n        #if defined(_PASSFORWARD) || defined(_PASSGBUFFER) // forward pass on URP/Standard/HDRP + built-in deferred\n\n            float3 normalWorld = mul(tangentNormal, d.TBNMatrix);\n\n\t\t\t#ifdef LIGHTMAP_ON\n\n                // Static\n\n\t\t\t\tfloat2 lmUV = d.texcoord1 * unity_LightmapST.xy + unity_LightmapST.zw;\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_STANDARD\n\t\t\t\t\tindDif = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n\n\t\t\t\t\t#ifdef DIRLIGHTMAP_COMBINED\n\t\t\t\t\t\tfloat4 dirMap = BakeryTex2D(unity_LightmapInd, lmUV);\n\t\t\t\t\t\tindDif = Unity_DecodeDirectionalLightmap(indDif, dirMap, normalWorld);\n\n\t\t\t\t\t\t#ifdef BAKERY_LMSPEC\n\t\t\t\t\t\t\tindSpec = BakeryDirectionalLightmapSpecular(lmUV, normalWorld, -d.worldSpaceViewDir, smoothness) * indDif;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\n\t\t\t\t\tindDif = d.vertexColor;\n\n                    #ifdef BAKERY_VERTEXLMMASK\n                        shadowmask = d.extraV2F4;\n                    #endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n\t\t\t\t\t\t// worldSpaceNormal is per-vertex\n\t\t\t\t\t\t// normalWorld is per-pixel\n\t\t\t\t\t\tfloat3 bakedLightDirection = d.extraV2F5;\n\t\t\t\t\t\tBakeryVertexLMDirection(indDif, indSpec, bakedLightDirection, d.worldSpaceNormal, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXSH\n\t\t\t\t\t\tBakeryVertexLMSH(indDif, indSpec, d.extraV2F5, d.extraV2F6, d.extraV2F7, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_RNM\n\t\t\t\t\tBakeryRNM(indDif, indSpec, lmUV, tangentNormal, smoothness, -d.tangentSpaceViewDir);\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_SH\n\t\t\t\t\tBakerySH(indDif, indSpec, lmUV, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t#endif\n\n            #else\n\n                // Dynamic\n\n                #ifdef BAKERY_VOLUME\n\n                    bool isGlobal = dot(abs(_VolumeInvSize),1) == 0;\n                    float3 volViewDir = -d.worldSpaceViewDir;\n                    #ifdef BAKERY_VOLROTATION\n                        float4x4 volMatrix = (isGlobal ? _GlobalVolumeMatrix : _VolumeMatrix);\n                        float3 volInvSize = (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 lpUV = mul(volMatrix, float4(d.worldSpacePosition,1)).xyz * volInvSize + 0.5f;\n                        float3 volNormal = mul((float3x3)volMatrix, normalWorld);\n                        #ifdef BAKERY_LMSPEC\n                            volViewDir = mul((float3x3)volMatrix, volViewDir);\n                        #endif\n                    #else\n                        float3 lpUV = (d.worldSpacePosition - (isGlobal ? _GlobalVolumeMin : _VolumeMin)) * (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 volNormal = normalWorld;\n                    #endif\n\n                    #ifdef BAKERY_COMPRESSED_VOLUME\n                        float4 tex0, tex1, tex2, tex3;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex3 = _Volume3.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz * L0;\n                        L1y = tex2.xyz * L0;\n                        L1z = tex3.xyz * L0;\n                    #else\n                        float4 tex0, tex1, tex2;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV);\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV);\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz;\n                        L1y = tex2.xyz;\n                        L1z = float3(tex0.w, tex1.w, tex2.w);\n                    #endif\n                    indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), volNormal);\n                    indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), volNormal);\n                    indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), volNormal);\n\n                    #ifdef UNITY_COLORSPACE_GAMMA\n                        indDif = pow(indDif, 1.0f / 2.2f);\n                    #endif\n\n                    #ifdef BAKERY_LMSPEC\n                        float3 nL1x = L1x / L0;\n                        float3 nL1y = L1y / L0;\n                        float3 nL1z = L1z / L0;\n                        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n                        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - volViewDir);\n                        half nh = saturate(dot(volNormal, halfDir));\n                        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n                        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n                        half spec = GGXTerm(nh, roughness);\n                        float3 sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n                        indSpec = max(spec * sh, 0.0);\n                    #endif\n\n                    shadowmask = _VolumeMask.Sample(sampler_Volume0, lpUV);\n\n                #else\n\n                    #ifdef BAKERY_SHNONLINEAR\n                        float3 L0 = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);\n                        indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, unity_SHAr.xyz, normalWorld);\n                        indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, unity_SHAg.xyz, normalWorld);\n                        indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, unity_SHAb.xyz, normalWorld);\n                    #else\n                        indDif = ShadeSH9(float4(normalWorld,1));\n                    #endif\n\n                #endif\n\n\t\t\t#endif\n\n        #endif\n\t}\n\n\t// this is the main surface function. Surface is like a surface shader output structure, but\n\t// with our new outputs as well.\n\tvoid Ext_SurfaceFunction15 (inout Surface o, ShaderData d)\n\t{\n        #if _USEBAKERY\n\t\t    float3 indDif;\n\t\t    float3 indSpec;\n            float4 shadowmask = 1;\n\t\t    DoBakeryStuff(indDif, indSpec, shadowmask, o.Normal, o.Smoothness, d);\n\t\t    o.DiffuseGI = indDif;\n\t\t    o.BackDiffuseGI = indDif;\n\t\t    o.SpecularGI = indSpec;\n            o.ShadowMask = shadowmask;\n        #endif\n\t}\n\n\n\n\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                  Ext_SurfaceFunction1(l, d);\n                  Ext_SurfaceFunction2(l, d);\n                  Ext_SurfaceFunction3(l, d);\n                  Ext_SurfaceFunction4(l, d);\n                  Ext_SurfaceFunction5(l, d);\n                  Ext_SurfaceFunction6(l, d);\n                  Ext_SurfaceFunction7(l, d);\n                  Ext_SurfaceFunction8(l, d);\n                  Ext_SurfaceFunction9(l, d);\n\t\t            Ext_SurfaceFunction10(l, d);\n                  Ext_SurfaceFunction11(l, d);\n                  Ext_SurfaceFunction12(l, d);\n                  Ext_SurfaceFunction13(l, d);\n                  Ext_SurfaceFunction14(l, d);\n                  Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraV2F d;\n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                  Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                  Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                  #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                  v2p.extraV2F4 = d.extraV2F4;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                  v2p.extraV2F5 = d.extraV2F5;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F6 = d.extraV2F6;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F7 = d.extraV2F7;\n                  #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                d.extraV2F4 = v2p.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                d.extraV2F5 = v2p.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F6 = v2p.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F7 = v2p.extraV2F7;\n                #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n                Ext_ModifyTessellatedVertex2(v, d);\n                Ext_ModifyTessellatedVertex3(v, d);\n                Ext_ModifyTessellatedVertex4(v, d);\n                Ext_ModifyTessellatedVertex5(v, d);\n                Ext_ModifyTessellatedVertex6(v, d);\n                Ext_ModifyTessellatedVertex7(v, d);\n                Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                v2p.extraV2F4 = d.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                v2p.extraV2F5 = d.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F6 = d.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F7 = d.extraV2F7;\n                #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n\n\n\n         \n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n            // d.texcoord3 = i.texcoord3;\n             #endif\n\n             d.isFrontFace = facing;\n             #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n             d.vertexColor = i.vertexColor;\n             #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(i.worldPos, 1)).xyz;\n            #endif\n             d.localSpaceNormal = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n             #if LOD_FADE_CROSSFADE\n             d.screenPos = i.screenPos;\n             d.screenUV = (i.screenPos.xy / i.screenPos.w);\n             #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n             #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n             d.extraV2F4 = i.extraV2F4;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n             d.extraV2F5 = i.extraV2F5;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F6 = i.extraV2F6;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F7 = i.extraV2F7;\n             #endif\n\n            return d;\n         }\n         \n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           UNITY_SETUP_INSTANCE_ID(v);\n           VertexToPixel o;\n           UNITY_INITIALIZE_OUTPUT(VertexToPixel,o);\n           UNITY_TRANSFER_INSTANCE_ID(v,o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o);\n#endif\n\n           o.pos = UnityObjectToClipPos(v.vertex);\n            o.texcoord0 = v.texcoord0;\n            o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n            #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n           // o.texcoord3 = v.texcoord3;\n            #endif\n\n            #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n            o.vertexColor = v.vertexColor;\n            #endif\n\n            #if LOD_FADE_CROSSFADE\n            o.screenPos = ComputeScreenPos(o.pos);\n            #endif\n\n           o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n           o.worldNormal = UnityObjectToWorldNormal(v.normal);\n           o.worldTangent.xyz = UnityObjectToWorldDir(v.tangent.xyz);\n           fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n           o.worldTangent.w = tangentSign;\n\n           #ifdef DYNAMICLIGHTMAP_ON\n           o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n           #endif\n           #ifdef LIGHTMAP_ON\n           o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n           #endif\n\n           // SH/ambient and vertex lights\n           #ifndef LIGHTMAP_ON\n             #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n               o.sh = 0;\n               // Approximated illumination from non-important point lights\n               #ifdef VERTEXLIGHT_ON\n                 o.sh += Shade4PointLights (\n                   unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,\n                   unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n                   unity_4LightAtten0, o.worldPos, o.worldNormal);\n               #endif\n               o.sh = ShadeSHPerVertex (o.worldNormal, o.sh);\n             #endif\n           #endif // !LIGHTMAP_ON\n\n           UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader\n           #ifdef FOG_COMBINED_WITH_TSPACE\n             UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader\n           #elif defined FOG_COMBINED_WITH_WORLD_POS\n             UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader\n           #else\n             UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader\n           #endif\n\n           return o;\n         }\n\n         \n\n         // fragment shader\n         fixed4 Frag (VertexToPixel IN\n         #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n         #endif\n         #if NEED_FACING\n            , bool facing : SV_IsFrontFace\n         #endif\n         ) : SV_Target\n         {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           // prepare and unpack data\n           #ifdef FOG_COMBINED_WITH_TSPACE\n             UNITY_EXTRACT_FOG_FROM_TSPACE(IN);\n           #elif defined FOG_COMBINED_WITH_WORLD_POS\n             UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);\n           #else\n             UNITY_EXTRACT_FOG(IN);\n           #endif\n\n           ShaderData d = CreateShaderData(IN\n              #if NEED_FACING\n                 , facing\n              #endif\n           );\n           Surface l = (Surface)0;\n\n\n           #ifdef _DEPTHOFFSET_ON\n              l.outputDepth = outputDepth;\n           #endif\n\n           \n\n           l.Albedo = half3(0.5, 0.5, 0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n           l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n            \n\n           #ifdef _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n           #endif\n\n\n           #ifndef USING_DIRECTIONAL_LIGHT\n             fixed3 lightDir = normalize(UnityWorldSpaceLightDir(d.worldSpacePosition));\n           #else\n             fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n           #endif\n           float3 worldViewDir = normalize(UnityWorldSpaceViewDir(d.worldSpacePosition));\n\n           // compute lighting & shadowing factor\n           UNITY_LIGHT_ATTENUATION(atten, IN, d.worldSpacePosition)\n\n           #if _USESPECULAR || _USESPECULARWORKFLOW || _SPECULARFROMMETALLIC\n              #ifdef UNITY_COMPILER_HLSL\n                 SurfaceOutputStandardSpecular o = (SurfaceOutputStandardSpecular)0;\n              #else\n                 SurfaceOutputStandardSpecular o;\n              #endif\n              o.Specular = l.Specular;\n              o.Occlusion = l.Occlusion;\n              o.Smoothness = l.Smoothness;\n           #elif _BDRFLAMBERT || _BDRF3 || _SIMPLELIT\n              #ifdef UNITY_COMPILER_HLSL\n                 SurfaceOutput o = (SurfaceOutput)0;\n              #else\n                 SurfaceOutput o;\n              #endif\n\n              o.Specular = l.SpecularPower;\n              o.Gloss = l.Smoothness;\n              _SpecColor.rgb = l.Specular; // fucking hell Unity, wtf..\n           #else\n              #ifdef UNITY_COMPILER_HLSL\n                 SurfaceOutputStandard o = (SurfaceOutputStandard)0;\n              #else\n                 SurfaceOutputStandard o;\n              #endif\n              o.Smoothness = l.Smoothness;\n              o.Metallic = l.Metallic;\n              o.Occlusion = l.Occlusion;\n           #endif\n\n           o.Albedo = l.Albedo;\n           o.Emission = l.Emission;\n           o.Alpha = l.Alpha;\n           #if _WORLDSPACENORMAL\n              o.Normal = l.Normal;\n           #else\n              o.Normal = normalize(TangentToWorldSpace(d, l.Normal));\n           #endif\n\n            fixed4 c = 0;\n            // Setup lighting environment\n            UnityGI gi;\n            UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n            gi.indirect.diffuse = 0;\n            gi.indirect.specular = 0;\n            gi.light.color = _LightColor0.rgb;\n            gi.light.dir = lightDir;\n            // Call GI (lightmaps/SH/reflections) lighting function\n            UnityGIInput giInput;\n            UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n            giInput.light = gi.light;\n            giInput.worldPos = d.worldSpacePosition;\n            giInput.worldViewDir = worldViewDir;\n            giInput.atten = atten;\n            #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n               giInput.lightmapUV = IN.lmap;\n            #else\n               giInput.lightmapUV = 0.0;\n            #endif\n            #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n               giInput.ambient = IN.sh;\n            #else\n               giInput.ambient.rgb = 0.0;\n            #endif\n            giInput.probeHDR[0] = unity_SpecCube0_HDR;\n            giInput.probeHDR[1] = unity_SpecCube1_HDR;\n            #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n               giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending\n            #endif\n            #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n               giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n               giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n               giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n               giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n               giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n            #endif\n\n            \n\n            #if defined(_OVERRIDE_SHADOWMASK)\n               float4 mulColor = saturate(dot(l.ShadowMask, unity_OcclusionMaskSelector));\n               gi.light.color = mulColor;\n               giInput.light.color = mulColor;\n            #endif\n\n            #if _UNLIT\n              c.rgb = l.Albedo;\n              c.a = l.Alpha;\n            #elif _BDRF3 || _SIMPLELIT\n               LightingBlinnPhong_GI(o, giInput, gi);\n               #if defined(_OVERRIDE_BAKEDGI)\n                  gi.indirect.diffuse = l.DiffuseGI;\n                  gi.indirect.specular = l.SpecularGI;\n               #endif\n               c += LightingBlinnPhong (o, d.worldSpaceViewDir, gi);\n            #elif _USESPECULAR || _USESPECULARWORKFLOW || _SPECULARFROMMETALLIC\n               LightingStandardSpecular_GI(o, giInput, gi);\n               #if defined(_OVERRIDE_BAKEDGI)\n                  gi.indirect.diffuse = l.DiffuseGI;\n                  gi.indirect.specular = l.SpecularGI;\n               #endif\n               c += LightingStandardSpecular (o, d.worldSpaceViewDir, gi);\n            #else\n               LightingStandard_GI(o, giInput, gi);\n               #if defined(_OVERRIDE_BAKEDGI)\n                  gi.indirect.diffuse = l.DiffuseGI;\n                  gi.indirect.specular = l.SpecularGI;\n               #endif\n               c += LightingStandard (o, d.worldSpaceViewDir, gi);\n            #endif\n\n           c.rgb += o.Emission;\n\n           ChainFinalColorForward(l, d, c);\n\n           UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog\n           \n           \n\n           return c;\n         }\n\n         ENDCG\n\n      }\n\n\n      \n      \n\n\t   // ---- forward rendering additive lights pass:\n\t   Pass\n      {\n\t\t   Name \"FORWARD\"\n\t\t   Tags { \"LightMode\" = \"ForwardAdd\" }\n\t\t   ZWrite Off Blend One One\n         Blend SrcAlpha One\n            Cull [_CullMode]\n\n\n         CGPROGRAM\n\n            #pragma vertex Vert\n   #pragma fragment Frag\n\n         // compile directives\n         #pragma target 3.0\n         #pragma multi_compile_instancing\n         #pragma multi_compile_fog\n         #pragma skip_variants INSTANCING_ON\n         #pragma multi_compile_fwdadd_fullshadows\n         #include \"HLSLSupport.cginc\"\n         #define UNITY_INSTANCED_LOD_FADE\n         #define UNITY_INSTANCED_SH\n         #define UNITY_INSTANCED_LIGHTMAPSTS\n         #include \"UnityShaderVariables.cginc\"\n         #include \"UnityShaderUtilities.cginc\"\n\n\n         #include \"UnityCG.cginc\"\n         #include \"Lighting.cginc\"\n         #include \"UnityPBSLighting.cginc\"\n         #include \"AutoLight.cginc\"\n\n         \n\n         #define _PASSFORWARD 1\n         #define _PASSFORWARDADD 1\n\n         \n\n\n   #pragma shader_feature_local_fragment _ _PACKEDFAST\n   #pragma shader_feature_local _ _TRIPLANAR\n   #pragma shader_feature_local_fragment _ _NORMALMAP \n   #pragma shader_feature_local_fragment _ _MASKMAP\n   #pragma shader_feature_local_fragment _ _DETAIL\n   #pragma shader_feature_local_fragment _ _DETAILTRIPLANAR\n   #pragma shader_feature_local_fragment _ _DETAILSTOCHASTIC\n   #pragma shader_feature_local_fragment _ _EMISSION\n   #pragma shader_feature_local_fragment _ _FLATSHADE\n   #pragma shader_feature_local _ _STOCHASTIC\n   #pragma shader_feature_local_fragment _ _PARALLAX //_POM\n   #pragma shader_feature_local_fragment _ _SPECULAR\n   #pragma shader_feature_local _ _NOISEWORLD _NOISELOCAL\n   #pragma shader_feature_local _ _NOISEHQ _NOISETEXTURE _NOISEWORLEY\n   // only for URP/Standard Forward\n   #pragma shader_feature_local_fragment _ _SIMPLELIT\n\n\n   #pragma shader_feature_local_fragment _ _TINTMASK\n\n\n    #pragma shader_feature_local _ _LAYERVERTEXMASK _LAYERTEXTUREMASK\n\n    #define _HAS_WEIGHTTEXTURE_MASK 1\n\n\n   #pragma shader_feature_local _ _USELAYER\n   #pragma shader_feature_local _ _LAYERTRIPLANAR\n   #pragma shader_feature_local _ _LAYERALBEDO\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL\n   #pragma shader_feature_local _ _LAYERMASK\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION\n   #pragma shader_feature_local _ _LAYERNOISE\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC\n   #pragma shader_feature_local _ _LAYERANGLEFILTER\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_1\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_1\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_1\n   #pragma shader_feature_local _ _LAYERMASK_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_1\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_1\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_1\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_1\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_2\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_2\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_2\n   #pragma shader_feature_local _ _LAYERMASK_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_2\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_2\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_2\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_2\n\n\n   #pragma shader_feature_local _ _TRAX_ON\n\n\n   #pragma shader_feature_local_fragment _ _WETNESS\n   #pragma shader_feature_local_fragment _ _PUDDLES\n   #pragma shader_feature_local_fragment _ _PUDDLENOISE\n   #pragma shader_feature_local_fragment _ _RAINDROPS\n\n\n   #pragma shader_feature_local _ _SNOW\n   #pragma shader_feature_local _ _SNOWMASKMAP\n   #pragma shader_feature_local _ _SNOWNOISE\n   #pragma shader_feature_local_fragment _SNOWSTOCHASTIC\n\n\n   #pragma shader_feature_local_fragment _ _WIND_ON\n\n\n\n\n   #pragma shader_feature_local_fragment _ _SURFACEGRADIENT _AUTONORMAL\n   #define _WORLDSPACENORMAL 1\n\n\n   #pragma shader_feature_local _ _DEBUG_SAMPLECOUNT\n\n\n\t#pragma shader_feature_local_fragment _ _DISSOLVE\n\n\n   #pragma multi_compile_local  LOD_FADE_CROSSFADE\n\n\n\n#pragma instancing_options procedural:setupVSPro forwardadd\n\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\nstruct IndirectShaderData\n{\n\tfloat4x4 PositionMatrix;\n\tfloat4x4 InversePositionMatrix;\n\tfloat4 ControlData;\n};\n\n#if defined(SHADER_API_GLCORE) || defined(SHADER_API_D3D11) || defined(SHADER_API_GLES3) || defined(SHADER_API_METAL) || defined(SHADER_API_VULKAN) || defined(SHADER_API_PSSL) || defined(SHADER_API_XBOXONE)\n\tuniform StructuredBuffer<IndirectShaderData> VisibleShaderDataBuffer;\n#endif\n\n#endif\n\nfloat VSPRenderingLayerMask;\n\nvoid setupVSPro()\n{\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\n    #if _HDRP\n\t    unity_RenderingLayer.x = VSPRenderingLayerMask;\n    #endif\n\n\t#ifdef unity_ObjectToWorld\n\t#undef unity_ObjectToWorld\n\t#endif\n\n\t#ifdef unity_WorldToObject\n\t#undef unity_WorldToObject\n\t#endif\n\n\tunity_ObjectToWorld = VisibleShaderDataBuffer[unity_InstanceID].PositionMatrix;\n\tunity_WorldToObject = VisibleShaderDataBuffer[unity_InstanceID].InversePositionMatrix;\n#endif\n\n}\n\n\n\t#pragma multi_compile _LIGHTMAPMODE_STANDARD _LIGHTMAPMODE_RNM _LIGHTMAPMODE_SH _LIGHTMAPMODE_VERTEX _LIGHTMAPMODE_VERTEXDIRECTIONAL _LIGHTMAPMODE_VERTEXSH\n\n    #pragma shader_feature USEBAKERY\n    #pragma shader_feature BAKERY_VERTEXLMMASK\n    #pragma shader_feature BAKERY_SHNONLINEAR\n    #pragma shader_feature BAKERY_LMSPEC\n    #pragma shader_feature BAKERY_BICUBIC\n    #pragma shader_feature BAKERY_VOLUME\n    #pragma shader_feature BAKERY_VOLROTATION\n    #pragma shader_feature BAKERY_COMPRESSED_VOLUME\n\n    #if _USEBAKERY\n\t    #define _OVERRIDE_BAKEDGI\n        #if BAKERY_VOLUME || (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)) && defined(BAKERY_VERTEXLMMASK)\n            #define _OVERRIDE_SHADOWMASK\n        #endif\n    #endif\n\n\n\n\n\n\n\n\n   #define _STANDARD 1\n\n   #define _ALPHABLEND_ON 1\n// If your looking in here and thinking WTF, yeah, I know. These are taken from the SRPs, to allow us to use the same\n// texturing library they use. However, since they are not included in the standard pipeline by default, there is no\n// way to include them in and they have to be inlined, since someone could copy this shader onto another machine without\n// Better Shaders installed. Unfortunate, but I'd rather do this and have a nice library for texture sampling instead\n// of the patchy one Unity provides being inlined/emulated in HDRP/URP. Strangely, PSSL and XBoxOne libraries are not\n// included in the standard SRP code, but they are in tons of Unity own projects on the web, so I grabbed them from there.\n\n\n#if defined(SHADER_API_XBOXONE)\n\t\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n\n#elif defined(SHADER_API_PSSL)\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.GetLOD(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RW_Texture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RW_Texture2D_Array<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RW_Texture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n\n\n#elif defined(SHADER_API_D3D11)\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_METAL)\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)          Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)           Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)           Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_VULKAN)\n// This file assume SHADER_API_VULKAN is defined\n\t// TODO: This is a straight copy from D3D11.hlsl. Go through all this stuff and adjust where needed.\n\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)          Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)           Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)           Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_SWITCH)\n\t// This file assume SHADER_API_SWITCH is defined\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)          Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)           Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)           Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                       textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)              textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)     textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)          textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod) textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                       textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)              textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_GLCORE)\n\n\t// OpenGL 4.1 SM 5.0 https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html\n\t#if (SHADER_TARGET >= 46)\n\t#define OPENGL4_1_SM5 1\n\t#else\n\t#define OPENGL4_1_SM5 0\n\t#endif\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                  Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)            Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)                TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)          TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                  Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)            TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)      TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)          TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)    TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)            TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)             TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)       TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)           TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)     TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)             TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)   TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)         RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)   RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)         RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                    SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)                SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)                textureName.SampleGrad(samplerName, coord2, ddx, ddy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#ifdef UNITY_NO_CUBEMAP_ARRAY\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, bias) ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#else\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#endif\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                          textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                 textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                   textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)      textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                 textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)    textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\n\t#if OPENGL4_1_SM5\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   textureName.Gather(samplerName, float4(coord3, index))\n\t#else\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#endif\n\n\n\t#elif defined(SHADER_API_GLES3)\n\n\t// GLES 3.1 + AEP shader feature https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html\n\t#if (SHADER_TARGET >= 40)\n\t#define GLES3_1_AEP 1\n\t#else\n\t#define GLES3_1_AEP 0\n\t#endif\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                  Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)            Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)                TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)          TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                  Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)            Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)      Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)          TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)    TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)            Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)             Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)       Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)           TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)     TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)             Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)   TEXTURECUBE_ARRAY(textureName)\n\n\t#if GLES3_1_AEP\n\t#define RW_TEXTURE2D(type, textureName)         RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)   RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)         RWTexture3D<type> textureName\n\t#else\n\t#define RW_TEXTURE2D(type, textureName)         ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2D)\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)   ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2DArray)\n\t#define RW_TEXTURE3D(type, textureName)         ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture3D)\n\t#endif\n\n\t#define SAMPLER(samplerName)                    SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)                SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)                textureName.SampleGrad(samplerName, coord2, ddx, ddy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\n\t#ifdef UNITY_NO_CUBEMAP_ARRAY\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_BIAS)\n\t#else\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#endif\n\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                          textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                 textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                   textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)      textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                 textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)    textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                       textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                              textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                     textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                          textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)        textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)                 textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                       textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                              textureName.Load(int4(unCoord3, lod))\n\n\t#if GLES3_1_AEP\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherAlpha(samplerName, coord2)\n\t#else\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_RED_TEXTURE2D)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_GREEN_TEXTURE2D)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_BLUE_TEXTURE2D)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_ALPHA_TEXTURE2D)\n\t#endif\n\n\n#elif defined(SHADER_API_GLES)\n\n\n\t#define uint int\n\n\t#define rcp(x) 1.0 / (x)\n\t#define ddx_fine ddx\n\t#define ddy_fine ddy\n\t#define asfloat\n\t#define asuint(x) asint(x)\n\t#define f32tof16\n\t#define f16tof32\n\n\t#define ERROR_ON_UNSUPPORTED_FUNCTION(funcName) #error #funcName is not supported on GLES 2.0\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) #error calculate Level of Detail not supported in GLES2\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                          sampler2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)                    samplerCUBE textureName // No support to texture2DArray\n\t#define TEXTURECUBE(textureName)                        samplerCUBE textureName\n\t#define TEXTURECUBE_ARRAY(textureName)                  samplerCUBE textureName // No supoport to textureCubeArray and can't emulate with texture2DArray\n\t#define TEXTURE3D(textureName)                          sampler3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)                    sampler2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)              TEXTURECUBE_FLOAT(textureName) // No support to texture2DArray\n\t#define TEXTURECUBE_FLOAT(textureName)                  samplerCUBE_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)            TEXTURECUBE_FLOAT(textureName) // No support to textureCubeArray\n\t#define TEXTURE3D_FLOAT(textureName)                    sampler3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)                     sampler2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)               TEXTURECUBE_HALF(textureName) // No support to texture2DArray\n\t#define TEXTURECUBE_HALF(textureName)                   samplerCUBE_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)             TEXTURECUBE_HALF(textureName) // No support to textureCubeArray\n\t#define TEXTURE3D_HALF(textureName)                     sampler3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)                   SHADOW2D_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)             TEXTURECUBE_SHADOW(textureName) // No support to texture array\n\t#define TEXTURECUBE_SHADOW(textureName)                 SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)           TEXTURECUBE_SHADOW(textureName) // No support to texture array\n\n\t#define RW_TEXTURE2D(type, textureNam)                  ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2D)\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)           ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2DArray)\n\t#define RW_TEXTURE3D(type, textureNam)                  ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture3D)\n\n\t#define SAMPLER(samplerName)\n\t#define SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                sampler2D textureName\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)          samplerCUBE textureName\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)              samplerCUBE textureName\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        samplerCUBE textureName\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                sampler3D textureName\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)         SHADOW2D_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)   SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)       SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)               textureName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)         textureName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)             textureName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)       textureName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)               textureName\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)        textureName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)  textureName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)      textureName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2) tex2D(textureName, coord2)\n\n\t#if (SHADER_TARGET >= 30)\n\t    #define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod) tex2Dlod(textureName, float4(coord2, 0, lod))\n\t#else\n\t    // No lod support. Very poor approximation with bias.\n\t    #define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod) SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, lod)\n\t#endif\n\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                       tex2Dbias(textureName, float4(coord2, 0, bias))\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)                   SAMPLE_TEXTURE2D(textureName, samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                     ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY)\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)            ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_LOD)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)          ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_BIAS)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy)    ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_GRAD)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                                texCUBE(textureName, coord3)\n\t// No lod support. Very poor approximation with bias.\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                       SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                     texCUBEbias(textureName, float4(coord3, bias))\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                   ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)          ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)        ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_BIAS)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                                  tex3D(textureName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                         ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE3D_LOD)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                           SHADOW2D_SAMPLE(textureName, samplerName, coord3)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)              ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_SHADOW)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                         SHADOWCUBE_SAMPLE(textureName, samplerName, coord4)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)            ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_SHADOW)\n\n\n\t// Not supported. Can't define as error because shader library is calling these functions.\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                               half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                                      half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                             half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                                  half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)                half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)                         half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                               ERROR_ON_UNSUPPORTED_FUNCTION(LOAD_TEXTURE3D)\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                                      ERROR_ON_UNSUPPORTED_FUNCTION(LOAD_TEXTURE3D_LOD)\n\n\t// Gather not supported. Fallback to regular texture sampling.\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_RED_TEXTURE2D)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_GREEN_TEXTURE2D)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_BLUE_TEXTURE2D)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_ALPHA_TEXTURE2D)\n\n#else\n#error unsupported shader api\n#endif\n\n\n\n\n// default flow control attributes\n#ifndef UNITY_BRANCH\n#   define UNITY_BRANCH\n#endif\n#ifndef UNITY_FLATTEN\n#   define UNITY_FLATTEN\n#endif\n#ifndef UNITY_UNROLL\n#   define UNITY_UNROLL\n#endif\n#ifndef UNITY_UNROLLX\n#   define UNITY_UNROLLX(_x)\n#endif\n#ifndef UNITY_LOOP\n#   define UNITY_LOOP\n#endif\n\n\n\n#define NEED_FACING 1\n\n         // data across stages, stripped like the above.\n         struct VertexToPixel\n         {\n            UNITY_POSITION(pos);       // must be named pos because Unity does stupid macro stuff\n            float3 worldPos : TEXCOORD0;\n            float3 worldNormal : TEXCOORD1;\n            float4 worldTangent : TEXCOORD2;\n             float4 texcoord0 : TEXCCOORD3;\n             float4 texcoord1 : TEXCCOORD4;\n            // float4 texcoord2 : TEXCCOORD5;\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n            // float4 texcoord3 : TEXCCOORD6;\n             #endif\n            \n             #if LOD_FADE_CROSSFADE\n             float4 screenPos : TEXCOORD7;\n             #endif\n\n            UNITY_LIGHTING_COORDS(8,9)\n            UNITY_FOG_COORDS(10)\n\n            \n             #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n             float4 vertexColor : COLOR_centroid;\n             #endif\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // float4 extraV2F0 : TEXCOORD11;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // float4 extraV2F1 : TEXCOORD12;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // float4 extraV2F2 : TEXCOORD13;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // float4 extraV2F3 : TEXCOORD14;\n            // #endif\n\n             #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n             float4 extraV2F4 : TEXCOORD15_centroid;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n             float4 extraV2F5 : TEXCOORD16_centroid;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             float4 extraV2F6 : TEXCOORD17_centroid;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             float4 extraV2F7 : TEXCOORD18_centroid;\n             #endif\n\n            UNITY_VERTEX_INPUT_INSTANCE_ID\n            UNITY_VERTEX_OUTPUT_STEREO\n\n         };\n\n         \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n   half4 weightTextureMask;\n   \n\n\n   float traxBuffer;\n\n\n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // would love to strip these, but they are used in certain\n               // combinations of the lighting system, and may be used\n               // by the user as well, so no easy way to strip them.\n\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR_centroid;\n                #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                float4 extraV2F4 : TEXCOORD9_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                float4 extraV2F5 : TEXCOORD10_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F6 : TEXCOORD11_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F7 : TEXCOORD12_centroid;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef UNITY_MATRIX_M\n               #undef UNITY_MATRIX_I_M\n               #undef UNITY_MATRIX_V\n               #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n               #undef UNITY_MATRIX_VP\n               #undef UNITY_MATRIX_MV\n               #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n               #undef UNITY_MATRIX_MVP\n\n               #define UNITY_MATRIX_M     unity_ObjectToWorld\n               #define UNITY_MATRIX_I_M   unity_WorldToObject\n               #define UNITY_MATRIX_V     unity_MatrixV\n               #define UNITY_MATRIX_I_V   unity_MatrixInvV\n               #define UNITY_MATRIX_P     OptimizeProjectionMatrix(glstate_matrix_projection)\n               #define UNITY_MATRIX_VP    unity_MatrixVP\n               #define UNITY_MATRIX_MV    mul(UNITY_MATRIX_V, UNITY_MATRIX_M)\n               #define UNITY_MATRIX_T_MV  transpose(UNITY_MATRIX_MV)\n               #define UNITY_MATRIX_IT_MV transpose(mul(UNITY_MATRIX_I_M, UNITY_MATRIX_I_V))\n               #define UNITY_MATRIX_MVP   mul(UNITY_MATRIX_VP, UNITY_MATRIX_M)\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)UNITY_MATRIX_M, transpose(mul(UNITY_MATRIX_I_M, UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)UNITY_MATRIX_V, norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n               #endif\n               #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n         \n\n\n   half4 _Tint;\n   half _UVSource;\n   half _TriplanarContrast;\n   half _AlbedoContrast;\n   half _AlbedoBrightness;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half3 _EmissionColor;\n   float _DetailUVSource;\n   half _StochasticScale;\n   half _DetailStochasticScale;\n   half _Smoothness;\n   half _Metallic;\n   half2 _SmoothnessRemap;\n   half2 _AORemap;\n   half2 _MetallicRemap;\n   half2 _HeightRemap;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n   half _AlphaThreshold;\n   half _Cutoff; // for Unity's light mapper\n   half _TriplanarSpace;\n   half _DetailTriplanarSpace;\n   half _DetailTriplanarContrast;\n   half _MicroShadowStrength;\n   half3 _FuzzyShadingColor;\n   half _FuzzyShadingOn;\n   half3 _FuzzyShadingParams;\n\n   //int _POMMaxSamples;\n   //float _POMMin;\n   //float _POMFade;\n#if _FLATSHADE\n   half _FlatShadingBlend;\n#endif\n\n   half _StochasticContrast;\n   half _DetailStochasticContrast;\n\n#if _PARALLAX || _POM\n   half _ParallaxHeight;\n#endif\n\n\n\n\tfloat4 _TintMask_ST;\n\thalf3 _RColor;\n\thalf3 _GColor;\n\thalf3 _BColor;\n\thalf3 _AColor;\n\n\n\thalf _LayerTextureMaskUVMode;\n    float4 _LayerTextureMask_ST;\n\n\n   //#if _USELAYER\n       float4 _LayerAlbedoMap_ST;\n       half3 _LayerTint;\n       half _LayerBlendMode;\n       float _LayerUVSource;\n       half _LayerAlbedoBrightness;\n       half _LayerAlbedoContrast;\n       half _LayerHeightContrast;\n       half _LayerStrength;\n       half _LayerAlbedoStrength;\n       half _LayerNormalStrength;\n       half _LayerSmoothnessStrength;\n       half _LayerSmoothness;\n       half _LayerMetallic;\n       half _LayerStochasticScale;\n       half2 _LayerSmoothnessRemap;\n       half2 _LayerAORemap;\n       half2 _LayerMetallicRemap;\n       half2 _LayerHeightRemap;\n       float4 _LayerWeightOverDistance;\n       half _LayerMicroShadowStrength;\n       //#if _LAYERNOISE\n           float _LayerNoiseFrequency;\n           float _LayerNoiseAmplitude;\n           float _LayerNoiseOffset;\n           float _LayerNoiseCenter;\n           half3 _LayerBlendTint;\n       //#endif\n       //#if _LAYERANGLEFILTER\n           half _LayerFalloff;\n           half _LayerAngleMin;\n           half _LayerHeight;\n           half _LayerInvertHeight;\n           half _LayerVertexNormalBlend;\n       //#endif\n       half _LayerTriplanarSpace;\n       half _LayerTriplanarContrast;\n       half _LayerBlendContrast;\n       half3 _LayerEmissionColor;\n       half _LayerStochasticContrast;\n       half _LayerTessStrength;\n       half3 _LayerFuzzyShadingColor;\n       half _LayerFuzzyShadingOn;\n       half3 _LayerFuzzyShadingParams;\n   //#endif\n\n\n   //#if _USELAYER_DEF_1\n       float4 _LayerAlbedoMap_Ext_1_ST;\n       half3 _LayerTint_Ext_1;\n       half _LayerBlendMode_Ext_1;\n       float _LayerUVSource_Ext_1;\n       half _LayerAlbedoBrightness_Ext_1;\n       half _LayerAlbedoContrast_Ext_1;\n       half _LayerHeightContrast_Ext_1;\n       half _LayerStrength_Ext_1;\n       half _LayerAlbedoStrength_Ext_1;\n       half _LayerNormalStrength_Ext_1;\n       half _LayerSmoothnessStrength_Ext_1;\n       half _LayerSmoothness_Ext_1;\n       half _LayerMetallic_Ext_1;\n       half _LayerStochasticScale_Ext_1;\n       half2 _LayerSmoothnessRemap_Ext_1;\n       half2 _LayerAORemap_Ext_1;\n       half2 _LayerMetallicRemap_Ext_1;\n       half2 _LayerHeightRemap_Ext_1;\n       float4 _LayerWeightOverDistance_Ext_1;\n       half _LayerMicroShadowStrength_Ext_1;\n       //#if _LAYERNOISE_DEF_1\n           float _LayerNoiseFrequency_Ext_1;\n           float _LayerNoiseAmplitude_Ext_1;\n           float _LayerNoiseOffset_Ext_1;\n           float _LayerNoiseCenter_Ext_1;\n           half3 _LayerBlendTint_Ext_1;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_1\n           half _LayerFalloff_Ext_1;\n           half _LayerAngleMin_Ext_1;\n           half _LayerHeight_Ext_1;\n           half _LayerInvertHeight_Ext_1;\n           half _LayerVertexNormalBlend_Ext_1;\n       //#endif\n       half _LayerTriplanarSpace_Ext_1;\n       half _LayerTriplanarContrast_Ext_1;\n       half _LayerBlendContrast_Ext_1;\n       half3 _LayerEmissionColor_Ext_1;\n       half _LayerStochasticContrast_Ext_1;\n       half _LayerTessStrength_Ext_1;\n       half3 _LayerFuzzyShadingColor_Ext_1;\n       half _LayerFuzzyShadingOn_Ext_1;\n       half3 _LayerFuzzyShadingParams_Ext_1;\n   //#endif\n\n\n   //#if _USELAYER_DEF_2\n       float4 _LayerAlbedoMap_Ext_2_ST;\n       half3 _LayerTint_Ext_2;\n       half _LayerBlendMode_Ext_2;\n       float _LayerUVSource_Ext_2;\n       half _LayerAlbedoBrightness_Ext_2;\n       half _LayerAlbedoContrast_Ext_2;\n       half _LayerHeightContrast_Ext_2;\n       half _LayerStrength_Ext_2;\n       half _LayerAlbedoStrength_Ext_2;\n       half _LayerNormalStrength_Ext_2;\n       half _LayerSmoothnessStrength_Ext_2;\n       half _LayerSmoothness_Ext_2;\n       half _LayerMetallic_Ext_2;\n       half _LayerStochasticScale_Ext_2;\n       half2 _LayerSmoothnessRemap_Ext_2;\n       half2 _LayerAORemap_Ext_2;\n       half2 _LayerMetallicRemap_Ext_2;\n       half2 _LayerHeightRemap_Ext_2;\n       float4 _LayerWeightOverDistance_Ext_2;\n       half _LayerMicroShadowStrength_Ext_2;\n       //#if _LAYERNOISE_DEF_2\n           float _LayerNoiseFrequency_Ext_2;\n           float _LayerNoiseAmplitude_Ext_2;\n           float _LayerNoiseOffset_Ext_2;\n           float _LayerNoiseCenter_Ext_2;\n           half3 _LayerBlendTint_Ext_2;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_2\n           half _LayerFalloff_Ext_2;\n           half _LayerAngleMin_Ext_2;\n           half _LayerHeight_Ext_2;\n           half _LayerInvertHeight_Ext_2;\n           half _LayerVertexNormalBlend_Ext_2;\n       //#endif\n       half _LayerTriplanarSpace_Ext_2;\n       half _LayerTriplanarContrast_Ext_2;\n       half _LayerBlendContrast_Ext_2;\n       half3 _LayerEmissionColor_Ext_2;\n       half _LayerStochasticContrast_Ext_2;\n       half _LayerTessStrength_Ext_2;\n       half3 _LayerFuzzyShadingColor_Ext_2;\n       half _LayerFuzzyShadingOn_Ext_2;\n       half3 _LayerFuzzyShadingParams_Ext_2;\n   //#endif\n\n\n    half _TraxDisplacementDepth;\n    half _TraxDisplacementStrength;\n    half _TraxMipBias;\n    half _TraxNormalStrength;\n    float4 _TraxAlbedo_ST;\n    half _TraxInterpContrast;\n    half _TraxHeightContrast;\n    half3 _TraxTint;\n\n\n\n    half _Porosity;\n    int _WetnessMode;\n    int _PuddleMode;\n\n    half  _PuddleAmount;\n    half  _PuddleFalloff;\n    half4 _PuddleColor;\n    half _PuddleNoiseFrequency;\n    half _PuddleNoiseAmplitude;\n    half _PuddleNoiseOffset;\n    half _PuddleNoiseCenter;\n    half _PuddleAngleMin;\n\n    half _WetnessAmount;\n\thalf _WetnessMin;\n    half _WetnessMax;\n    half _WetnessFalloff;\n\thalf _WetnessAngleMin;\n    float _WetnessShoreline;\n\n    int _RainMode;\n    half3 _RainIntensityScale;\n\n\n\n\n    float4 _SnowAlbedo_ST;\n    half3 _SnowTint;\n    half _SnowAmount;\n    half _SnowAngle;\n    half _SnowContrast;\n    half _SnowVertexHeight;\n    half _SnowMode;\n    half3 _SnowWorldFade; // z is on/off\n    float4 _SnowTraxAlbedo_ST;\n    half3 _SnowTraxTint;\n\n    half _SnowNoiseFreq; \n    half _SnowNoiseAmp;\n    half _SnowNoiseOffset;\n    half _SnowStochasticContrast;\n    half _SnowStochasticScale;\n\n\n    half     _WindParticulateSpace;\n    half     _WindParticulateRotation;\n    half      _WindParticulateSpeed;\n    float4     _WindParticulate_ST;\n    half      _WindParticulatePower;\n    half4    _WindParticulateColor;\n    half4    _WindParticulateWorldHeightMask;\n    half4    _WindParticulateAngleMask;\n    half      _WindParticulateOcclusionStrength;\n    half      _WindParticulateStrength;\n    half4    _WindParticulateEmissive;\n    half     _WindParticulateTextureHeight;\n\n\n   float _DoubleSidedNormalMode;\n\n\n\thalf _AutoNormalStrength;\n\n\n\tint _DebugSampleCountThreshold;\n\n\n\thalf _DissolveAmount;\n\thalf _DissolveEmissiveStr;\n\thalf _DissolveEdgeContrast;\n\thalf _DissolveColoration;\n\tfloat4 _DissolveTexture_ST;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n         \n\n         \n\n         \n\n#ifndef __STACKABLEFUNCLIBRARY_INCLUDES__\n#define __STACKABLEFUNCLIBRARY_INCLUDES__\n\n   #if _DEBUG_SAMPLECOUNT\n      int _sampleCount;\n      #define COUNTSAMPLE { _sampleCount++; }\n   #else\n      #define COUNTSAMPLE\n   #endif\n\n   TEXTURE2D(_NoiseTex);\n   SAMPLER(sampler_NoiseTex);\n\n\n\n   half3 AdjustContrast(half3 color, half contrast)\n   {\n       half3 comp = 0.5;\n   #if !UNITY_COLORSPACE_GAMMA\n       comp = 0.22;\n   #endif\n       color = saturate(lerp(comp, color, contrast));\n       return color;\n   }\n\n   float2 DoParallaxOffset( half h, half height, half3 viewDir)\n   {\n      h = h * height - height/2.0;\n      float3 v = normalize(viewDir);\n      v.z += 0.42;\n      return h * (v.xy / v.z);\n   }\n\n\n\n   #define SAMPLEBARY SampleTexBary\n\n   struct SampleConfig\n   {\n      float2 uv0;\n      float2 uv1;\n      float2 uv2;\n      float2 dx0;\n      float2 dy0;\n      float2 dx1;\n      float2 dy1;\n      float2 dx2;\n      float2 dy2;\n      float3 weights;\n      float3 origWeights;\n   };\n\n   struct Config\n   {\n      float2 origUV; // unscaled uv\n      float2 origScale;\n      float2 uv;        // no stocastic or triplanar\n      float2 dx;\n      float2 dy;\n      SampleConfig uvT; // just stochastic, or just triplanar\n      SampleConfig uvX; // stochastic and triplanar\n      SampleConfig uvY;\n      SampleConfig uvZ;\n\n      \n      float3 absVertNormal;\n      half3 axisSign;\n      float3 normal;\n   };\n\n\n    float2 Hash2D( float2 x )\n    {\n        float2 k = float2( 0.3183099, 0.3678794 );\n        x = x*k + k.yx;\n        return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );\n    }\n\n    float Noise2D(float2 p )\n    {\n        float2 i = floor( p );\n        float2 f = frac( p );\n         \n        float2 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), \n                        dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),\n                    lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), \n                        dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);\n    }\n      \n\n    float2 WorleyHash2D(float2 p)\n    {\n \t    return frac(cos(mul(p, float2x2(-64.2,71.3,81.4,-29.8)))*8321.3); \n    }\n    float WorleyNoise2D(float2 p)\n    {\n        float dist = 1;\n        float2 i = floor(p);\n        float2 f = frac(p);\n    \n        for(int x = -1;x<=1;x++)\n        {\n            for(int y = -1;y<=1;y++)\n            {\n                float d = distance(WorleyHash2D(i+float2(x,y))+float2(x,y),f);\n                dist = min(dist,d);\n            }\n        }\n        return dist;\n\t\n    }\n\n#ifndef PI\n    #define PI 3.14159265359\n#endif\n\n    float GetIntegerNoise(float2 p)\n    {\n        p  = 53.7 * frac( (p*0.3183099) + float2(0.71,0.113));\n        return frac( p.x*p.y*(p.x+p.y) );\n    }\n\n    float WorleyHash3D(float f)\n    {\n        return frac(sin(f)*43758.5453);\n    }\n\n    float WorleyHash31(float3 v)\n    {\n        return WorleyHash3D(dot(v, float3(253.14, 453.74, 183.3)));\n    }\n\n    float3 WorleyRandom3D( float3 p )\n    {\n        return frac(sin(float3(dot(p,float3(127.1,311.7,217.3)),dot(p,float3(269.5,183.3,431.1)), dot(p,float3(365.6,749.9,323.7))))*437158.5453);\n    }\n\n    float WorleyNoise3D(float3 uvw)\n    {\n        float noise = 0.0;\n    \n        float3 p = floor(uvw);\n        float3 f = frac(uvw);\n    \n        float4 res = 1;\n        for(int x = -1; x <=1; ++x)\n        {\n            for(int y = -1; y <=1; ++y)\n            {\n                for(int z = -1; z <=1; ++z)\n                {\n                    float3 gp = p + float3(x, y, z);\n\n                    float3 v = WorleyRandom3D(gp);\n\n\t\t\t\t    float3 diff = gp + v - uvw;\n                \n                    float d = length(diff);\n                \n                    if(d < res.x)\n                    {\n                        res.xyz = float3(d, res.x, res.y);\n                    }\n                    else if(d < res.y)\n                    {\n                        res.xyz = float3(res.x, d, res.y);\n                    }\n                    else if(d < res.z)\n                    {\n                        res.z = d;\n                    }\n                \n                    res.w = WorleyHash31(gp);\n                }\n            }\n        }\n\n        return res.x;\n    }\n    \n      \n    float3 Hash3D( float3 p )\n    {\n        p = float3( dot(p,float3(127.1,311.7, 74.7)),\n                dot(p,float3(269.5,183.3,246.1)),\n                dot(p,float3(113.5,271.9,124.6)));\n\n        return -1.0 + 2.0*frac(sin(p)*437.5453123);\n    }\n\n    float Noise3D( float3 p )\n    {\n        float3 i = floor( p );\n        float3 f = frac( p );\n         \n        float3 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),\n                    lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n    }\n\n    \n    float FBM2D(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           return SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n\n    }\n      \n    float FBM3D(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           half A = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.zy).g;\n           half B = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33).g;\n           half C = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoise(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3D(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3D(d.localSpacePosition * frequency+ offset, d.localSpaceNormal);\n        #else\n           return FBM2D(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n    \n    #if _SURFACEGRADIENT  \n\n    #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)\n\n      \n      \n    half3 SurfaceGradientFromTBN(ShaderData d, half2 deriv)\n    {\n        return deriv.x * d.TBNMatrix[0] + deriv.y * d.TBNMatrix[1];\n    }\n\n    half2 TspaceNormalToDerivative(half3 vM)\n    {\n        const half scale = 1.0/128.0;\n        const half3 vMa = abs(vM);\n        const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));\n\n        return -half2(vM.x, vM.y)/z_ma;\n    }\n\n    half3 SurfgradFromVolumeGradient(ShaderData d, half3 grad)\n    {\n        return grad - dot(d.worldSpaceNormal, grad) * d.worldSpaceNormal;\n    }\n\n    half3 SurfgradFromTriplanarProjection(ShaderData d, half3 pN, half3 xN, half3 yN, half3 zN)\n    {\n        const half w0 = pN.x;\n        const half w1 = pN.y;\n        const half w2 = pN.z;\n\n        half2 xD = TspaceNormalToDerivative(xN);\n        half2 yD = TspaceNormalToDerivative(yN);\n        half2 zD = TspaceNormalToDerivative(zN);\n\n        half3 volumeGrad = half3(w2 * zD.x + w1 * yD.y, w2 * zD.y + w0 * xD.y, w0 * xD.x + w1 * yD.x);\n\n        return SurfgradFromVolumeGradient(d, volumeGrad);\n    }\n\n    half3 ConvertNormalToGradient(ShaderData d, half3 normal)\n    {\n        half2 deriv = TspaceNormalToDerivative(normal);\n\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n    half3 ConvertNormal2ToGradient(ShaderData d, half2 packedNormal)\n    {\n        half2 tNormal = packedNormal;\n        half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF\n        half2 deriv = tNormal * -rcpZ;\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n\n    half3 ResolveNormalFromSurfaceGradient(ShaderData d, half3 gradient)\n    {\n        return normalize(d.worldSpaceNormal - gradient);\n    }\n\n    #endif // _SURFACEGRADIENT\n\n\n    // normals are in surface gradient or world space depending on settings, and can also be generated by height\n    half3 GetWorldSpaceNormal(ShaderData d, half3 normal, half pheight)\n    {\n       #if _SURFACEGRADIENT\n          return ResolveNormalFromSurfaceGradient(d, normal);\n       #elif _AUTONORMAL\n          float3 dx = ddx(d.worldSpacePosition);\n          float3 dy = ddy(d.worldSpacePosition);\n          float3 crossX = cross(float3(0,1,0), dx);\n          float3 crossY = cross(float3(0,1,0), dy);\n          float3 dt = abs(dot(crossY, dx));\n          float height = _AutoNormalStrength * 0.5 * pheight;\n          float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n          n.y *= -1.0;\n          return TangentToWorldSpace(d, normalize((dt * float3(0,1,0)) - n).xzy);\n       #else\n          return TangentToWorldSpace(d, normal);\n          \n       #endif\n       \n    }\n\n   void WaterBRDF (inout half3 albedo, inout half smoothness, half metallic, half wetFactor, half surfPorosity) \n   {\n      half porosity = saturate((( (1 - smoothness) - 0.5)) / max(surfPorosity, 0.001));\n      half factor = lerp(1, 0.2, (1 - metallic) * porosity);\n      albedo *= lerp(1.0, factor, wetFactor);\n      smoothness = lerp(smoothness, 0.92f, wetFactor);\n   }\n\n   void OffsetUV(inout Config c, float2 offset)\n   {\n       c.uv += offset;\n       c.uvT.uv0 += offset;\n       c.uvT.uv1 += offset;\n       c.uvT.uv2 += offset;\n       c.uvX.uv0 += offset;\n       c.uvX.uv1 += offset;\n       c.uvX.uv2 += offset;\n       c.uvY.uv0 += offset;\n       c.uvY.uv1 += offset;\n       c.uvY.uv2 += offset;\n       c.uvZ.uv0 += offset;\n       c.uvZ.uv1 += offset;\n       c.uvZ.uv2 += offset;\n   }\n\n\n    void TriangleGrid(float2 uv, float scale,\n       out float w1, out float w2, out float w3,\n       out int2 vertex1, out int2 vertex2, out int2 vertex3)\n    {\n       // Scaling of the input\n       uv *= 3.464 * scale; // 2 * sqrt(3)\n\n       // Skew input space into simplex triangle grid\n       const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);\n       float2 skewedCoord = mul(gridToSkewedGrid, uv);\n\n       // Compute local triangle vertex IDs and local barycentric coordinates\n       int2 baseId = int2(floor(skewedCoord));\n       float3 temp = float3(frac(skewedCoord), 0);\n       temp.z = 1.0 - temp.x - temp.y;\n       if (temp.z > 0.0)\n       {\n          w1 = temp.z;\n          w2 = temp.y;\n          w3 = temp.x;\n          vertex1 = baseId;\n          vertex2 = baseId + int2(0, 1);\n          vertex3 = baseId + int2(1, 0);\n       }\n       else\n       {\n          w1 = -temp.z;\n          w2 = 1.0 - temp.y;\n          w3 = 1.0 - temp.x;\n          vertex1 = baseId + int2(1, 1);\n          vertex2 = baseId + int2(1, 0);\n          vertex3 = baseId + int2(0, 1);\n       }\n    }\n\n    // Fast random hash function\n    float2 SimpleHash2(float2 p)\n    {\n       return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 43758.5453);\n    }\n\n\n    half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)\n    {\n        // compute weight with height map\n        const half epsilon = 1.0f / 1024.0f;\n        half3 weights = half3(iWeights.x * (tex0 + epsilon), \n                                 iWeights.y * (tex1 + epsilon),\n                                 iWeights.z * (tex2 + epsilon));\n\n        // Contrast weights\n        half maxWeight = max(weights.x, max(weights.y, weights.z));\n        half transition = contrast * maxWeight;\n        half threshold = maxWeight - transition;\n        half scale = 1.0f / transition;\n        weights = saturate((weights - threshold) * scale);\n        // Normalize weights.\n        half weightScale = 1.0f / (weights.x + weights.y + weights.z);\n        weights *= weightScale;\n        return weights;\n    }\n\n\n    half3 PackedUnpackScaleNormal(half4 packedNormal, float scale)\n   {\n       #if _PACKEDFAST\n          half3 normal;\n          normal.xy = (packedNormal.ag * 2 - 1) * scale;\n          normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n          return normal;  \n       #endif\n       return UnpackScaleNormal(packedNormal, scale);\n   }\n\n    void InitStochasticDxDy(inout SampleConfig c, Config cfg)\n    {\n      c.dx0 = ddx(cfg.origUV) * cfg.origScale;\n      c.dy0 = ddy(cfg.origUV) * cfg.origScale;\n      c.dx1 = c.dx0; c.dx1 = c.dx0;\n      c.dx2 = c.dy0; c.dy2 = c.dy0;\n    }\n\n    void PrepareStochasticUVs(float scale, float2 uv, out SampleConfig c)\n    {\n       // Get triangle info\n       ZERO_INITIALIZE(SampleConfig, c);\n       float w1, w2, w3;\n       int2 vertex1, vertex2, vertex3;\n       TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n       // Assign random offset to each triangle vertex\n       c.uv0 = uv;\n       c.uv1 = uv;\n       c.uv2 = uv;\n   \n       c.uv0.xy += SimpleHash2(vertex1);\n       c.uv1.xy += SimpleHash2(vertex2);\n       c.uv2.xy += SimpleHash2(vertex3);\n       c.weights = half3(w1, w2, w3);\n       c.origWeights = half3(w1, w2, w3);\n    }\n\n\n   half3 LitBlendDetailNormal(half3 n1, half3 n2)\n   {\n      #if _SURFACEGRADIENT\n         return n1 + n2;\n      #else\n         return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n      #endif\n   }\n\n   float3 TriplanarBlendUnpackedRNM(float3 n1, float3 n2)\n   {\n       n1.z += 1;\n       n2.xy = -n2.xy;\n       return n1 * dot(n1, n2) / n1.z - n2;\n   }\n\n   void InitConfigDxDy(inout Config c)\n   {\n      c.uvT.dx0 = ddx(c.uvT.uv0);\n      c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1);\n      c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2);\n      c.uvT.dy2 = ddy(c.uvT.uv2);\n   }\n\n   Config CreateConfig(ShaderData d, float4 scale, float space, int uvsource, half triplanarContrast)\n   {\n      Config c;\n      ZERO_INITIALIZE(Config, c);\n\n      float3 pos = d.worldSpacePosition;\n      float3 normal = d.worldSpaceNormal;\n      if (space > 0)\n      {\n         pos = d.localSpacePosition;\n         normal = d.localSpaceNormal;\n      }\n\n      c.uv = d.texcoord0.xy;\n      \n      if (uvsource == 1)\n        c.uv = d.texcoord1.xy;\n      else if (uvsource == 2)\n        c.uv = pos.yz * float2(1, -1);\n      else if (uvsource == 3)\n        c.uv = pos.xz * float2(1, -1);\n      else if (uvsource == 4)\n        c.uv = pos.xy * float2(1, -1);\n\n      c.origUV = c.uv;\n      c.origScale = scale.xy;\n\n      c.uv = c.uv * scale.xy + scale.zw;\n      c.dx = ddx(c.uv);\n      c.dy = ddy(c.uv);\n\n      c.normal = normal;\n      c.uvT.uv0 = pos.zy * scale.xy + scale.zw;\n      c.uvT.uv1 = pos.xz * scale.xy + scale.zw;\n      c.uvT.uv2 = pos.xy * scale.xy + scale.zw;\n        \n      c.uvT.uv1 += 0.33;\n      c.uvT.uv2 += 0.67;\n\n      c.uvT.dx0 = ddx(c.uvT.uv0); c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1); c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2); c.uvT.dy2 = ddy(c.uvT.uv2);\n\n      half3 triblend = saturate(pow(abs(c.normal), triplanarContrast));\n      triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n      c.uvT.weights = triblend;\n      c.uvT.origWeights = triblend;\n      c.axisSign = d.worldSpaceNormal < 0 ? -1 : 1;\n      c.absVertNormal = abs(d.worldSpaceNormal);\n     \n\n      return c;\n   }\n\n\n   half4 TriSample(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0) * c.weights.x;\n      }\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1) * c.weights.y;\n      }  \n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2) * c.weights.z;\n      }\n\n      return res;\n   }\n\n   half4 TriSampleBary(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      c.weights = BaryWeightBlend(c.origWeights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   half4 TriSampleGrad(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvX, contrast, d) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvY, contrast, d) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n           res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvZ, contrast, d) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   \n   half4 SampleTexBaryStochastic(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   half4 SampleTexBaryTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleGrad(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   \n   half4 SampleTexBary(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        COUNTSAMPLE\n        return SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv, c.dx, c.dy);\n   }\n\n   half4 SampleTexStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ) * c.uvT.weights.z;\n\n        return res;     \n   }\n\n   \n   half4 SampleTexStochastic(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n\n   half4 SampleTexTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n   \n   half4 SampleTex(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       COUNTSAMPLE\n       return SAMPLE_TEXTURE2D(tex, ss, c.uv);\n   }\n   \n\n \n   half3 SampleNormalStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n         dataX = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n         dataY = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n         dataZ = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ));\n\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n\n          return WorldToTangentSpace(d, worldNormal);\n       #endif\n   }\n\n\n   half3 SampleNormalTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n      {\n          COUNTSAMPLE\n          dataX = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv0, c.uvT.dx0, c.uvT.dy0));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n      {\n          COUNTSAMPLE\n          dataY = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv1, c.uvT.dx1, c.uvT.dy1));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n      {\n         COUNTSAMPLE\n         dataZ = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv2, c.uvT.dx2, c.uvT.dy2));\n      }\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n          return WorldToTangentSpace(d, worldNormal);\n      #endif\n   }\n\n   half3 SampleNormalStochastic(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n     half4 normal = TriSample(tex, ss, c.uvT);\n     #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half3 SampleNormal(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 normal = SAMPLE_TEXTURE2D(tex, ss, c.uv);\n      #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half HeightBlend(half h1, half h2, half slope, half contrast)\n   {\n      h2 = 1 - h2;\n      half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); \n      half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));\n      return blend;\n   }\n\n\n    #if _POM\n    float2 POM(TEXTURE2D_PARAM(tex, ss), Config c, float contrast, ShaderData d)\n    {\n       float2 curv = float2(0, 0);\n       float refPlane = 0;\n\n       float result = 0;\n       int stepIndex = 0;\n       int maxSamples = _POMMaxSamples;\n       int minSamples = 4;\n       float camDist = distance(_WorldSpaceCameraPos, d.worldSpacePosition);\n       float distanceFade = 1 - saturate((camDist - _POMMin) / max(1, _POMFade));\n       int numSteps = ( int )lerp( maxSamples, minSamples, dot( d.worldSpaceNormal, d.worldSpaceViewDir )) * distanceFade;\n       if (numSteps < 1)\n           numSteps = 1;\n       float layerHeight = 1.0 / numSteps;\n       float2 plane = _ParallaxHeight * ( d.tangentSpaceViewDir.xy / d.tangentSpaceViewDir.z ) * distanceFade;\n       OffsetUV(c, refPlane * plane);\n       float2 deltaTex = -plane * layerHeight;\n       float2 prevTexOffset = 0;\n       float prevRayZ = 1.0f;\n       float prevHeight = 0.0f;\n       float2 currTexOffset = deltaTex;\n       float currRayZ = 1.0f - layerHeight;\n       float currHeight = 0.0f;\n       float intersection = 0;\n       float2 finalTexOffset = 0;\n\n       while ( stepIndex < numSteps + 1 )\n       {\n          result = dot( curv, currTexOffset * currTexOffset );\n          Config cfg = c;\n          OffsetUV(cfg, currTexOffset);\n          currHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( currHeight > currRayZ )\n          {\n             stepIndex = numSteps + 1;\n          }\n          else\n          {\n             stepIndex++;\n             prevTexOffset = currTexOffset;\n             prevRayZ = currRayZ;\n             prevHeight = currHeight;\n             currTexOffset += deltaTex;\n             currRayZ -= layerHeight * ( 1 - result );\n          }\n       }\n       int sectionSteps = 10;\n       int sectionIndex = 0;\n       float newZ = 0;\n       float newHeight = 0;\n       while ( sectionIndex < sectionSteps )\n       {\n          intersection = ( prevHeight - prevRayZ ) / ( prevHeight - currHeight + currRayZ - prevRayZ );\n          finalTexOffset = prevTexOffset + intersection * deltaTex;\n          newZ = prevRayZ - intersection * layerHeight;\n          Config cfg = c;\n          OffsetUV(cfg, finalTexOffset);\n          newHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( newHeight > newZ )\n          {\n             currTexOffset = finalTexOffset;\n             currHeight = newHeight;\n             currRayZ = newZ;\n             deltaTex = intersection * deltaTex;\n             layerHeight = intersection * layerHeight;\n          }\n          else\n          {\n             prevTexOffset = finalTexOffset;\n             prevHeight = newHeight;\n             prevRayZ = newZ;\n             deltaTex = ( 1 - intersection ) * deltaTex;\n             layerHeight = ( 1 - intersection ) * layerHeight;\n          }\n          sectionIndex++;\n       }\n       #if _PASSHADOWS\n       if ( unity_LightShadowBias.z == 0.0 )\n       {\n       #endif\n          if ( result > 1 )\n             clip( -1 );\n       #if _PASSHADOWS\n       }\n       #endif\n       return finalTexOffset;\n    }\n    #endif\n\n   \n\n   // tess versions\n   #if _TESSELLATION_ON\n   half4 TriSampleLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias) * c.weights.x;\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias) * c.weights.y;\n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias) * c.weights.z;\n\n      return res;\n   }\n\n   half4 TriSampleBaryLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias, float contrast)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias);\n      half4 r2 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias);\n      half4 r3 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias);\n      c.weights = BaryWeightBlend(c.weights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryLODStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvX, bias, contrast) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvY, bias, contrast) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvZ, bias, contrast) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   half4 SampleTexBaryLODStochastic(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n       return TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias, contrast);\n   }\n\n   half4 SampleTexBaryLODTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return TriSampleLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias);\n   }\n\n   half4 SampleTexBaryLOD(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv, bias);\n   }\n\n\n    float FBM2DLOD(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           return SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv, _TessellationMipBias).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n        \n        \n    }\n\n    float FBM3DLOD(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           half A = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.zy, _TessellationMipBias).g;\n           half B = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33, _TessellationMipBias).g;\n           half C = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67, _TessellationMipBias).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoiseLOD(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3DLOD(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3DLOD(d.localSpacePosition * frequency + offset, d.localSpaceNormal);\n        #else\n           return FBM2DLOD(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n   #endif //_TESSELLATION_ON\n\n\n    half3 FuzzyShade(ShaderData d, half height, half3 color, half3 normal, half coreMult, half edgeMult, half power)\n    {\n        float3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half dt = saturate(dot(d.worldSpaceViewDir, worldNormal));\n        half dark = 1.0 - (coreMult * dt);\n        half edge = pow(1-dt, abs(power)) * edgeMult;\n        return color * (dark + edge);\n    }\n\n\thalf MicroShadow(ShaderData d, half3 normal, half height, half ao, half strength)\n\t{\n        float3 sun;\n\t\tfloat3 sunColor;\n\t\tGetSun(sun, sunColor);\n\t\tfloat3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half shadow = saturate(abs(dot(worldNormal, sun)) + (ao * ao * 2.0) - 1.0);\n        return 1 - ((1-shadow) * strength);\n\t}\n\n\n#endif\n\n\n\n   #if defined(_SPECULAR)\n      #define _USESPECULAR 1\n      #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n   #endif\n\n   \n   TEXTURE2D(_AlbedoMap);\n   SAMPLER(sampler_AlbedoMap);\n   TEXTURE2D(_NormalMap);\n   SAMPLER(sampler_NormalMap);\n   TEXTURE2D(_MaskMap);\n   TEXTURE2D(_DetailMap);\n   TEXTURE2D(_EmissionMap);\n\n   #if _SPECULAR\n       TEXTURE2D(_SpecularMap);\n   #endif\n\n   \n   \n   void Ext_SurfaceFunction0 (inout Surface o, inout ShaderData d)\n   {\n      // define samplers based on settings\n      #undef SAMPLEBARY\n      #undef SAMPLE\n      #undef SAMPLENORMAL\n      #if _STOCHASTIC && _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n        #define SAMPLE     SampleTexStochasticTriplanar\n        #define SAMPLENORMAL SampleNormalStochasticTriplanar\n      #elif _STOCHASTIC\n        #define SAMPLEBARY SampleTexBaryStochastic\n        #define SAMPLE     SampleTexStochastic\n        #define SAMPLENORMAL SampleNormalStochastic\n      #elif _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryTriplanar\n        #define SAMPLE     SampleTexTriplanar\n        #define SAMPLENORMAL SampleNormalTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBary\n        #define SAMPLE     SampleTex\n        #define SAMPLENORMAL SampleNormal\n      #endif\n\n      Config c = CreateConfig(d, _AlbedoMap_ST, _TriplanarSpace, _UVSource, _TriplanarContrast);\n      InitConfigDxDy(c);\n      #if _STOCHASTIC && !_TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uv, c.uvT);\n         InitStochasticDxDy(c.uvT, c);\n      #elif _STOCHASTIC && _TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv0, c.uvX);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv1, c.uvY);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv2, c.uvZ);\n         InitStochasticDxDy(c.uvX, c);\n         InitStochasticDxDy(c.uvY, c);\n         InitStochasticDxDy(c.uvZ, c);\n      #endif\n\n      #if _POM\n          // would need to handle height remapping if we ever want to ship this\n          float2 pomOffset = POM(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n          OffsetUV(c, pomOffset);\n      #endif\n\n      half4 albedo = SAMPLEBARY(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n      \n      #if _PARALLAX\n         float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n         OffsetUV(c, offset);\n         albedo = SAMPLE(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c);\n         \n      #endif\n      albedo.a = lerp(_HeightRemap.x, _HeightRemap.y, albedo.a);\n      albedo.rgb *= _Tint.rgb;\n\n      albedo.rgb = AdjustContrast(albedo.rgb, _AlbedoContrast);\n      albedo.rgb += _AlbedoBrightness;\n\n\n      if (_AlphaThreshold > 0)\n      {\n         clip(albedo.a - _AlphaThreshold);\n      }\n\n      #if defined(_FLATSHADE)\n\t\t     float3 dx = ddx(d.worldSpacePosition);\n\t\t     float3 dy = ddy(d.worldSpacePosition);\n\t\t     float3 worldNormal = normalize(cross(dy, dx));\n\t\t     worldNormal = lerp(d.worldSpaceNormal, worldNormal, _FlatShadingBlend);\n\t\t     d.worldSpaceNormal = worldNormal;\n\t\t     d.TBNMatrix[2] = worldNormal;\n      #endif\n\n\n\n      o.Albedo = albedo.rgb;\n      o.Alpha = albedo.a;\n\n      float smoothness = _Smoothness;\n      float ao = 1;\n\n      #if defined(_NORMALMAP) && !defined(_AUTONORMAL)\n         o.Normal = SAMPLENORMAL(TEXTURE2D_ARGS(_NormalMap, sampler_NormalMap), c, d, _NormalStrength, smoothness, ao);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, ao);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n      #endif\n\n      half detailMask = 1;\n      o.Smoothness = smoothness;\n      o.Occlusion = ao;\n      o.Metallic = _Metallic;\n      #if defined(_MASKMAP) && !_PACKEDFAST\n         // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = SampleTex(TEXTURE2D_ARGS(_MaskMap, sampler_AlbedoMap), c);\n         o.Metallic = lerp(_MetallicRemap.x, _MetallicRemap.y, mask.r);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, mask.g);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, mask.a);\n         detailMask = mask.b;\n      #endif // separate maps\n\n      #if _SPECULAR\n         o.Specular = SAMPLE(TEXTURE2D_ARGS(_SpecularMap, sampler_AlbedoMap), c).rgb;\n      #endif\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = SAMPLE(TEXTURE2D_ARGS(_EmissionMap, sampler_AlbedoMap), c).rgb * _EmissionColor;\n      #endif\n\n      if (_FuzzyShadingOn > 0)\n      {\n        o.Albedo *= FuzzyShade(d, albedo.a, _FuzzyShadingColor, o.Normal, _FuzzyShadingParams.x, _FuzzyShadingParams.y, _FuzzyShadingParams.z);\n      }\n\n\n      // HDRP style detail texturing\n\n      #if defined(_DETAIL)\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _DETAILSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n         Config dc = CreateConfig(d, _DetailMap_ST, _DetailTriplanarSpace, _DetailUVSource, _DetailTriplanarContrast);\n         InitConfigDxDy(dc);\n         #if _DETAILSTOCHASTIC && !_DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uv, dc.uvT);\n             InitStochasticDxDy(dc.uvT, dc);\n         #elif _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv0, dc.uvX);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv1, dc.uvY);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv2, dc.uvZ);\n             InitStochasticDxDy(dc.uvX, dc);\n             InitStochasticDxDy(dc.uvY, dc);\n             InitStochasticDxDy(dc.uvZ, dc);\n         #endif\n\n         half4 detailSample = SAMPLEBARY(TEXTURE2D_ARGS(_DetailMap, sampler_AlbedoMap), dc, _DetailStochasticContrast, d);\n         smoothness = detailSample.z;\n         #if !_AUTONORMAL\n            half3 dnormal = float3(detailSample.ag * 2 - 1, 1) * detailMask * _DetailNormalStrength;\n            dnormal.z = sqrt(1 - dnormal.x * dnormal.x - dnormal.y * dnormal.y);\n            #if _SURFACEGRADIENT\n               dnormal = ConvertNormalToGradient(d, dnormal);\n            #endif\n            o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n         #endif\n     \n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * smoothness, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n      if (_MicroShadowStrength > 0)\n      {\n        o.Occlusion *= MicroShadow(d, o.Normal, o.Alpha, o.Occlusion, _MicroShadowStrength);\n      }\n  \n      // in case something needs height in the stack..\n      o.Height = o.Alpha;\n\n\n      \n   }\n\n\n\n\t#if _TINTMASK\n\t\tTEXTURE2D(_TintMask);\n\t\tSAMPLER(sampler_TintMask);\n\t#endif\n\n\tvoid Ext_SurfaceFunction1 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _TINTMASK\n\t\t   half4 w = SAMPLE_TEXTURE2D(_TintMask, sampler_TintMask, d.texcoord0.xy * _TintMask_ST.xy + _TintMask_ST.zw);\n\t\t   // allow black to be no tint..\n\t\t   half3 tint = o.Albedo * (_RColor.rgb * 2 * w.r + _GColor.rgb * 2 * w.g + _BColor.rgb * 2 * w.b + _AColor.rgb * 2 * w.a);\n\t\t   o.Albedo = lerp(o.Albedo, tint, saturate(w.r + w.g + w.b + w.a));\n\t\t#endif\n\t}\n\n\n\n\n\t#if _LAYERTEXTUREMASK\n       TEXTURE2D(_LayerTextureMask);\n       SAMPLER(sampler_LayerTextureMask); \n    #endif\n\n   void Ext_ModifyTessellatedVertex2 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON\n          float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n\n          #if _LAYERTEXTUREMASK\n               float2 layerUV = v.texcoord0.xy;\n               if (_LayerTextureMaskUVMode == 1)\n                  layerUV = v.texcoord1.xy;\n               else if (_LayerTextureMaskUVMode == 2)\n                  layerUV = worldSpacePosition.yz;\n               else if (_LayerTextureMaskUVMode == 3)\n                  layerUV = worldSpacePosition.xz;\n               else if (_LayerTextureMaskUVMode == 4)\n                  layerUV = worldSpacePosition.xy;\n\n              e.blackboard.weightTextureMask = SAMPLE_TEXTURE2D_LOD(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw, _TessellationMipBias);\n          #endif\n      #endif\n    }\n\n\n\tvoid Ext_SurfaceFunction2 (inout Surface o, inout ShaderData d)\n\t{\n\t\t#if _LAYERTEXTUREMASK\n           float2 layerUV = d.texcoord0.xy;\n           if (_LayerTextureMaskUVMode == 1)\n              layerUV = d.texcoord1.xy;\n           else if (_LayerTextureMaskUVMode == 2)\n              layerUV = d.worldSpacePosition.yz;\n           else if (_LayerTextureMaskUVMode == 3)\n              layerUV = d.worldSpacePosition.xz;\n           else if (_LayerTextureMaskUVMode == 4)\n              layerUV = d.worldSpacePosition.xy;\n\n          d.blackboard.weightTextureMask = SAMPLE_TEXTURE2D(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw);\n      #endif\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap);\n   SAMPLER(sampler_LayerAlbedoMap);\n   TEXTURE2D(_LayerNormalMap);\n   TEXTURE2D(_LayerMaskMap);\n   TEXTURE2D(_LayerEmissionMap);\n\n   \n\n   void Ext_ModifyTessellatedVertex3 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER) && defined(_LAYERALBEDO) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n         half detailMask = 1;\n         #if _LAYERNOISE\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency,  _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin;\n            dt = saturate(dt * _LayerFalloff);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight) * _LayerFalloff);\n            if (_LayerInvertHeight > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength;\n         detailMask *= _LayerTessStrength;\n\n         #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast).a;\n         albedo = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo);\n\n         if (_LayerBlendMode == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction3 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n            // noise up the mask\n            #if _LAYERNOISE\n               mask = DoNoise(d, _LayerNoiseFrequency, _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend);\n\t    \n                dt -= _LayerAngleMin;\n                dt = saturate(dt * _LayerFalloff);\n\n                float hf = saturate((o.Height - _LayerHeight) * _LayerFalloff);\n                if (_LayerInvertHeight > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 0\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 0\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength;\n\n            #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint, 0.5);\n            #if defined(_LAYERALBEDO)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c, _LayerStochasticContrast, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c);\n                #endif\n                albedo.rgb *= _LayerTint;\n                albedo.a = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL || _LAYERMASK\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap, sampler_LayerAlbedoMap, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast);\n            albedo.rgb += _LayerAlbedoBrightness;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap, sampler_LayerAlbedoMap), c, d, _LayerNormalStrength * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO)\n                if (_LayerFuzzyShadingOn > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor.rgb, dnormal,\n                                            _LayerFuzzyShadingParams.x, _LayerFuzzyShadingParams.y, _LayerFuzzyShadingParams.z);\n                }\n\n                if (_LayerBlendMode == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast);\n                else if (_LayerBlendMode == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE\n                      float maskDif = (_LayerBlendContrast * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength);\n                   #if _LAYERNOISE\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap, sampler_LayerAlbedoMap), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength);\n                }\n\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap, sampler_LayerAlbedoMap), c).rgb * _LayerEmissionColor;\n                #if _LAYERALBEDO\n                    if (_LayerBlendMode > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_1);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_1);\n   TEXTURE2D(_LayerNormalMap_Ext_1);\n   TEXTURE2D(_LayerMaskMap_Ext_1);\n   TEXTURE2D(_LayerEmissionMap_Ext_1);\n\n   \n\n   void Ext_ModifyTessellatedVertex4 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_1) && defined(_LAYERALBEDO_DEF_1) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_1\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_1,  _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_1\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_1;\n            dt = saturate(dt * _LayerFalloff_Ext_1);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n            if (_LayerInvertHeight_Ext_1 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_1;\n         detailMask *= _LayerTessStrength_Ext_1;\n\n         #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_1).a;\n         albedo = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo);\n\n         if (_LayerBlendMode_Ext_1 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_1);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_1 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction4 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_1)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_1\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_1, _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_1\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_1);\n\t    \n                dt -= _LayerAngleMin_Ext_1;\n                dt = saturate(dt * _LayerFalloff_Ext_1);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n                if (_LayerInvertHeight_Ext_1 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 01\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 01\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_1;\n\n            #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_1, 0.5);\n            #if defined(_LAYERALBEDO_DEF_1)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, _LayerStochasticContrast_Ext_1, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_1;\n                albedo.a = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_1 || _LAYERMASK_DEF_1\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_1);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_1;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, d, _LayerNormalStrength_Ext_1 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_1)\n                if (_LayerFuzzyShadingOn_Ext_1 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_1.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_1.x, _LayerFuzzyShadingParams_Ext_1.y, _LayerFuzzyShadingParams_Ext_1.z);\n                }\n\n                if (_LayerBlendMode_Ext_1 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_1);\n                else if (_LayerBlendMode_Ext_1 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_1 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_1);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_1\n                      float maskDif = (_LayerBlendContrast_Ext_1 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_1 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                   #if _LAYERNOISE_DEF_1\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_1));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_1 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_1);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_1) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_1 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_1);\n                }\n\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_1);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_1, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_1, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_1\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c).rgb * _LayerEmissionColor_Ext_1;\n                #if _LAYERALBEDO_DEF_1\n                    if (_LayerBlendMode_Ext_1 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_2);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_2);\n   TEXTURE2D(_LayerNormalMap_Ext_2);\n   TEXTURE2D(_LayerMaskMap_Ext_2);\n   TEXTURE2D(_LayerEmissionMap_Ext_2);\n\n   \n\n   void Ext_ModifyTessellatedVertex5 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_2) && defined(_LAYERALBEDO_DEF_2) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_2\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_2,  _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_2\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_2;\n            dt = saturate(dt * _LayerFalloff_Ext_2);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n            if (_LayerInvertHeight_Ext_2 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_2;\n         detailMask *= _LayerTessStrength_Ext_2;\n\n         #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_2).a;\n         albedo = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo);\n\n         if (_LayerBlendMode_Ext_2 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_2);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_2 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction5 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_2)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_2\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_2, _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_2\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_2);\n\t    \n                dt -= _LayerAngleMin_Ext_2;\n                dt = saturate(dt * _LayerFalloff_Ext_2);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n                if (_LayerInvertHeight_Ext_2 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 02\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 02\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_2;\n\n            #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_2, 0.5);\n            #if defined(_LAYERALBEDO_DEF_2)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, _LayerStochasticContrast_Ext_2, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_2;\n                albedo.a = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_2 || _LAYERMASK_DEF_2\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_2);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_2;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, d, _LayerNormalStrength_Ext_2 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_2)\n                if (_LayerFuzzyShadingOn_Ext_2 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_2.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_2.x, _LayerFuzzyShadingParams_Ext_2.y, _LayerFuzzyShadingParams_Ext_2.z);\n                }\n\n                if (_LayerBlendMode_Ext_2 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_2);\n                else if (_LayerBlendMode_Ext_2 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_2 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_2);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_2\n                      float maskDif = (_LayerBlendContrast_Ext_2 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_2 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                   #if _LAYERNOISE_DEF_2\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_2));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_2 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_2);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_2) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_2 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_2);\n                }\n\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_2);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_2, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_2, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_2\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c).rgb * _LayerEmissionColor_Ext_2;\n                #if _LAYERALBEDO_DEF_2\n                    if (_LayerBlendMode_Ext_2 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   #if _TRAX_ON\n   TEXTURE2D(_TraxAlbedo);\n   SAMPLER(sampler_TraxAlbedo);\n   TEXTURE2D(_TraxPackedNormal);\n   TEXTURE2D(_TraxMask);\n\n   sampler2D_float _GMSTraxBuffer;\n\n   float4 _GMSTraxBuffer_TexelSize;\n   float3 _GMSTraxBufferPosition;\n   float _GMSTraxBufferWorldSize;\n   float _GMSTraxFudgeFactor;\n\n   float SampleTraxBufferLOD(float3 worldPos)\n   {    \n      // generate UVs for the buffer, which is moving\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 8);\n      uv *= 0.5;\n      uv += 0.5;\n            \n      float s =  tex2Dlod(_GMSTraxBuffer, float4(uv, 0, 0)).r;\n\n      return 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n   }\n         \n        \n   float SampleTraxBuffer(float3 worldPos, out float3 norm)\n   {\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 3);\n      uv *= 0.5;\n      uv += 0.5;\n            \n\n      float2 offset = _GMSTraxBuffer_TexelSize.xy;\n\n      float s = tex2D(_GMSTraxBuffer, uv).r;\n               \n      float s1 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, -1)).r;\n      float s2 = tex2D(_GMSTraxBuffer, uv + offset * float2(-1, 0)).r;\n      float s3 = tex2D(_GMSTraxBuffer, uv + offset * float2(1, 0)).r;\n      float s4 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, 1)).r;\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      float r = 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n \n      // generate normals\n      norm.x = (s1 - s4) * 0.25; \n      norm.y = (s2 - s3) * 0.25;\n      norm.z = 2;\n      norm = normalize(norm);\n     \n      norm.xy *= 1 - r;\n            \n      return r;\n   }\n   #endif\n\n   void Ext_ModifyTessellatedVertex6 (inout VertexData v, inout ExtraV2F d)\n   {\n       #if _TESSELLATION_ON && _TRAX_ON && _HAS_LIT_TESSELLATION\n          \n           float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n           float3 worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n           float traxBuffer = SampleTraxBufferLOD(worldSpacePosition);\n           d.blackboard.traxBuffer = traxBuffer;\n           float2 uv = worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n           half albedo = SAMPLE_TEXTURE2D_LOD(_TraxAlbedo, sampler_TraxAlbedo, uv, _TraxMipBias).a;\n\n           float traxOffset = albedo * _TraxDisplacementStrength;\n           traxOffset *= 1 - v.texcoord0.z;\n           traxOffset *= _TessellationDisplacement;\n           float dig = _TraxDisplacementDepth * (1 - v.texcoord0.z);\n           float3 traxVertex = d.blackboard.originalVertexPosition + (v.normal * (traxOffset - dig));\n           v.vertex.xyz = lerp(traxVertex, v.vertex.xyz, traxBuffer);\n\n           d.blackboard.vertexHeightOffset = lerp(traxOffset-dig, d.blackboard.vertexHeightOffset, traxBuffer);\n\n       #endif\n\n   }\n\n   void Ext_SurfaceFunction6 (inout Surface o, inout ShaderData d)\n   {\n      #if _TRAX_ON\n        float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n        float2 fsdx = ddx(uv);\n        float2 fsdy = ddy(uv);\n\n        float3 traxNormal;\n        float traxBuffer = SampleTraxBuffer(d.worldSpacePosition, traxNormal);\n        \n        #if _TESSELLATION_ON\n            traxBuffer -= _TraxDisplacementDepth;\n        #endif\n\n        d.blackboard.traxBuffer = traxBuffer;\n\n        UNITY_BRANCH\n        if (traxBuffer > 0)\n        {\n            half4 albedo = SAMPLE_TEXTURE2D_GRAD(_TraxAlbedo, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            albedo.rgb *= _TraxTint.rgb;\n            half4 normalSample = SAMPLE_TEXTURE2D_GRAD(_TraxPackedNormal, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n\n            half smoothness = normalSample.r;\n            half ao = normalSample.b;\n            half3 normal;\n            normal.xy = (normalSample.ag * 2 - 1) * _TraxNormalStrength;\n            normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n\n            \n            half h = HeightBlend(albedo.a, o.Alpha, traxBuffer, _TraxHeightContrast);\n\n            h = lerp(traxBuffer, h, _TraxInterpContrast);\n\n            o.Albedo = lerp(albedo, o.Albedo, h);\n\n            #if _SURFACEGRADIENT\n                o.Normal = lerp(normal, o.Normal, h);\n            #else\n                o.Normal = lerp(normal + traxNormal, o.Normal, h);\n            #endif\n        \n            o.Smoothness = lerp(smoothness, o.Smoothness, h);\n            o.Occlusion = lerp(ao, o.Occlusion, h);\n        }\n      #endif\n   }\n\n\n\n\n    #if _RAINDROPS\n       TEXTURE2D(_RainDropTexture);\n       SAMPLER(sampler_RainDropTexture);\n       half _Global_RainIntensity;\n    #endif\n\n    #if _WETNESS\n       half2 _Global_WetnessParams; // global, not in cbuffer\n    #endif\n   \n    #if _RAINDROPS\n    half2 ComputeRipple(float2 uv, half time, half weight)\n    {\n        half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_RainDropTexture, uv);\n        COUNTSAMPLE\n        ripple.yz = ripple.yz * 2 - 1;\n\n        half dropFrac = frac(ripple.w + time);\n        half timeFrac = dropFrac - 1.0 + ripple.x;\n        half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);\n        half finalFactor = dropFactor * ripple.x * \n                                sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);\n\n        return half2(ripple.yz * finalFactor);\n    }\n    #endif\n\n    half2 DoRain(half2 waterNorm, float2 uv, out half2 ripple)\n    {\n        #if _RAINDROPS\n            float rainIntensity = _RainIntensityScale.x;\n            if (_RainMode > 1)\n            {\n                rainIntensity = _Global_RainIntensity;\n            }\n\n            half dropStrength = rainIntensity;\n            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); \n            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);\n            half4 times = _Time.yyyy;\n            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);\n\n            float2 ruv1 = uv * _RainIntensityScale.yy;\n            float2 ruv2 = ruv1;\n\n            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);\n            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);\n            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);\n            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);\n            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);\n            weights = saturate(weights * 4);\n\n            half2 rippleNormal = half2( weights.x * ripple1.xy +\n                        weights.y * ripple2.xy + \n                        weights.z * ripple3.xy + \n                        weights.w * ripple4.xy);\n\n            ripple = rippleNormal * dropStrength * rainIntensity;\n            waterNorm = lerp(waterNorm, normalize(half3(rippleNormal.xy + rippleNormal.xy, 1)).xy, rainIntensity * dropStrength); \n            return waterNorm;                        \n        #else\n            return waterNorm;\n        #endif\n    }\n\n   half2 _Global_PuddleParams;   // this is a global, so keep it out of the cbuffer\n   void GetPuddleParams(ShaderData d, inout float puddleMask, inout float pudHeight)\n   {\n      #if _PUDDLES || _GLOBALPUDDLES\n          pudHeight = _PuddleAmount;\n          if (_PuddleMode > 0)\n             pudHeight = _Global_PuddleParams.x;    \n      \n\n          half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t      dt -= _PuddleAngleMin;\n          dt = saturate(dt * _PuddleFalloff);\n          puddleMask *= dt;\n      #endif\n   }\n   \n   void Ext_ModifyTessellatedVertex7 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _PUDDLES && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n         half mask = 1;\n         half pudHeight = 1;\n\n         // save some ops by doing this in 2d\n         #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2DLOD(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2DLOD(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #else\n                mask = (FBM2DLOD(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n         #endif\n\n         GetPuddleParams(d, mask, pudHeight);\n         float height = pudHeight * mask;\n         if (e.blackboard.vertexHeightOffset < height)\n         {\n            e.blackboard.vertexHeightOffset = height;\n            height -= _TessellationOffset; \n            // dampen cracks\n            height *= 1 - v.texcoord0.z;\n            height *= _TessellationDisplacement;\n            v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n            \n        }\n      #endif\n   }\n\n\n#if _WETNESS\n\n   float GetWetnessLevel(Surface o, ShaderData d, float wetnessMask)\n   {\n      float wetLevel = clamp(_WetnessAmount, _WetnessMin, _WetnessMax);\n      \n      if (_WetnessMode > 0)\n         wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);\n\n      wetLevel = saturate(wetLevel + (1 - saturate(d.worldSpacePosition.y - _WetnessShoreline)));\n      float3x3 tbn = float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal);\n      float dt = dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0));\n      dt -= _WetnessAngleMin;\n      dt = saturate(dt * _WetnessFalloff * wetLevel);\n      dt *= wetnessMask;\n      return dt;\n   }\n#endif\n   \n\n   void Ext_SurfaceFunction7 (inout Surface o, ShaderData d)\n   {\n      half wetnessLevel = 0;\n      #if _WETNESS\n          wetnessLevel = GetWetnessLevel(o, d, 1); // mask one day?\n      #endif\n\n      half depthMask = 0;\n      half depth = 0;\n\n      #if _PUDDLES\n          half mask = 1;\n          half pudHeight = 1;\n          #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2D(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2D(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);      \n            #else\n                mask = (FBM2D(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n          #endif\n\n          GetPuddleParams(d, mask, pudHeight);\n          pudHeight *= mask;\n          depth = pudHeight - o.Height;\n          depthMask = saturate(depth * _PuddleFalloff);\n          depthMask *= _PuddleColor.a;\n          depth = o.Height - pudHeight;\n\n          // extend wetness slighting higher than the puddle\n          half wetmask = saturate((pudHeight + 0.05 - o.Height) * _PuddleFalloff);\n          wetnessLevel = max(wetmask, wetnessLevel);\n       #endif\n\n       \n       #if _WETNESS || _PUDDLES\n          half3 waterNorm = half3(0,0,1);\n          half3 wetAlbedo = o.Albedo;\n          half wetSmoothness = o.Smoothness;\n          #if _PUDDLES\n             wetAlbedo *= _PuddleColor.rgb;\n          #endif\n          WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetnessLevel, _Porosity);\n\n          half ri = 0;\n          half2 ripple = 0;\n          #if (_RAINDROPS || _GLOBALRAIN) && (_PUDDLES || _GLOBALPUDDLES)\n             ri = _RainIntensityScale.z;\n             waterNorm.xy = DoRain(waterNorm.xy, d.texcoord0.xy, ripple) * depthMask;\n          #endif\n\n          o.Normal = lerp(o.Normal, waterNorm, depthMask);\n          o.Normal = lerp(o.Normal, LitBlendDetailNormal(o.Normal, half3(ripple.xy, 1)), saturate(ri - depthMask) * wetnessLevel);\n          o.Occlusion = lerp(o.Occlusion, 1, depthMask);\n          o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetnessLevel);\n          o.Albedo = lerp(o.Albedo, wetAlbedo, wetnessLevel);\n          o.Emission *= 1 + depth;\n          o.Metallic *= 1 + depth;\n          o.Specular *= 1 + depth;\n\n       #endif\n\n   }\n\n\n\n\n    #if _SNOW\n       TEXTURE2D(_SnowAlbedo);\n       SAMPLER(sampler_SnowAlbedo);\n       TEXTURE2D(_SnowNormal);\n       TEXTURE2D(_SnowMaskMap);\n       #if _TRAX_ON\n          TEXTURE2D(_SnowTraxAlbedo);\n          TEXTURE2D(_SnowTraxNormal);\n          TEXTURE2D(_SnowTraxMaskMap);\n       #endif\n    #endif\n\n   float _Global_SnowLevel;\n\n\n   void Ext_ModifyVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n    #if (_SNOW)\n        float amount = _SnowAmount;\n        if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n        float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n        float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n        snowAmount -= _SnowAngle;\n        snowAmount *= _SnowContrast * 0.5;\n        snowAmount = saturate(snowAmount) * amount;\n        float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n        if (_SnowWorldFade.z > 0)\n        {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n        }\n        #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n        #endif\n        snowAmount = saturate(snowAmount);\n\n        #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n        #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n        #endif\n\n        float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n        v.vertex.xyz = v.vertex.xyz + displacementVec * snowAmount * snowAmount * _SnowVertexHeight;\n    #endif\n   }\n\n   void Ext_ModifyTessellatedVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _SNOW && _HAS_LIT_TESSELLATION\n         float amount = _SnowAmount;\n         if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n         float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n         float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n         snowAmount -= _SnowAngle;\n         snowAmount *= _SnowContrast * 0.5;\n         float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n         if (_SnowWorldFade.z > 0)\n         {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n         }\n\n         snowAmount = saturate(snowAmount) * amount;\n\n         #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n         #endif\n         snowAmount = saturate(snowAmount);\n\n         #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n         #endif\n\n         float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n         half heightMap = SAMPLE_TEXTURE2D_LOD(_SnowAlbedo, sampler_SnowAlbedo, worldPos.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw, 2);\n\n         float height = max(_SnowVertexHeight * 3 * snowAmount + snowAmount * heightMap, e.blackboard.vertexHeightOffset);\n         #if _TRAX_ON\n            height *= e.blackboard.traxBuffer;\n         #endif\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n\n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n         \n      #endif\n\n   }\n\n   void SampleSnowSurface(TEXTURE2D_PARAM(alb, ss), TEXTURE2D_PARAM(norm, ss2), TEXTURE2D_PARAM(mask, ss3),\n        ShaderData d, float2 uv, float2 dx, float2 dy, out half4 albedo, out half3 normal, out half2 smoothAO)\n   {\n      #if _SNOWSTOCHASTIC\n         float w1, w2, w3;\n         int2 vertex1, vertex2, vertex3;\n         TriangleGrid(uv, _SnowStochasticScale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n         // Assign random offset to each triangle vertex\n         float2 uv0 = uv;\n         float2 uv1 = uv;\n         float2 uv2 = uv;\n   \n         uv0.xy += SimpleHash2(vertex1);\n         uv1.xy += SimpleHash2(vertex2);\n         uv2.xy += SimpleHash2(vertex3);\n         half3 weights = half3(w1, w2, w3);\n\n         half4 albedo0 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv0, dx, dy);\n         half4 albedo1 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv1, dx, dy);\n         half4 albedo2 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv2, dx, dy);\n         COUNTSAMPLE\n         COUNTSAMPLE\n         COUNTSAMPLE\n         weights = BaryWeightBlend(weights, albedo0.a, albedo1.a, albedo2.a, _SnowStochasticContrast);\n         albedo = albedo0 * weights.x + albedo1 * weights.y + albedo2 * weights.z;\n\n         normal = half3(0,0,1);\n         smoothAO = half2(0, 1);\n\n         #if !_AUTONORMAL\n            half4 n0 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv0, dx, dy);\n            half4 n1 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv1, dx, dy);\n            half4 n2 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n            half4 snowNormSamp = n0 * weights.x + n1 * weights.y + n2 * weights.z;\n\n            normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n                \n            #if _PACKEDFAST\n               smoothAO.x = snowNormSamp.r;\n               smoothAO.y = snowNormSamp.b;\n            #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask0 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv0, dx, dy);\n            half4 snowMask1 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv1, dx, dy);\n            half4 snowMask2 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n            half4 snowMask = snowMask0 * weights.x + snowMask1 * weights.y + snowMask2 * weights.z;\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n      #else // not stochastic\n          albedo = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv, dx, dy);\n          COUNTSAMPLE\n\n          normal = half3(0,0,1);\n          smoothAO = half2(0, 1);\n\n          #if !_AUTONORMAL\n             half4 snowNormSamp = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv, dx, dy);\n             COUNTSAMPLE\n             normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n             #if _SURFACEGRADIENT\n                normal = ConvertNormalToGradient(d, normal);\n             #endif\n                 \n             #if _PACKEDFAST\n                smoothAO.x = snowNormSamp.r;\n                smoothAO.y = snowNormSamp.b;\n             #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv, dx, dy);\n            COUNTSAMPLE\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n     #endif // stochastic\n   }\n\n   \n   void Ext_SurfaceFunction8 (inout Surface o, ShaderData d)\n   {\n      #if _SNOW\n          float amount = _SnowAmount;\n          if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n          float snowAmount = lerp(dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), dot(d.worldSpaceNormal, float3(0,1,0)), amount * 0.8) + 1;\n          snowAmount -= _SnowAngle;\n          snowAmount *= _SnowContrast;\n          snowAmount = saturate(snowAmount) - (1-amount) * (1-amount);\n\n          if (_SnowWorldFade.z > 0)\n          {\n             float worldFade = saturate((d.worldSpacePosition.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n             snowAmount *= worldFade;\n          }\n\n          #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(d.worldSpacePosition.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n          #endif\n          snowAmount = saturate(snowAmount);\n\n          float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw;\n          float2 dx = ddx(uv);\n          float2 dy = ddy(uv);\n\n          #if _TRAX_ON\n              float2 tuv = d.worldSpacePosition.xz * float2(1, -1) * _SnowTraxAlbedo_ST.xy + _SnowTraxAlbedo_ST.zw;\n              float2 tdx = ddx(uv);\n              float2 tdy = ddy(uv);\n          #endif\n\n          #if _LAYERVERTEXMASK\n              snowAmount *= d.vertexColor.a;\n          #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n              snowAmount *= d.blackboard.weightTextureMask.a;\n          #endif\n\n          UNITY_BRANCH\n          if (snowAmount > 0)\n          {\n             half4 snowAlbedo;\n             half3 snowNormal;\n             half2 snowSmoothAO;\n             SampleSnowSurface(TEXTURE2D_ARGS(_SnowAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowNormal, sampler_SnowAlbedo),\n                    TEXTURE2D_ARGS(_SnowMaskMap, sampler_SnowAlbedo), d, uv, dx, dy, snowAlbedo, snowNormal, snowSmoothAO);\n\n             snowAlbedo.rgb *= _SnowTint.rgb;\n\n             #if _TRAX_ON\n                half traxBuffer = 1 - d.blackboard.traxBuffer;\n                UNITY_BRANCH\n                if (traxBuffer > 0)\n                {\n                    half4 tsnowAlbedo;\n                    half3 tsnowNormal;\n                    half2 tsnowSmoothAO;\n                    SampleSnowSurface(TEXTURE2D_ARGS(_SnowTraxAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowTraxNormal, sampler_SnowAlbedo),\n                        TEXTURE2D_ARGS(_SnowTraxMaskMap, sampler_SnowAlbedo), d, tuv, tdx, tdy, tsnowAlbedo, tsnowNormal, tsnowSmoothAO);\n\n                    tsnowAlbedo.rgb *= _SnowTraxTint;\n                    half h = HeightBlend(snowAlbedo.a, tsnowAlbedo.a, traxBuffer, 0.5);\n                    snowAlbedo = lerp(snowAlbedo, tsnowAlbedo, h);\n                    snowNormal = lerp(snowNormal, tsnowNormal, h);\n                    snowSmoothAO = lerp(snowSmoothAO, tsnowSmoothAO, h);\n                }\n             #endif\n\n             #if !_AUTONORMAL\n                o.Normal = lerp(o.Normal, snowNormal, snowAmount);\n             #endif\n             o.Albedo = lerp(o.Albedo, snowAlbedo.rgb, snowAmount);\n             o.Alpha = lerp(o.Alpha, snowAlbedo.a, snowAmount);\n             o.Smoothness = lerp(o.Smoothness, snowSmoothAO.x, snowAmount);\n             o.Occlusion = lerp(o.Occlusion, snowSmoothAO.y, snowAmount);\n             o.Height = o.Alpha;\n\n          }\n      #endif\n   }\n\n   \n\n\n\n\n\n   TEXTURE2D(_WindParticulate);\n   SAMPLER(sampler_WindParticulate);\n\n// In case we want to read it more than once..\n\n#ifndef __STACKABLE_WIND_INCLUDES__\n#define __STACKABLE_WIND_INCLUDES__\n\n\n   half FilterRange(float4 range, float y)\n   {\n      half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));\n      w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));\n      return w;\n   }\n\n   \n   float2 RotateUV(float2 uv, float amt)\n   {\n      uv -=0.5;\n      float s = sin ( amt);\n      float c = cos ( amt );\n      float2x2 mtx = float2x2( c, -s, s, c);\n      mtx *= 0.5;\n      mtx += 0.5;\n      mtx = mtx * 2-1;\n      uv = mul ( uv, mtx );\n      uv += 0.5;\n      return uv;\n   }\n\n\n   half FilterWindParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)\n   {\n      float2 windDir = RotateUV(float2(1, 0), windRot);\n      float2 flow = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));\n      float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill\n      return FilterRange(range, cofacing);\n   }\n\n   fixed ProcessWindParticulateMask(inout fixed mask, float contrast)\n   {\n      mask = pow(abs(mask), abs(contrast));\n      fixed invMask = 1.0 - mask;\n      invMask *= invMask; \n      invMask *= invMask;\n      return invMask;\n   }\n#endif // include guard\n\n   void Ext_SurfaceFunction9 (inout Surface o, ShaderData d)\n   {\n      #if _WIND_ON && !_PASSMETA\n   \n         float3 upVector = float3(0,0,1);\n\n         half upDot = max(0.0, dot(d.worldSpaceNormal, float3(0, 1, 0)));\n\n         float2 uv = d.worldSpacePosition.xz;\n         if (_WindParticulateSpace > 0.5)\n            uv = d.texcoord0.xy;\n         float windRotation = _WindParticulateRotation;\n         float windStrength = _WindParticulateStrength;\n\n         float2 wuv = RotateUV(uv, windRotation);\n\n         half windBlend = 1.0;\n\n         float windWorldMask = FilterRange(_WindParticulateWorldHeightMask, d.worldSpacePosition.y);\n         windWorldMask *= FilterRange(_WindParticulateAngleMask, upDot);\n\n         // compute mask\n         wuv *= float2(_WindParticulate_ST.x, 1) * _WindParticulate_ST.y + _WindParticulate_ST.zw;\n         float speed = _Time.x * _WindParticulateSpeed;\n         half w1 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv * 3 + speed * float2(1,0)).g;\n         half w2 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv + speed * float2(1.1,0)).a;\n         half windMask = (w1 * w2);\n\n         windMask *= windStrength * windBlend * windWorldMask;\n         windMask *= saturate((_WindParticulateTextureHeight - o.Height) * 10);\n\n         half windInvMask = ProcessWindParticulateMask(windMask, _WindParticulatePower);\n    \n         o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);\n         o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindParticulateEmissive.rgb;\n         o.Normal.xy *= windInvMask;\n         o.Smoothness *= windInvMask;\n         o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;\n         o.Metallic *= windInvMask;\n      #endif\n\n   }\n\n\n\n\n\tvoid Ext_SurfaceFunction10 (inout Surface o, ShaderData d)\n\t{\n        if (_DoubleSidedNormalMode == 0)\n        {\n           o.Normal *= d.isFrontFace ? 1 : -1;\n        }\n        else if (_DoubleSidedNormalMode == 1)\n        {\n\t\t   o.Normal.z *= d.isFrontFace ? 1 : -1;\n        }\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction11 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _SURFACEGRADIENT\n\t\t\to.Normal = ResolveNormalFromSurfaceGradient(d, o.Normal);\n\t    #elif _AUTONORMAL\n\t        float3 dx = ddx(d.worldSpacePosition);\n\t\t\tfloat3 dy = ddy(d.worldSpacePosition);\n\t\t\tfloat3 crossX = cross(float3(0,1,0), dx);\n\t\t\tfloat3 crossY = cross(float3(0,1,0), dy);\n\t\t\tfloat3 dt = abs(dot(crossY, dx));\n\t\t\tfloat height = _AutoNormalStrength * 0.5 * o.Alpha;\n\t\t\tfloat3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n\t\t\tn.y *= -1.0;\n\t\t\to.Normal = normalize((dt * float3(0,1,0)) - n).xzy;\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#else\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#endif\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction12 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DEBUG_SAMPLECOUNT\n\t\t\tif (_sampleCount > _DebugSampleCountThreshold)\n\t\t\t{\n\t\t\t\to.Albedo.r = 1;\n\t\t\t\to.Albedo.gb *= 0.2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\to.Albedo.b = 1;\n\t\t\t}\n\n        #endif\n\t}\n\n\n\n\n\tSAMPLER(sampler_DissolveTexture);\n\tTEXTURE2D(_DissolveTexture);\n\tTEXTURE2D(_DissolveGradient);\n\n\tvoid Ext_SurfaceFunction13 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DISSOLVE\n\t\tfloat2 uv = d.texcoord0.xy * _DissolveTexture_ST.xy + _DissolveTexture_ST.zw;\n\t\tfloat2 dx = ddx(uv);\n\t\tfloat2 dy = ddy(uv);\n\n\t\tUNITY_BRANCH\n\t\tif (_DissolveAmount > 0)\n\t\t{\n\t\t\thalf dissolve = SAMPLE_TEXTURE2D_GRAD(_DissolveTexture, sampler_DissolveTexture, uv, dx, dy).g;\n\t\t\thalf cp =  saturate(_DissolveAmount - (dissolve - _DissolveAmount) * _DissolveEdgeContrast) + _DissolveAmount;\n\t\t\thalf cp2 = saturate(1.0 - abs((dissolve - _DissolveAmount) * _DissolveEdgeContrast));\n\t\t\tclip(1.0 - cp);\n\t\t\tfloat2 fuv = float2(cp2, 0.5);\n\t\t\thalf3 col = SAMPLE_TEXTURE2D_LOD(_DissolveGradient, sampler_DissolveTexture, fuv, 0).rgb;\n\t\t\t\t\n\t\t\to.Albedo = lerp(o.Albedo, col, _DissolveColoration * cp2);\n\t\t\to.Emission = lerp(o.Emission, col * _DissolveEmissiveStr, _DissolveColoration * cp2);\n\t\t}\n\t\t#endif\n\t}\n\n\n\n\n    float Dither8x8Bayer( int x, int y )\n    {\n        const float dither[ 64 ] = {\n                1, 49, 13, 61,  4, 52, 16, 64,\n            33, 17, 45, 29, 36, 20, 48, 32,\n                9, 57,  5, 53, 12, 60,  8, 56,\n            41, 25, 37, 21, 44, 28, 40, 24,\n                3, 51, 15, 63,  2, 50, 14, 62,\n            35, 19, 47, 31, 34, 18, 46, 30,\n            11, 59,  7, 55, 10, 58,  6, 54,\n            43, 27, 39, 23, 42, 26, 38, 22};\n        int r = y * 8 + x;\n        return dither[r] / 64; \n    }\n\n    void ApplyDitherCrossFadeVSP(float2 vpos, float fadeValue)\n    {\n        float dither = Dither8x8Bayer( fmod(vpos.x, 8), fmod(vpos.y, 8) );\n        float sgn = fadeValue > 0 ? 1.0f : -1.0f;\n        clip(dither - (1-fadeValue) * sgn);\n    }\n    \n\n\tvoid Ext_SurfaceFunction14 (inout Surface o, ShaderData d)\n\t{\n\t\t#if LOD_FADE_CROSSFADE\n            float4 screenPosNorm = d.screenPos / d.screenPos.w;\n            screenPosNorm.z = ( UNITY_NEAR_CLIP_VALUE >= 0 ) ? screenPosNorm.z : screenPosNorm.z * 0.5 + 0.5;\n            float2 clipScreen = screenPosNorm.xy * _ScreenParams.xy;\n            ApplyDitherCrossFadeVSP(clipScreen,unity_LODFade.x);\n        #endif\n\t}\n\n\n\n\n\n\n// declare outside of CBuffer\n\nfloat4x4 _GlobalVolumeMatrix;\nfloat4x4 _VolumeMatrix;\nfloat3 _VolumeMin;\nfloat3 _VolumeInvSize;\nfloat3 _GlobalVolumeMin;\nfloat3 _GlobalVolumeInvSize;\n\n// I inlined a section of your include. You can use includes in better shaders, but doing it via a subshader or this way\n// is much better. The reason is that this allows your shader to be all inclusive, and packed up for asset store distribition,\n// without requiring specific paths to other files, etc.\n//\n\n#ifndef BAKERY_INCLUDED\n#define BAKERY_INCLUDED\n\n#define BAKERYMODE_DEFAULT 0\n#define BAKERYMODE_VERTEXLM 1.0f\n#define BAKERYMODE_RNM 2.0f\n#define BAKERYMODE_SH 3.0f\n\n\n// can't fit vertexLM SH to sm3_0 interpolators\n#ifndef SHADER_API_D3D11\n    #undef _LIGHTMAPMODE_VERTEXSH\n#endif\n\n// can't do stuff on sm2_0 due to standard shader alrady taking up all instructions\n#if SHADER_TARGET < 30\n    #undef BAKERY_BICUBIC\n    #undef BAKERY_LMSPEC\n\n    #undef _LIGHTMAPMODE_RNM\n    #undef _LIGHTMAPMODE_SH\n    #undef _LIGHTMAPMODE_VERTEX\n#endif\n\n#define lumaConv float3(0.2125f, 0.7154f, 0.0721f)\n\n#ifdef BAKERY_VOLUME\n    #ifdef BAKERY_COMPRESSED_VOLUME\n        Texture3D _Volume3;\n    #endif\n#endif\n\n\nhalf3 LinearToGamma (half3 linRGB)\n{\n    linRGB = max(linRGB, half3(0.h, 0.h, 0.h));\n    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n    return max(1.055h * pow(linRGB, 0.416666667h) - 0.055h, 0.h);\n}\n\nfloat shEvaluateDiffuseL1Geomerics(float L0, float3 L1, float3 n)\n{\n    // average energy\n    float R0 = L0;\n\n    // avg direction of incoming light\n    float3 R1 = 0.5f * L1;\n\n    // directional brightness\n    float lenR1 = length(R1);\n\n    // linear angle between normal and direction 0-1\n    //float q = 0.5f * (1.0f + dot(R1 / lenR1, n));\n    //float q = dot(R1 / lenR1, n) * 0.5 + 0.5;\n    float q = dot(normalize(R1), n) * 0.5 + 0.5;\n\n    // power for q\n    // lerps from 1 (linear) to 3 (cubic) based on directionality\n    float p = 1.0f + 2.0f * lenR1 / R0;\n\n    // dynamic range constant\n    // should vary between 4 (highly directional) and 0 (ambient)\n    float a = (1.0f - lenR1 / R0) / (1.0f + lenR1 / R0);\n\n    return R0 * (a + (1.0f - a) * (p + 1.0f) * pow(q, p));\n}\n\n#ifdef BAKERY_VERTEXLMMASK\n    float4 unpack4NFloats(float src)\n\t{\n        //return fmod(float4(src / 262144.0, src / 4096.0, src / 64.0, src), 64.0)/64.0;\n        return frac(float4(src / (262144.0*64), src / (4096.0*64), src / (64.0*64), src));\n    }\n#endif\n\n#if defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n    float3 unpack3NFloats(float src)\n\t{\n        float r = frac(src);\n        float g = frac(src * 256.0);\n        float b = frac(src * 65536.0);\n        return float3(r, g, b);\n    }\n#endif\n\n// Unity defines these under different names in each SRP, so use our own\ninline float3 Bakery_SafeNormalize(float3 inVec)\n{\n    float dp3 = max(0.001f, dot(inVec, inVec));\n    return inVec * rsqrt(dp3);\n}\n\n#if _URP || _HDRP\n\nfloat SmoothnessToPerceptualRoughness(float smoothness)\n{\n    return (1 - smoothness);\n}\n#endif\n\n#if !_STANDARD\nhalf4 unity_Lightmap_HDR;\ninline half3 DecodeLightmap( fixed4 color )\n{\n    return DecodeLightmap( color, unity_Lightmap_HDR );\n}\n\n#define UNITY_INV_PI        0.31830988618f\ninline float GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return UNITY_INV_PI * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n    void BakeryVertexLMDirection(inout float3 diffuseColor, inout float3 specularColor, float3 lightDirection, float3 vertexNormalWorld, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 dominantDir = Bakery_SafeNormalize(lightDirection);\n        half halfLambert = dot(normalWorld, dominantDir) * 0.5 + 0.5;\n        half flatNormalHalfLambert = dot(vertexNormalWorld, dominantDir) * 0.5 + 0.5;\n\n        #ifdef BAKERY_LMSPEC\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = spec * diffuseColor;\n        #endif\n\n        diffuseColor *= halfLambert / max(1e-4h, flatNormalHalfLambert);\n    }\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXSH\n    void BakeryVertexLMSH(inout float3 diffuseColor, inout float3 specularColor, float3 shL1x, float3 shL1y, float3 shL1z, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 L0 = diffuseColor;\n        float3 nL1x = shL1x;\n        float3 nL1y = shL1y;\n        float3 nL1z = shL1z;\n        float3 L1x = nL1x * L0 * 2;\n        float3 L1y = nL1y * L0 * 2;\n        float3 L1z = nL1z * L0 * 2;\n\n        float3 sh;\n    #if BAKERY_SHNONLINEAR\n        //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n        //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n        //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n        float lumaL0 = dot(L0, 1);\n        float lumaL1x = dot(L1x, 1);\n        float lumaL1y = dot(L1y, 1);\n        float lumaL1z = dot(L1z, 1);\n        float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n        float regularLumaSH = dot(sh, 1);\n        //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n        sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    #else\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    #endif\n\n        diffuseColor = max(sh, 0.0);\n\n        #ifdef BAKERY_LMSPEC\n            float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n            float focus = saturate(length(dominantDir));\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = max(spec * sh, 0.0);\n        #endif\n    }\n#endif\n\n\n\n#ifdef BAKERY_BICUBIC\nfloat BakeryBicubic_w0(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-a + 3.0f) - 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w1(float a)\n{\n    return (1.0f/6.0f)*(a*a*(3.0f*a - 6.0f) + 4.0f);\n}\n\nfloat BakeryBicubic_w2(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-3.0f*a + 3.0f) + 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w3(float a)\n{\n    return (1.0f/6.0f)*(a*a*a);\n}\n\nfloat BakeryBicubic_g0(float a)\n{\n    return BakeryBicubic_w0(a) + BakeryBicubic_w1(a);\n}\n\nfloat BakeryBicubic_g1(float a)\n{\n    return BakeryBicubic_w2(a) + BakeryBicubic_w3(a);\n}\n\nfloat BakeryBicubic_h0(float a)\n{\n    return -1.0f + BakeryBicubic_w1(a) / (BakeryBicubic_w0(a) + BakeryBicubic_w1(a)) + 0.5f;\n}\n\nfloat BakeryBicubic_h1(float a)\n{\n    return 1.0f + BakeryBicubic_w3(a) / (BakeryBicubic_w2(a) + BakeryBicubic_w3(a)) + 0.5f;\n}\n#endif\n\n\n#if defined(_LIGHTMAPMODE_RNM) || defined(_LIGHTMAPMODE_SH)\nTexture2D _RNM0, _RNM1, _RNM2;\n#endif\n\n#ifdef BAKERY_VOLUME\nTexture3D _Volume0, _Volume1, _Volume2, _VolumeMask;\nSamplerState sampler_Volume0;\n#endif\n\n#if defined(BAKERY_BICUBIC) && defined(LIGHTMAP_ON) && defined(SHADER_API_D3D11)\n    // Bicubic\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\tfloat width, height;\n\t\ttex.GetDimensions(width, height);\n\t\tfloat texelSize = 1.0f / width;\n\n        float x = uv.x * width;\n        float y = uv.y * width;\n\n        x -= 0.5f;\n        y -= 0.5f;\n\n        float px = floor(x);\n        float py = floor(y);\n\n        float fx = x - px;\n        float fy = y - py;\n\n        float g0x = BakeryBicubic_g0(fx);\n        float g1x = BakeryBicubic_g1(fx);\n        float h0x = BakeryBicubic_h0(fx);\n        float h1x = BakeryBicubic_h1(fx);\n        float h0y = BakeryBicubic_h0(fy);\n        float h1y = BakeryBicubic_h1(fy);\n\n        return     BakeryBicubic_g0(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h0y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h0y) * texelSize))) +\n\n                   BakeryBicubic_g1(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h1y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h1y) * texelSize)));\n    }\n#else\n    // Bilinear\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\t#ifdef LIGHTMAP_ON\n\t\t\treturn tex.Sample(samplerunity_Lightmap, uv);\n\t\t#else\n\t\t\treturn float4(1,0,0,1);\n\t\t#endif\n    }\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\n#ifdef BAKERY_LMSPEC\nfloat BakeryDirectionalLightmapSpecular(float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 dominantDir = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap, lmUV).xyz * 2 - 1;\n    half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n    half nh = saturate(dot(normalWorld, halfDir));\n    half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n    half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n    half spec = GGXTerm(nh, roughness);\n    return spec;\n}\n#endif\n#endif\n\n\n\n#ifdef _LIGHTMAPMODE_RNM\nvoid BakeryRNM(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalMap, float smoothness, float3 viewDirT)\n{\n    const float3 rnmBasis0 = float3(0.816496580927726f, 0, 0.5773502691896258f);\n    const float3 rnmBasis1 = float3(-0.4082482904638631f, 0.7071067811865475f, 0.5773502691896258f);\n    const float3 rnmBasis2 = float3(-0.4082482904638631f, -0.7071067811865475f, 0.5773502691896258f);\n\n    float3 rnm0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 rnm1 = DecodeLightmap(BakeryTex2D(_RNM1, lmUV));\n    float3 rnm2 = DecodeLightmap(BakeryTex2D(_RNM2, lmUV));\n\n    #ifdef BAKERY_SSBUMP\n        diffuseColor = normalMap.x * rnm0\n                     + normalMap.z * rnm1\n                     + normalMap.y * rnm2;\n         diffuseColor *= 2;\n    #else\n        diffuseColor = saturate(dot(rnmBasis0, normalMap)) * rnm0\n                     + saturate(dot(rnmBasis1, normalMap)) * rnm1\n                     + saturate(dot(rnmBasis2, normalMap)) * rnm2;\n    #endif\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDirT = rnmBasis0 * dot(rnm0, lumaConv) +\n                              rnmBasis1 * dot(rnm1, lumaConv) +\n                              rnmBasis2 * dot(rnm2, lumaConv);\n\n        float3 dominantDirTN = normalize(dominantDirT);\n        float3 specColor = saturate(dot(rnmBasis0, dominantDirTN)) * rnm0 +\n                           saturate(dot(rnmBasis1, dominantDirTN)) * rnm1 +\n                           saturate(dot(rnmBasis2, dominantDirTN)) * rnm2;\n\n        half3 halfDir = Bakery_SafeNormalize(dominantDirTN - viewDirT);\n        half nh = saturate(dot(normalMap, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n        specularColor = spec * specColor;\n    #endif\n}\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\ninline half3 Unity_DecodeDirectionalLightmap(half3 color, fixed4 dirTex, half3 normalWorld)\n{\n    // In directional (non-specular) mode Enlighten bakes dominant light direction\n    // in a way, that using it for half Lambert and then dividing by a \"rebalancing coefficient\"\n    // gives a result close to plain diffuse response lightmaps, but normalmapped.\n\n    // Note that dir is not unit length on purpose. Its length is \"directionality\", like\n    // for the directional specular lightmaps.\n\n    half halfLambert = dot(normalWorld, dirTex.xyz - 0.5) + 0.5;\n\n    return color * halfLambert / max(1e-4h, dirTex.w);\n}\n#endif\n\n#ifdef _LIGHTMAPMODE_SH\nvoid BakerySH(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 L0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 nL1x = BakeryTex2D(_RNM0, lmUV) * 2 - 1;\n    float3 nL1y = BakeryTex2D(_RNM1, lmUV) * 2 - 1;\n    float3 nL1z = BakeryTex2D(_RNM2, lmUV) * 2 - 1;\n    float3 L1x = nL1x * L0 * 2;\n    float3 L1y = nL1y * L0 * 2;\n    float3 L1z = nL1z * L0 * 2;\n\n    float3 sh;\n#if BAKERY_SHNONLINEAR\n    float lumaL0 = dot(L0, 1);\n    float lumaL1x = dot(L1x, 1);\n    float lumaL1y = dot(L1y, 1);\n    float lumaL1z = dot(L1z, 1);\n    float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    float regularLumaSH = dot(sh, 1);\n    //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n    sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n    //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n    //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n#else\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n#endif\n\n    diffuseColor = max(sh, 0.0);\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n        float focus = saturate(length(dominantDir));\n        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n        half nh = saturate(dot(normalWorld, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n\n        sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n\n        specularColor = max(spec * sh, 0.0);\n    #endif\n}\n#endif\n\n#endif // include guards\n\n\n    void Ext_ModifyVertex15 (inout VertexData v, inout ExtraV2F e)\n    {\n        #if _USEBAKERY\n\t\t    #if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\t\t\t    // Unpack from RGBM\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.a * 8.0f;\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.rgb;\n\n\t\t\t    #ifdef BAKERY_VERTEXLMMASK\n\t\t\t\t    e.extraV2F4.xyzw = unpack4NFloats(v.texcoord1);\n\t\t\t    #endif\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXSH\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n                e.extraV2F6.xyz = unpack3NFloats(v.texcoord3.x) * 2 - 1;\n                e.extraV2F7.xyz = unpack3NFloats(v.texcoord3.y) * 2 - 1;\n            #endif\n       #endif\n    }\n\n#if _HDRP || _URP\n    half3 SHEvalLinearL0L1 (half4 normal)\n    {\n        half3 x;\n\n        // Linear (L1) + constant (L0) polynomial terms\n        x.r = dot(unity_SHAr,normal);\n        x.g = dot(unity_SHAg,normal);\n        x.b = dot(unity_SHAb,normal);\n\n        return x;\n    }\n\n    // normal should be normalized, w=1.0\n    half3 SHEvalLinearL2 (half4 normal)\n    {\n        half3 x1, x2;\n        // 4 of the quadratic (L2) polynomials\n        half4 vB = normal.xyzz * normal.yzzx;\n        x1.r = dot(unity_SHBr,vB);\n        x1.g = dot(unity_SHBg,vB);\n        x1.b = dot(unity_SHBb,vB);\n\n        // Final (5th) quadratic (L2) polynomial\n        half vC = normal.x*normal.x - normal.y*normal.y;\n        x2 = unity_SHC.rgb * vC;\n\n        return x1 + x2;\n    }\n\n    half3 ShadeSH9 (half4 normal)\n    {\n        // Linear + constant polynomial terms\n        half3 res = SHEvalLinearL0L1 (normal);\n\n        // Quadratic polynomials\n        res += SHEvalLinearL2 (normal);\n\n        #ifdef UNITY_COLORSPACE_GAMMA\n            res = LinearToGamma (res);\n        #endif\n\n        return res;\n\n    }\n#endif\n\n\n\n\tvoid DoBakeryStuff(inout float3 indDif, inout float3 indSpec, inout float4 shadowmask, float3 tangentNormal, float smoothness, ShaderData d)\n\t{\n\t\t// Quality!\n\t\tindDif = 1;\n\t\tindSpec = 0;\n\n        #if defined(_PASSFORWARD) || defined(_PASSGBUFFER) // forward pass on URP/Standard/HDRP + built-in deferred\n\n            float3 normalWorld = mul(tangentNormal, d.TBNMatrix);\n\n\t\t\t#ifdef LIGHTMAP_ON\n\n                // Static\n\n\t\t\t\tfloat2 lmUV = d.texcoord1 * unity_LightmapST.xy + unity_LightmapST.zw;\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_STANDARD\n\t\t\t\t\tindDif = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n\n\t\t\t\t\t#ifdef DIRLIGHTMAP_COMBINED\n\t\t\t\t\t\tfloat4 dirMap = BakeryTex2D(unity_LightmapInd, lmUV);\n\t\t\t\t\t\tindDif = Unity_DecodeDirectionalLightmap(indDif, dirMap, normalWorld);\n\n\t\t\t\t\t\t#ifdef BAKERY_LMSPEC\n\t\t\t\t\t\t\tindSpec = BakeryDirectionalLightmapSpecular(lmUV, normalWorld, -d.worldSpaceViewDir, smoothness) * indDif;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\n\t\t\t\t\tindDif = d.vertexColor;\n\n                    #ifdef BAKERY_VERTEXLMMASK\n                        shadowmask = d.extraV2F4;\n                    #endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n\t\t\t\t\t\t// worldSpaceNormal is per-vertex\n\t\t\t\t\t\t// normalWorld is per-pixel\n\t\t\t\t\t\tfloat3 bakedLightDirection = d.extraV2F5;\n\t\t\t\t\t\tBakeryVertexLMDirection(indDif, indSpec, bakedLightDirection, d.worldSpaceNormal, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXSH\n\t\t\t\t\t\tBakeryVertexLMSH(indDif, indSpec, d.extraV2F5, d.extraV2F6, d.extraV2F7, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_RNM\n\t\t\t\t\tBakeryRNM(indDif, indSpec, lmUV, tangentNormal, smoothness, -d.tangentSpaceViewDir);\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_SH\n\t\t\t\t\tBakerySH(indDif, indSpec, lmUV, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t#endif\n\n            #else\n\n                // Dynamic\n\n                #ifdef BAKERY_VOLUME\n\n                    bool isGlobal = dot(abs(_VolumeInvSize),1) == 0;\n                    float3 volViewDir = -d.worldSpaceViewDir;\n                    #ifdef BAKERY_VOLROTATION\n                        float4x4 volMatrix = (isGlobal ? _GlobalVolumeMatrix : _VolumeMatrix);\n                        float3 volInvSize = (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 lpUV = mul(volMatrix, float4(d.worldSpacePosition,1)).xyz * volInvSize + 0.5f;\n                        float3 volNormal = mul((float3x3)volMatrix, normalWorld);\n                        #ifdef BAKERY_LMSPEC\n                            volViewDir = mul((float3x3)volMatrix, volViewDir);\n                        #endif\n                    #else\n                        float3 lpUV = (d.worldSpacePosition - (isGlobal ? _GlobalVolumeMin : _VolumeMin)) * (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 volNormal = normalWorld;\n                    #endif\n\n                    #ifdef BAKERY_COMPRESSED_VOLUME\n                        float4 tex0, tex1, tex2, tex3;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex3 = _Volume3.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz * L0;\n                        L1y = tex2.xyz * L0;\n                        L1z = tex3.xyz * L0;\n                    #else\n                        float4 tex0, tex1, tex2;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV);\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV);\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz;\n                        L1y = tex2.xyz;\n                        L1z = float3(tex0.w, tex1.w, tex2.w);\n                    #endif\n                    indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), volNormal);\n                    indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), volNormal);\n                    indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), volNormal);\n\n                    #ifdef UNITY_COLORSPACE_GAMMA\n                        indDif = pow(indDif, 1.0f / 2.2f);\n                    #endif\n\n                    #ifdef BAKERY_LMSPEC\n                        float3 nL1x = L1x / L0;\n                        float3 nL1y = L1y / L0;\n                        float3 nL1z = L1z / L0;\n                        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n                        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - volViewDir);\n                        half nh = saturate(dot(volNormal, halfDir));\n                        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n                        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n                        half spec = GGXTerm(nh, roughness);\n                        float3 sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n                        indSpec = max(spec * sh, 0.0);\n                    #endif\n\n                    shadowmask = _VolumeMask.Sample(sampler_Volume0, lpUV);\n\n                #else\n\n                    #ifdef BAKERY_SHNONLINEAR\n                        float3 L0 = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);\n                        indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, unity_SHAr.xyz, normalWorld);\n                        indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, unity_SHAg.xyz, normalWorld);\n                        indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, unity_SHAb.xyz, normalWorld);\n                    #else\n                        indDif = ShadeSH9(float4(normalWorld,1));\n                    #endif\n\n                #endif\n\n\t\t\t#endif\n\n        #endif\n\t}\n\n\t// this is the main surface function. Surface is like a surface shader output structure, but\n\t// with our new outputs as well.\n\tvoid Ext_SurfaceFunction15 (inout Surface o, ShaderData d)\n\t{\n        #if _USEBAKERY\n\t\t    float3 indDif;\n\t\t    float3 indSpec;\n            float4 shadowmask = 1;\n\t\t    DoBakeryStuff(indDif, indSpec, shadowmask, o.Normal, o.Smoothness, d);\n\t\t    o.DiffuseGI = indDif;\n\t\t    o.BackDiffuseGI = indDif;\n\t\t    o.SpecularGI = indSpec;\n            o.ShadowMask = shadowmask;\n        #endif\n\t}\n\n\n\n\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                  Ext_SurfaceFunction1(l, d);\n                  Ext_SurfaceFunction2(l, d);\n                  Ext_SurfaceFunction3(l, d);\n                  Ext_SurfaceFunction4(l, d);\n                  Ext_SurfaceFunction5(l, d);\n                  Ext_SurfaceFunction6(l, d);\n                  Ext_SurfaceFunction7(l, d);\n                  Ext_SurfaceFunction8(l, d);\n                  Ext_SurfaceFunction9(l, d);\n\t\t            Ext_SurfaceFunction10(l, d);\n                  Ext_SurfaceFunction11(l, d);\n                  Ext_SurfaceFunction12(l, d);\n                  Ext_SurfaceFunction13(l, d);\n                  Ext_SurfaceFunction14(l, d);\n                  Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraV2F d;\n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                  Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                  Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                  #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                  v2p.extraV2F4 = d.extraV2F4;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                  v2p.extraV2F5 = d.extraV2F5;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F6 = d.extraV2F6;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F7 = d.extraV2F7;\n                  #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                d.extraV2F4 = v2p.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                d.extraV2F5 = v2p.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F6 = v2p.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F7 = v2p.extraV2F7;\n                #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n                Ext_ModifyTessellatedVertex2(v, d);\n                Ext_ModifyTessellatedVertex3(v, d);\n                Ext_ModifyTessellatedVertex4(v, d);\n                Ext_ModifyTessellatedVertex5(v, d);\n                Ext_ModifyTessellatedVertex6(v, d);\n                Ext_ModifyTessellatedVertex7(v, d);\n                Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                v2p.extraV2F4 = d.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                v2p.extraV2F5 = d.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F6 = d.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F7 = d.extraV2F7;\n                #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n\n\n         \n         \n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n            // d.texcoord3 = i.texcoord3;\n             #endif\n\n             d.isFrontFace = facing;\n             #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n             d.vertexColor = i.vertexColor;\n             #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(i.worldPos, 1)).xyz;\n            #endif\n             d.localSpaceNormal = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n             #if LOD_FADE_CROSSFADE\n             d.screenPos = i.screenPos;\n             d.screenUV = (i.screenPos.xy / i.screenPos.w);\n             #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n             #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n             d.extraV2F4 = i.extraV2F4;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n             d.extraV2F5 = i.extraV2F5;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F6 = i.extraV2F6;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F7 = i.extraV2F7;\n             #endif\n\n            return d;\n         }\n         \n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           UNITY_SETUP_INSTANCE_ID(v);\n           VertexToPixel o;\n           UNITY_INITIALIZE_OUTPUT(VertexToPixel,o);\n           UNITY_TRANSFER_INSTANCE_ID(v,o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o);\n#endif\n\n           o.pos = UnityObjectToClipPos(v.vertex);\n            o.texcoord0 = v.texcoord0;\n            o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n            #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n           // o.texcoord3 = v.texcoord3;\n            #endif\n\n            #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n            o.vertexColor = v.vertexColor;\n            #endif\n\n            #if LOD_FADE_CROSSFADE\n            o.screenPos = ComputeScreenPos(o.pos);\n            #endif\n\n           o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n           o.worldNormal = UnityObjectToWorldNormal(v.normal);\n           o.worldTangent.xyz = UnityObjectToWorldDir(v.tangent.xyz);\n           fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n           o.worldTangent.w = tangentSign;\n\n           UNITY_TRANSFER_LIGHTING(o, v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader\n           UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader\n\n           return o;\n         }\n\n         \n\n         // fragment shader\n         fixed4 Frag (VertexToPixel IN\n         #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n         #endif\n         #if NEED_FACING\n            , bool facing : SV_IsFrontFace\n         #endif\n         ) : SV_Target\n         {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           // prepare and unpack data\n\n           #ifdef FOG_COMBINED_WITH_TSPACE\n             UNITY_EXTRACT_FOG_FROM_TSPACE(IN);\n           #elif defined FOG_COMBINED_WITH_WORLD_POS\n             UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);\n           #else\n             UNITY_EXTRACT_FOG(IN);\n           #endif\n\n\n\n           ShaderData d = CreateShaderData(IN\n              #if NEED_FACING\n                 , facing\n              #endif\n           );\n           Surface l = (Surface)0;\n\n\n           #ifdef _DEPTHOFFSET_ON\n              l.outputDepth = outputDepth;\n           #endif\n\n           l.Albedo = half3(0.5, 0.5, 0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n           l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n           #ifdef _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n           #endif\n\n\n           #ifndef USING_DIRECTIONAL_LIGHT\n             fixed3 lightDir = normalize(UnityWorldSpaceLightDir(d.worldSpacePosition));\n           #else\n             fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n           #endif\n           float3 worldViewDir = normalize(UnityWorldSpaceViewDir(d.worldSpacePosition));\n\n           #if _USESPECULAR || _USESPECULARWORKFLOW || _SPECULARFROMMETALLIC\n              #ifdef UNITY_COMPILER_HLSL\n                 SurfaceOutputStandardSpecular o = (SurfaceOutputStandardSpecular)0;\n              #else\n                 SurfaceOutputStandardSpecular o;\n              #endif\n              o.Specular = l.Specular;\n              o.Occlusion = l.Occlusion;\n              o.Smoothness = l.Smoothness;\n           #elif _BDRFLAMBERT || _BDRF3 || _SIMPLELIT\n              #ifdef UNITY_COMPILER_HLSL\n                 SurfaceOutput o = (SurfaceOutput)0;\n              #else\n                 SurfaceOutput o;\n              #endif\n\n              o.Specular = l.SpecularPower;\n              o.Gloss = l.Smoothness;\n              _SpecColor.rgb = l.Specular; // fucking hell Unity, wtf..\n           #else\n              #ifdef UNITY_COMPILER_HLSL\n                 SurfaceOutputStandard o = (SurfaceOutputStandard)0;\n              #else\n                 SurfaceOutputStandard o;\n              #endif\n              o.Smoothness = l.Smoothness;\n              o.Metallic = l.Metallic;\n              o.Occlusion = l.Occlusion;\n           #endif\n\n   \n           o.Albedo = l.Albedo;\n           o.Emission = l.Emission;\n           o.Alpha = l.Alpha;\n\n           #if _WORLDSPACENORMAL\n              o.Normal = l.Normal;\n           #else\n              o.Normal = normalize(TangentToWorldSpace(d, l.Normal));\n           #endif\n\n\n\n           UNITY_LIGHT_ATTENUATION(atten, IN, d.worldSpacePosition)\n           half4 c = 0;\n\n           // Setup lighting environment\n           UnityGI gi;\n           UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n           gi.indirect.diffuse = 0;\n           gi.indirect.specular = 0;\n           gi.light.color = _LightColor0.rgb;\n           gi.light.dir = lightDir;\n           gi.light.color *= atten;\n\n           #if defined(_OVERRIDE_SHADOWMASK)\n               float4 mulColor = saturate(dot(l.ShadowMask, unity_OcclusionMaskSelector));\n               gi.light.color = mulColor;\n            #endif\n\n           #if _USESPECULAR\n              c += LightingStandardSpecular (o, worldViewDir, gi);\n           #elif _BDRF3 || _SIMPLELIT\n              c += LightingBlinnPhong (o, d.worldSpaceViewDir, gi);\n           #else\n              c += LightingStandard (o, worldViewDir, gi);\n           #endif\n           \n\n           ChainFinalColorForward(l, d, c);\n\n           UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog\n\n           #if !_ALPHABLEND_ON\n              UNITY_OPAQUE_ALPHA(c.a);\n           #endif\n           \n           return c;\n         }\n\n         ENDCG\n\n      }\n\n      \n      \n\t   // ---- meta information extraction pass:\n\t   Pass\n      {\n\t\t   Name \"Meta\"\n\t\t   Tags { \"LightMode\" = \"Meta\" }\n\t\t   Cull Off\n\n            Cull [_CullMode]\n\n\n         CGPROGRAM\n\n            #pragma vertex Vert\n   #pragma fragment Frag\n\n         // compile directives\n         #pragma target 3.0\n         #pragma multi_compile_instancing\n         #pragma skip_variants FOG_LINEAR FOG_EXP FOG_EXP2\n         #pragma shader_feature EDITOR_VISUALIZATION\n\n         #include \"HLSLSupport.cginc\"\n         #define UNITY_INSTANCED_LOD_FADE\n         #define UNITY_INSTANCED_SH\n         #define UNITY_INSTANCED_LIGHTMAPSTS\n         #include \"UnityShaderVariables.cginc\"\n         #include \"UnityShaderUtilities.cginc\"\n\n         #include \"UnityCG.cginc\"\n         #include \"Lighting.cginc\"\n         #include \"UnityPBSLighting.cginc\"\n         #include \"UnityMetaPass.cginc\"\n\n         #define _PASSMETA 1\n\n         \n\n\n   #pragma shader_feature_local_fragment _ _PACKEDFAST\n   #pragma shader_feature_local _ _TRIPLANAR\n   #pragma shader_feature_local_fragment _ _NORMALMAP \n   #pragma shader_feature_local_fragment _ _MASKMAP\n   #pragma shader_feature_local_fragment _ _DETAIL\n   #pragma shader_feature_local_fragment _ _DETAILTRIPLANAR\n   #pragma shader_feature_local_fragment _ _DETAILSTOCHASTIC\n   #pragma shader_feature_local_fragment _ _EMISSION\n   #pragma shader_feature_local_fragment _ _FLATSHADE\n   #pragma shader_feature_local _ _STOCHASTIC\n   #pragma shader_feature_local_fragment _ _PARALLAX //_POM\n   #pragma shader_feature_local_fragment _ _SPECULAR\n   #pragma shader_feature_local _ _NOISEWORLD _NOISELOCAL\n   #pragma shader_feature_local _ _NOISEHQ _NOISETEXTURE _NOISEWORLEY\n   // only for URP/Standard Forward\n   #pragma shader_feature_local_fragment _ _SIMPLELIT\n\n\n   #pragma shader_feature_local_fragment _ _TINTMASK\n\n\n    #pragma shader_feature_local _ _LAYERVERTEXMASK _LAYERTEXTUREMASK\n\n    #define _HAS_WEIGHTTEXTURE_MASK 1\n\n\n   #pragma shader_feature_local _ _USELAYER\n   #pragma shader_feature_local _ _LAYERTRIPLANAR\n   #pragma shader_feature_local _ _LAYERALBEDO\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL\n   #pragma shader_feature_local _ _LAYERMASK\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION\n   #pragma shader_feature_local _ _LAYERNOISE\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC\n   #pragma shader_feature_local _ _LAYERANGLEFILTER\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_1\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_1\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_1\n   #pragma shader_feature_local _ _LAYERMASK_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_1\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_1\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_1\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_1\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_2\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_2\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_2\n   #pragma shader_feature_local _ _LAYERMASK_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_2\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_2\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_2\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_2\n\n\n   #pragma shader_feature_local _ _TRAX_ON\n\n\n   #pragma shader_feature_local_fragment _ _WETNESS\n   #pragma shader_feature_local_fragment _ _PUDDLES\n   #pragma shader_feature_local_fragment _ _PUDDLENOISE\n   #pragma shader_feature_local_fragment _ _RAINDROPS\n\n\n   #pragma shader_feature_local _ _SNOW\n   #pragma shader_feature_local _ _SNOWMASKMAP\n   #pragma shader_feature_local _ _SNOWNOISE\n   #pragma shader_feature_local_fragment _SNOWSTOCHASTIC\n\n\n   #pragma shader_feature_local_fragment _ _WIND_ON\n\n\n\n\n   #pragma shader_feature_local_fragment _ _SURFACEGRADIENT _AUTONORMAL\n   #define _WORLDSPACENORMAL 1\n\n\n   #pragma shader_feature_local _ _DEBUG_SAMPLECOUNT\n\n\n\t#pragma shader_feature_local_fragment _ _DISSOLVE\n\n\n   #pragma multi_compile_local  LOD_FADE_CROSSFADE\n\n\n\n#pragma instancing_options procedural:setupVSPro forwardadd\n\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\nstruct IndirectShaderData\n{\n\tfloat4x4 PositionMatrix;\n\tfloat4x4 InversePositionMatrix;\n\tfloat4 ControlData;\n};\n\n#if defined(SHADER_API_GLCORE) || defined(SHADER_API_D3D11) || defined(SHADER_API_GLES3) || defined(SHADER_API_METAL) || defined(SHADER_API_VULKAN) || defined(SHADER_API_PSSL) || defined(SHADER_API_XBOXONE)\n\tuniform StructuredBuffer<IndirectShaderData> VisibleShaderDataBuffer;\n#endif\n\n#endif\n\nfloat VSPRenderingLayerMask;\n\nvoid setupVSPro()\n{\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\n    #if _HDRP\n\t    unity_RenderingLayer.x = VSPRenderingLayerMask;\n    #endif\n\n\t#ifdef unity_ObjectToWorld\n\t#undef unity_ObjectToWorld\n\t#endif\n\n\t#ifdef unity_WorldToObject\n\t#undef unity_WorldToObject\n\t#endif\n\n\tunity_ObjectToWorld = VisibleShaderDataBuffer[unity_InstanceID].PositionMatrix;\n\tunity_WorldToObject = VisibleShaderDataBuffer[unity_InstanceID].InversePositionMatrix;\n#endif\n\n}\n\n\n\t#pragma multi_compile _LIGHTMAPMODE_STANDARD _LIGHTMAPMODE_RNM _LIGHTMAPMODE_SH _LIGHTMAPMODE_VERTEX _LIGHTMAPMODE_VERTEXDIRECTIONAL _LIGHTMAPMODE_VERTEXSH\n\n    #pragma shader_feature USEBAKERY\n    #pragma shader_feature BAKERY_VERTEXLMMASK\n    #pragma shader_feature BAKERY_SHNONLINEAR\n    #pragma shader_feature BAKERY_LMSPEC\n    #pragma shader_feature BAKERY_BICUBIC\n    #pragma shader_feature BAKERY_VOLUME\n    #pragma shader_feature BAKERY_VOLROTATION\n    #pragma shader_feature BAKERY_COMPRESSED_VOLUME\n\n    #if _USEBAKERY\n\t    #define _OVERRIDE_BAKEDGI\n        #if BAKERY_VOLUME || (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)) && defined(BAKERY_VERTEXLMMASK)\n            #define _OVERRIDE_SHADOWMASK\n        #endif\n    #endif\n\n\n\n\n\n\n\n\n   #define _STANDARD 1\n\n   #define _ALPHABLEND_ON 1\n// If your looking in here and thinking WTF, yeah, I know. These are taken from the SRPs, to allow us to use the same\n// texturing library they use. However, since they are not included in the standard pipeline by default, there is no\n// way to include them in and they have to be inlined, since someone could copy this shader onto another machine without\n// Better Shaders installed. Unfortunate, but I'd rather do this and have a nice library for texture sampling instead\n// of the patchy one Unity provides being inlined/emulated in HDRP/URP. Strangely, PSSL and XBoxOne libraries are not\n// included in the standard SRP code, but they are in tons of Unity own projects on the web, so I grabbed them from there.\n\n\n#if defined(SHADER_API_XBOXONE)\n\t\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n\n#elif defined(SHADER_API_PSSL)\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.GetLOD(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RW_Texture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RW_Texture2D_Array<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RW_Texture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n\n\n#elif defined(SHADER_API_D3D11)\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_METAL)\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)          Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)           Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)           Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_VULKAN)\n// This file assume SHADER_API_VULKAN is defined\n\t// TODO: This is a straight copy from D3D11.hlsl. Go through all this stuff and adjust where needed.\n\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)          Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)           Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)           Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_SWITCH)\n\t// This file assume SHADER_API_SWITCH is defined\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)          Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)           Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)           Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                       textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)              textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)     textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)          textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod) textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                       textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)              textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_GLCORE)\n\n\t// OpenGL 4.1 SM 5.0 https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html\n\t#if (SHADER_TARGET >= 46)\n\t#define OPENGL4_1_SM5 1\n\t#else\n\t#define OPENGL4_1_SM5 0\n\t#endif\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                  Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)            Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)                TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)          TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                  Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)            TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)      TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)          TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)    TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)            TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)             TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)       TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)           TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)     TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)             TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)   TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)         RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)   RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)         RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                    SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)                SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)                textureName.SampleGrad(samplerName, coord2, ddx, ddy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#ifdef UNITY_NO_CUBEMAP_ARRAY\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, bias) ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#else\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#endif\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                          textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                 textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                   textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)      textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                 textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)    textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\n\t#if OPENGL4_1_SM5\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   textureName.Gather(samplerName, float4(coord3, index))\n\t#else\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#endif\n\n\n\t#elif defined(SHADER_API_GLES3)\n\n\t// GLES 3.1 + AEP shader feature https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html\n\t#if (SHADER_TARGET >= 40)\n\t#define GLES3_1_AEP 1\n\t#else\n\t#define GLES3_1_AEP 0\n\t#endif\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                  Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)            Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)                TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)          TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                  Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)            Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)      Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)          TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)    TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)            Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)             Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)       Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)           TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)     TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)             Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)   TEXTURECUBE_ARRAY(textureName)\n\n\t#if GLES3_1_AEP\n\t#define RW_TEXTURE2D(type, textureName)         RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)   RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)         RWTexture3D<type> textureName\n\t#else\n\t#define RW_TEXTURE2D(type, textureName)         ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2D)\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)   ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2DArray)\n\t#define RW_TEXTURE3D(type, textureName)         ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture3D)\n\t#endif\n\n\t#define SAMPLER(samplerName)                    SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)                SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)                textureName.SampleGrad(samplerName, coord2, ddx, ddy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\n\t#ifdef UNITY_NO_CUBEMAP_ARRAY\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_BIAS)\n\t#else\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#endif\n\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                          textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                 textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                   textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)      textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                 textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)    textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                       textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                              textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                     textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                          textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)        textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)                 textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                       textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                              textureName.Load(int4(unCoord3, lod))\n\n\t#if GLES3_1_AEP\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherAlpha(samplerName, coord2)\n\t#else\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_RED_TEXTURE2D)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_GREEN_TEXTURE2D)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_BLUE_TEXTURE2D)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_ALPHA_TEXTURE2D)\n\t#endif\n\n\n#elif defined(SHADER_API_GLES)\n\n\n\t#define uint int\n\n\t#define rcp(x) 1.0 / (x)\n\t#define ddx_fine ddx\n\t#define ddy_fine ddy\n\t#define asfloat\n\t#define asuint(x) asint(x)\n\t#define f32tof16\n\t#define f16tof32\n\n\t#define ERROR_ON_UNSUPPORTED_FUNCTION(funcName) #error #funcName is not supported on GLES 2.0\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) #error calculate Level of Detail not supported in GLES2\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                          sampler2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)                    samplerCUBE textureName // No support to texture2DArray\n\t#define TEXTURECUBE(textureName)                        samplerCUBE textureName\n\t#define TEXTURECUBE_ARRAY(textureName)                  samplerCUBE textureName // No supoport to textureCubeArray and can't emulate with texture2DArray\n\t#define TEXTURE3D(textureName)                          sampler3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)                    sampler2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)              TEXTURECUBE_FLOAT(textureName) // No support to texture2DArray\n\t#define TEXTURECUBE_FLOAT(textureName)                  samplerCUBE_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)            TEXTURECUBE_FLOAT(textureName) // No support to textureCubeArray\n\t#define TEXTURE3D_FLOAT(textureName)                    sampler3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)                     sampler2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)               TEXTURECUBE_HALF(textureName) // No support to texture2DArray\n\t#define TEXTURECUBE_HALF(textureName)                   samplerCUBE_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)             TEXTURECUBE_HALF(textureName) // No support to textureCubeArray\n\t#define TEXTURE3D_HALF(textureName)                     sampler3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)                   SHADOW2D_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)             TEXTURECUBE_SHADOW(textureName) // No support to texture array\n\t#define TEXTURECUBE_SHADOW(textureName)                 SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)           TEXTURECUBE_SHADOW(textureName) // No support to texture array\n\n\t#define RW_TEXTURE2D(type, textureNam)                  ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2D)\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)           ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2DArray)\n\t#define RW_TEXTURE3D(type, textureNam)                  ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture3D)\n\n\t#define SAMPLER(samplerName)\n\t#define SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                sampler2D textureName\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)          samplerCUBE textureName\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)              samplerCUBE textureName\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        samplerCUBE textureName\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                sampler3D textureName\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)         SHADOW2D_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)   SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)       SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)               textureName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)         textureName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)             textureName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)       textureName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)               textureName\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)        textureName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)  textureName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)      textureName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2) tex2D(textureName, coord2)\n\n\t#if (SHADER_TARGET >= 30)\n\t    #define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod) tex2Dlod(textureName, float4(coord2, 0, lod))\n\t#else\n\t    // No lod support. Very poor approximation with bias.\n\t    #define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod) SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, lod)\n\t#endif\n\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                       tex2Dbias(textureName, float4(coord2, 0, bias))\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)                   SAMPLE_TEXTURE2D(textureName, samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                     ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY)\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)            ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_LOD)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)          ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_BIAS)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy)    ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_GRAD)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                                texCUBE(textureName, coord3)\n\t// No lod support. Very poor approximation with bias.\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                       SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                     texCUBEbias(textureName, float4(coord3, bias))\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                   ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)          ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)        ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_BIAS)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                                  tex3D(textureName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                         ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE3D_LOD)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                           SHADOW2D_SAMPLE(textureName, samplerName, coord3)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)              ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_SHADOW)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                         SHADOWCUBE_SAMPLE(textureName, samplerName, coord4)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)            ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_SHADOW)\n\n\n\t// Not supported. Can't define as error because shader library is calling these functions.\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                               half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                                      half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                             half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                                  half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)                half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)                         half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                               ERROR_ON_UNSUPPORTED_FUNCTION(LOAD_TEXTURE3D)\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                                      ERROR_ON_UNSUPPORTED_FUNCTION(LOAD_TEXTURE3D_LOD)\n\n\t// Gather not supported. Fallback to regular texture sampling.\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_RED_TEXTURE2D)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_GREEN_TEXTURE2D)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_BLUE_TEXTURE2D)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_ALPHA_TEXTURE2D)\n\n#else\n#error unsupported shader api\n#endif\n\n\n\n\n// default flow control attributes\n#ifndef UNITY_BRANCH\n#   define UNITY_BRANCH\n#endif\n#ifndef UNITY_FLATTEN\n#   define UNITY_FLATTEN\n#endif\n#ifndef UNITY_UNROLL\n#   define UNITY_UNROLL\n#endif\n#ifndef UNITY_UNROLLX\n#   define UNITY_UNROLLX(_x)\n#endif\n#ifndef UNITY_LOOP\n#   define UNITY_LOOP\n#endif\n\n\n\n#define NEED_FACING 1\n\n         \n\n         // data across stages, stripped like the above.\n         struct VertexToPixel\n         {\n            UNITY_POSITION(pos);\n            float3 worldPos : TEXCOORD0;\n            float3 worldNormal : TEXCOORD1;\n            float4 worldTangent : TEXCOORD2;\n             float4 texcoord0 : TEXCCOORD3;\n             float4 texcoord1 : TEXCCOORD4;\n            // float4 texcoord2 : TEXCCOORD5;\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n            // float4 texcoord3 : TEXCCOORD6;\n             #endif\n\n             #if LOD_FADE_CROSSFADE\n             float4 screenPos : TEXCOORD7;\n             #endif\n\n            #ifdef EDITOR_VISUALIZATION\n              float2 vizUV : TEXCOORD8;\n              float4 lightCoord : TEXCOORD9;\n            #endif\n\n            \n             #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n             float4 vertexColor : COLOR_centroid;\n             #endif\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // float4 extraV2F0 : TEXCOORD10;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // float4 extraV2F1 : TEXCOORD11;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // float4 extraV2F2 : TEXCOORD12;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // float4 extraV2F3 : TEXCOORD13;\n            // #endif\n\n             #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n             float4 extraV2F4 : TEXCOORD14_centroid;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n             float4 extraV2F5 : TEXCOORD15_centroid;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             float4 extraV2F6 : TEXCOORD16_centroid;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             float4 extraV2F7 : TEXCOORD17_centroid;\n             #endif\n\n\n            UNITY_VERTEX_INPUT_INSTANCE_ID\n            UNITY_VERTEX_OUTPUT_STEREO\n         };\n\n         \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n   half4 weightTextureMask;\n   \n\n\n   float traxBuffer;\n\n\n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // would love to strip these, but they are used in certain\n               // combinations of the lighting system, and may be used\n               // by the user as well, so no easy way to strip them.\n\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR_centroid;\n                #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                float4 extraV2F4 : TEXCOORD9_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                float4 extraV2F5 : TEXCOORD10_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F6 : TEXCOORD11_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F7 : TEXCOORD12_centroid;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef UNITY_MATRIX_M\n               #undef UNITY_MATRIX_I_M\n               #undef UNITY_MATRIX_V\n               #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n               #undef UNITY_MATRIX_VP\n               #undef UNITY_MATRIX_MV\n               #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n               #undef UNITY_MATRIX_MVP\n\n               #define UNITY_MATRIX_M     unity_ObjectToWorld\n               #define UNITY_MATRIX_I_M   unity_WorldToObject\n               #define UNITY_MATRIX_V     unity_MatrixV\n               #define UNITY_MATRIX_I_V   unity_MatrixInvV\n               #define UNITY_MATRIX_P     OptimizeProjectionMatrix(glstate_matrix_projection)\n               #define UNITY_MATRIX_VP    unity_MatrixVP\n               #define UNITY_MATRIX_MV    mul(UNITY_MATRIX_V, UNITY_MATRIX_M)\n               #define UNITY_MATRIX_T_MV  transpose(UNITY_MATRIX_MV)\n               #define UNITY_MATRIX_IT_MV transpose(mul(UNITY_MATRIX_I_M, UNITY_MATRIX_I_V))\n               #define UNITY_MATRIX_MVP   mul(UNITY_MATRIX_VP, UNITY_MATRIX_M)\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)UNITY_MATRIX_M, transpose(mul(UNITY_MATRIX_I_M, UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)UNITY_MATRIX_V, norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n               #endif\n               #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n         \n\n\n   half4 _Tint;\n   half _UVSource;\n   half _TriplanarContrast;\n   half _AlbedoContrast;\n   half _AlbedoBrightness;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half3 _EmissionColor;\n   float _DetailUVSource;\n   half _StochasticScale;\n   half _DetailStochasticScale;\n   half _Smoothness;\n   half _Metallic;\n   half2 _SmoothnessRemap;\n   half2 _AORemap;\n   half2 _MetallicRemap;\n   half2 _HeightRemap;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n   half _AlphaThreshold;\n   half _Cutoff; // for Unity's light mapper\n   half _TriplanarSpace;\n   half _DetailTriplanarSpace;\n   half _DetailTriplanarContrast;\n   half _MicroShadowStrength;\n   half3 _FuzzyShadingColor;\n   half _FuzzyShadingOn;\n   half3 _FuzzyShadingParams;\n\n   //int _POMMaxSamples;\n   //float _POMMin;\n   //float _POMFade;\n#if _FLATSHADE\n   half _FlatShadingBlend;\n#endif\n\n   half _StochasticContrast;\n   half _DetailStochasticContrast;\n\n#if _PARALLAX || _POM\n   half _ParallaxHeight;\n#endif\n\n\n\n\tfloat4 _TintMask_ST;\n\thalf3 _RColor;\n\thalf3 _GColor;\n\thalf3 _BColor;\n\thalf3 _AColor;\n\n\n\thalf _LayerTextureMaskUVMode;\n    float4 _LayerTextureMask_ST;\n\n\n   //#if _USELAYER\n       float4 _LayerAlbedoMap_ST;\n       half3 _LayerTint;\n       half _LayerBlendMode;\n       float _LayerUVSource;\n       half _LayerAlbedoBrightness;\n       half _LayerAlbedoContrast;\n       half _LayerHeightContrast;\n       half _LayerStrength;\n       half _LayerAlbedoStrength;\n       half _LayerNormalStrength;\n       half _LayerSmoothnessStrength;\n       half _LayerSmoothness;\n       half _LayerMetallic;\n       half _LayerStochasticScale;\n       half2 _LayerSmoothnessRemap;\n       half2 _LayerAORemap;\n       half2 _LayerMetallicRemap;\n       half2 _LayerHeightRemap;\n       float4 _LayerWeightOverDistance;\n       half _LayerMicroShadowStrength;\n       //#if _LAYERNOISE\n           float _LayerNoiseFrequency;\n           float _LayerNoiseAmplitude;\n           float _LayerNoiseOffset;\n           float _LayerNoiseCenter;\n           half3 _LayerBlendTint;\n       //#endif\n       //#if _LAYERANGLEFILTER\n           half _LayerFalloff;\n           half _LayerAngleMin;\n           half _LayerHeight;\n           half _LayerInvertHeight;\n           half _LayerVertexNormalBlend;\n       //#endif\n       half _LayerTriplanarSpace;\n       half _LayerTriplanarContrast;\n       half _LayerBlendContrast;\n       half3 _LayerEmissionColor;\n       half _LayerStochasticContrast;\n       half _LayerTessStrength;\n       half3 _LayerFuzzyShadingColor;\n       half _LayerFuzzyShadingOn;\n       half3 _LayerFuzzyShadingParams;\n   //#endif\n\n\n   //#if _USELAYER_DEF_1\n       float4 _LayerAlbedoMap_Ext_1_ST;\n       half3 _LayerTint_Ext_1;\n       half _LayerBlendMode_Ext_1;\n       float _LayerUVSource_Ext_1;\n       half _LayerAlbedoBrightness_Ext_1;\n       half _LayerAlbedoContrast_Ext_1;\n       half _LayerHeightContrast_Ext_1;\n       half _LayerStrength_Ext_1;\n       half _LayerAlbedoStrength_Ext_1;\n       half _LayerNormalStrength_Ext_1;\n       half _LayerSmoothnessStrength_Ext_1;\n       half _LayerSmoothness_Ext_1;\n       half _LayerMetallic_Ext_1;\n       half _LayerStochasticScale_Ext_1;\n       half2 _LayerSmoothnessRemap_Ext_1;\n       half2 _LayerAORemap_Ext_1;\n       half2 _LayerMetallicRemap_Ext_1;\n       half2 _LayerHeightRemap_Ext_1;\n       float4 _LayerWeightOverDistance_Ext_1;\n       half _LayerMicroShadowStrength_Ext_1;\n       //#if _LAYERNOISE_DEF_1\n           float _LayerNoiseFrequency_Ext_1;\n           float _LayerNoiseAmplitude_Ext_1;\n           float _LayerNoiseOffset_Ext_1;\n           float _LayerNoiseCenter_Ext_1;\n           half3 _LayerBlendTint_Ext_1;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_1\n           half _LayerFalloff_Ext_1;\n           half _LayerAngleMin_Ext_1;\n           half _LayerHeight_Ext_1;\n           half _LayerInvertHeight_Ext_1;\n           half _LayerVertexNormalBlend_Ext_1;\n       //#endif\n       half _LayerTriplanarSpace_Ext_1;\n       half _LayerTriplanarContrast_Ext_1;\n       half _LayerBlendContrast_Ext_1;\n       half3 _LayerEmissionColor_Ext_1;\n       half _LayerStochasticContrast_Ext_1;\n       half _LayerTessStrength_Ext_1;\n       half3 _LayerFuzzyShadingColor_Ext_1;\n       half _LayerFuzzyShadingOn_Ext_1;\n       half3 _LayerFuzzyShadingParams_Ext_1;\n   //#endif\n\n\n   //#if _USELAYER_DEF_2\n       float4 _LayerAlbedoMap_Ext_2_ST;\n       half3 _LayerTint_Ext_2;\n       half _LayerBlendMode_Ext_2;\n       float _LayerUVSource_Ext_2;\n       half _LayerAlbedoBrightness_Ext_2;\n       half _LayerAlbedoContrast_Ext_2;\n       half _LayerHeightContrast_Ext_2;\n       half _LayerStrength_Ext_2;\n       half _LayerAlbedoStrength_Ext_2;\n       half _LayerNormalStrength_Ext_2;\n       half _LayerSmoothnessStrength_Ext_2;\n       half _LayerSmoothness_Ext_2;\n       half _LayerMetallic_Ext_2;\n       half _LayerStochasticScale_Ext_2;\n       half2 _LayerSmoothnessRemap_Ext_2;\n       half2 _LayerAORemap_Ext_2;\n       half2 _LayerMetallicRemap_Ext_2;\n       half2 _LayerHeightRemap_Ext_2;\n       float4 _LayerWeightOverDistance_Ext_2;\n       half _LayerMicroShadowStrength_Ext_2;\n       //#if _LAYERNOISE_DEF_2\n           float _LayerNoiseFrequency_Ext_2;\n           float _LayerNoiseAmplitude_Ext_2;\n           float _LayerNoiseOffset_Ext_2;\n           float _LayerNoiseCenter_Ext_2;\n           half3 _LayerBlendTint_Ext_2;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_2\n           half _LayerFalloff_Ext_2;\n           half _LayerAngleMin_Ext_2;\n           half _LayerHeight_Ext_2;\n           half _LayerInvertHeight_Ext_2;\n           half _LayerVertexNormalBlend_Ext_2;\n       //#endif\n       half _LayerTriplanarSpace_Ext_2;\n       half _LayerTriplanarContrast_Ext_2;\n       half _LayerBlendContrast_Ext_2;\n       half3 _LayerEmissionColor_Ext_2;\n       half _LayerStochasticContrast_Ext_2;\n       half _LayerTessStrength_Ext_2;\n       half3 _LayerFuzzyShadingColor_Ext_2;\n       half _LayerFuzzyShadingOn_Ext_2;\n       half3 _LayerFuzzyShadingParams_Ext_2;\n   //#endif\n\n\n    half _TraxDisplacementDepth;\n    half _TraxDisplacementStrength;\n    half _TraxMipBias;\n    half _TraxNormalStrength;\n    float4 _TraxAlbedo_ST;\n    half _TraxInterpContrast;\n    half _TraxHeightContrast;\n    half3 _TraxTint;\n\n\n\n    half _Porosity;\n    int _WetnessMode;\n    int _PuddleMode;\n\n    half  _PuddleAmount;\n    half  _PuddleFalloff;\n    half4 _PuddleColor;\n    half _PuddleNoiseFrequency;\n    half _PuddleNoiseAmplitude;\n    half _PuddleNoiseOffset;\n    half _PuddleNoiseCenter;\n    half _PuddleAngleMin;\n\n    half _WetnessAmount;\n\thalf _WetnessMin;\n    half _WetnessMax;\n    half _WetnessFalloff;\n\thalf _WetnessAngleMin;\n    float _WetnessShoreline;\n\n    int _RainMode;\n    half3 _RainIntensityScale;\n\n\n\n\n    float4 _SnowAlbedo_ST;\n    half3 _SnowTint;\n    half _SnowAmount;\n    half _SnowAngle;\n    half _SnowContrast;\n    half _SnowVertexHeight;\n    half _SnowMode;\n    half3 _SnowWorldFade; // z is on/off\n    float4 _SnowTraxAlbedo_ST;\n    half3 _SnowTraxTint;\n\n    half _SnowNoiseFreq; \n    half _SnowNoiseAmp;\n    half _SnowNoiseOffset;\n    half _SnowStochasticContrast;\n    half _SnowStochasticScale;\n\n\n    half     _WindParticulateSpace;\n    half     _WindParticulateRotation;\n    half      _WindParticulateSpeed;\n    float4     _WindParticulate_ST;\n    half      _WindParticulatePower;\n    half4    _WindParticulateColor;\n    half4    _WindParticulateWorldHeightMask;\n    half4    _WindParticulateAngleMask;\n    half      _WindParticulateOcclusionStrength;\n    half      _WindParticulateStrength;\n    half4    _WindParticulateEmissive;\n    half     _WindParticulateTextureHeight;\n\n\n   float _DoubleSidedNormalMode;\n\n\n\thalf _AutoNormalStrength;\n\n\n\tint _DebugSampleCountThreshold;\n\n\n\thalf _DissolveAmount;\n\thalf _DissolveEmissiveStr;\n\thalf _DissolveEdgeContrast;\n\thalf _DissolveColoration;\n\tfloat4 _DissolveTexture_ST;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n         \n\n         \n\n         \n\n#ifndef __STACKABLEFUNCLIBRARY_INCLUDES__\n#define __STACKABLEFUNCLIBRARY_INCLUDES__\n\n   #if _DEBUG_SAMPLECOUNT\n      int _sampleCount;\n      #define COUNTSAMPLE { _sampleCount++; }\n   #else\n      #define COUNTSAMPLE\n   #endif\n\n   TEXTURE2D(_NoiseTex);\n   SAMPLER(sampler_NoiseTex);\n\n\n\n   half3 AdjustContrast(half3 color, half contrast)\n   {\n       half3 comp = 0.5;\n   #if !UNITY_COLORSPACE_GAMMA\n       comp = 0.22;\n   #endif\n       color = saturate(lerp(comp, color, contrast));\n       return color;\n   }\n\n   float2 DoParallaxOffset( half h, half height, half3 viewDir)\n   {\n      h = h * height - height/2.0;\n      float3 v = normalize(viewDir);\n      v.z += 0.42;\n      return h * (v.xy / v.z);\n   }\n\n\n\n   #define SAMPLEBARY SampleTexBary\n\n   struct SampleConfig\n   {\n      float2 uv0;\n      float2 uv1;\n      float2 uv2;\n      float2 dx0;\n      float2 dy0;\n      float2 dx1;\n      float2 dy1;\n      float2 dx2;\n      float2 dy2;\n      float3 weights;\n      float3 origWeights;\n   };\n\n   struct Config\n   {\n      float2 origUV; // unscaled uv\n      float2 origScale;\n      float2 uv;        // no stocastic or triplanar\n      float2 dx;\n      float2 dy;\n      SampleConfig uvT; // just stochastic, or just triplanar\n      SampleConfig uvX; // stochastic and triplanar\n      SampleConfig uvY;\n      SampleConfig uvZ;\n\n      \n      float3 absVertNormal;\n      half3 axisSign;\n      float3 normal;\n   };\n\n\n    float2 Hash2D( float2 x )\n    {\n        float2 k = float2( 0.3183099, 0.3678794 );\n        x = x*k + k.yx;\n        return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );\n    }\n\n    float Noise2D(float2 p )\n    {\n        float2 i = floor( p );\n        float2 f = frac( p );\n         \n        float2 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), \n                        dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),\n                    lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), \n                        dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);\n    }\n      \n\n    float2 WorleyHash2D(float2 p)\n    {\n \t    return frac(cos(mul(p, float2x2(-64.2,71.3,81.4,-29.8)))*8321.3); \n    }\n    float WorleyNoise2D(float2 p)\n    {\n        float dist = 1;\n        float2 i = floor(p);\n        float2 f = frac(p);\n    \n        for(int x = -1;x<=1;x++)\n        {\n            for(int y = -1;y<=1;y++)\n            {\n                float d = distance(WorleyHash2D(i+float2(x,y))+float2(x,y),f);\n                dist = min(dist,d);\n            }\n        }\n        return dist;\n\t\n    }\n\n#ifndef PI\n    #define PI 3.14159265359\n#endif\n\n    float GetIntegerNoise(float2 p)\n    {\n        p  = 53.7 * frac( (p*0.3183099) + float2(0.71,0.113));\n        return frac( p.x*p.y*(p.x+p.y) );\n    }\n\n    float WorleyHash3D(float f)\n    {\n        return frac(sin(f)*43758.5453);\n    }\n\n    float WorleyHash31(float3 v)\n    {\n        return WorleyHash3D(dot(v, float3(253.14, 453.74, 183.3)));\n    }\n\n    float3 WorleyRandom3D( float3 p )\n    {\n        return frac(sin(float3(dot(p,float3(127.1,311.7,217.3)),dot(p,float3(269.5,183.3,431.1)), dot(p,float3(365.6,749.9,323.7))))*437158.5453);\n    }\n\n    float WorleyNoise3D(float3 uvw)\n    {\n        float noise = 0.0;\n    \n        float3 p = floor(uvw);\n        float3 f = frac(uvw);\n    \n        float4 res = 1;\n        for(int x = -1; x <=1; ++x)\n        {\n            for(int y = -1; y <=1; ++y)\n            {\n                for(int z = -1; z <=1; ++z)\n                {\n                    float3 gp = p + float3(x, y, z);\n\n                    float3 v = WorleyRandom3D(gp);\n\n\t\t\t\t    float3 diff = gp + v - uvw;\n                \n                    float d = length(diff);\n                \n                    if(d < res.x)\n                    {\n                        res.xyz = float3(d, res.x, res.y);\n                    }\n                    else if(d < res.y)\n                    {\n                        res.xyz = float3(res.x, d, res.y);\n                    }\n                    else if(d < res.z)\n                    {\n                        res.z = d;\n                    }\n                \n                    res.w = WorleyHash31(gp);\n                }\n            }\n        }\n\n        return res.x;\n    }\n    \n      \n    float3 Hash3D( float3 p )\n    {\n        p = float3( dot(p,float3(127.1,311.7, 74.7)),\n                dot(p,float3(269.5,183.3,246.1)),\n                dot(p,float3(113.5,271.9,124.6)));\n\n        return -1.0 + 2.0*frac(sin(p)*437.5453123);\n    }\n\n    float Noise3D( float3 p )\n    {\n        float3 i = floor( p );\n        float3 f = frac( p );\n         \n        float3 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),\n                    lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n    }\n\n    \n    float FBM2D(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           return SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n\n    }\n      \n    float FBM3D(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           half A = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.zy).g;\n           half B = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33).g;\n           half C = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoise(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3D(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3D(d.localSpacePosition * frequency+ offset, d.localSpaceNormal);\n        #else\n           return FBM2D(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n    \n    #if _SURFACEGRADIENT  \n\n    #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)\n\n      \n      \n    half3 SurfaceGradientFromTBN(ShaderData d, half2 deriv)\n    {\n        return deriv.x * d.TBNMatrix[0] + deriv.y * d.TBNMatrix[1];\n    }\n\n    half2 TspaceNormalToDerivative(half3 vM)\n    {\n        const half scale = 1.0/128.0;\n        const half3 vMa = abs(vM);\n        const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));\n\n        return -half2(vM.x, vM.y)/z_ma;\n    }\n\n    half3 SurfgradFromVolumeGradient(ShaderData d, half3 grad)\n    {\n        return grad - dot(d.worldSpaceNormal, grad) * d.worldSpaceNormal;\n    }\n\n    half3 SurfgradFromTriplanarProjection(ShaderData d, half3 pN, half3 xN, half3 yN, half3 zN)\n    {\n        const half w0 = pN.x;\n        const half w1 = pN.y;\n        const half w2 = pN.z;\n\n        half2 xD = TspaceNormalToDerivative(xN);\n        half2 yD = TspaceNormalToDerivative(yN);\n        half2 zD = TspaceNormalToDerivative(zN);\n\n        half3 volumeGrad = half3(w2 * zD.x + w1 * yD.y, w2 * zD.y + w0 * xD.y, w0 * xD.x + w1 * yD.x);\n\n        return SurfgradFromVolumeGradient(d, volumeGrad);\n    }\n\n    half3 ConvertNormalToGradient(ShaderData d, half3 normal)\n    {\n        half2 deriv = TspaceNormalToDerivative(normal);\n\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n    half3 ConvertNormal2ToGradient(ShaderData d, half2 packedNormal)\n    {\n        half2 tNormal = packedNormal;\n        half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF\n        half2 deriv = tNormal * -rcpZ;\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n\n    half3 ResolveNormalFromSurfaceGradient(ShaderData d, half3 gradient)\n    {\n        return normalize(d.worldSpaceNormal - gradient);\n    }\n\n    #endif // _SURFACEGRADIENT\n\n\n    // normals are in surface gradient or world space depending on settings, and can also be generated by height\n    half3 GetWorldSpaceNormal(ShaderData d, half3 normal, half pheight)\n    {\n       #if _SURFACEGRADIENT\n          return ResolveNormalFromSurfaceGradient(d, normal);\n       #elif _AUTONORMAL\n          float3 dx = ddx(d.worldSpacePosition);\n          float3 dy = ddy(d.worldSpacePosition);\n          float3 crossX = cross(float3(0,1,0), dx);\n          float3 crossY = cross(float3(0,1,0), dy);\n          float3 dt = abs(dot(crossY, dx));\n          float height = _AutoNormalStrength * 0.5 * pheight;\n          float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n          n.y *= -1.0;\n          return TangentToWorldSpace(d, normalize((dt * float3(0,1,0)) - n).xzy);\n       #else\n          return TangentToWorldSpace(d, normal);\n          \n       #endif\n       \n    }\n\n   void WaterBRDF (inout half3 albedo, inout half smoothness, half metallic, half wetFactor, half surfPorosity) \n   {\n      half porosity = saturate((( (1 - smoothness) - 0.5)) / max(surfPorosity, 0.001));\n      half factor = lerp(1, 0.2, (1 - metallic) * porosity);\n      albedo *= lerp(1.0, factor, wetFactor);\n      smoothness = lerp(smoothness, 0.92f, wetFactor);\n   }\n\n   void OffsetUV(inout Config c, float2 offset)\n   {\n       c.uv += offset;\n       c.uvT.uv0 += offset;\n       c.uvT.uv1 += offset;\n       c.uvT.uv2 += offset;\n       c.uvX.uv0 += offset;\n       c.uvX.uv1 += offset;\n       c.uvX.uv2 += offset;\n       c.uvY.uv0 += offset;\n       c.uvY.uv1 += offset;\n       c.uvY.uv2 += offset;\n       c.uvZ.uv0 += offset;\n       c.uvZ.uv1 += offset;\n       c.uvZ.uv2 += offset;\n   }\n\n\n    void TriangleGrid(float2 uv, float scale,\n       out float w1, out float w2, out float w3,\n       out int2 vertex1, out int2 vertex2, out int2 vertex3)\n    {\n       // Scaling of the input\n       uv *= 3.464 * scale; // 2 * sqrt(3)\n\n       // Skew input space into simplex triangle grid\n       const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);\n       float2 skewedCoord = mul(gridToSkewedGrid, uv);\n\n       // Compute local triangle vertex IDs and local barycentric coordinates\n       int2 baseId = int2(floor(skewedCoord));\n       float3 temp = float3(frac(skewedCoord), 0);\n       temp.z = 1.0 - temp.x - temp.y;\n       if (temp.z > 0.0)\n       {\n          w1 = temp.z;\n          w2 = temp.y;\n          w3 = temp.x;\n          vertex1 = baseId;\n          vertex2 = baseId + int2(0, 1);\n          vertex3 = baseId + int2(1, 0);\n       }\n       else\n       {\n          w1 = -temp.z;\n          w2 = 1.0 - temp.y;\n          w3 = 1.0 - temp.x;\n          vertex1 = baseId + int2(1, 1);\n          vertex2 = baseId + int2(1, 0);\n          vertex3 = baseId + int2(0, 1);\n       }\n    }\n\n    // Fast random hash function\n    float2 SimpleHash2(float2 p)\n    {\n       return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 43758.5453);\n    }\n\n\n    half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)\n    {\n        // compute weight with height map\n        const half epsilon = 1.0f / 1024.0f;\n        half3 weights = half3(iWeights.x * (tex0 + epsilon), \n                                 iWeights.y * (tex1 + epsilon),\n                                 iWeights.z * (tex2 + epsilon));\n\n        // Contrast weights\n        half maxWeight = max(weights.x, max(weights.y, weights.z));\n        half transition = contrast * maxWeight;\n        half threshold = maxWeight - transition;\n        half scale = 1.0f / transition;\n        weights = saturate((weights - threshold) * scale);\n        // Normalize weights.\n        half weightScale = 1.0f / (weights.x + weights.y + weights.z);\n        weights *= weightScale;\n        return weights;\n    }\n\n\n    half3 PackedUnpackScaleNormal(half4 packedNormal, float scale)\n   {\n       #if _PACKEDFAST\n          half3 normal;\n          normal.xy = (packedNormal.ag * 2 - 1) * scale;\n          normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n          return normal;  \n       #endif\n       return UnpackScaleNormal(packedNormal, scale);\n   }\n\n    void InitStochasticDxDy(inout SampleConfig c, Config cfg)\n    {\n      c.dx0 = ddx(cfg.origUV) * cfg.origScale;\n      c.dy0 = ddy(cfg.origUV) * cfg.origScale;\n      c.dx1 = c.dx0; c.dx1 = c.dx0;\n      c.dx2 = c.dy0; c.dy2 = c.dy0;\n    }\n\n    void PrepareStochasticUVs(float scale, float2 uv, out SampleConfig c)\n    {\n       // Get triangle info\n       ZERO_INITIALIZE(SampleConfig, c);\n       float w1, w2, w3;\n       int2 vertex1, vertex2, vertex3;\n       TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n       // Assign random offset to each triangle vertex\n       c.uv0 = uv;\n       c.uv1 = uv;\n       c.uv2 = uv;\n   \n       c.uv0.xy += SimpleHash2(vertex1);\n       c.uv1.xy += SimpleHash2(vertex2);\n       c.uv2.xy += SimpleHash2(vertex3);\n       c.weights = half3(w1, w2, w3);\n       c.origWeights = half3(w1, w2, w3);\n    }\n\n\n   half3 LitBlendDetailNormal(half3 n1, half3 n2)\n   {\n      #if _SURFACEGRADIENT\n         return n1 + n2;\n      #else\n         return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n      #endif\n   }\n\n   float3 TriplanarBlendUnpackedRNM(float3 n1, float3 n2)\n   {\n       n1.z += 1;\n       n2.xy = -n2.xy;\n       return n1 * dot(n1, n2) / n1.z - n2;\n   }\n\n   void InitConfigDxDy(inout Config c)\n   {\n      c.uvT.dx0 = ddx(c.uvT.uv0);\n      c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1);\n      c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2);\n      c.uvT.dy2 = ddy(c.uvT.uv2);\n   }\n\n   Config CreateConfig(ShaderData d, float4 scale, float space, int uvsource, half triplanarContrast)\n   {\n      Config c;\n      ZERO_INITIALIZE(Config, c);\n\n      float3 pos = d.worldSpacePosition;\n      float3 normal = d.worldSpaceNormal;\n      if (space > 0)\n      {\n         pos = d.localSpacePosition;\n         normal = d.localSpaceNormal;\n      }\n\n      c.uv = d.texcoord0.xy;\n      \n      if (uvsource == 1)\n        c.uv = d.texcoord1.xy;\n      else if (uvsource == 2)\n        c.uv = pos.yz * float2(1, -1);\n      else if (uvsource == 3)\n        c.uv = pos.xz * float2(1, -1);\n      else if (uvsource == 4)\n        c.uv = pos.xy * float2(1, -1);\n\n      c.origUV = c.uv;\n      c.origScale = scale.xy;\n\n      c.uv = c.uv * scale.xy + scale.zw;\n      c.dx = ddx(c.uv);\n      c.dy = ddy(c.uv);\n\n      c.normal = normal;\n      c.uvT.uv0 = pos.zy * scale.xy + scale.zw;\n      c.uvT.uv1 = pos.xz * scale.xy + scale.zw;\n      c.uvT.uv2 = pos.xy * scale.xy + scale.zw;\n        \n      c.uvT.uv1 += 0.33;\n      c.uvT.uv2 += 0.67;\n\n      c.uvT.dx0 = ddx(c.uvT.uv0); c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1); c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2); c.uvT.dy2 = ddy(c.uvT.uv2);\n\n      half3 triblend = saturate(pow(abs(c.normal), triplanarContrast));\n      triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n      c.uvT.weights = triblend;\n      c.uvT.origWeights = triblend;\n      c.axisSign = d.worldSpaceNormal < 0 ? -1 : 1;\n      c.absVertNormal = abs(d.worldSpaceNormal);\n     \n\n      return c;\n   }\n\n\n   half4 TriSample(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0) * c.weights.x;\n      }\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1) * c.weights.y;\n      }  \n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2) * c.weights.z;\n      }\n\n      return res;\n   }\n\n   half4 TriSampleBary(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      c.weights = BaryWeightBlend(c.origWeights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   half4 TriSampleGrad(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvX, contrast, d) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvY, contrast, d) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n           res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvZ, contrast, d) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   \n   half4 SampleTexBaryStochastic(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   half4 SampleTexBaryTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleGrad(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   \n   half4 SampleTexBary(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        COUNTSAMPLE\n        return SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv, c.dx, c.dy);\n   }\n\n   half4 SampleTexStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ) * c.uvT.weights.z;\n\n        return res;     \n   }\n\n   \n   half4 SampleTexStochastic(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n\n   half4 SampleTexTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n   \n   half4 SampleTex(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       COUNTSAMPLE\n       return SAMPLE_TEXTURE2D(tex, ss, c.uv);\n   }\n   \n\n \n   half3 SampleNormalStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n         dataX = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n         dataY = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n         dataZ = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ));\n\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n\n          return WorldToTangentSpace(d, worldNormal);\n       #endif\n   }\n\n\n   half3 SampleNormalTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n      {\n          COUNTSAMPLE\n          dataX = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv0, c.uvT.dx0, c.uvT.dy0));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n      {\n          COUNTSAMPLE\n          dataY = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv1, c.uvT.dx1, c.uvT.dy1));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n      {\n         COUNTSAMPLE\n         dataZ = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv2, c.uvT.dx2, c.uvT.dy2));\n      }\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n          return WorldToTangentSpace(d, worldNormal);\n      #endif\n   }\n\n   half3 SampleNormalStochastic(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n     half4 normal = TriSample(tex, ss, c.uvT);\n     #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half3 SampleNormal(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 normal = SAMPLE_TEXTURE2D(tex, ss, c.uv);\n      #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half HeightBlend(half h1, half h2, half slope, half contrast)\n   {\n      h2 = 1 - h2;\n      half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); \n      half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));\n      return blend;\n   }\n\n\n    #if _POM\n    float2 POM(TEXTURE2D_PARAM(tex, ss), Config c, float contrast, ShaderData d)\n    {\n       float2 curv = float2(0, 0);\n       float refPlane = 0;\n\n       float result = 0;\n       int stepIndex = 0;\n       int maxSamples = _POMMaxSamples;\n       int minSamples = 4;\n       float camDist = distance(_WorldSpaceCameraPos, d.worldSpacePosition);\n       float distanceFade = 1 - saturate((camDist - _POMMin) / max(1, _POMFade));\n       int numSteps = ( int )lerp( maxSamples, minSamples, dot( d.worldSpaceNormal, d.worldSpaceViewDir )) * distanceFade;\n       if (numSteps < 1)\n           numSteps = 1;\n       float layerHeight = 1.0 / numSteps;\n       float2 plane = _ParallaxHeight * ( d.tangentSpaceViewDir.xy / d.tangentSpaceViewDir.z ) * distanceFade;\n       OffsetUV(c, refPlane * plane);\n       float2 deltaTex = -plane * layerHeight;\n       float2 prevTexOffset = 0;\n       float prevRayZ = 1.0f;\n       float prevHeight = 0.0f;\n       float2 currTexOffset = deltaTex;\n       float currRayZ = 1.0f - layerHeight;\n       float currHeight = 0.0f;\n       float intersection = 0;\n       float2 finalTexOffset = 0;\n\n       while ( stepIndex < numSteps + 1 )\n       {\n          result = dot( curv, currTexOffset * currTexOffset );\n          Config cfg = c;\n          OffsetUV(cfg, currTexOffset);\n          currHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( currHeight > currRayZ )\n          {\n             stepIndex = numSteps + 1;\n          }\n          else\n          {\n             stepIndex++;\n             prevTexOffset = currTexOffset;\n             prevRayZ = currRayZ;\n             prevHeight = currHeight;\n             currTexOffset += deltaTex;\n             currRayZ -= layerHeight * ( 1 - result );\n          }\n       }\n       int sectionSteps = 10;\n       int sectionIndex = 0;\n       float newZ = 0;\n       float newHeight = 0;\n       while ( sectionIndex < sectionSteps )\n       {\n          intersection = ( prevHeight - prevRayZ ) / ( prevHeight - currHeight + currRayZ - prevRayZ );\n          finalTexOffset = prevTexOffset + intersection * deltaTex;\n          newZ = prevRayZ - intersection * layerHeight;\n          Config cfg = c;\n          OffsetUV(cfg, finalTexOffset);\n          newHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( newHeight > newZ )\n          {\n             currTexOffset = finalTexOffset;\n             currHeight = newHeight;\n             currRayZ = newZ;\n             deltaTex = intersection * deltaTex;\n             layerHeight = intersection * layerHeight;\n          }\n          else\n          {\n             prevTexOffset = finalTexOffset;\n             prevHeight = newHeight;\n             prevRayZ = newZ;\n             deltaTex = ( 1 - intersection ) * deltaTex;\n             layerHeight = ( 1 - intersection ) * layerHeight;\n          }\n          sectionIndex++;\n       }\n       #if _PASSHADOWS\n       if ( unity_LightShadowBias.z == 0.0 )\n       {\n       #endif\n          if ( result > 1 )\n             clip( -1 );\n       #if _PASSHADOWS\n       }\n       #endif\n       return finalTexOffset;\n    }\n    #endif\n\n   \n\n   // tess versions\n   #if _TESSELLATION_ON\n   half4 TriSampleLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias) * c.weights.x;\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias) * c.weights.y;\n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias) * c.weights.z;\n\n      return res;\n   }\n\n   half4 TriSampleBaryLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias, float contrast)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias);\n      half4 r2 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias);\n      half4 r3 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias);\n      c.weights = BaryWeightBlend(c.weights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryLODStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvX, bias, contrast) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvY, bias, contrast) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvZ, bias, contrast) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   half4 SampleTexBaryLODStochastic(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n       return TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias, contrast);\n   }\n\n   half4 SampleTexBaryLODTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return TriSampleLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias);\n   }\n\n   half4 SampleTexBaryLOD(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv, bias);\n   }\n\n\n    float FBM2DLOD(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           return SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv, _TessellationMipBias).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n        \n        \n    }\n\n    float FBM3DLOD(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           half A = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.zy, _TessellationMipBias).g;\n           half B = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33, _TessellationMipBias).g;\n           half C = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67, _TessellationMipBias).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoiseLOD(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3DLOD(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3DLOD(d.localSpacePosition * frequency + offset, d.localSpaceNormal);\n        #else\n           return FBM2DLOD(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n   #endif //_TESSELLATION_ON\n\n\n    half3 FuzzyShade(ShaderData d, half height, half3 color, half3 normal, half coreMult, half edgeMult, half power)\n    {\n        float3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half dt = saturate(dot(d.worldSpaceViewDir, worldNormal));\n        half dark = 1.0 - (coreMult * dt);\n        half edge = pow(1-dt, abs(power)) * edgeMult;\n        return color * (dark + edge);\n    }\n\n\thalf MicroShadow(ShaderData d, half3 normal, half height, half ao, half strength)\n\t{\n        float3 sun;\n\t\tfloat3 sunColor;\n\t\tGetSun(sun, sunColor);\n\t\tfloat3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half shadow = saturate(abs(dot(worldNormal, sun)) + (ao * ao * 2.0) - 1.0);\n        return 1 - ((1-shadow) * strength);\n\t}\n\n\n#endif\n\n\n\n   #if defined(_SPECULAR)\n      #define _USESPECULAR 1\n      #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n   #endif\n\n   \n   TEXTURE2D(_AlbedoMap);\n   SAMPLER(sampler_AlbedoMap);\n   TEXTURE2D(_NormalMap);\n   SAMPLER(sampler_NormalMap);\n   TEXTURE2D(_MaskMap);\n   TEXTURE2D(_DetailMap);\n   TEXTURE2D(_EmissionMap);\n\n   #if _SPECULAR\n       TEXTURE2D(_SpecularMap);\n   #endif\n\n   \n   \n   void Ext_SurfaceFunction0 (inout Surface o, inout ShaderData d)\n   {\n      // define samplers based on settings\n      #undef SAMPLEBARY\n      #undef SAMPLE\n      #undef SAMPLENORMAL\n      #if _STOCHASTIC && _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n        #define SAMPLE     SampleTexStochasticTriplanar\n        #define SAMPLENORMAL SampleNormalStochasticTriplanar\n      #elif _STOCHASTIC\n        #define SAMPLEBARY SampleTexBaryStochastic\n        #define SAMPLE     SampleTexStochastic\n        #define SAMPLENORMAL SampleNormalStochastic\n      #elif _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryTriplanar\n        #define SAMPLE     SampleTexTriplanar\n        #define SAMPLENORMAL SampleNormalTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBary\n        #define SAMPLE     SampleTex\n        #define SAMPLENORMAL SampleNormal\n      #endif\n\n      Config c = CreateConfig(d, _AlbedoMap_ST, _TriplanarSpace, _UVSource, _TriplanarContrast);\n      InitConfigDxDy(c);\n      #if _STOCHASTIC && !_TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uv, c.uvT);\n         InitStochasticDxDy(c.uvT, c);\n      #elif _STOCHASTIC && _TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv0, c.uvX);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv1, c.uvY);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv2, c.uvZ);\n         InitStochasticDxDy(c.uvX, c);\n         InitStochasticDxDy(c.uvY, c);\n         InitStochasticDxDy(c.uvZ, c);\n      #endif\n\n      #if _POM\n          // would need to handle height remapping if we ever want to ship this\n          float2 pomOffset = POM(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n          OffsetUV(c, pomOffset);\n      #endif\n\n      half4 albedo = SAMPLEBARY(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n      \n      #if _PARALLAX\n         float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n         OffsetUV(c, offset);\n         albedo = SAMPLE(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c);\n         \n      #endif\n      albedo.a = lerp(_HeightRemap.x, _HeightRemap.y, albedo.a);\n      albedo.rgb *= _Tint.rgb;\n\n      albedo.rgb = AdjustContrast(albedo.rgb, _AlbedoContrast);\n      albedo.rgb += _AlbedoBrightness;\n\n\n      if (_AlphaThreshold > 0)\n      {\n         clip(albedo.a - _AlphaThreshold);\n      }\n\n      #if defined(_FLATSHADE)\n\t\t     float3 dx = ddx(d.worldSpacePosition);\n\t\t     float3 dy = ddy(d.worldSpacePosition);\n\t\t     float3 worldNormal = normalize(cross(dy, dx));\n\t\t     worldNormal = lerp(d.worldSpaceNormal, worldNormal, _FlatShadingBlend);\n\t\t     d.worldSpaceNormal = worldNormal;\n\t\t     d.TBNMatrix[2] = worldNormal;\n      #endif\n\n\n\n      o.Albedo = albedo.rgb;\n      o.Alpha = albedo.a;\n\n      float smoothness = _Smoothness;\n      float ao = 1;\n\n      #if defined(_NORMALMAP) && !defined(_AUTONORMAL)\n         o.Normal = SAMPLENORMAL(TEXTURE2D_ARGS(_NormalMap, sampler_NormalMap), c, d, _NormalStrength, smoothness, ao);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, ao);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n      #endif\n\n      half detailMask = 1;\n      o.Smoothness = smoothness;\n      o.Occlusion = ao;\n      o.Metallic = _Metallic;\n      #if defined(_MASKMAP) && !_PACKEDFAST\n         // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = SampleTex(TEXTURE2D_ARGS(_MaskMap, sampler_AlbedoMap), c);\n         o.Metallic = lerp(_MetallicRemap.x, _MetallicRemap.y, mask.r);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, mask.g);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, mask.a);\n         detailMask = mask.b;\n      #endif // separate maps\n\n      #if _SPECULAR\n         o.Specular = SAMPLE(TEXTURE2D_ARGS(_SpecularMap, sampler_AlbedoMap), c).rgb;\n      #endif\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = SAMPLE(TEXTURE2D_ARGS(_EmissionMap, sampler_AlbedoMap), c).rgb * _EmissionColor;\n      #endif\n\n      if (_FuzzyShadingOn > 0)\n      {\n        o.Albedo *= FuzzyShade(d, albedo.a, _FuzzyShadingColor, o.Normal, _FuzzyShadingParams.x, _FuzzyShadingParams.y, _FuzzyShadingParams.z);\n      }\n\n\n      // HDRP style detail texturing\n\n      #if defined(_DETAIL)\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _DETAILSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n         Config dc = CreateConfig(d, _DetailMap_ST, _DetailTriplanarSpace, _DetailUVSource, _DetailTriplanarContrast);\n         InitConfigDxDy(dc);\n         #if _DETAILSTOCHASTIC && !_DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uv, dc.uvT);\n             InitStochasticDxDy(dc.uvT, dc);\n         #elif _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv0, dc.uvX);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv1, dc.uvY);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv2, dc.uvZ);\n             InitStochasticDxDy(dc.uvX, dc);\n             InitStochasticDxDy(dc.uvY, dc);\n             InitStochasticDxDy(dc.uvZ, dc);\n         #endif\n\n         half4 detailSample = SAMPLEBARY(TEXTURE2D_ARGS(_DetailMap, sampler_AlbedoMap), dc, _DetailStochasticContrast, d);\n         smoothness = detailSample.z;\n         #if !_AUTONORMAL\n            half3 dnormal = float3(detailSample.ag * 2 - 1, 1) * detailMask * _DetailNormalStrength;\n            dnormal.z = sqrt(1 - dnormal.x * dnormal.x - dnormal.y * dnormal.y);\n            #if _SURFACEGRADIENT\n               dnormal = ConvertNormalToGradient(d, dnormal);\n            #endif\n            o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n         #endif\n     \n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * smoothness, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n      if (_MicroShadowStrength > 0)\n      {\n        o.Occlusion *= MicroShadow(d, o.Normal, o.Alpha, o.Occlusion, _MicroShadowStrength);\n      }\n  \n      // in case something needs height in the stack..\n      o.Height = o.Alpha;\n\n\n      \n   }\n\n\n\n\t#if _TINTMASK\n\t\tTEXTURE2D(_TintMask);\n\t\tSAMPLER(sampler_TintMask);\n\t#endif\n\n\tvoid Ext_SurfaceFunction1 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _TINTMASK\n\t\t   half4 w = SAMPLE_TEXTURE2D(_TintMask, sampler_TintMask, d.texcoord0.xy * _TintMask_ST.xy + _TintMask_ST.zw);\n\t\t   // allow black to be no tint..\n\t\t   half3 tint = o.Albedo * (_RColor.rgb * 2 * w.r + _GColor.rgb * 2 * w.g + _BColor.rgb * 2 * w.b + _AColor.rgb * 2 * w.a);\n\t\t   o.Albedo = lerp(o.Albedo, tint, saturate(w.r + w.g + w.b + w.a));\n\t\t#endif\n\t}\n\n\n\n\n\t#if _LAYERTEXTUREMASK\n       TEXTURE2D(_LayerTextureMask);\n       SAMPLER(sampler_LayerTextureMask); \n    #endif\n\n   void Ext_ModifyTessellatedVertex2 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON\n          float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n\n          #if _LAYERTEXTUREMASK\n               float2 layerUV = v.texcoord0.xy;\n               if (_LayerTextureMaskUVMode == 1)\n                  layerUV = v.texcoord1.xy;\n               else if (_LayerTextureMaskUVMode == 2)\n                  layerUV = worldSpacePosition.yz;\n               else if (_LayerTextureMaskUVMode == 3)\n                  layerUV = worldSpacePosition.xz;\n               else if (_LayerTextureMaskUVMode == 4)\n                  layerUV = worldSpacePosition.xy;\n\n              e.blackboard.weightTextureMask = SAMPLE_TEXTURE2D_LOD(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw, _TessellationMipBias);\n          #endif\n      #endif\n    }\n\n\n\tvoid Ext_SurfaceFunction2 (inout Surface o, inout ShaderData d)\n\t{\n\t\t#if _LAYERTEXTUREMASK\n           float2 layerUV = d.texcoord0.xy;\n           if (_LayerTextureMaskUVMode == 1)\n              layerUV = d.texcoord1.xy;\n           else if (_LayerTextureMaskUVMode == 2)\n              layerUV = d.worldSpacePosition.yz;\n           else if (_LayerTextureMaskUVMode == 3)\n              layerUV = d.worldSpacePosition.xz;\n           else if (_LayerTextureMaskUVMode == 4)\n              layerUV = d.worldSpacePosition.xy;\n\n          d.blackboard.weightTextureMask = SAMPLE_TEXTURE2D(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw);\n      #endif\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap);\n   SAMPLER(sampler_LayerAlbedoMap);\n   TEXTURE2D(_LayerNormalMap);\n   TEXTURE2D(_LayerMaskMap);\n   TEXTURE2D(_LayerEmissionMap);\n\n   \n\n   void Ext_ModifyTessellatedVertex3 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER) && defined(_LAYERALBEDO) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n         half detailMask = 1;\n         #if _LAYERNOISE\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency,  _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin;\n            dt = saturate(dt * _LayerFalloff);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight) * _LayerFalloff);\n            if (_LayerInvertHeight > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength;\n         detailMask *= _LayerTessStrength;\n\n         #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast).a;\n         albedo = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo);\n\n         if (_LayerBlendMode == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction3 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n            // noise up the mask\n            #if _LAYERNOISE\n               mask = DoNoise(d, _LayerNoiseFrequency, _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend);\n\t    \n                dt -= _LayerAngleMin;\n                dt = saturate(dt * _LayerFalloff);\n\n                float hf = saturate((o.Height - _LayerHeight) * _LayerFalloff);\n                if (_LayerInvertHeight > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 0\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 0\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength;\n\n            #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint, 0.5);\n            #if defined(_LAYERALBEDO)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c, _LayerStochasticContrast, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c);\n                #endif\n                albedo.rgb *= _LayerTint;\n                albedo.a = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL || _LAYERMASK\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap, sampler_LayerAlbedoMap, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast);\n            albedo.rgb += _LayerAlbedoBrightness;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap, sampler_LayerAlbedoMap), c, d, _LayerNormalStrength * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO)\n                if (_LayerFuzzyShadingOn > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor.rgb, dnormal,\n                                            _LayerFuzzyShadingParams.x, _LayerFuzzyShadingParams.y, _LayerFuzzyShadingParams.z);\n                }\n\n                if (_LayerBlendMode == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast);\n                else if (_LayerBlendMode == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE\n                      float maskDif = (_LayerBlendContrast * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength);\n                   #if _LAYERNOISE\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap, sampler_LayerAlbedoMap), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength);\n                }\n\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap, sampler_LayerAlbedoMap), c).rgb * _LayerEmissionColor;\n                #if _LAYERALBEDO\n                    if (_LayerBlendMode > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_1);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_1);\n   TEXTURE2D(_LayerNormalMap_Ext_1);\n   TEXTURE2D(_LayerMaskMap_Ext_1);\n   TEXTURE2D(_LayerEmissionMap_Ext_1);\n\n   \n\n   void Ext_ModifyTessellatedVertex4 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_1) && defined(_LAYERALBEDO_DEF_1) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_1\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_1,  _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_1\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_1;\n            dt = saturate(dt * _LayerFalloff_Ext_1);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n            if (_LayerInvertHeight_Ext_1 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_1;\n         detailMask *= _LayerTessStrength_Ext_1;\n\n         #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_1).a;\n         albedo = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo);\n\n         if (_LayerBlendMode_Ext_1 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_1);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_1 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction4 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_1)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_1\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_1, _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_1\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_1);\n\t    \n                dt -= _LayerAngleMin_Ext_1;\n                dt = saturate(dt * _LayerFalloff_Ext_1);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n                if (_LayerInvertHeight_Ext_1 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 01\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 01\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_1;\n\n            #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_1, 0.5);\n            #if defined(_LAYERALBEDO_DEF_1)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, _LayerStochasticContrast_Ext_1, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_1;\n                albedo.a = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_1 || _LAYERMASK_DEF_1\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_1);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_1;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, d, _LayerNormalStrength_Ext_1 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_1)\n                if (_LayerFuzzyShadingOn_Ext_1 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_1.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_1.x, _LayerFuzzyShadingParams_Ext_1.y, _LayerFuzzyShadingParams_Ext_1.z);\n                }\n\n                if (_LayerBlendMode_Ext_1 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_1);\n                else if (_LayerBlendMode_Ext_1 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_1 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_1);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_1\n                      float maskDif = (_LayerBlendContrast_Ext_1 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_1 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                   #if _LAYERNOISE_DEF_1\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_1));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_1 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_1);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_1) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_1 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_1);\n                }\n\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_1);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_1, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_1, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_1\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c).rgb * _LayerEmissionColor_Ext_1;\n                #if _LAYERALBEDO_DEF_1\n                    if (_LayerBlendMode_Ext_1 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_2);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_2);\n   TEXTURE2D(_LayerNormalMap_Ext_2);\n   TEXTURE2D(_LayerMaskMap_Ext_2);\n   TEXTURE2D(_LayerEmissionMap_Ext_2);\n\n   \n\n   void Ext_ModifyTessellatedVertex5 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_2) && defined(_LAYERALBEDO_DEF_2) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_2\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_2,  _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_2\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_2;\n            dt = saturate(dt * _LayerFalloff_Ext_2);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n            if (_LayerInvertHeight_Ext_2 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_2;\n         detailMask *= _LayerTessStrength_Ext_2;\n\n         #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_2).a;\n         albedo = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo);\n\n         if (_LayerBlendMode_Ext_2 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_2);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_2 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction5 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_2)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_2\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_2, _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_2\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_2);\n\t    \n                dt -= _LayerAngleMin_Ext_2;\n                dt = saturate(dt * _LayerFalloff_Ext_2);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n                if (_LayerInvertHeight_Ext_2 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 02\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 02\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_2;\n\n            #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_2, 0.5);\n            #if defined(_LAYERALBEDO_DEF_2)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, _LayerStochasticContrast_Ext_2, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_2;\n                albedo.a = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_2 || _LAYERMASK_DEF_2\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_2);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_2;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, d, _LayerNormalStrength_Ext_2 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_2)\n                if (_LayerFuzzyShadingOn_Ext_2 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_2.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_2.x, _LayerFuzzyShadingParams_Ext_2.y, _LayerFuzzyShadingParams_Ext_2.z);\n                }\n\n                if (_LayerBlendMode_Ext_2 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_2);\n                else if (_LayerBlendMode_Ext_2 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_2 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_2);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_2\n                      float maskDif = (_LayerBlendContrast_Ext_2 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_2 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                   #if _LAYERNOISE_DEF_2\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_2));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_2 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_2);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_2) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_2 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_2);\n                }\n\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_2);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_2, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_2, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_2\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c).rgb * _LayerEmissionColor_Ext_2;\n                #if _LAYERALBEDO_DEF_2\n                    if (_LayerBlendMode_Ext_2 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   #if _TRAX_ON\n   TEXTURE2D(_TraxAlbedo);\n   SAMPLER(sampler_TraxAlbedo);\n   TEXTURE2D(_TraxPackedNormal);\n   TEXTURE2D(_TraxMask);\n\n   sampler2D_float _GMSTraxBuffer;\n\n   float4 _GMSTraxBuffer_TexelSize;\n   float3 _GMSTraxBufferPosition;\n   float _GMSTraxBufferWorldSize;\n   float _GMSTraxFudgeFactor;\n\n   float SampleTraxBufferLOD(float3 worldPos)\n   {    \n      // generate UVs for the buffer, which is moving\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 8);\n      uv *= 0.5;\n      uv += 0.5;\n            \n      float s =  tex2Dlod(_GMSTraxBuffer, float4(uv, 0, 0)).r;\n\n      return 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n   }\n         \n        \n   float SampleTraxBuffer(float3 worldPos, out float3 norm)\n   {\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 3);\n      uv *= 0.5;\n      uv += 0.5;\n            \n\n      float2 offset = _GMSTraxBuffer_TexelSize.xy;\n\n      float s = tex2D(_GMSTraxBuffer, uv).r;\n               \n      float s1 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, -1)).r;\n      float s2 = tex2D(_GMSTraxBuffer, uv + offset * float2(-1, 0)).r;\n      float s3 = tex2D(_GMSTraxBuffer, uv + offset * float2(1, 0)).r;\n      float s4 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, 1)).r;\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      float r = 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n \n      // generate normals\n      norm.x = (s1 - s4) * 0.25; \n      norm.y = (s2 - s3) * 0.25;\n      norm.z = 2;\n      norm = normalize(norm);\n     \n      norm.xy *= 1 - r;\n            \n      return r;\n   }\n   #endif\n\n   void Ext_ModifyTessellatedVertex6 (inout VertexData v, inout ExtraV2F d)\n   {\n       #if _TESSELLATION_ON && _TRAX_ON && _HAS_LIT_TESSELLATION\n          \n           float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n           float3 worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n           float traxBuffer = SampleTraxBufferLOD(worldSpacePosition);\n           d.blackboard.traxBuffer = traxBuffer;\n           float2 uv = worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n           half albedo = SAMPLE_TEXTURE2D_LOD(_TraxAlbedo, sampler_TraxAlbedo, uv, _TraxMipBias).a;\n\n           float traxOffset = albedo * _TraxDisplacementStrength;\n           traxOffset *= 1 - v.texcoord0.z;\n           traxOffset *= _TessellationDisplacement;\n           float dig = _TraxDisplacementDepth * (1 - v.texcoord0.z);\n           float3 traxVertex = d.blackboard.originalVertexPosition + (v.normal * (traxOffset - dig));\n           v.vertex.xyz = lerp(traxVertex, v.vertex.xyz, traxBuffer);\n\n           d.blackboard.vertexHeightOffset = lerp(traxOffset-dig, d.blackboard.vertexHeightOffset, traxBuffer);\n\n       #endif\n\n   }\n\n   void Ext_SurfaceFunction6 (inout Surface o, inout ShaderData d)\n   {\n      #if _TRAX_ON\n        float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n        float2 fsdx = ddx(uv);\n        float2 fsdy = ddy(uv);\n\n        float3 traxNormal;\n        float traxBuffer = SampleTraxBuffer(d.worldSpacePosition, traxNormal);\n        \n        #if _TESSELLATION_ON\n            traxBuffer -= _TraxDisplacementDepth;\n        #endif\n\n        d.blackboard.traxBuffer = traxBuffer;\n\n        UNITY_BRANCH\n        if (traxBuffer > 0)\n        {\n            half4 albedo = SAMPLE_TEXTURE2D_GRAD(_TraxAlbedo, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            albedo.rgb *= _TraxTint.rgb;\n            half4 normalSample = SAMPLE_TEXTURE2D_GRAD(_TraxPackedNormal, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n\n            half smoothness = normalSample.r;\n            half ao = normalSample.b;\n            half3 normal;\n            normal.xy = (normalSample.ag * 2 - 1) * _TraxNormalStrength;\n            normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n\n            \n            half h = HeightBlend(albedo.a, o.Alpha, traxBuffer, _TraxHeightContrast);\n\n            h = lerp(traxBuffer, h, _TraxInterpContrast);\n\n            o.Albedo = lerp(albedo, o.Albedo, h);\n\n            #if _SURFACEGRADIENT\n                o.Normal = lerp(normal, o.Normal, h);\n            #else\n                o.Normal = lerp(normal + traxNormal, o.Normal, h);\n            #endif\n        \n            o.Smoothness = lerp(smoothness, o.Smoothness, h);\n            o.Occlusion = lerp(ao, o.Occlusion, h);\n        }\n      #endif\n   }\n\n\n\n\n    #if _RAINDROPS\n       TEXTURE2D(_RainDropTexture);\n       SAMPLER(sampler_RainDropTexture);\n       half _Global_RainIntensity;\n    #endif\n\n    #if _WETNESS\n       half2 _Global_WetnessParams; // global, not in cbuffer\n    #endif\n   \n    #if _RAINDROPS\n    half2 ComputeRipple(float2 uv, half time, half weight)\n    {\n        half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_RainDropTexture, uv);\n        COUNTSAMPLE\n        ripple.yz = ripple.yz * 2 - 1;\n\n        half dropFrac = frac(ripple.w + time);\n        half timeFrac = dropFrac - 1.0 + ripple.x;\n        half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);\n        half finalFactor = dropFactor * ripple.x * \n                                sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);\n\n        return half2(ripple.yz * finalFactor);\n    }\n    #endif\n\n    half2 DoRain(half2 waterNorm, float2 uv, out half2 ripple)\n    {\n        #if _RAINDROPS\n            float rainIntensity = _RainIntensityScale.x;\n            if (_RainMode > 1)\n            {\n                rainIntensity = _Global_RainIntensity;\n            }\n\n            half dropStrength = rainIntensity;\n            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); \n            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);\n            half4 times = _Time.yyyy;\n            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);\n\n            float2 ruv1 = uv * _RainIntensityScale.yy;\n            float2 ruv2 = ruv1;\n\n            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);\n            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);\n            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);\n            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);\n            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);\n            weights = saturate(weights * 4);\n\n            half2 rippleNormal = half2( weights.x * ripple1.xy +\n                        weights.y * ripple2.xy + \n                        weights.z * ripple3.xy + \n                        weights.w * ripple4.xy);\n\n            ripple = rippleNormal * dropStrength * rainIntensity;\n            waterNorm = lerp(waterNorm, normalize(half3(rippleNormal.xy + rippleNormal.xy, 1)).xy, rainIntensity * dropStrength); \n            return waterNorm;                        \n        #else\n            return waterNorm;\n        #endif\n    }\n\n   half2 _Global_PuddleParams;   // this is a global, so keep it out of the cbuffer\n   void GetPuddleParams(ShaderData d, inout float puddleMask, inout float pudHeight)\n   {\n      #if _PUDDLES || _GLOBALPUDDLES\n          pudHeight = _PuddleAmount;\n          if (_PuddleMode > 0)\n             pudHeight = _Global_PuddleParams.x;    \n      \n\n          half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t      dt -= _PuddleAngleMin;\n          dt = saturate(dt * _PuddleFalloff);\n          puddleMask *= dt;\n      #endif\n   }\n   \n   void Ext_ModifyTessellatedVertex7 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _PUDDLES && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n         half mask = 1;\n         half pudHeight = 1;\n\n         // save some ops by doing this in 2d\n         #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2DLOD(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2DLOD(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #else\n                mask = (FBM2DLOD(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n         #endif\n\n         GetPuddleParams(d, mask, pudHeight);\n         float height = pudHeight * mask;\n         if (e.blackboard.vertexHeightOffset < height)\n         {\n            e.blackboard.vertexHeightOffset = height;\n            height -= _TessellationOffset; \n            // dampen cracks\n            height *= 1 - v.texcoord0.z;\n            height *= _TessellationDisplacement;\n            v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n            \n        }\n      #endif\n   }\n\n\n#if _WETNESS\n\n   float GetWetnessLevel(Surface o, ShaderData d, float wetnessMask)\n   {\n      float wetLevel = clamp(_WetnessAmount, _WetnessMin, _WetnessMax);\n      \n      if (_WetnessMode > 0)\n         wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);\n\n      wetLevel = saturate(wetLevel + (1 - saturate(d.worldSpacePosition.y - _WetnessShoreline)));\n      float3x3 tbn = float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal);\n      float dt = dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0));\n      dt -= _WetnessAngleMin;\n      dt = saturate(dt * _WetnessFalloff * wetLevel);\n      dt *= wetnessMask;\n      return dt;\n   }\n#endif\n   \n\n   void Ext_SurfaceFunction7 (inout Surface o, ShaderData d)\n   {\n      half wetnessLevel = 0;\n      #if _WETNESS\n          wetnessLevel = GetWetnessLevel(o, d, 1); // mask one day?\n      #endif\n\n      half depthMask = 0;\n      half depth = 0;\n\n      #if _PUDDLES\n          half mask = 1;\n          half pudHeight = 1;\n          #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2D(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2D(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);      \n            #else\n                mask = (FBM2D(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n          #endif\n\n          GetPuddleParams(d, mask, pudHeight);\n          pudHeight *= mask;\n          depth = pudHeight - o.Height;\n          depthMask = saturate(depth * _PuddleFalloff);\n          depthMask *= _PuddleColor.a;\n          depth = o.Height - pudHeight;\n\n          // extend wetness slighting higher than the puddle\n          half wetmask = saturate((pudHeight + 0.05 - o.Height) * _PuddleFalloff);\n          wetnessLevel = max(wetmask, wetnessLevel);\n       #endif\n\n       \n       #if _WETNESS || _PUDDLES\n          half3 waterNorm = half3(0,0,1);\n          half3 wetAlbedo = o.Albedo;\n          half wetSmoothness = o.Smoothness;\n          #if _PUDDLES\n             wetAlbedo *= _PuddleColor.rgb;\n          #endif\n          WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetnessLevel, _Porosity);\n\n          half ri = 0;\n          half2 ripple = 0;\n          #if (_RAINDROPS || _GLOBALRAIN) && (_PUDDLES || _GLOBALPUDDLES)\n             ri = _RainIntensityScale.z;\n             waterNorm.xy = DoRain(waterNorm.xy, d.texcoord0.xy, ripple) * depthMask;\n          #endif\n\n          o.Normal = lerp(o.Normal, waterNorm, depthMask);\n          o.Normal = lerp(o.Normal, LitBlendDetailNormal(o.Normal, half3(ripple.xy, 1)), saturate(ri - depthMask) * wetnessLevel);\n          o.Occlusion = lerp(o.Occlusion, 1, depthMask);\n          o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetnessLevel);\n          o.Albedo = lerp(o.Albedo, wetAlbedo, wetnessLevel);\n          o.Emission *= 1 + depth;\n          o.Metallic *= 1 + depth;\n          o.Specular *= 1 + depth;\n\n       #endif\n\n   }\n\n\n\n\n    #if _SNOW\n       TEXTURE2D(_SnowAlbedo);\n       SAMPLER(sampler_SnowAlbedo);\n       TEXTURE2D(_SnowNormal);\n       TEXTURE2D(_SnowMaskMap);\n       #if _TRAX_ON\n          TEXTURE2D(_SnowTraxAlbedo);\n          TEXTURE2D(_SnowTraxNormal);\n          TEXTURE2D(_SnowTraxMaskMap);\n       #endif\n    #endif\n\n   float _Global_SnowLevel;\n\n\n   void Ext_ModifyVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n    #if (_SNOW)\n        float amount = _SnowAmount;\n        if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n        float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n        float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n        snowAmount -= _SnowAngle;\n        snowAmount *= _SnowContrast * 0.5;\n        snowAmount = saturate(snowAmount) * amount;\n        float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n        if (_SnowWorldFade.z > 0)\n        {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n        }\n        #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n        #endif\n        snowAmount = saturate(snowAmount);\n\n        #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n        #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n        #endif\n\n        float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n        v.vertex.xyz = v.vertex.xyz + displacementVec * snowAmount * snowAmount * _SnowVertexHeight;\n    #endif\n   }\n\n   void Ext_ModifyTessellatedVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _SNOW && _HAS_LIT_TESSELLATION\n         float amount = _SnowAmount;\n         if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n         float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n         float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n         snowAmount -= _SnowAngle;\n         snowAmount *= _SnowContrast * 0.5;\n         float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n         if (_SnowWorldFade.z > 0)\n         {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n         }\n\n         snowAmount = saturate(snowAmount) * amount;\n\n         #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n         #endif\n         snowAmount = saturate(snowAmount);\n\n         #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n         #endif\n\n         float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n         half heightMap = SAMPLE_TEXTURE2D_LOD(_SnowAlbedo, sampler_SnowAlbedo, worldPos.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw, 2);\n\n         float height = max(_SnowVertexHeight * 3 * snowAmount + snowAmount * heightMap, e.blackboard.vertexHeightOffset);\n         #if _TRAX_ON\n            height *= e.blackboard.traxBuffer;\n         #endif\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n\n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n         \n      #endif\n\n   }\n\n   void SampleSnowSurface(TEXTURE2D_PARAM(alb, ss), TEXTURE2D_PARAM(norm, ss2), TEXTURE2D_PARAM(mask, ss3),\n        ShaderData d, float2 uv, float2 dx, float2 dy, out half4 albedo, out half3 normal, out half2 smoothAO)\n   {\n      #if _SNOWSTOCHASTIC\n         float w1, w2, w3;\n         int2 vertex1, vertex2, vertex3;\n         TriangleGrid(uv, _SnowStochasticScale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n         // Assign random offset to each triangle vertex\n         float2 uv0 = uv;\n         float2 uv1 = uv;\n         float2 uv2 = uv;\n   \n         uv0.xy += SimpleHash2(vertex1);\n         uv1.xy += SimpleHash2(vertex2);\n         uv2.xy += SimpleHash2(vertex3);\n         half3 weights = half3(w1, w2, w3);\n\n         half4 albedo0 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv0, dx, dy);\n         half4 albedo1 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv1, dx, dy);\n         half4 albedo2 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv2, dx, dy);\n         COUNTSAMPLE\n         COUNTSAMPLE\n         COUNTSAMPLE\n         weights = BaryWeightBlend(weights, albedo0.a, albedo1.a, albedo2.a, _SnowStochasticContrast);\n         albedo = albedo0 * weights.x + albedo1 * weights.y + albedo2 * weights.z;\n\n         normal = half3(0,0,1);\n         smoothAO = half2(0, 1);\n\n         #if !_AUTONORMAL\n            half4 n0 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv0, dx, dy);\n            half4 n1 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv1, dx, dy);\n            half4 n2 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n            half4 snowNormSamp = n0 * weights.x + n1 * weights.y + n2 * weights.z;\n\n            normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n                \n            #if _PACKEDFAST\n               smoothAO.x = snowNormSamp.r;\n               smoothAO.y = snowNormSamp.b;\n            #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask0 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv0, dx, dy);\n            half4 snowMask1 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv1, dx, dy);\n            half4 snowMask2 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n            half4 snowMask = snowMask0 * weights.x + snowMask1 * weights.y + snowMask2 * weights.z;\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n      #else // not stochastic\n          albedo = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv, dx, dy);\n          COUNTSAMPLE\n\n          normal = half3(0,0,1);\n          smoothAO = half2(0, 1);\n\n          #if !_AUTONORMAL\n             half4 snowNormSamp = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv, dx, dy);\n             COUNTSAMPLE\n             normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n             #if _SURFACEGRADIENT\n                normal = ConvertNormalToGradient(d, normal);\n             #endif\n                 \n             #if _PACKEDFAST\n                smoothAO.x = snowNormSamp.r;\n                smoothAO.y = snowNormSamp.b;\n             #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv, dx, dy);\n            COUNTSAMPLE\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n     #endif // stochastic\n   }\n\n   \n   void Ext_SurfaceFunction8 (inout Surface o, ShaderData d)\n   {\n      #if _SNOW\n          float amount = _SnowAmount;\n          if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n          float snowAmount = lerp(dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), dot(d.worldSpaceNormal, float3(0,1,0)), amount * 0.8) + 1;\n          snowAmount -= _SnowAngle;\n          snowAmount *= _SnowContrast;\n          snowAmount = saturate(snowAmount) - (1-amount) * (1-amount);\n\n          if (_SnowWorldFade.z > 0)\n          {\n             float worldFade = saturate((d.worldSpacePosition.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n             snowAmount *= worldFade;\n          }\n\n          #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(d.worldSpacePosition.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n          #endif\n          snowAmount = saturate(snowAmount);\n\n          float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw;\n          float2 dx = ddx(uv);\n          float2 dy = ddy(uv);\n\n          #if _TRAX_ON\n              float2 tuv = d.worldSpacePosition.xz * float2(1, -1) * _SnowTraxAlbedo_ST.xy + _SnowTraxAlbedo_ST.zw;\n              float2 tdx = ddx(uv);\n              float2 tdy = ddy(uv);\n          #endif\n\n          #if _LAYERVERTEXMASK\n              snowAmount *= d.vertexColor.a;\n          #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n              snowAmount *= d.blackboard.weightTextureMask.a;\n          #endif\n\n          UNITY_BRANCH\n          if (snowAmount > 0)\n          {\n             half4 snowAlbedo;\n             half3 snowNormal;\n             half2 snowSmoothAO;\n             SampleSnowSurface(TEXTURE2D_ARGS(_SnowAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowNormal, sampler_SnowAlbedo),\n                    TEXTURE2D_ARGS(_SnowMaskMap, sampler_SnowAlbedo), d, uv, dx, dy, snowAlbedo, snowNormal, snowSmoothAO);\n\n             snowAlbedo.rgb *= _SnowTint.rgb;\n\n             #if _TRAX_ON\n                half traxBuffer = 1 - d.blackboard.traxBuffer;\n                UNITY_BRANCH\n                if (traxBuffer > 0)\n                {\n                    half4 tsnowAlbedo;\n                    half3 tsnowNormal;\n                    half2 tsnowSmoothAO;\n                    SampleSnowSurface(TEXTURE2D_ARGS(_SnowTraxAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowTraxNormal, sampler_SnowAlbedo),\n                        TEXTURE2D_ARGS(_SnowTraxMaskMap, sampler_SnowAlbedo), d, tuv, tdx, tdy, tsnowAlbedo, tsnowNormal, tsnowSmoothAO);\n\n                    tsnowAlbedo.rgb *= _SnowTraxTint;\n                    half h = HeightBlend(snowAlbedo.a, tsnowAlbedo.a, traxBuffer, 0.5);\n                    snowAlbedo = lerp(snowAlbedo, tsnowAlbedo, h);\n                    snowNormal = lerp(snowNormal, tsnowNormal, h);\n                    snowSmoothAO = lerp(snowSmoothAO, tsnowSmoothAO, h);\n                }\n             #endif\n\n             #if !_AUTONORMAL\n                o.Normal = lerp(o.Normal, snowNormal, snowAmount);\n             #endif\n             o.Albedo = lerp(o.Albedo, snowAlbedo.rgb, snowAmount);\n             o.Alpha = lerp(o.Alpha, snowAlbedo.a, snowAmount);\n             o.Smoothness = lerp(o.Smoothness, snowSmoothAO.x, snowAmount);\n             o.Occlusion = lerp(o.Occlusion, snowSmoothAO.y, snowAmount);\n             o.Height = o.Alpha;\n\n          }\n      #endif\n   }\n\n   \n\n\n\n\n\n   TEXTURE2D(_WindParticulate);\n   SAMPLER(sampler_WindParticulate);\n\n// In case we want to read it more than once..\n\n#ifndef __STACKABLE_WIND_INCLUDES__\n#define __STACKABLE_WIND_INCLUDES__\n\n\n   half FilterRange(float4 range, float y)\n   {\n      half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));\n      w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));\n      return w;\n   }\n\n   \n   float2 RotateUV(float2 uv, float amt)\n   {\n      uv -=0.5;\n      float s = sin ( amt);\n      float c = cos ( amt );\n      float2x2 mtx = float2x2( c, -s, s, c);\n      mtx *= 0.5;\n      mtx += 0.5;\n      mtx = mtx * 2-1;\n      uv = mul ( uv, mtx );\n      uv += 0.5;\n      return uv;\n   }\n\n\n   half FilterWindParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)\n   {\n      float2 windDir = RotateUV(float2(1, 0), windRot);\n      float2 flow = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));\n      float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill\n      return FilterRange(range, cofacing);\n   }\n\n   fixed ProcessWindParticulateMask(inout fixed mask, float contrast)\n   {\n      mask = pow(abs(mask), abs(contrast));\n      fixed invMask = 1.0 - mask;\n      invMask *= invMask; \n      invMask *= invMask;\n      return invMask;\n   }\n#endif // include guard\n\n   void Ext_SurfaceFunction9 (inout Surface o, ShaderData d)\n   {\n      #if _WIND_ON && !_PASSMETA\n   \n         float3 upVector = float3(0,0,1);\n\n         half upDot = max(0.0, dot(d.worldSpaceNormal, float3(0, 1, 0)));\n\n         float2 uv = d.worldSpacePosition.xz;\n         if (_WindParticulateSpace > 0.5)\n            uv = d.texcoord0.xy;\n         float windRotation = _WindParticulateRotation;\n         float windStrength = _WindParticulateStrength;\n\n         float2 wuv = RotateUV(uv, windRotation);\n\n         half windBlend = 1.0;\n\n         float windWorldMask = FilterRange(_WindParticulateWorldHeightMask, d.worldSpacePosition.y);\n         windWorldMask *= FilterRange(_WindParticulateAngleMask, upDot);\n\n         // compute mask\n         wuv *= float2(_WindParticulate_ST.x, 1) * _WindParticulate_ST.y + _WindParticulate_ST.zw;\n         float speed = _Time.x * _WindParticulateSpeed;\n         half w1 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv * 3 + speed * float2(1,0)).g;\n         half w2 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv + speed * float2(1.1,0)).a;\n         half windMask = (w1 * w2);\n\n         windMask *= windStrength * windBlend * windWorldMask;\n         windMask *= saturate((_WindParticulateTextureHeight - o.Height) * 10);\n\n         half windInvMask = ProcessWindParticulateMask(windMask, _WindParticulatePower);\n    \n         o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);\n         o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindParticulateEmissive.rgb;\n         o.Normal.xy *= windInvMask;\n         o.Smoothness *= windInvMask;\n         o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;\n         o.Metallic *= windInvMask;\n      #endif\n\n   }\n\n\n\n\n\tvoid Ext_SurfaceFunction10 (inout Surface o, ShaderData d)\n\t{\n        if (_DoubleSidedNormalMode == 0)\n        {\n           o.Normal *= d.isFrontFace ? 1 : -1;\n        }\n        else if (_DoubleSidedNormalMode == 1)\n        {\n\t\t   o.Normal.z *= d.isFrontFace ? 1 : -1;\n        }\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction11 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _SURFACEGRADIENT\n\t\t\to.Normal = ResolveNormalFromSurfaceGradient(d, o.Normal);\n\t    #elif _AUTONORMAL\n\t        float3 dx = ddx(d.worldSpacePosition);\n\t\t\tfloat3 dy = ddy(d.worldSpacePosition);\n\t\t\tfloat3 crossX = cross(float3(0,1,0), dx);\n\t\t\tfloat3 crossY = cross(float3(0,1,0), dy);\n\t\t\tfloat3 dt = abs(dot(crossY, dx));\n\t\t\tfloat height = _AutoNormalStrength * 0.5 * o.Alpha;\n\t\t\tfloat3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n\t\t\tn.y *= -1.0;\n\t\t\to.Normal = normalize((dt * float3(0,1,0)) - n).xzy;\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#else\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#endif\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction12 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DEBUG_SAMPLECOUNT\n\t\t\tif (_sampleCount > _DebugSampleCountThreshold)\n\t\t\t{\n\t\t\t\to.Albedo.r = 1;\n\t\t\t\to.Albedo.gb *= 0.2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\to.Albedo.b = 1;\n\t\t\t}\n\n        #endif\n\t}\n\n\n\n\n\tSAMPLER(sampler_DissolveTexture);\n\tTEXTURE2D(_DissolveTexture);\n\tTEXTURE2D(_DissolveGradient);\n\n\tvoid Ext_SurfaceFunction13 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DISSOLVE\n\t\tfloat2 uv = d.texcoord0.xy * _DissolveTexture_ST.xy + _DissolveTexture_ST.zw;\n\t\tfloat2 dx = ddx(uv);\n\t\tfloat2 dy = ddy(uv);\n\n\t\tUNITY_BRANCH\n\t\tif (_DissolveAmount > 0)\n\t\t{\n\t\t\thalf dissolve = SAMPLE_TEXTURE2D_GRAD(_DissolveTexture, sampler_DissolveTexture, uv, dx, dy).g;\n\t\t\thalf cp =  saturate(_DissolveAmount - (dissolve - _DissolveAmount) * _DissolveEdgeContrast) + _DissolveAmount;\n\t\t\thalf cp2 = saturate(1.0 - abs((dissolve - _DissolveAmount) * _DissolveEdgeContrast));\n\t\t\tclip(1.0 - cp);\n\t\t\tfloat2 fuv = float2(cp2, 0.5);\n\t\t\thalf3 col = SAMPLE_TEXTURE2D_LOD(_DissolveGradient, sampler_DissolveTexture, fuv, 0).rgb;\n\t\t\t\t\n\t\t\to.Albedo = lerp(o.Albedo, col, _DissolveColoration * cp2);\n\t\t\to.Emission = lerp(o.Emission, col * _DissolveEmissiveStr, _DissolveColoration * cp2);\n\t\t}\n\t\t#endif\n\t}\n\n\n\n\n    float Dither8x8Bayer( int x, int y )\n    {\n        const float dither[ 64 ] = {\n                1, 49, 13, 61,  4, 52, 16, 64,\n            33, 17, 45, 29, 36, 20, 48, 32,\n                9, 57,  5, 53, 12, 60,  8, 56,\n            41, 25, 37, 21, 44, 28, 40, 24,\n                3, 51, 15, 63,  2, 50, 14, 62,\n            35, 19, 47, 31, 34, 18, 46, 30,\n            11, 59,  7, 55, 10, 58,  6, 54,\n            43, 27, 39, 23, 42, 26, 38, 22};\n        int r = y * 8 + x;\n        return dither[r] / 64; \n    }\n\n    void ApplyDitherCrossFadeVSP(float2 vpos, float fadeValue)\n    {\n        float dither = Dither8x8Bayer( fmod(vpos.x, 8), fmod(vpos.y, 8) );\n        float sgn = fadeValue > 0 ? 1.0f : -1.0f;\n        clip(dither - (1-fadeValue) * sgn);\n    }\n    \n\n\tvoid Ext_SurfaceFunction14 (inout Surface o, ShaderData d)\n\t{\n\t\t#if LOD_FADE_CROSSFADE\n            float4 screenPosNorm = d.screenPos / d.screenPos.w;\n            screenPosNorm.z = ( UNITY_NEAR_CLIP_VALUE >= 0 ) ? screenPosNorm.z : screenPosNorm.z * 0.5 + 0.5;\n            float2 clipScreen = screenPosNorm.xy * _ScreenParams.xy;\n            ApplyDitherCrossFadeVSP(clipScreen,unity_LODFade.x);\n        #endif\n\t}\n\n\n\n\n\n\n// declare outside of CBuffer\n\nfloat4x4 _GlobalVolumeMatrix;\nfloat4x4 _VolumeMatrix;\nfloat3 _VolumeMin;\nfloat3 _VolumeInvSize;\nfloat3 _GlobalVolumeMin;\nfloat3 _GlobalVolumeInvSize;\n\n// I inlined a section of your include. You can use includes in better shaders, but doing it via a subshader or this way\n// is much better. The reason is that this allows your shader to be all inclusive, and packed up for asset store distribition,\n// without requiring specific paths to other files, etc.\n//\n\n#ifndef BAKERY_INCLUDED\n#define BAKERY_INCLUDED\n\n#define BAKERYMODE_DEFAULT 0\n#define BAKERYMODE_VERTEXLM 1.0f\n#define BAKERYMODE_RNM 2.0f\n#define BAKERYMODE_SH 3.0f\n\n\n// can't fit vertexLM SH to sm3_0 interpolators\n#ifndef SHADER_API_D3D11\n    #undef _LIGHTMAPMODE_VERTEXSH\n#endif\n\n// can't do stuff on sm2_0 due to standard shader alrady taking up all instructions\n#if SHADER_TARGET < 30\n    #undef BAKERY_BICUBIC\n    #undef BAKERY_LMSPEC\n\n    #undef _LIGHTMAPMODE_RNM\n    #undef _LIGHTMAPMODE_SH\n    #undef _LIGHTMAPMODE_VERTEX\n#endif\n\n#define lumaConv float3(0.2125f, 0.7154f, 0.0721f)\n\n#ifdef BAKERY_VOLUME\n    #ifdef BAKERY_COMPRESSED_VOLUME\n        Texture3D _Volume3;\n    #endif\n#endif\n\n\nhalf3 LinearToGamma (half3 linRGB)\n{\n    linRGB = max(linRGB, half3(0.h, 0.h, 0.h));\n    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n    return max(1.055h * pow(linRGB, 0.416666667h) - 0.055h, 0.h);\n}\n\nfloat shEvaluateDiffuseL1Geomerics(float L0, float3 L1, float3 n)\n{\n    // average energy\n    float R0 = L0;\n\n    // avg direction of incoming light\n    float3 R1 = 0.5f * L1;\n\n    // directional brightness\n    float lenR1 = length(R1);\n\n    // linear angle between normal and direction 0-1\n    //float q = 0.5f * (1.0f + dot(R1 / lenR1, n));\n    //float q = dot(R1 / lenR1, n) * 0.5 + 0.5;\n    float q = dot(normalize(R1), n) * 0.5 + 0.5;\n\n    // power for q\n    // lerps from 1 (linear) to 3 (cubic) based on directionality\n    float p = 1.0f + 2.0f * lenR1 / R0;\n\n    // dynamic range constant\n    // should vary between 4 (highly directional) and 0 (ambient)\n    float a = (1.0f - lenR1 / R0) / (1.0f + lenR1 / R0);\n\n    return R0 * (a + (1.0f - a) * (p + 1.0f) * pow(q, p));\n}\n\n#ifdef BAKERY_VERTEXLMMASK\n    float4 unpack4NFloats(float src)\n\t{\n        //return fmod(float4(src / 262144.0, src / 4096.0, src / 64.0, src), 64.0)/64.0;\n        return frac(float4(src / (262144.0*64), src / (4096.0*64), src / (64.0*64), src));\n    }\n#endif\n\n#if defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n    float3 unpack3NFloats(float src)\n\t{\n        float r = frac(src);\n        float g = frac(src * 256.0);\n        float b = frac(src * 65536.0);\n        return float3(r, g, b);\n    }\n#endif\n\n// Unity defines these under different names in each SRP, so use our own\ninline float3 Bakery_SafeNormalize(float3 inVec)\n{\n    float dp3 = max(0.001f, dot(inVec, inVec));\n    return inVec * rsqrt(dp3);\n}\n\n#if _URP || _HDRP\n\nfloat SmoothnessToPerceptualRoughness(float smoothness)\n{\n    return (1 - smoothness);\n}\n#endif\n\n#if !_STANDARD\nhalf4 unity_Lightmap_HDR;\ninline half3 DecodeLightmap( fixed4 color )\n{\n    return DecodeLightmap( color, unity_Lightmap_HDR );\n}\n\n#define UNITY_INV_PI        0.31830988618f\ninline float GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return UNITY_INV_PI * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n    void BakeryVertexLMDirection(inout float3 diffuseColor, inout float3 specularColor, float3 lightDirection, float3 vertexNormalWorld, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 dominantDir = Bakery_SafeNormalize(lightDirection);\n        half halfLambert = dot(normalWorld, dominantDir) * 0.5 + 0.5;\n        half flatNormalHalfLambert = dot(vertexNormalWorld, dominantDir) * 0.5 + 0.5;\n\n        #ifdef BAKERY_LMSPEC\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = spec * diffuseColor;\n        #endif\n\n        diffuseColor *= halfLambert / max(1e-4h, flatNormalHalfLambert);\n    }\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXSH\n    void BakeryVertexLMSH(inout float3 diffuseColor, inout float3 specularColor, float3 shL1x, float3 shL1y, float3 shL1z, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 L0 = diffuseColor;\n        float3 nL1x = shL1x;\n        float3 nL1y = shL1y;\n        float3 nL1z = shL1z;\n        float3 L1x = nL1x * L0 * 2;\n        float3 L1y = nL1y * L0 * 2;\n        float3 L1z = nL1z * L0 * 2;\n\n        float3 sh;\n    #if BAKERY_SHNONLINEAR\n        //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n        //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n        //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n        float lumaL0 = dot(L0, 1);\n        float lumaL1x = dot(L1x, 1);\n        float lumaL1y = dot(L1y, 1);\n        float lumaL1z = dot(L1z, 1);\n        float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n        float regularLumaSH = dot(sh, 1);\n        //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n        sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    #else\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    #endif\n\n        diffuseColor = max(sh, 0.0);\n\n        #ifdef BAKERY_LMSPEC\n            float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n            float focus = saturate(length(dominantDir));\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = max(spec * sh, 0.0);\n        #endif\n    }\n#endif\n\n\n\n#ifdef BAKERY_BICUBIC\nfloat BakeryBicubic_w0(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-a + 3.0f) - 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w1(float a)\n{\n    return (1.0f/6.0f)*(a*a*(3.0f*a - 6.0f) + 4.0f);\n}\n\nfloat BakeryBicubic_w2(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-3.0f*a + 3.0f) + 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w3(float a)\n{\n    return (1.0f/6.0f)*(a*a*a);\n}\n\nfloat BakeryBicubic_g0(float a)\n{\n    return BakeryBicubic_w0(a) + BakeryBicubic_w1(a);\n}\n\nfloat BakeryBicubic_g1(float a)\n{\n    return BakeryBicubic_w2(a) + BakeryBicubic_w3(a);\n}\n\nfloat BakeryBicubic_h0(float a)\n{\n    return -1.0f + BakeryBicubic_w1(a) / (BakeryBicubic_w0(a) + BakeryBicubic_w1(a)) + 0.5f;\n}\n\nfloat BakeryBicubic_h1(float a)\n{\n    return 1.0f + BakeryBicubic_w3(a) / (BakeryBicubic_w2(a) + BakeryBicubic_w3(a)) + 0.5f;\n}\n#endif\n\n\n#if defined(_LIGHTMAPMODE_RNM) || defined(_LIGHTMAPMODE_SH)\nTexture2D _RNM0, _RNM1, _RNM2;\n#endif\n\n#ifdef BAKERY_VOLUME\nTexture3D _Volume0, _Volume1, _Volume2, _VolumeMask;\nSamplerState sampler_Volume0;\n#endif\n\n#if defined(BAKERY_BICUBIC) && defined(LIGHTMAP_ON) && defined(SHADER_API_D3D11)\n    // Bicubic\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\tfloat width, height;\n\t\ttex.GetDimensions(width, height);\n\t\tfloat texelSize = 1.0f / width;\n\n        float x = uv.x * width;\n        float y = uv.y * width;\n\n        x -= 0.5f;\n        y -= 0.5f;\n\n        float px = floor(x);\n        float py = floor(y);\n\n        float fx = x - px;\n        float fy = y - py;\n\n        float g0x = BakeryBicubic_g0(fx);\n        float g1x = BakeryBicubic_g1(fx);\n        float h0x = BakeryBicubic_h0(fx);\n        float h1x = BakeryBicubic_h1(fx);\n        float h0y = BakeryBicubic_h0(fy);\n        float h1y = BakeryBicubic_h1(fy);\n\n        return     BakeryBicubic_g0(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h0y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h0y) * texelSize))) +\n\n                   BakeryBicubic_g1(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h1y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h1y) * texelSize)));\n    }\n#else\n    // Bilinear\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\t#ifdef LIGHTMAP_ON\n\t\t\treturn tex.Sample(samplerunity_Lightmap, uv);\n\t\t#else\n\t\t\treturn float4(1,0,0,1);\n\t\t#endif\n    }\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\n#ifdef BAKERY_LMSPEC\nfloat BakeryDirectionalLightmapSpecular(float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 dominantDir = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap, lmUV).xyz * 2 - 1;\n    half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n    half nh = saturate(dot(normalWorld, halfDir));\n    half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n    half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n    half spec = GGXTerm(nh, roughness);\n    return spec;\n}\n#endif\n#endif\n\n\n\n#ifdef _LIGHTMAPMODE_RNM\nvoid BakeryRNM(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalMap, float smoothness, float3 viewDirT)\n{\n    const float3 rnmBasis0 = float3(0.816496580927726f, 0, 0.5773502691896258f);\n    const float3 rnmBasis1 = float3(-0.4082482904638631f, 0.7071067811865475f, 0.5773502691896258f);\n    const float3 rnmBasis2 = float3(-0.4082482904638631f, -0.7071067811865475f, 0.5773502691896258f);\n\n    float3 rnm0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 rnm1 = DecodeLightmap(BakeryTex2D(_RNM1, lmUV));\n    float3 rnm2 = DecodeLightmap(BakeryTex2D(_RNM2, lmUV));\n\n    #ifdef BAKERY_SSBUMP\n        diffuseColor = normalMap.x * rnm0\n                     + normalMap.z * rnm1\n                     + normalMap.y * rnm2;\n         diffuseColor *= 2;\n    #else\n        diffuseColor = saturate(dot(rnmBasis0, normalMap)) * rnm0\n                     + saturate(dot(rnmBasis1, normalMap)) * rnm1\n                     + saturate(dot(rnmBasis2, normalMap)) * rnm2;\n    #endif\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDirT = rnmBasis0 * dot(rnm0, lumaConv) +\n                              rnmBasis1 * dot(rnm1, lumaConv) +\n                              rnmBasis2 * dot(rnm2, lumaConv);\n\n        float3 dominantDirTN = normalize(dominantDirT);\n        float3 specColor = saturate(dot(rnmBasis0, dominantDirTN)) * rnm0 +\n                           saturate(dot(rnmBasis1, dominantDirTN)) * rnm1 +\n                           saturate(dot(rnmBasis2, dominantDirTN)) * rnm2;\n\n        half3 halfDir = Bakery_SafeNormalize(dominantDirTN - viewDirT);\n        half nh = saturate(dot(normalMap, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n        specularColor = spec * specColor;\n    #endif\n}\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\ninline half3 Unity_DecodeDirectionalLightmap(half3 color, fixed4 dirTex, half3 normalWorld)\n{\n    // In directional (non-specular) mode Enlighten bakes dominant light direction\n    // in a way, that using it for half Lambert and then dividing by a \"rebalancing coefficient\"\n    // gives a result close to plain diffuse response lightmaps, but normalmapped.\n\n    // Note that dir is not unit length on purpose. Its length is \"directionality\", like\n    // for the directional specular lightmaps.\n\n    half halfLambert = dot(normalWorld, dirTex.xyz - 0.5) + 0.5;\n\n    return color * halfLambert / max(1e-4h, dirTex.w);\n}\n#endif\n\n#ifdef _LIGHTMAPMODE_SH\nvoid BakerySH(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 L0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 nL1x = BakeryTex2D(_RNM0, lmUV) * 2 - 1;\n    float3 nL1y = BakeryTex2D(_RNM1, lmUV) * 2 - 1;\n    float3 nL1z = BakeryTex2D(_RNM2, lmUV) * 2 - 1;\n    float3 L1x = nL1x * L0 * 2;\n    float3 L1y = nL1y * L0 * 2;\n    float3 L1z = nL1z * L0 * 2;\n\n    float3 sh;\n#if BAKERY_SHNONLINEAR\n    float lumaL0 = dot(L0, 1);\n    float lumaL1x = dot(L1x, 1);\n    float lumaL1y = dot(L1y, 1);\n    float lumaL1z = dot(L1z, 1);\n    float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    float regularLumaSH = dot(sh, 1);\n    //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n    sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n    //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n    //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n#else\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n#endif\n\n    diffuseColor = max(sh, 0.0);\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n        float focus = saturate(length(dominantDir));\n        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n        half nh = saturate(dot(normalWorld, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n\n        sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n\n        specularColor = max(spec * sh, 0.0);\n    #endif\n}\n#endif\n\n#endif // include guards\n\n\n    void Ext_ModifyVertex15 (inout VertexData v, inout ExtraV2F e)\n    {\n        #if _USEBAKERY\n\t\t    #if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\t\t\t    // Unpack from RGBM\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.a * 8.0f;\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.rgb;\n\n\t\t\t    #ifdef BAKERY_VERTEXLMMASK\n\t\t\t\t    e.extraV2F4.xyzw = unpack4NFloats(v.texcoord1);\n\t\t\t    #endif\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXSH\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n                e.extraV2F6.xyz = unpack3NFloats(v.texcoord3.x) * 2 - 1;\n                e.extraV2F7.xyz = unpack3NFloats(v.texcoord3.y) * 2 - 1;\n            #endif\n       #endif\n    }\n\n#if _HDRP || _URP\n    half3 SHEvalLinearL0L1 (half4 normal)\n    {\n        half3 x;\n\n        // Linear (L1) + constant (L0) polynomial terms\n        x.r = dot(unity_SHAr,normal);\n        x.g = dot(unity_SHAg,normal);\n        x.b = dot(unity_SHAb,normal);\n\n        return x;\n    }\n\n    // normal should be normalized, w=1.0\n    half3 SHEvalLinearL2 (half4 normal)\n    {\n        half3 x1, x2;\n        // 4 of the quadratic (L2) polynomials\n        half4 vB = normal.xyzz * normal.yzzx;\n        x1.r = dot(unity_SHBr,vB);\n        x1.g = dot(unity_SHBg,vB);\n        x1.b = dot(unity_SHBb,vB);\n\n        // Final (5th) quadratic (L2) polynomial\n        half vC = normal.x*normal.x - normal.y*normal.y;\n        x2 = unity_SHC.rgb * vC;\n\n        return x1 + x2;\n    }\n\n    half3 ShadeSH9 (half4 normal)\n    {\n        // Linear + constant polynomial terms\n        half3 res = SHEvalLinearL0L1 (normal);\n\n        // Quadratic polynomials\n        res += SHEvalLinearL2 (normal);\n\n        #ifdef UNITY_COLORSPACE_GAMMA\n            res = LinearToGamma (res);\n        #endif\n\n        return res;\n\n    }\n#endif\n\n\n\n\tvoid DoBakeryStuff(inout float3 indDif, inout float3 indSpec, inout float4 shadowmask, float3 tangentNormal, float smoothness, ShaderData d)\n\t{\n\t\t// Quality!\n\t\tindDif = 1;\n\t\tindSpec = 0;\n\n        #if defined(_PASSFORWARD) || defined(_PASSGBUFFER) // forward pass on URP/Standard/HDRP + built-in deferred\n\n            float3 normalWorld = mul(tangentNormal, d.TBNMatrix);\n\n\t\t\t#ifdef LIGHTMAP_ON\n\n                // Static\n\n\t\t\t\tfloat2 lmUV = d.texcoord1 * unity_LightmapST.xy + unity_LightmapST.zw;\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_STANDARD\n\t\t\t\t\tindDif = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n\n\t\t\t\t\t#ifdef DIRLIGHTMAP_COMBINED\n\t\t\t\t\t\tfloat4 dirMap = BakeryTex2D(unity_LightmapInd, lmUV);\n\t\t\t\t\t\tindDif = Unity_DecodeDirectionalLightmap(indDif, dirMap, normalWorld);\n\n\t\t\t\t\t\t#ifdef BAKERY_LMSPEC\n\t\t\t\t\t\t\tindSpec = BakeryDirectionalLightmapSpecular(lmUV, normalWorld, -d.worldSpaceViewDir, smoothness) * indDif;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\n\t\t\t\t\tindDif = d.vertexColor;\n\n                    #ifdef BAKERY_VERTEXLMMASK\n                        shadowmask = d.extraV2F4;\n                    #endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n\t\t\t\t\t\t// worldSpaceNormal is per-vertex\n\t\t\t\t\t\t// normalWorld is per-pixel\n\t\t\t\t\t\tfloat3 bakedLightDirection = d.extraV2F5;\n\t\t\t\t\t\tBakeryVertexLMDirection(indDif, indSpec, bakedLightDirection, d.worldSpaceNormal, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXSH\n\t\t\t\t\t\tBakeryVertexLMSH(indDif, indSpec, d.extraV2F5, d.extraV2F6, d.extraV2F7, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_RNM\n\t\t\t\t\tBakeryRNM(indDif, indSpec, lmUV, tangentNormal, smoothness, -d.tangentSpaceViewDir);\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_SH\n\t\t\t\t\tBakerySH(indDif, indSpec, lmUV, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t#endif\n\n            #else\n\n                // Dynamic\n\n                #ifdef BAKERY_VOLUME\n\n                    bool isGlobal = dot(abs(_VolumeInvSize),1) == 0;\n                    float3 volViewDir = -d.worldSpaceViewDir;\n                    #ifdef BAKERY_VOLROTATION\n                        float4x4 volMatrix = (isGlobal ? _GlobalVolumeMatrix : _VolumeMatrix);\n                        float3 volInvSize = (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 lpUV = mul(volMatrix, float4(d.worldSpacePosition,1)).xyz * volInvSize + 0.5f;\n                        float3 volNormal = mul((float3x3)volMatrix, normalWorld);\n                        #ifdef BAKERY_LMSPEC\n                            volViewDir = mul((float3x3)volMatrix, volViewDir);\n                        #endif\n                    #else\n                        float3 lpUV = (d.worldSpacePosition - (isGlobal ? _GlobalVolumeMin : _VolumeMin)) * (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 volNormal = normalWorld;\n                    #endif\n\n                    #ifdef BAKERY_COMPRESSED_VOLUME\n                        float4 tex0, tex1, tex2, tex3;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex3 = _Volume3.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz * L0;\n                        L1y = tex2.xyz * L0;\n                        L1z = tex3.xyz * L0;\n                    #else\n                        float4 tex0, tex1, tex2;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV);\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV);\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz;\n                        L1y = tex2.xyz;\n                        L1z = float3(tex0.w, tex1.w, tex2.w);\n                    #endif\n                    indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), volNormal);\n                    indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), volNormal);\n                    indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), volNormal);\n\n                    #ifdef UNITY_COLORSPACE_GAMMA\n                        indDif = pow(indDif, 1.0f / 2.2f);\n                    #endif\n\n                    #ifdef BAKERY_LMSPEC\n                        float3 nL1x = L1x / L0;\n                        float3 nL1y = L1y / L0;\n                        float3 nL1z = L1z / L0;\n                        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n                        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - volViewDir);\n                        half nh = saturate(dot(volNormal, halfDir));\n                        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n                        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n                        half spec = GGXTerm(nh, roughness);\n                        float3 sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n                        indSpec = max(spec * sh, 0.0);\n                    #endif\n\n                    shadowmask = _VolumeMask.Sample(sampler_Volume0, lpUV);\n\n                #else\n\n                    #ifdef BAKERY_SHNONLINEAR\n                        float3 L0 = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);\n                        indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, unity_SHAr.xyz, normalWorld);\n                        indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, unity_SHAg.xyz, normalWorld);\n                        indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, unity_SHAb.xyz, normalWorld);\n                    #else\n                        indDif = ShadeSH9(float4(normalWorld,1));\n                    #endif\n\n                #endif\n\n\t\t\t#endif\n\n        #endif\n\t}\n\n\t// this is the main surface function. Surface is like a surface shader output structure, but\n\t// with our new outputs as well.\n\tvoid Ext_SurfaceFunction15 (inout Surface o, ShaderData d)\n\t{\n        #if _USEBAKERY\n\t\t    float3 indDif;\n\t\t    float3 indSpec;\n            float4 shadowmask = 1;\n\t\t    DoBakeryStuff(indDif, indSpec, shadowmask, o.Normal, o.Smoothness, d);\n\t\t    o.DiffuseGI = indDif;\n\t\t    o.BackDiffuseGI = indDif;\n\t\t    o.SpecularGI = indSpec;\n            o.ShadowMask = shadowmask;\n        #endif\n\t}\n\n\n\n\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                  Ext_SurfaceFunction1(l, d);\n                  Ext_SurfaceFunction2(l, d);\n                  Ext_SurfaceFunction3(l, d);\n                  Ext_SurfaceFunction4(l, d);\n                  Ext_SurfaceFunction5(l, d);\n                  Ext_SurfaceFunction6(l, d);\n                  Ext_SurfaceFunction7(l, d);\n                  Ext_SurfaceFunction8(l, d);\n                  Ext_SurfaceFunction9(l, d);\n\t\t            Ext_SurfaceFunction10(l, d);\n                  Ext_SurfaceFunction11(l, d);\n                  Ext_SurfaceFunction12(l, d);\n                  Ext_SurfaceFunction13(l, d);\n                  Ext_SurfaceFunction14(l, d);\n                  Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraV2F d;\n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                  Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                  Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                  #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                  v2p.extraV2F4 = d.extraV2F4;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                  v2p.extraV2F5 = d.extraV2F5;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F6 = d.extraV2F6;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F7 = d.extraV2F7;\n                  #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                d.extraV2F4 = v2p.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                d.extraV2F5 = v2p.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F6 = v2p.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F7 = v2p.extraV2F7;\n                #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n                Ext_ModifyTessellatedVertex2(v, d);\n                Ext_ModifyTessellatedVertex3(v, d);\n                Ext_ModifyTessellatedVertex4(v, d);\n                Ext_ModifyTessellatedVertex5(v, d);\n                Ext_ModifyTessellatedVertex6(v, d);\n                Ext_ModifyTessellatedVertex7(v, d);\n                Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                v2p.extraV2F4 = d.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                v2p.extraV2F5 = d.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F6 = d.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F7 = d.extraV2F7;\n                #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n\n\n\n         \n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n            // d.texcoord3 = i.texcoord3;\n             #endif\n\n             d.isFrontFace = facing;\n             #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n             d.vertexColor = i.vertexColor;\n             #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(i.worldPos, 1)).xyz;\n            #endif\n             d.localSpaceNormal = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n             #if LOD_FADE_CROSSFADE\n             d.screenPos = i.screenPos;\n             d.screenUV = (i.screenPos.xy / i.screenPos.w);\n             #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n             #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n             d.extraV2F4 = i.extraV2F4;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n             d.extraV2F5 = i.extraV2F5;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F6 = i.extraV2F6;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F7 = i.extraV2F7;\n             #endif\n\n            return d;\n         }\n         \n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n            UNITY_SETUP_INSTANCE_ID(v);\n            VertexToPixel o;\n            UNITY_INITIALIZE_OUTPUT(VertexToPixel,o);\n            UNITY_TRANSFER_INSTANCE_ID(v,o);\n            UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o);\n#endif\n\n            o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n            #ifdef EDITOR_VISUALIZATION\n               o.vizUV = 0;\n               o.lightCoord = 0;\n               if (unity_VisualizationMode == EDITORVIZ_TEXTURE)\n                  o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord0.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);\n               else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)\n               {\n                  o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n                  o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));\n               }\n            #endif\n\n\n             o.texcoord0 = v.texcoord0;\n             o.texcoord1 = v.texcoord1;\n            // o.texcoord2 = v.texcoord2;\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n            // o.texcoord3 = v.texcoord3;\n             #endif\n\n             #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n             o.vertexColor = v.vertexColor;\n             #endif\n\n             #if LOD_FADE_CROSSFADE\n             o.screenPos = ComputeScreenPos(o.pos);\n             #endif\n\n            o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n            o.worldNormal = UnityObjectToWorldNormal(v.normal);\n            o.worldTangent.xyz = UnityObjectToWorldDir(v.tangent.xyz);\n            fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n            o.worldTangent.w = tangentSign;\n\n            return o;\n         }\n\n         \n\n         // fragment shader\n         fixed4 Frag (VertexToPixel IN\n         #if NEED_FACING\n            , bool facing : SV_IsFrontFace\n         #endif\n         ) : SV_Target\n         {\n            UNITY_SETUP_INSTANCE_ID(IN);\n\n            #ifdef FOG_COMBINED_WITH_TSPACE\n               UNITY_EXTRACT_FOG_FROM_TSPACE(IN);\n            #elif defined FOG_COMBINED_WITH_WORLD_POS\n               UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);\n            #else\n               UNITY_EXTRACT_FOG(IN);\n            #endif\n\n            ShaderData d = CreateShaderData(IN\n               #if NEED_FACING\n                 , facing\n              #endif\n            );\n\n            Surface l = (Surface)0;\n\n            l.Albedo = half3(0.5, 0.5, 0.5);\n            l.Normal = float3(0,0,1);\n            l.Occlusion = 1;\n            l.Alpha = 1;\n\n            \n            ChainSurfaceFunction(l, d);\n\n            UnityMetaInput metaIN;\n            UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);\n            metaIN.Albedo = l.Albedo;\n            metaIN.Emission = l.Emission;\n          \n            #if _USESPECULAR\n               metaIN.SpecularColor = l.Specular;\n            #endif\n\n            #ifdef EDITOR_VISUALIZATION\n              metaIN.VizUV = IN.vizUV;\n              metaIN.LightCoord = IN.lightCoord;\n            #endif\n            return UnityMetaFragment(metaIN);\n         }\n         ENDCG\n\n      }\n\n      \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   }\n   \n   \n   CustomEditor \"JBooth.BetterLit.LitBaseMaterialEditor\"\n}\n"},{"srpTarget":1,"UnityVersionMin":20194,"UnityVersionMax":20201,"shader":{"instanceID":0},"shaderSrc":"////////////////////////////////////////\n// Generated with Better Shaders\n//\n// Auto-generated shader code, don't hand edit!\n//\n//   Unity Version: 2020.3.0f1\n//   Render Pipeline: URP2019\n//   Platform: OSXEditor\n////////////////////////////////////////\n\n\nShader \"Hidden/Better Lit/Lit Alpha\"\n{\n   Properties\n   {\n      \n   [HideInInspector]_NoiseTex(\"Noise Texture\", 2D) = \"black\" {}\n\n\n    [HideInInspector]_MainTex(\"Unity Standard Shader Hack Property\", 2D) = \"white\" {} // use this to do material conversion.\n    [HideInInspector]_BaseColor(\"Unity HDRP/URP Shader Hack Property\", 2D) = \"white\" {} // use this to do material conversion.\n    [HideInInspector]_BumpMap(\"Unity Standard Shader Hack Property\", 2D) = \"bump\" {} // use this to do material conversion.\n    [HideInInspector]_IsConverted(\"Have we done one time conversion yet?\", Float) = 0\n    \n    _TriplanarSpace (\"Triplanar Space\", Float) = 0\n    _TriplanarContrast (\"Triplanar Contrast\", Range(1, 10)) = 4\n    _UVSource(\"UV Source\", Float) = 0\n    _AlbedoMap(\"Albedo/Height\", 2D) = \"white\" {}\n    _Tint (\"Tint\", Color) = (1, 1, 1, 1)\n    _AlbedoBrightness(\"Brightness\", Range(-1, 1)) = 0\n    _AlbedoContrast(\"Contrast\", Range(0,2)) = 1\n    _AlphaThreshold(\"Alpha Threshold\", Range(0,1)) = 0.0\n    _Cutoff(\"Unity Lightmapper sucks\", Range(0, 1)) = 0.0\n    _NormalMap(\"Normal\", 2D) = \"bump\" {}\n    _NormalStrength(\"Normal Strength\", Range(0,2)) = 1\n    \n    _MaskMap(\"Mask Map\", 2D) = \"black\" {}\n    _Smoothness(\"Smoothness\", Range(0,1)) = 0\n    _Metallic(\"Metallic\", Range(0,1)) = 0\n    _SpecularMap(\"Specular Map\", 2D) = \"black\" {}\n\n    _EmissionMap(\"Emission Map\", 2D) = \"black\" {}\n    _EmissionColor(\"Emission Strength\", Color) = (0,0,0,0)\n\n    _SmoothnessRemap(\"Smoothness Remap\", Vector) = (0, 1, 0, 0)\n    _AORemap(\"AO Remap\", Vector) = (0, 1, 0, 0)\n    _MetallicRemap(\"Metallic Remap\", Vector) = (0, 1, 0, 0)\n    _HeightRemap(\"Height Remap\", Vector) = (0, 1, 0, 0)\n\n    _DetailUVSource(\"Detail UV Source\", Float) = 0\n    _DetailMap(\"Detail Map\", 2D) = \"white\" {}\n    _DetailAlbedoStrength(\"Detail Albedo Strength\", Range(0, 2)) = 1\n    _DetailNormalStrength(\"Detail Normal Strength\", Range(0, 2)) = 1\n    _DetailSmoothnessStrength(\"Detail Smoothness Strength\", Range(0, 2)) = 1\n    _DetailTriplanarSpace (\"Triplanar Space\", Float) = 0\n    _DetailTriplanarContrast (\"Triplanar Contrast\", Range(1, 10)) = 4\n    _DetailStochasticContrast(\"Stochastic Contrast\", Range(0.01,0.999)) = 0.7\n    _DetailStochasticScale(\"Stochastic Contrast\", Range(0.2,1.5)) = 0.5\n    _FlatShadingBlend(\"Flat Shading Blend\", Range(0,4)) = 1\n    _StochasticContrast(\"Stochastic Contrast\", Range(0.01,0.999)) = 0.7\n    _StochasticScale(\"Stochastic Contrast\", Range(0.2,1.5)) = 0.5\n    _ParallaxHeight(\"Parallax Height\", Range(0, 0.25)) = 0\n\n    _MicroShadowStrength(\"Micro Shadow Strength\", Range(0, 2)) = 0\n    _FuzzyShadingOn(\"FuzzyShadingToggle\", Float) = 0\n    _FuzzyShadingColor(\"Fuzzy Shading Color\", Color) = (1,1,1,1)\n    _FuzzyShadingParams(\"Fuzzy Shading Params\", Vector) = (0.3,1,1.5,1) // coreMult, edgeMult, power\n\n    //_POMMaxSamples (\"POM Max Samples\", Range(4, 32)) = 8\n    //_POMMin (\"POM Min Distance\", Float) = 25\n    //_POMFade (\"Pom Fade Range\", Float) = 25\n\n\n\n\t_TintMask(\"Tint Mask\", 2D) = \"white\" {}\n\t_RColor(\"R Color\", Color) = (0.5,0.5,0.5,1)\n\t_GColor(\"G Color\", Color) = (0.5,0.5,0.5,1)\n\t_BColor(\"B Color\", Color) = (0.5,0.5,0.5,1)\n\t_AColor(\"A Color\", Color) = (0.5,0.5,0.5,1)\n\n\n\t_LayerTextureMask(\"Layer Texture Mask\", 2D) = \"white\" {}\n    _LayerTextureMaskUVMode(\"Layer Texture Mask UV Mode\", Float) = 0\n\n\n\t_LayerUVSource(\"Detail UV Source\", Float) = 0\n    [Enum(Multiply2X, 0, AlphaBlend, 1, HeightBlend, 2)]_LayerBlendMode(\"Layer Blend Mode\", Float) = 0\n    _LayerStrength(\"Layer Strength\", Range(0,2)) = 1\n    _LayerAlbedoStrength(\"Detail Albedo Strength\", Range(0, 2)) = 1\n    _LayerNormalStrength(\"Detail Normal Strength\", Range(0, 2)) = 1\n    _LayerSmoothnessRemap(\"Smoothness Remap\", Vector) = (0, 1, 0, 0)\n    _LayerAORemap(\"Occlusion Remap\", Vector) = (0, 1, 0, 0)\n    _LayerMetallicRemap(\"Metallic Remap\", Vector) = (0, 1, 0, 0)\n    _LayerSmoothness(\"Smoothness\", Range(0,1)) = 0\n    _LayerSmoothnessStrength(\"Smoothness Strength\", Range(0,1)) = 1\n    _LayerHeightRemap(\"Height Remap\", Vector) = (0, 1, 0, 0)\n    _LayerHeightContrast(\"Height Contrast\", Range(0.01, 0.99)) = 0.5\n    _LayerMetallic(\"Metallic\", Range(0,1)) = 0\n    _LayerScale(\"Detail UV Scale\", Float) = 3\n    _LayerTriplanarSpace (\"Triplanar Space\", Float) = 0\n    _LayerTriplanarContrast (\"Triplanar Contrast\", Range(1, 10)) = 4\n    _LayerAlbedoMap(\"Albedo/Height\", 2D) = \"white\" {}\n    _LayerNormalMap(\"Normal\", 2D) = \"bump\" {}\n    _LayerMaskMap(\"Mask Map\", 2D) = \"black\" {}\n    _LayerNoiseFrequency(\"Noise Frequency\", Float) = 1\n    _LayerNoiseAmplitude(\"Noise Amplitude\", Range(0,10)) = 0.5\n    _LayerNoiseOffset(\"Noise Offset\", Float) = 0\n    _LayerNoiseCenter(\"Noise Center\", Range(-5, 5)) = 0\n    _LayerStochasticContrast(\"Stochastic Contrast\", Range(0.01,0.999)) = 0.7\n    _LayerStochasticScale(\"Stochastic Scale\", Range(0.2,1.5)) = 0.5\n    _LayerBlendTint(\"Layer Blend Tint\", Color) = (1,1,1,1)\n    _LayerBlendContrast(\"Layer Blend Contrast\", Range(0.5, 8)) = 2\n    _LayerTint(\"Layer Tint\", Color) = (1,1,1,1)\n    _LayerAlbedoBrightness(\"Layer Brightness\", Range(-1, 1)) = 0\n    _LayerAlbedoContrast(\"Layer Contrast\", Range(0, 2)) = 1\n    _LayerEmissionMap(\"Layer Emission Map\", 2D) = \"black\" {}\n    _LayerEmissionColor(\"Layer Emission Multiplier\", Color) = (0,0,0,0)\n    _LayerAngleMin(\"Angle Minimum\", Range(0,1)) = 0.1\n    _LayerVertexNormalBlend(\"Vertex->Normal Filter\", Range(0,1)) = 0.8\n    _LayerHeight(\"Height Filter\", Range(0,1)) = 0\n    [Enum(Top,0,Bottom,1)] _LayerInvertHeight (\"Layer on\", Float) = 0\n    _LayerFalloff(\"Angle Falloff Contrast\", Range(2, 40)) = 8\n    _LayerTessStrength(\"Displacement Strength\", Range(0,1)) = 1\n    _LayerWeightOverDistance(\"Weight Over Distance\", Vector) = (1,1,1,1) // start distance/weight, end fade range/weight\n    _LayerMicroShadowStrength(\"Micro Shadow Strength\", Range(0,2)) = 0\n    _LayerFuzzyShadingOn(\"FuzzyShadingToggle\", Float) = 0\n    _LayerFuzzyShadingColor(\"Fuzzy Shading Color\", Color) = (1,1,1,1)\n    _LayerFuzzyShadingParams(\"Fuzzy Shading Params\", Vector) = (0.3,1,1.5,1) // coreMult, edgeMult, power\n\n\n\n\n\t_LayerUVSource_Ext_1(\"Detail UV Source\", Float) = 0\n    [Enum(Multiply2X, 0, AlphaBlend, 1, HeightBlend, 2)]_LayerBlendMode_Ext_1(\"Layer Blend Mode\", Float) = 0\n    _LayerStrength_Ext_1(\"Layer Strength\", Range(0,2)) = 1\n    _LayerAlbedoStrength_Ext_1(\"Detail Albedo Strength\", Range(0, 2)) = 1\n    _LayerNormalStrength_Ext_1(\"Detail Normal Strength\", Range(0, 2)) = 1\n    _LayerSmoothnessRemap_Ext_1(\"Smoothness Remap\", Vector) = (0, 1, 0, 0)\n    _LayerAORemap_Ext_1(\"Occlusion Remap\", Vector) = (0, 1, 0, 0)\n    _LayerMetallicRemap_Ext_1(\"Metallic Remap\", Vector) = (0, 1, 0, 0)\n    _LayerSmoothness_Ext_1(\"Smoothness\", Range(0,1)) = 0\n    _LayerSmoothnessStrength_Ext_1(\"Smoothness Strength\", Range(0,1)) = 1\n    _LayerHeightRemap_Ext_1(\"Height Remap\", Vector) = (0, 1, 0, 0)\n    _LayerHeightContrast_Ext_1(\"Height Contrast\", Range(0.01, 0.99)) = 0.5\n    _LayerMetallic_Ext_1(\"Metallic\", Range(0,1)) = 0\n    _LayerScale_Ext_1(\"Detail UV Scale\", Float) = 3\n    _LayerTriplanarSpace_Ext_1 (\"Triplanar Space\", Float) = 0\n    _LayerTriplanarContrast_Ext_1 (\"Triplanar Contrast\", Range(1, 10)) = 4\n    _LayerAlbedoMap_Ext_1(\"Albedo/Height\", 2D) = \"white\" {}\n    _LayerNormalMap_Ext_1(\"Normal\", 2D) = \"bump\" {}\n    _LayerMaskMap_Ext_1(\"Mask Map\", 2D) = \"black\" {}\n    _LayerNoiseFrequency_Ext_1(\"Noise Frequency\", Float) = 1\n    _LayerNoiseAmplitude_Ext_1(\"Noise Amplitude\", Range(0,10)) = 0.5\n    _LayerNoiseOffset_Ext_1(\"Noise Offset\", Float) = 0\n    _LayerNoiseCenter_Ext_1(\"Noise Center\", Range(-5, 5)) = 0\n    _LayerStochasticContrast_Ext_1(\"Stochastic Contrast\", Range(0.01,0.999)) = 0.7\n    _LayerStochasticScale_Ext_1(\"Stochastic Scale\", Range(0.2,1.5)) = 0.5\n    _LayerBlendTint_Ext_1(\"Layer Blend Tint\", Color) = (1,1,1,1)\n    _LayerBlendContrast_Ext_1(\"Layer Blend Contrast\", Range(0.5, 8)) = 2\n    _LayerTint_Ext_1(\"Layer Tint\", Color) = (1,1,1,1)\n    _LayerAlbedoBrightness_Ext_1(\"Layer Brightness\", Range(-1, 1)) = 0\n    _LayerAlbedoContrast_Ext_1(\"Layer Contrast\", Range(0, 2)) = 1\n    _LayerEmissionMap_Ext_1(\"Layer Emission Map\", 2D) = \"black\" {}\n    _LayerEmissionColor_Ext_1(\"Layer Emission Multiplier\", Color) = (0,0,0,0)\n    _LayerAngleMin_Ext_1(\"Angle Minimum\", Range(0,1)) = 0.1\n    _LayerVertexNormalBlend_Ext_1(\"Vertex->Normal Filter\", Range(0,1)) = 0.8\n    _LayerHeight_Ext_1(\"Height Filter\", Range(0,1)) = 0\n    [Enum(Top,0,Bottom,1)] _LayerInvertHeight_Ext_1 (\"Layer on\", Float) = 0\n    _LayerFalloff_Ext_1(\"Angle Falloff Contrast\", Range(2, 40)) = 8\n    _LayerTessStrength_Ext_1(\"Displacement Strength\", Range(0,1)) = 1\n    _LayerWeightOverDistance_Ext_1(\"Weight Over Distance\", Vector) = (1,1,1,1) // start distance/weight, end fade range/weight\n    _LayerMicroShadowStrength_Ext_1(\"Micro Shadow Strength\", Range(0,2)) = 0\n    _LayerFuzzyShadingOn_Ext_1(\"FuzzyShadingToggle\", Float) = 0\n    _LayerFuzzyShadingColor_Ext_1(\"Fuzzy Shading Color\", Color) = (1,1,1,1)\n    _LayerFuzzyShadingParams_Ext_1(\"Fuzzy Shading Params\", Vector) = (0.3,1,1.5,1) // coreMult, edgeMult, power\n\n\n\n\n\t_LayerUVSource_Ext_2(\"Detail UV Source\", Float) = 0\n    [Enum(Multiply2X, 0, AlphaBlend, 1, HeightBlend, 2)]_LayerBlendMode_Ext_2(\"Layer Blend Mode\", Float) = 0\n    _LayerStrength_Ext_2(\"Layer Strength\", Range(0,2)) = 1\n    _LayerAlbedoStrength_Ext_2(\"Detail Albedo Strength\", Range(0, 2)) = 1\n    _LayerNormalStrength_Ext_2(\"Detail Normal Strength\", Range(0, 2)) = 1\n    _LayerSmoothnessRemap_Ext_2(\"Smoothness Remap\", Vector) = (0, 1, 0, 0)\n    _LayerAORemap_Ext_2(\"Occlusion Remap\", Vector) = (0, 1, 0, 0)\n    _LayerMetallicRemap_Ext_2(\"Metallic Remap\", Vector) = (0, 1, 0, 0)\n    _LayerSmoothness_Ext_2(\"Smoothness\", Range(0,1)) = 0\n    _LayerSmoothnessStrength_Ext_2(\"Smoothness Strength\", Range(0,1)) = 1\n    _LayerHeightRemap_Ext_2(\"Height Remap\", Vector) = (0, 1, 0, 0)\n    _LayerHeightContrast_Ext_2(\"Height Contrast\", Range(0.01, 0.99)) = 0.5\n    _LayerMetallic_Ext_2(\"Metallic\", Range(0,1)) = 0\n    _LayerScale_Ext_2(\"Detail UV Scale\", Float) = 3\n    _LayerTriplanarSpace_Ext_2 (\"Triplanar Space\", Float) = 0\n    _LayerTriplanarContrast_Ext_2 (\"Triplanar Contrast\", Range(1, 10)) = 4\n    _LayerAlbedoMap_Ext_2(\"Albedo/Height\", 2D) = \"white\" {}\n    _LayerNormalMap_Ext_2(\"Normal\", 2D) = \"bump\" {}\n    _LayerMaskMap_Ext_2(\"Mask Map\", 2D) = \"black\" {}\n    _LayerNoiseFrequency_Ext_2(\"Noise Frequency\", Float) = 1\n    _LayerNoiseAmplitude_Ext_2(\"Noise Amplitude\", Range(0,10)) = 0.5\n    _LayerNoiseOffset_Ext_2(\"Noise Offset\", Float) = 0\n    _LayerNoiseCenter_Ext_2(\"Noise Center\", Range(-5, 5)) = 0\n    _LayerStochasticContrast_Ext_2(\"Stochastic Contrast\", Range(0.01,0.999)) = 0.7\n    _LayerStochasticScale_Ext_2(\"Stochastic Scale\", Range(0.2,1.5)) = 0.5\n    _LayerBlendTint_Ext_2(\"Layer Blend Tint\", Color) = (1,1,1,1)\n    _LayerBlendContrast_Ext_2(\"Layer Blend Contrast\", Range(0.5, 8)) = 2\n    _LayerTint_Ext_2(\"Layer Tint\", Color) = (1,1,1,1)\n    _LayerAlbedoBrightness_Ext_2(\"Layer Brightness\", Range(-1, 1)) = 0\n    _LayerAlbedoContrast_Ext_2(\"Layer Contrast\", Range(0, 2)) = 1\n    _LayerEmissionMap_Ext_2(\"Layer Emission Map\", 2D) = \"black\" {}\n    _LayerEmissionColor_Ext_2(\"Layer Emission Multiplier\", Color) = (0,0,0,0)\n    _LayerAngleMin_Ext_2(\"Angle Minimum\", Range(0,1)) = 0.1\n    _LayerVertexNormalBlend_Ext_2(\"Vertex->Normal Filter\", Range(0,1)) = 0.8\n    _LayerHeight_Ext_2(\"Height Filter\", Range(0,1)) = 0\n    [Enum(Top,0,Bottom,1)] _LayerInvertHeight_Ext_2 (\"Layer on\", Float) = 0\n    _LayerFalloff_Ext_2(\"Angle Falloff Contrast\", Range(2, 40)) = 8\n    _LayerTessStrength_Ext_2(\"Displacement Strength\", Range(0,1)) = 1\n    _LayerWeightOverDistance_Ext_2(\"Weight Over Distance\", Vector) = (1,1,1,1) // start distance/weight, end fade range/weight\n    _LayerMicroShadowStrength_Ext_2(\"Micro Shadow Strength\", Range(0,2)) = 0\n    _LayerFuzzyShadingOn_Ext_2(\"FuzzyShadingToggle\", Float) = 0\n    _LayerFuzzyShadingColor_Ext_2(\"Fuzzy Shading Color\", Color) = (1,1,1,1)\n    _LayerFuzzyShadingParams_Ext_2(\"Fuzzy Shading Params\", Vector) = (0.3,1,1.5,1) // coreMult, edgeMult, power\n\n\n\n\n    [Toggle] _Trax(\"Enable Trax\", Float) = 0\n    _TraxAlbedo(\"Trax Albedo\", 2D) = \"white\" {}\n    _TraxPackedNormal(\"Trax Packed Normal\", 2D) = \"bump\" {}\n    _TraxNormalStrength(\"Normal Strength\", Range(0,2)) = 1\n    _TraxDisplacementDepth(\"Trax Depression Depth\", Float) = 0.1\n    _TraxDisplacementStrength(\"Trax Displacement\", Range(0,3)) = 0.2\n    _TraxMipBias(\"Trax Mip Bias\", Range(0, 5)) = 3\n    _TraxInterpContrast(\"Interpolation Contrast\", Range(0,1)) = 0.9\n    _TraxHeightContrast(\"Height Contrast\", Range(0,1)) = 0.5\n    _TraxTint(\"Tint Color\", Color) = (1,1,1,1)\n\n\n   _WetnessMode(\"Wetness Mode\", Int) = 0\n   _PuddleMode(\"Puddle Mode\", Int) = 0\n   _RainMode(\"Rain Mode\", Int) = 0\n   _WetnessAmount(\"Wetness Amount\", Range(0,1)) = 0\n   _Porosity(\"Porosity\", Range(0,1)) = 0.4\n   _WetnessMin(\"Minimum Wetness\", Range(0,1)) = 0\n   _WetnessMax(\"Maximum Wetness\", Range(0,1)) = 1\n   _WetnessFalloff(\"Angle Falloff\", Range(0,1)) = 1\n   _WetnessAngleMin(\"Wetness Minimum Angle\", Range(-1,1)) = -1\n   _PuddleAmount(\"Puddle Amount\", Range(0,1)) = 0\n   _PuddleFalloff(\"Puddle Contrast\", Range(2, 50)) = 12\n   _PuddleAngleMin(\"Moss Angle Minimum\", Range(0,1)) = 0.1\n   _PuddleColor(\"Puddle Color\", Color) = (0.2, 0.2, 0.2, 0.7)\n   _PuddleNoiseFrequency(\"Noise Frequency\", Float) = 1\n   _PuddleNoiseAmplitude(\"Noise Amplitude\", Range(0,10)) = 0.5\n   _PuddleNoiseCenter(\"Noise Center\", Range(-5, 5)) = 0\n   _PuddleNoiseOffset(\"Noise Offset\", Float) = 0\n   _RainDropTexture(\"RainDrop Texture\", 2D) = \"white\" {}\n   _RainIntensityScale(\"Intensity/Scale/MinWet\", Vector) = (1, 25, 0, 0)\n   _WetnessShoreline(\"Wetness Shore Height\", Float) = -99999\n\n\n    _SnowMode(\"Snow Mode\", Int) = 0\n    _SnowAlbedo(\"Snow Albedo\", 2D) = \"white\" {}\n    _SnowTint(\"Snow Trax Albedo\", Color) = (1,1,1,1)\n    _SnowNormal(\"Snow Normal\", 2D) = \"bump\" {}\n    _SnowMaskMap(\"Snow Mask Map\", 2D) = \"black\" {}\n    _SnowAmount(\"Snow Amount\", Range(0,1)) = 1\n    _SnowAngle(\"Snow Angle Falloff\", Range(0,2)) = 1\n    _SnowContrast(\"Snow Contrast\", Range(0.5, 4)) = 1.5\n    _SnowVertexHeight(\"Snow Vertex Height\", Range(0,1)) = 0.05\n    _SnowWorldFade(\"Snow Height Fade\", Vector) = (100, 50, 0, 0)\n    _SnowTraxAlbedo(\"Snow Trax Albedo\", 2D) = \"white\" {}\n    _SnowTraxTint(\"Snow Trax Albedo\", Color) = (1,1,1,1)\n    _SnowTraxNormal(\"Snow Trax Normal\", 2D) = \"bump\" {}\n    _SnowTraxMaskMap(\"Snow Trax Mask Map\", 2D) = \"black\" {}\n    _SnowNoiseFreq(\"Snow Noise Frequency\", Float) = 1\n    _SnowNoiseAmp(\"Snow Noise Amplitude\", Float) = 1\n    _SnowNoiseOffset(\"Snow Noise Offset\", Float) = 0\n    _SnowStochasticContrast(\"Snow Stochastic Contrast\", Range(0.01, 0.99)) = 0.7\n    _SnowStochasticScale(\"Snow Stochastic Scale\", Range(0,2)) = 1\n\n\n   [BetterHeader(Wind Particulate)]\n   [Toggle] _Wind(\"Enable Wind\", Float) = 0\n   [Enum(World, 0, UV, 1)]_WindParticulateSpace(\"Wind UV Source\", Float) = 0\n   _WindParticulate(\"Wind Texture\", 2D) = \"black\" {}\n   _WindParticulateStrength(\"Strength\", Range(0, 3)) = 2\n   _WindParticulateSpeed(\"Speed\", Float) = 1\n   _WindParticulatePower(\"Contrast\", Range(0.2, 6)) = 1\n   _WindParticulateRotation(\"Rotation\", Float) = 0\n   _WindParticulateColor(\"Color, strength\", Color) = (1, 1, 1, 1)\n   _WindParticulateWorldHeightMask(\"Wind Height Mask\", Vector) = (-99999, -99999, 99999, 99999)\n   _WindParticulateTextureHeight(\"Wind Texture Height\", Range(0,1)) = 1\n   _WindParticulateAngleMask(\"Wind Angle Mask\", Vector) = (-1, -1, 1, 1)\n   _WindParticulateOcclusionStrength(\"Wind Occlusion Strength\", Range(0,1)) = 1\n   _WindParticulateEmissive(\"Wind Emissive\", Color) = (0,0,0,0)\n\n\n   [Enum(Off,0,Front,1,Back,2)]_CullMode(\"Culling Mode\", Float) = 2\n   [Enum(Flip, 0, Mirror, 1, None, 2)] _DoubleSidedNormalMode(\"Double sided normal mode\", Float) = 1\n\n\n   _AutoNormalStrength(\"Auto Normal Strength\", Range(0,2)) = 0.5\n\n\n\t_DebugSampleCountThreshold (\"Debug Sample Threshold\", Int) = 12\n\n\n\t[Toggle(_DISSOLVE)] _DissolveEnabled (\"Enable Dissolve\", Float) = 0\n    _DissolveAmount(\"Dissolve Amount\", Range(0,1)) = 0\n\t_DissolveTexture(\"Dissolve Texture\", 2D) = \"black\" {}\n    _DissolveGradient(\"Dissolve Gradient\", 2D) = \"white\" {}\n\t_DissolveColoration(\"Dissolve Coloration\", Range(0,1)) = 1\n\t_DissolveEdgeContrast(\"Dissolve Edge Contrast\", Range(2, 128)) = 10\n    _DissolveEmissiveStr(\"Dissolve Emissive Strength\", Range(0,4)) = 0\n\n\n\n\n\n\n\t[BetterHeader(Bakery)]\n    [Toggle(USEBAKERY)] _USEBAKERY (\"Enabled Bakery\", Float) = 0\n\t[KeywordEnum(Standard, RNM, SH, Vertex, VertexDirectional, VertexSH)] _LightmapMode (\"Lightmapping mode\", Float) = 0\n    [Toggle(BAKERY_VERTEXLMMASK)] _BAKERY_VERTEXLMMASK (\"Enable vertex shadowmask\", Float) = 0\n    [Toggle(BAKERY_SHNONLINEAR)] _BAKERY_SHNONLINEAR (\"SH non-linear mode\", Float) = 1\n    [Toggle(BAKERY_LMSPEC)] _BAKERY_LMSPEC (\"Enable Lightmap Specular\", Float) = 0\n    [Toggle(BAKERY_BICUBIC)] _BAKERY_BICUBIC (\"Enable Bicubic Filter\", Float) = 0\n    [Toggle(BAKERY_VOLUME)] _BAKERY_VOLUME (\"Use volumes\", Float) = 0\n    [Toggle(BAKERY_VOLROTATION)] _BAKERY_VOLROTATION (\"Allow volume rotation\", Float) = 0\n\n\n\n\n\n   _IsAlpha(\"Not Used or set, just so the editor knows we are an alpha shader\", Float) = 0\n\n\n   }\n   SubShader\n   {\n      Tags { \"RenderPipeline\"=\"UniversalPipeline\" \"RenderType\" = \"Transparent\" \"Queue\" = \"Transparent\" }\n\n      \n      \nZWrite Off ColorMask RGB\n\n\n        Pass\n        {\n            Name \"Universal Forward\"\n            Tags \n            { \n                \"LightMode\" = \"UniversalForward\"\n            }\n            Blend SrcAlpha OneMinusSrcAlpha, One OneMinusSrcAlpha\nCull Back\n ZTest LEqual\nZWrite Off\n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n            #pragma multi_compile_fog\n            #pragma multi_compile_instancing\n        \n            // Keywords\n            #pragma multi_compile _ LIGHTMAP_ON\n            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS\n            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE\n            #pragma multi_compile _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS _ADDITIONAL_OFF\n            #pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS\n            #pragma multi_compile _ _SHADOWS_SOFT\n            #pragma multi_compile _ _MIXED_LIGHTING_SUBTRACTIVE\n\n            // GraphKeywords: <None>\n\n\n            #define VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n            #define SHADER_PASS SHADERPASS_FORWARD\n            #define SHADERPASS_FORWARD\n\n            #define _PASSFORWARD 1\n\n            \n\n\n   #pragma shader_feature_local_fragment _ _PACKEDFAST\n   #pragma shader_feature_local _ _TRIPLANAR\n   #pragma shader_feature_local_fragment _ _NORMALMAP \n   #pragma shader_feature_local_fragment _ _MASKMAP\n   #pragma shader_feature_local_fragment _ _DETAIL\n   #pragma shader_feature_local_fragment _ _DETAILTRIPLANAR\n   #pragma shader_feature_local_fragment _ _DETAILSTOCHASTIC\n   #pragma shader_feature_local_fragment _ _EMISSION\n   #pragma shader_feature_local_fragment _ _FLATSHADE\n   #pragma shader_feature_local _ _STOCHASTIC\n   #pragma shader_feature_local_fragment _ _PARALLAX //_POM\n   #pragma shader_feature_local_fragment _ _SPECULAR\n   #pragma shader_feature_local _ _NOISEWORLD _NOISELOCAL\n   #pragma shader_feature_local _ _NOISEHQ _NOISETEXTURE _NOISEWORLEY\n   // only for URP/Standard Forward\n   #pragma shader_feature_local_fragment _ _SIMPLELIT\n\n\n   #pragma shader_feature_local_fragment _ _TINTMASK\n\n\n    #pragma shader_feature_local _ _LAYERVERTEXMASK _LAYERTEXTUREMASK\n\n    #define _HAS_WEIGHTTEXTURE_MASK 1\n\n\n   #pragma shader_feature_local _ _USELAYER\n   #pragma shader_feature_local _ _LAYERTRIPLANAR\n   #pragma shader_feature_local _ _LAYERALBEDO\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL\n   #pragma shader_feature_local _ _LAYERMASK\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION\n   #pragma shader_feature_local _ _LAYERNOISE\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC\n   #pragma shader_feature_local _ _LAYERANGLEFILTER\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_1\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_1\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_1\n   #pragma shader_feature_local _ _LAYERMASK_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_1\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_1\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_1\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_1\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_2\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_2\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_2\n   #pragma shader_feature_local _ _LAYERMASK_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_2\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_2\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_2\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_2\n\n\n   #pragma shader_feature_local _ _TRAX_ON\n\n\n   #pragma shader_feature_local_fragment _ _WETNESS\n   #pragma shader_feature_local_fragment _ _PUDDLES\n   #pragma shader_feature_local_fragment _ _PUDDLENOISE\n   #pragma shader_feature_local_fragment _ _RAINDROPS\n\n\n   #pragma shader_feature_local _ _SNOW\n   #pragma shader_feature_local _ _SNOWMASKMAP\n   #pragma shader_feature_local _ _SNOWNOISE\n   #pragma shader_feature_local_fragment _SNOWSTOCHASTIC\n\n\n   #pragma shader_feature_local_fragment _ _WIND_ON\n\n\n\n\n   #pragma shader_feature_local_fragment _ _SURFACEGRADIENT _AUTONORMAL\n   #define _WORLDSPACENORMAL 1\n\n\n   #pragma shader_feature_local _ _DEBUG_SAMPLECOUNT\n\n\n\t#pragma shader_feature_local_fragment _ _DISSOLVE\n\n\n   #pragma multi_compile_local  LOD_FADE_CROSSFADE\n\n\n\n#pragma instancing_options procedural:setupVSPro forwardadd\n\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\nstruct IndirectShaderData\n{\n\tfloat4x4 PositionMatrix;\n\tfloat4x4 InversePositionMatrix;\n\tfloat4 ControlData;\n};\n\n#if defined(SHADER_API_GLCORE) || defined(SHADER_API_D3D11) || defined(SHADER_API_GLES3) || defined(SHADER_API_METAL) || defined(SHADER_API_VULKAN) || defined(SHADER_API_PSSL) || defined(SHADER_API_XBOXONE)\n\tuniform StructuredBuffer<IndirectShaderData> VisibleShaderDataBuffer;\n#endif\n\n#endif\n\nfloat VSPRenderingLayerMask;\n\nvoid setupVSPro()\n{\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\n    #if _HDRP\n\t    unity_RenderingLayer.x = VSPRenderingLayerMask;\n    #endif\n\n\t#ifdef unity_ObjectToWorld\n\t#undef unity_ObjectToWorld\n\t#endif\n\n\t#ifdef unity_WorldToObject\n\t#undef unity_WorldToObject\n\t#endif\n\n\tunity_ObjectToWorld = VisibleShaderDataBuffer[unity_InstanceID].PositionMatrix;\n\tunity_WorldToObject = VisibleShaderDataBuffer[unity_InstanceID].InversePositionMatrix;\n#endif\n\n}\n\n\n\t#pragma multi_compile _LIGHTMAPMODE_STANDARD _LIGHTMAPMODE_RNM _LIGHTMAPMODE_SH _LIGHTMAPMODE_VERTEX _LIGHTMAPMODE_VERTEXDIRECTIONAL _LIGHTMAPMODE_VERTEXSH\n\n    #pragma shader_feature USEBAKERY\n    #pragma shader_feature BAKERY_VERTEXLMMASK\n    #pragma shader_feature BAKERY_SHNONLINEAR\n    #pragma shader_feature BAKERY_LMSPEC\n    #pragma shader_feature BAKERY_BICUBIC\n    #pragma shader_feature BAKERY_VOLUME\n    #pragma shader_feature BAKERY_VOLROTATION\n    #pragma shader_feature BAKERY_COMPRESSED_VOLUME\n\n    #if _USEBAKERY\n\t    #define _OVERRIDE_BAKEDGI\n        #if BAKERY_VOLUME || (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)) && defined(BAKERY_VERTEXLMMASK)\n            #define _OVERRIDE_SHADOWMASK\n        #endif\n    #endif\n\n\n\n\n\n\n\n\n   #define _URP 1\n\n   #define _ALPHABLEND_ON 1\n#define _ALPHABLEND_ON 1\n#define _SURFACE_TYPE_TRANSPARENT 1\n#define NEED_FACING 1\n\n            // this has to be here or specular color will be ignored. Not in SG code\n            #if _SIMPLELIT\n               #define _SPECULAR_COLOR\n            #endif\n\n\n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl\"\n        \n\n               #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n\n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCCOORD3;\n          float4 texcoord1 : TEXCCOORD4;\n         // float4 texcoord2 : TEXCCOORD5;\n\n          #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n         // float4 texcoord3 : TEXCCOORD6;\n          #endif\n\n          #if LOD_FADE_CROSSFADE\n          float4 screenPos : TEXCOORD7;\n          #endif\n\n          #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n          half4 vertexColor : COLOR_centroid;\n          #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n         // float4 extraV2F0 : TEXCOORD12;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n         // float4 extraV2F1 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n         // float4 extraV2F2 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n         // float4 extraV2F3 : TEXCOORD15;\n         // #endif\n\n          #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n          float4 extraV2F4 : TEXCOORD16_centroid;\n          #endif\n\n          #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n          float4 extraV2F5 : TEXCOORD17_centroid;\n          #endif\n\n          #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n          float4 extraV2F6 : TEXCOORD18_centroid;\n          #endif\n\n          #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n          float4 extraV2F7 : TEXCOORD19_centroid;\n          #endif\n            \n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD9;\n         #endif\n            float4 fogFactorAndVertexLight : TEXCOORD10;\n            float4 shadowCoord : TEXCOORD11;\n         #if UNITY_ANY_INSTANCING_ENABLED\n            uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n            uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n            uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n            FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n      };\n\n\n         \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n   half4 weightTextureMask;\n   \n\n\n   float traxBuffer;\n\n\n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // would love to strip these, but they are used in certain\n               // combinations of the lighting system, and may be used\n               // by the user as well, so no easy way to strip them.\n\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR_centroid;\n                #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                float4 extraV2F4 : TEXCOORD9_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                float4 extraV2F5 : TEXCOORD10_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F6 : TEXCOORD11_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F7 : TEXCOORD12_centroid;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n               #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n               #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n               #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n               #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()     unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n               #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V   unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n               #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V    mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n               #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n               #endif\n               #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n         CBUFFER_START(UnityPerMaterial)\n\n            \n\n\n   half4 _Tint;\n   half _UVSource;\n   half _TriplanarContrast;\n   half _AlbedoContrast;\n   half _AlbedoBrightness;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half3 _EmissionColor;\n   float _DetailUVSource;\n   half _StochasticScale;\n   half _DetailStochasticScale;\n   half _Smoothness;\n   half _Metallic;\n   half2 _SmoothnessRemap;\n   half2 _AORemap;\n   half2 _MetallicRemap;\n   half2 _HeightRemap;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n   half _AlphaThreshold;\n   half _Cutoff; // for Unity's light mapper\n   half _TriplanarSpace;\n   half _DetailTriplanarSpace;\n   half _DetailTriplanarContrast;\n   half _MicroShadowStrength;\n   half3 _FuzzyShadingColor;\n   half _FuzzyShadingOn;\n   half3 _FuzzyShadingParams;\n\n   //int _POMMaxSamples;\n   //float _POMMin;\n   //float _POMFade;\n#if _FLATSHADE\n   half _FlatShadingBlend;\n#endif\n\n   half _StochasticContrast;\n   half _DetailStochasticContrast;\n\n#if _PARALLAX || _POM\n   half _ParallaxHeight;\n#endif\n\n\n\n\tfloat4 _TintMask_ST;\n\thalf3 _RColor;\n\thalf3 _GColor;\n\thalf3 _BColor;\n\thalf3 _AColor;\n\n\n\thalf _LayerTextureMaskUVMode;\n    float4 _LayerTextureMask_ST;\n\n\n   //#if _USELAYER\n       float4 _LayerAlbedoMap_ST;\n       half3 _LayerTint;\n       half _LayerBlendMode;\n       float _LayerUVSource;\n       half _LayerAlbedoBrightness;\n       half _LayerAlbedoContrast;\n       half _LayerHeightContrast;\n       half _LayerStrength;\n       half _LayerAlbedoStrength;\n       half _LayerNormalStrength;\n       half _LayerSmoothnessStrength;\n       half _LayerSmoothness;\n       half _LayerMetallic;\n       half _LayerStochasticScale;\n       half2 _LayerSmoothnessRemap;\n       half2 _LayerAORemap;\n       half2 _LayerMetallicRemap;\n       half2 _LayerHeightRemap;\n       float4 _LayerWeightOverDistance;\n       half _LayerMicroShadowStrength;\n       //#if _LAYERNOISE\n           float _LayerNoiseFrequency;\n           float _LayerNoiseAmplitude;\n           float _LayerNoiseOffset;\n           float _LayerNoiseCenter;\n           half3 _LayerBlendTint;\n       //#endif\n       //#if _LAYERANGLEFILTER\n           half _LayerFalloff;\n           half _LayerAngleMin;\n           half _LayerHeight;\n           half _LayerInvertHeight;\n           half _LayerVertexNormalBlend;\n       //#endif\n       half _LayerTriplanarSpace;\n       half _LayerTriplanarContrast;\n       half _LayerBlendContrast;\n       half3 _LayerEmissionColor;\n       half _LayerStochasticContrast;\n       half _LayerTessStrength;\n       half3 _LayerFuzzyShadingColor;\n       half _LayerFuzzyShadingOn;\n       half3 _LayerFuzzyShadingParams;\n   //#endif\n\n\n   //#if _USELAYER_DEF_1\n       float4 _LayerAlbedoMap_Ext_1_ST;\n       half3 _LayerTint_Ext_1;\n       half _LayerBlendMode_Ext_1;\n       float _LayerUVSource_Ext_1;\n       half _LayerAlbedoBrightness_Ext_1;\n       half _LayerAlbedoContrast_Ext_1;\n       half _LayerHeightContrast_Ext_1;\n       half _LayerStrength_Ext_1;\n       half _LayerAlbedoStrength_Ext_1;\n       half _LayerNormalStrength_Ext_1;\n       half _LayerSmoothnessStrength_Ext_1;\n       half _LayerSmoothness_Ext_1;\n       half _LayerMetallic_Ext_1;\n       half _LayerStochasticScale_Ext_1;\n       half2 _LayerSmoothnessRemap_Ext_1;\n       half2 _LayerAORemap_Ext_1;\n       half2 _LayerMetallicRemap_Ext_1;\n       half2 _LayerHeightRemap_Ext_1;\n       float4 _LayerWeightOverDistance_Ext_1;\n       half _LayerMicroShadowStrength_Ext_1;\n       //#if _LAYERNOISE_DEF_1\n           float _LayerNoiseFrequency_Ext_1;\n           float _LayerNoiseAmplitude_Ext_1;\n           float _LayerNoiseOffset_Ext_1;\n           float _LayerNoiseCenter_Ext_1;\n           half3 _LayerBlendTint_Ext_1;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_1\n           half _LayerFalloff_Ext_1;\n           half _LayerAngleMin_Ext_1;\n           half _LayerHeight_Ext_1;\n           half _LayerInvertHeight_Ext_1;\n           half _LayerVertexNormalBlend_Ext_1;\n       //#endif\n       half _LayerTriplanarSpace_Ext_1;\n       half _LayerTriplanarContrast_Ext_1;\n       half _LayerBlendContrast_Ext_1;\n       half3 _LayerEmissionColor_Ext_1;\n       half _LayerStochasticContrast_Ext_1;\n       half _LayerTessStrength_Ext_1;\n       half3 _LayerFuzzyShadingColor_Ext_1;\n       half _LayerFuzzyShadingOn_Ext_1;\n       half3 _LayerFuzzyShadingParams_Ext_1;\n   //#endif\n\n\n   //#if _USELAYER_DEF_2\n       float4 _LayerAlbedoMap_Ext_2_ST;\n       half3 _LayerTint_Ext_2;\n       half _LayerBlendMode_Ext_2;\n       float _LayerUVSource_Ext_2;\n       half _LayerAlbedoBrightness_Ext_2;\n       half _LayerAlbedoContrast_Ext_2;\n       half _LayerHeightContrast_Ext_2;\n       half _LayerStrength_Ext_2;\n       half _LayerAlbedoStrength_Ext_2;\n       half _LayerNormalStrength_Ext_2;\n       half _LayerSmoothnessStrength_Ext_2;\n       half _LayerSmoothness_Ext_2;\n       half _LayerMetallic_Ext_2;\n       half _LayerStochasticScale_Ext_2;\n       half2 _LayerSmoothnessRemap_Ext_2;\n       half2 _LayerAORemap_Ext_2;\n       half2 _LayerMetallicRemap_Ext_2;\n       half2 _LayerHeightRemap_Ext_2;\n       float4 _LayerWeightOverDistance_Ext_2;\n       half _LayerMicroShadowStrength_Ext_2;\n       //#if _LAYERNOISE_DEF_2\n           float _LayerNoiseFrequency_Ext_2;\n           float _LayerNoiseAmplitude_Ext_2;\n           float _LayerNoiseOffset_Ext_2;\n           float _LayerNoiseCenter_Ext_2;\n           half3 _LayerBlendTint_Ext_2;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_2\n           half _LayerFalloff_Ext_2;\n           half _LayerAngleMin_Ext_2;\n           half _LayerHeight_Ext_2;\n           half _LayerInvertHeight_Ext_2;\n           half _LayerVertexNormalBlend_Ext_2;\n       //#endif\n       half _LayerTriplanarSpace_Ext_2;\n       half _LayerTriplanarContrast_Ext_2;\n       half _LayerBlendContrast_Ext_2;\n       half3 _LayerEmissionColor_Ext_2;\n       half _LayerStochasticContrast_Ext_2;\n       half _LayerTessStrength_Ext_2;\n       half3 _LayerFuzzyShadingColor_Ext_2;\n       half _LayerFuzzyShadingOn_Ext_2;\n       half3 _LayerFuzzyShadingParams_Ext_2;\n   //#endif\n\n\n    half _TraxDisplacementDepth;\n    half _TraxDisplacementStrength;\n    half _TraxMipBias;\n    half _TraxNormalStrength;\n    float4 _TraxAlbedo_ST;\n    half _TraxInterpContrast;\n    half _TraxHeightContrast;\n    half3 _TraxTint;\n\n\n\n    half _Porosity;\n    int _WetnessMode;\n    int _PuddleMode;\n\n    half  _PuddleAmount;\n    half  _PuddleFalloff;\n    half4 _PuddleColor;\n    half _PuddleNoiseFrequency;\n    half _PuddleNoiseAmplitude;\n    half _PuddleNoiseOffset;\n    half _PuddleNoiseCenter;\n    half _PuddleAngleMin;\n\n    half _WetnessAmount;\n\thalf _WetnessMin;\n    half _WetnessMax;\n    half _WetnessFalloff;\n\thalf _WetnessAngleMin;\n    float _WetnessShoreline;\n\n    int _RainMode;\n    half3 _RainIntensityScale;\n\n\n\n\n    float4 _SnowAlbedo_ST;\n    half3 _SnowTint;\n    half _SnowAmount;\n    half _SnowAngle;\n    half _SnowContrast;\n    half _SnowVertexHeight;\n    half _SnowMode;\n    half3 _SnowWorldFade; // z is on/off\n    float4 _SnowTraxAlbedo_ST;\n    half3 _SnowTraxTint;\n\n    half _SnowNoiseFreq; \n    half _SnowNoiseAmp;\n    half _SnowNoiseOffset;\n    half _SnowStochasticContrast;\n    half _SnowStochasticScale;\n\n\n    half     _WindParticulateSpace;\n    half     _WindParticulateRotation;\n    half      _WindParticulateSpeed;\n    float4     _WindParticulate_ST;\n    half      _WindParticulatePower;\n    half4    _WindParticulateColor;\n    half4    _WindParticulateWorldHeightMask;\n    half4    _WindParticulateAngleMask;\n    half      _WindParticulateOcclusionStrength;\n    half      _WindParticulateStrength;\n    half4    _WindParticulateEmissive;\n    half     _WindParticulateTextureHeight;\n\n\n   float _DoubleSidedNormalMode;\n\n\n\thalf _AutoNormalStrength;\n\n\n\tint _DebugSampleCountThreshold;\n\n\n\thalf _DissolveAmount;\n\thalf _DissolveEmissiveStr;\n\thalf _DissolveEdgeContrast;\n\thalf _DissolveColoration;\n\tfloat4 _DissolveTexture_ST;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n         CBUFFER_END\n\n         \n\n         \n\n         #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\n#ifndef __STACKABLEFUNCLIBRARY_INCLUDES__\n#define __STACKABLEFUNCLIBRARY_INCLUDES__\n\n   #if _DEBUG_SAMPLECOUNT\n      int _sampleCount;\n      #define COUNTSAMPLE { _sampleCount++; }\n   #else\n      #define COUNTSAMPLE\n   #endif\n\n   TEXTURE2D(_NoiseTex);\n   SAMPLER(sampler_NoiseTex);\n\n\n\n   half3 AdjustContrast(half3 color, half contrast)\n   {\n       half3 comp = 0.5;\n   #if !UNITY_COLORSPACE_GAMMA\n       comp = 0.22;\n   #endif\n       color = saturate(lerp(comp, color, contrast));\n       return color;\n   }\n\n   float2 DoParallaxOffset( half h, half height, half3 viewDir)\n   {\n      h = h * height - height/2.0;\n      float3 v = normalize(viewDir);\n      v.z += 0.42;\n      return h * (v.xy / v.z);\n   }\n\n\n\n   #define SAMPLEBARY SampleTexBary\n\n   struct SampleConfig\n   {\n      float2 uv0;\n      float2 uv1;\n      float2 uv2;\n      float2 dx0;\n      float2 dy0;\n      float2 dx1;\n      float2 dy1;\n      float2 dx2;\n      float2 dy2;\n      float3 weights;\n      float3 origWeights;\n   };\n\n   struct Config\n   {\n      float2 origUV; // unscaled uv\n      float2 origScale;\n      float2 uv;        // no stocastic or triplanar\n      float2 dx;\n      float2 dy;\n      SampleConfig uvT; // just stochastic, or just triplanar\n      SampleConfig uvX; // stochastic and triplanar\n      SampleConfig uvY;\n      SampleConfig uvZ;\n\n      \n      float3 absVertNormal;\n      half3 axisSign;\n      float3 normal;\n   };\n\n\n    float2 Hash2D( float2 x )\n    {\n        float2 k = float2( 0.3183099, 0.3678794 );\n        x = x*k + k.yx;\n        return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );\n    }\n\n    float Noise2D(float2 p )\n    {\n        float2 i = floor( p );\n        float2 f = frac( p );\n         \n        float2 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), \n                        dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),\n                    lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), \n                        dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);\n    }\n      \n\n    float2 WorleyHash2D(float2 p)\n    {\n \t    return frac(cos(mul(p, float2x2(-64.2,71.3,81.4,-29.8)))*8321.3); \n    }\n    float WorleyNoise2D(float2 p)\n    {\n        float dist = 1;\n        float2 i = floor(p);\n        float2 f = frac(p);\n    \n        for(int x = -1;x<=1;x++)\n        {\n            for(int y = -1;y<=1;y++)\n            {\n                float d = distance(WorleyHash2D(i+float2(x,y))+float2(x,y),f);\n                dist = min(dist,d);\n            }\n        }\n        return dist;\n\t\n    }\n\n#ifndef PI\n    #define PI 3.14159265359\n#endif\n\n    float GetIntegerNoise(float2 p)\n    {\n        p  = 53.7 * frac( (p*0.3183099) + float2(0.71,0.113));\n        return frac( p.x*p.y*(p.x+p.y) );\n    }\n\n    float WorleyHash3D(float f)\n    {\n        return frac(sin(f)*43758.5453);\n    }\n\n    float WorleyHash31(float3 v)\n    {\n        return WorleyHash3D(dot(v, float3(253.14, 453.74, 183.3)));\n    }\n\n    float3 WorleyRandom3D( float3 p )\n    {\n        return frac(sin(float3(dot(p,float3(127.1,311.7,217.3)),dot(p,float3(269.5,183.3,431.1)), dot(p,float3(365.6,749.9,323.7))))*437158.5453);\n    }\n\n    float WorleyNoise3D(float3 uvw)\n    {\n        float noise = 0.0;\n    \n        float3 p = floor(uvw);\n        float3 f = frac(uvw);\n    \n        float4 res = 1;\n        for(int x = -1; x <=1; ++x)\n        {\n            for(int y = -1; y <=1; ++y)\n            {\n                for(int z = -1; z <=1; ++z)\n                {\n                    float3 gp = p + float3(x, y, z);\n\n                    float3 v = WorleyRandom3D(gp);\n\n\t\t\t\t    float3 diff = gp + v - uvw;\n                \n                    float d = length(diff);\n                \n                    if(d < res.x)\n                    {\n                        res.xyz = float3(d, res.x, res.y);\n                    }\n                    else if(d < res.y)\n                    {\n                        res.xyz = float3(res.x, d, res.y);\n                    }\n                    else if(d < res.z)\n                    {\n                        res.z = d;\n                    }\n                \n                    res.w = WorleyHash31(gp);\n                }\n            }\n        }\n\n        return res.x;\n    }\n    \n      \n    float3 Hash3D( float3 p )\n    {\n        p = float3( dot(p,float3(127.1,311.7, 74.7)),\n                dot(p,float3(269.5,183.3,246.1)),\n                dot(p,float3(113.5,271.9,124.6)));\n\n        return -1.0 + 2.0*frac(sin(p)*437.5453123);\n    }\n\n    float Noise3D( float3 p )\n    {\n        float3 i = floor( p );\n        float3 f = frac( p );\n         \n        float3 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),\n                    lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n    }\n\n    \n    float FBM2D(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           return SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n\n    }\n      \n    float FBM3D(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           half A = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.zy).g;\n           half B = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33).g;\n           half C = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoise(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3D(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3D(d.localSpacePosition * frequency+ offset, d.localSpaceNormal);\n        #else\n           return FBM2D(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n    \n    #if _SURFACEGRADIENT  \n\n    #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)\n\n      \n      \n    half3 SurfaceGradientFromTBN(ShaderData d, half2 deriv)\n    {\n        return deriv.x * d.TBNMatrix[0] + deriv.y * d.TBNMatrix[1];\n    }\n\n    half2 TspaceNormalToDerivative(half3 vM)\n    {\n        const half scale = 1.0/128.0;\n        const half3 vMa = abs(vM);\n        const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));\n\n        return -half2(vM.x, vM.y)/z_ma;\n    }\n\n    half3 SurfgradFromVolumeGradient(ShaderData d, half3 grad)\n    {\n        return grad - dot(d.worldSpaceNormal, grad) * d.worldSpaceNormal;\n    }\n\n    half3 SurfgradFromTriplanarProjection(ShaderData d, half3 pN, half3 xN, half3 yN, half3 zN)\n    {\n        const half w0 = pN.x;\n        const half w1 = pN.y;\n        const half w2 = pN.z;\n\n        half2 xD = TspaceNormalToDerivative(xN);\n        half2 yD = TspaceNormalToDerivative(yN);\n        half2 zD = TspaceNormalToDerivative(zN);\n\n        half3 volumeGrad = half3(w2 * zD.x + w1 * yD.y, w2 * zD.y + w0 * xD.y, w0 * xD.x + w1 * yD.x);\n\n        return SurfgradFromVolumeGradient(d, volumeGrad);\n    }\n\n    half3 ConvertNormalToGradient(ShaderData d, half3 normal)\n    {\n        half2 deriv = TspaceNormalToDerivative(normal);\n\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n    half3 ConvertNormal2ToGradient(ShaderData d, half2 packedNormal)\n    {\n        half2 tNormal = packedNormal;\n        half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF\n        half2 deriv = tNormal * -rcpZ;\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n\n    half3 ResolveNormalFromSurfaceGradient(ShaderData d, half3 gradient)\n    {\n        return normalize(d.worldSpaceNormal - gradient);\n    }\n\n    #endif // _SURFACEGRADIENT\n\n\n    // normals are in surface gradient or world space depending on settings, and can also be generated by height\n    half3 GetWorldSpaceNormal(ShaderData d, half3 normal, half pheight)\n    {\n       #if _SURFACEGRADIENT\n          return ResolveNormalFromSurfaceGradient(d, normal);\n       #elif _AUTONORMAL\n          float3 dx = ddx(d.worldSpacePosition);\n          float3 dy = ddy(d.worldSpacePosition);\n          float3 crossX = cross(float3(0,1,0), dx);\n          float3 crossY = cross(float3(0,1,0), dy);\n          float3 dt = abs(dot(crossY, dx));\n          float height = _AutoNormalStrength * 0.5 * pheight;\n          float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n          n.y *= -1.0;\n          return TangentToWorldSpace(d, normalize((dt * float3(0,1,0)) - n).xzy);\n       #else\n          return TangentToWorldSpace(d, normal);\n          \n       #endif\n       \n    }\n\n   void WaterBRDF (inout half3 albedo, inout half smoothness, half metallic, half wetFactor, half surfPorosity) \n   {\n      half porosity = saturate((( (1 - smoothness) - 0.5)) / max(surfPorosity, 0.001));\n      half factor = lerp(1, 0.2, (1 - metallic) * porosity);\n      albedo *= lerp(1.0, factor, wetFactor);\n      smoothness = lerp(smoothness, 0.92f, wetFactor);\n   }\n\n   void OffsetUV(inout Config c, float2 offset)\n   {\n       c.uv += offset;\n       c.uvT.uv0 += offset;\n       c.uvT.uv1 += offset;\n       c.uvT.uv2 += offset;\n       c.uvX.uv0 += offset;\n       c.uvX.uv1 += offset;\n       c.uvX.uv2 += offset;\n       c.uvY.uv0 += offset;\n       c.uvY.uv1 += offset;\n       c.uvY.uv2 += offset;\n       c.uvZ.uv0 += offset;\n       c.uvZ.uv1 += offset;\n       c.uvZ.uv2 += offset;\n   }\n\n\n    void TriangleGrid(float2 uv, float scale,\n       out float w1, out float w2, out float w3,\n       out int2 vertex1, out int2 vertex2, out int2 vertex3)\n    {\n       // Scaling of the input\n       uv *= 3.464 * scale; // 2 * sqrt(3)\n\n       // Skew input space into simplex triangle grid\n       const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);\n       float2 skewedCoord = mul(gridToSkewedGrid, uv);\n\n       // Compute local triangle vertex IDs and local barycentric coordinates\n       int2 baseId = int2(floor(skewedCoord));\n       float3 temp = float3(frac(skewedCoord), 0);\n       temp.z = 1.0 - temp.x - temp.y;\n       if (temp.z > 0.0)\n       {\n          w1 = temp.z;\n          w2 = temp.y;\n          w3 = temp.x;\n          vertex1 = baseId;\n          vertex2 = baseId + int2(0, 1);\n          vertex3 = baseId + int2(1, 0);\n       }\n       else\n       {\n          w1 = -temp.z;\n          w2 = 1.0 - temp.y;\n          w3 = 1.0 - temp.x;\n          vertex1 = baseId + int2(1, 1);\n          vertex2 = baseId + int2(1, 0);\n          vertex3 = baseId + int2(0, 1);\n       }\n    }\n\n    // Fast random hash function\n    float2 SimpleHash2(float2 p)\n    {\n       return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 43758.5453);\n    }\n\n\n    half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)\n    {\n        // compute weight with height map\n        const half epsilon = 1.0f / 1024.0f;\n        half3 weights = half3(iWeights.x * (tex0 + epsilon), \n                                 iWeights.y * (tex1 + epsilon),\n                                 iWeights.z * (tex2 + epsilon));\n\n        // Contrast weights\n        half maxWeight = max(weights.x, max(weights.y, weights.z));\n        half transition = contrast * maxWeight;\n        half threshold = maxWeight - transition;\n        half scale = 1.0f / transition;\n        weights = saturate((weights - threshold) * scale);\n        // Normalize weights.\n        half weightScale = 1.0f / (weights.x + weights.y + weights.z);\n        weights *= weightScale;\n        return weights;\n    }\n\n\n    half3 PackedUnpackScaleNormal(half4 packedNormal, float scale)\n   {\n       #if _PACKEDFAST\n          half3 normal;\n          normal.xy = (packedNormal.ag * 2 - 1) * scale;\n          normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n          return normal;  \n       #endif\n       return UnpackScaleNormal(packedNormal, scale);\n   }\n\n    void InitStochasticDxDy(inout SampleConfig c, Config cfg)\n    {\n      c.dx0 = ddx(cfg.origUV) * cfg.origScale;\n      c.dy0 = ddy(cfg.origUV) * cfg.origScale;\n      c.dx1 = c.dx0; c.dx1 = c.dx0;\n      c.dx2 = c.dy0; c.dy2 = c.dy0;\n    }\n\n    void PrepareStochasticUVs(float scale, float2 uv, out SampleConfig c)\n    {\n       // Get triangle info\n       ZERO_INITIALIZE(SampleConfig, c);\n       float w1, w2, w3;\n       int2 vertex1, vertex2, vertex3;\n       TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n       // Assign random offset to each triangle vertex\n       c.uv0 = uv;\n       c.uv1 = uv;\n       c.uv2 = uv;\n   \n       c.uv0.xy += SimpleHash2(vertex1);\n       c.uv1.xy += SimpleHash2(vertex2);\n       c.uv2.xy += SimpleHash2(vertex3);\n       c.weights = half3(w1, w2, w3);\n       c.origWeights = half3(w1, w2, w3);\n    }\n\n\n   half3 LitBlendDetailNormal(half3 n1, half3 n2)\n   {\n      #if _SURFACEGRADIENT\n         return n1 + n2;\n      #else\n         return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n      #endif\n   }\n\n   float3 TriplanarBlendUnpackedRNM(float3 n1, float3 n2)\n   {\n       n1.z += 1;\n       n2.xy = -n2.xy;\n       return n1 * dot(n1, n2) / n1.z - n2;\n   }\n\n   void InitConfigDxDy(inout Config c)\n   {\n      c.uvT.dx0 = ddx(c.uvT.uv0);\n      c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1);\n      c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2);\n      c.uvT.dy2 = ddy(c.uvT.uv2);\n   }\n\n   Config CreateConfig(ShaderData d, float4 scale, float space, int uvsource, half triplanarContrast)\n   {\n      Config c;\n      ZERO_INITIALIZE(Config, c);\n\n      float3 pos = d.worldSpacePosition;\n      float3 normal = d.worldSpaceNormal;\n      if (space > 0)\n      {\n         pos = d.localSpacePosition;\n         normal = d.localSpaceNormal;\n      }\n\n      c.uv = d.texcoord0.xy;\n      \n      if (uvsource == 1)\n        c.uv = d.texcoord1.xy;\n      else if (uvsource == 2)\n        c.uv = pos.yz * float2(1, -1);\n      else if (uvsource == 3)\n        c.uv = pos.xz * float2(1, -1);\n      else if (uvsource == 4)\n        c.uv = pos.xy * float2(1, -1);\n\n      c.origUV = c.uv;\n      c.origScale = scale.xy;\n\n      c.uv = c.uv * scale.xy + scale.zw;\n      c.dx = ddx(c.uv);\n      c.dy = ddy(c.uv);\n\n      c.normal = normal;\n      c.uvT.uv0 = pos.zy * scale.xy + scale.zw;\n      c.uvT.uv1 = pos.xz * scale.xy + scale.zw;\n      c.uvT.uv2 = pos.xy * scale.xy + scale.zw;\n        \n      c.uvT.uv1 += 0.33;\n      c.uvT.uv2 += 0.67;\n\n      c.uvT.dx0 = ddx(c.uvT.uv0); c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1); c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2); c.uvT.dy2 = ddy(c.uvT.uv2);\n\n      half3 triblend = saturate(pow(abs(c.normal), triplanarContrast));\n      triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n      c.uvT.weights = triblend;\n      c.uvT.origWeights = triblend;\n      c.axisSign = d.worldSpaceNormal < 0 ? -1 : 1;\n      c.absVertNormal = abs(d.worldSpaceNormal);\n     \n\n      return c;\n   }\n\n\n   half4 TriSample(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0) * c.weights.x;\n      }\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1) * c.weights.y;\n      }  \n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2) * c.weights.z;\n      }\n\n      return res;\n   }\n\n   half4 TriSampleBary(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      c.weights = BaryWeightBlend(c.origWeights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   half4 TriSampleGrad(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvX, contrast, d) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvY, contrast, d) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n           res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvZ, contrast, d) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   \n   half4 SampleTexBaryStochastic(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   half4 SampleTexBaryTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleGrad(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   \n   half4 SampleTexBary(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        COUNTSAMPLE\n        return SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv, c.dx, c.dy);\n   }\n\n   half4 SampleTexStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ) * c.uvT.weights.z;\n\n        return res;     \n   }\n\n   \n   half4 SampleTexStochastic(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n\n   half4 SampleTexTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n   \n   half4 SampleTex(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       COUNTSAMPLE\n       return SAMPLE_TEXTURE2D(tex, ss, c.uv);\n   }\n   \n\n \n   half3 SampleNormalStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n         dataX = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n         dataY = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n         dataZ = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ));\n\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n\n          return WorldToTangentSpace(d, worldNormal);\n       #endif\n   }\n\n\n   half3 SampleNormalTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n      {\n          COUNTSAMPLE\n          dataX = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv0, c.uvT.dx0, c.uvT.dy0));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n      {\n          COUNTSAMPLE\n          dataY = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv1, c.uvT.dx1, c.uvT.dy1));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n      {\n         COUNTSAMPLE\n         dataZ = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv2, c.uvT.dx2, c.uvT.dy2));\n      }\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n          return WorldToTangentSpace(d, worldNormal);\n      #endif\n   }\n\n   half3 SampleNormalStochastic(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n     half4 normal = TriSample(tex, ss, c.uvT);\n     #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half3 SampleNormal(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 normal = SAMPLE_TEXTURE2D(tex, ss, c.uv);\n      #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half HeightBlend(half h1, half h2, half slope, half contrast)\n   {\n      h2 = 1 - h2;\n      half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); \n      half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));\n      return blend;\n   }\n\n\n    #if _POM\n    float2 POM(TEXTURE2D_PARAM(tex, ss), Config c, float contrast, ShaderData d)\n    {\n       float2 curv = float2(0, 0);\n       float refPlane = 0;\n\n       float result = 0;\n       int stepIndex = 0;\n       int maxSamples = _POMMaxSamples;\n       int minSamples = 4;\n       float camDist = distance(_WorldSpaceCameraPos, d.worldSpacePosition);\n       float distanceFade = 1 - saturate((camDist - _POMMin) / max(1, _POMFade));\n       int numSteps = ( int )lerp( maxSamples, minSamples, dot( d.worldSpaceNormal, d.worldSpaceViewDir )) * distanceFade;\n       if (numSteps < 1)\n           numSteps = 1;\n       float layerHeight = 1.0 / numSteps;\n       float2 plane = _ParallaxHeight * ( d.tangentSpaceViewDir.xy / d.tangentSpaceViewDir.z ) * distanceFade;\n       OffsetUV(c, refPlane * plane);\n       float2 deltaTex = -plane * layerHeight;\n       float2 prevTexOffset = 0;\n       float prevRayZ = 1.0f;\n       float prevHeight = 0.0f;\n       float2 currTexOffset = deltaTex;\n       float currRayZ = 1.0f - layerHeight;\n       float currHeight = 0.0f;\n       float intersection = 0;\n       float2 finalTexOffset = 0;\n\n       while ( stepIndex < numSteps + 1 )\n       {\n          result = dot( curv, currTexOffset * currTexOffset );\n          Config cfg = c;\n          OffsetUV(cfg, currTexOffset);\n          currHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( currHeight > currRayZ )\n          {\n             stepIndex = numSteps + 1;\n          }\n          else\n          {\n             stepIndex++;\n             prevTexOffset = currTexOffset;\n             prevRayZ = currRayZ;\n             prevHeight = currHeight;\n             currTexOffset += deltaTex;\n             currRayZ -= layerHeight * ( 1 - result );\n          }\n       }\n       int sectionSteps = 10;\n       int sectionIndex = 0;\n       float newZ = 0;\n       float newHeight = 0;\n       while ( sectionIndex < sectionSteps )\n       {\n          intersection = ( prevHeight - prevRayZ ) / ( prevHeight - currHeight + currRayZ - prevRayZ );\n          finalTexOffset = prevTexOffset + intersection * deltaTex;\n          newZ = prevRayZ - intersection * layerHeight;\n          Config cfg = c;\n          OffsetUV(cfg, finalTexOffset);\n          newHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( newHeight > newZ )\n          {\n             currTexOffset = finalTexOffset;\n             currHeight = newHeight;\n             currRayZ = newZ;\n             deltaTex = intersection * deltaTex;\n             layerHeight = intersection * layerHeight;\n          }\n          else\n          {\n             prevTexOffset = finalTexOffset;\n             prevHeight = newHeight;\n             prevRayZ = newZ;\n             deltaTex = ( 1 - intersection ) * deltaTex;\n             layerHeight = ( 1 - intersection ) * layerHeight;\n          }\n          sectionIndex++;\n       }\n       #if _PASSHADOWS\n       if ( unity_LightShadowBias.z == 0.0 )\n       {\n       #endif\n          if ( result > 1 )\n             clip( -1 );\n       #if _PASSHADOWS\n       }\n       #endif\n       return finalTexOffset;\n    }\n    #endif\n\n   \n\n   // tess versions\n   #if _TESSELLATION_ON\n   half4 TriSampleLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias) * c.weights.x;\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias) * c.weights.y;\n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias) * c.weights.z;\n\n      return res;\n   }\n\n   half4 TriSampleBaryLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias, float contrast)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias);\n      half4 r2 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias);\n      half4 r3 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias);\n      c.weights = BaryWeightBlend(c.weights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryLODStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvX, bias, contrast) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvY, bias, contrast) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvZ, bias, contrast) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   half4 SampleTexBaryLODStochastic(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n       return TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias, contrast);\n   }\n\n   half4 SampleTexBaryLODTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return TriSampleLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias);\n   }\n\n   half4 SampleTexBaryLOD(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv, bias);\n   }\n\n\n    float FBM2DLOD(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           return SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv, _TessellationMipBias).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n        \n        \n    }\n\n    float FBM3DLOD(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           half A = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.zy, _TessellationMipBias).g;\n           half B = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33, _TessellationMipBias).g;\n           half C = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67, _TessellationMipBias).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoiseLOD(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3DLOD(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3DLOD(d.localSpacePosition * frequency + offset, d.localSpaceNormal);\n        #else\n           return FBM2DLOD(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n   #endif //_TESSELLATION_ON\n\n\n    half3 FuzzyShade(ShaderData d, half height, half3 color, half3 normal, half coreMult, half edgeMult, half power)\n    {\n        float3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half dt = saturate(dot(d.worldSpaceViewDir, worldNormal));\n        half dark = 1.0 - (coreMult * dt);\n        half edge = pow(1-dt, abs(power)) * edgeMult;\n        return color * (dark + edge);\n    }\n\n\thalf MicroShadow(ShaderData d, half3 normal, half height, half ao, half strength)\n\t{\n        float3 sun;\n\t\tfloat3 sunColor;\n\t\tGetSun(sun, sunColor);\n\t\tfloat3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half shadow = saturate(abs(dot(worldNormal, sun)) + (ao * ao * 2.0) - 1.0);\n        return 1 - ((1-shadow) * strength);\n\t}\n\n\n#endif\n\n\n\n   #if defined(_SPECULAR)\n      #define _USESPECULAR 1\n      #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n   #endif\n\n   \n   TEXTURE2D(_AlbedoMap);\n   SAMPLER(sampler_AlbedoMap);\n   TEXTURE2D(_NormalMap);\n   SAMPLER(sampler_NormalMap);\n   TEXTURE2D(_MaskMap);\n   TEXTURE2D(_DetailMap);\n   TEXTURE2D(_EmissionMap);\n\n   #if _SPECULAR\n       TEXTURE2D(_SpecularMap);\n   #endif\n\n   \n   \n   void Ext_SurfaceFunction0 (inout Surface o, inout ShaderData d)\n   {\n      // define samplers based on settings\n      #undef SAMPLEBARY\n      #undef SAMPLE\n      #undef SAMPLENORMAL\n      #if _STOCHASTIC && _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n        #define SAMPLE     SampleTexStochasticTriplanar\n        #define SAMPLENORMAL SampleNormalStochasticTriplanar\n      #elif _STOCHASTIC\n        #define SAMPLEBARY SampleTexBaryStochastic\n        #define SAMPLE     SampleTexStochastic\n        #define SAMPLENORMAL SampleNormalStochastic\n      #elif _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryTriplanar\n        #define SAMPLE     SampleTexTriplanar\n        #define SAMPLENORMAL SampleNormalTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBary\n        #define SAMPLE     SampleTex\n        #define SAMPLENORMAL SampleNormal\n      #endif\n\n      Config c = CreateConfig(d, _AlbedoMap_ST, _TriplanarSpace, _UVSource, _TriplanarContrast);\n      InitConfigDxDy(c);\n      #if _STOCHASTIC && !_TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uv, c.uvT);\n         InitStochasticDxDy(c.uvT, c);\n      #elif _STOCHASTIC && _TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv0, c.uvX);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv1, c.uvY);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv2, c.uvZ);\n         InitStochasticDxDy(c.uvX, c);\n         InitStochasticDxDy(c.uvY, c);\n         InitStochasticDxDy(c.uvZ, c);\n      #endif\n\n      #if _POM\n          // would need to handle height remapping if we ever want to ship this\n          float2 pomOffset = POM(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n          OffsetUV(c, pomOffset);\n      #endif\n\n      half4 albedo = SAMPLEBARY(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n      \n      #if _PARALLAX\n         float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n         OffsetUV(c, offset);\n         albedo = SAMPLE(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c);\n         \n      #endif\n      albedo.a = lerp(_HeightRemap.x, _HeightRemap.y, albedo.a);\n      albedo.rgb *= _Tint.rgb;\n\n      albedo.rgb = AdjustContrast(albedo.rgb, _AlbedoContrast);\n      albedo.rgb += _AlbedoBrightness;\n\n\n      if (_AlphaThreshold > 0)\n      {\n         clip(albedo.a - _AlphaThreshold);\n      }\n\n      #if defined(_FLATSHADE)\n\t\t     float3 dx = ddx(d.worldSpacePosition);\n\t\t     float3 dy = ddy(d.worldSpacePosition);\n\t\t     float3 worldNormal = normalize(cross(dy, dx));\n\t\t     worldNormal = lerp(d.worldSpaceNormal, worldNormal, _FlatShadingBlend);\n\t\t     d.worldSpaceNormal = worldNormal;\n\t\t     d.TBNMatrix[2] = worldNormal;\n      #endif\n\n\n\n      o.Albedo = albedo.rgb;\n      o.Alpha = albedo.a;\n\n      float smoothness = _Smoothness;\n      float ao = 1;\n\n      #if defined(_NORMALMAP) && !defined(_AUTONORMAL)\n         o.Normal = SAMPLENORMAL(TEXTURE2D_ARGS(_NormalMap, sampler_NormalMap), c, d, _NormalStrength, smoothness, ao);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, ao);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n      #endif\n\n      half detailMask = 1;\n      o.Smoothness = smoothness;\n      o.Occlusion = ao;\n      o.Metallic = _Metallic;\n      #if defined(_MASKMAP) && !_PACKEDFAST\n         // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = SampleTex(TEXTURE2D_ARGS(_MaskMap, sampler_AlbedoMap), c);\n         o.Metallic = lerp(_MetallicRemap.x, _MetallicRemap.y, mask.r);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, mask.g);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, mask.a);\n         detailMask = mask.b;\n      #endif // separate maps\n\n      #if _SPECULAR\n         o.Specular = SAMPLE(TEXTURE2D_ARGS(_SpecularMap, sampler_AlbedoMap), c).rgb;\n      #endif\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = SAMPLE(TEXTURE2D_ARGS(_EmissionMap, sampler_AlbedoMap), c).rgb * _EmissionColor;\n      #endif\n\n      if (_FuzzyShadingOn > 0)\n      {\n        o.Albedo *= FuzzyShade(d, albedo.a, _FuzzyShadingColor, o.Normal, _FuzzyShadingParams.x, _FuzzyShadingParams.y, _FuzzyShadingParams.z);\n      }\n\n\n      // HDRP style detail texturing\n\n      #if defined(_DETAIL)\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _DETAILSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n         Config dc = CreateConfig(d, _DetailMap_ST, _DetailTriplanarSpace, _DetailUVSource, _DetailTriplanarContrast);\n         InitConfigDxDy(dc);\n         #if _DETAILSTOCHASTIC && !_DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uv, dc.uvT);\n             InitStochasticDxDy(dc.uvT, dc);\n         #elif _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv0, dc.uvX);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv1, dc.uvY);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv2, dc.uvZ);\n             InitStochasticDxDy(dc.uvX, dc);\n             InitStochasticDxDy(dc.uvY, dc);\n             InitStochasticDxDy(dc.uvZ, dc);\n         #endif\n\n         half4 detailSample = SAMPLEBARY(TEXTURE2D_ARGS(_DetailMap, sampler_AlbedoMap), dc, _DetailStochasticContrast, d);\n         smoothness = detailSample.z;\n         #if !_AUTONORMAL\n            half3 dnormal = float3(detailSample.ag * 2 - 1, 1) * detailMask * _DetailNormalStrength;\n            dnormal.z = sqrt(1 - dnormal.x * dnormal.x - dnormal.y * dnormal.y);\n            #if _SURFACEGRADIENT\n               dnormal = ConvertNormalToGradient(d, dnormal);\n            #endif\n            o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n         #endif\n     \n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * smoothness, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n      if (_MicroShadowStrength > 0)\n      {\n        o.Occlusion *= MicroShadow(d, o.Normal, o.Alpha, o.Occlusion, _MicroShadowStrength);\n      }\n  \n      // in case something needs height in the stack..\n      o.Height = o.Alpha;\n\n\n      \n   }\n\n\n\n\t#if _TINTMASK\n\t\tTEXTURE2D(_TintMask);\n\t\tSAMPLER(sampler_TintMask);\n\t#endif\n\n\tvoid Ext_SurfaceFunction1 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _TINTMASK\n\t\t   half4 w = SAMPLE_TEXTURE2D(_TintMask, sampler_TintMask, d.texcoord0.xy * _TintMask_ST.xy + _TintMask_ST.zw);\n\t\t   // allow black to be no tint..\n\t\t   half3 tint = o.Albedo * (_RColor.rgb * 2 * w.r + _GColor.rgb * 2 * w.g + _BColor.rgb * 2 * w.b + _AColor.rgb * 2 * w.a);\n\t\t   o.Albedo = lerp(o.Albedo, tint, saturate(w.r + w.g + w.b + w.a));\n\t\t#endif\n\t}\n\n\n\n\n\t#if _LAYERTEXTUREMASK\n       TEXTURE2D(_LayerTextureMask);\n       SAMPLER(sampler_LayerTextureMask); \n    #endif\n\n   void Ext_ModifyTessellatedVertex2 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON\n          float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n\n          #if _LAYERTEXTUREMASK\n               float2 layerUV = v.texcoord0.xy;\n               if (_LayerTextureMaskUVMode == 1)\n                  layerUV = v.texcoord1.xy;\n               else if (_LayerTextureMaskUVMode == 2)\n                  layerUV = worldSpacePosition.yz;\n               else if (_LayerTextureMaskUVMode == 3)\n                  layerUV = worldSpacePosition.xz;\n               else if (_LayerTextureMaskUVMode == 4)\n                  layerUV = worldSpacePosition.xy;\n\n              e.blackboard.weightTextureMask = SAMPLE_TEXTURE2D_LOD(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw, _TessellationMipBias);\n          #endif\n      #endif\n    }\n\n\n\tvoid Ext_SurfaceFunction2 (inout Surface o, inout ShaderData d)\n\t{\n\t\t#if _LAYERTEXTUREMASK\n           float2 layerUV = d.texcoord0.xy;\n           if (_LayerTextureMaskUVMode == 1)\n              layerUV = d.texcoord1.xy;\n           else if (_LayerTextureMaskUVMode == 2)\n              layerUV = d.worldSpacePosition.yz;\n           else if (_LayerTextureMaskUVMode == 3)\n              layerUV = d.worldSpacePosition.xz;\n           else if (_LayerTextureMaskUVMode == 4)\n              layerUV = d.worldSpacePosition.xy;\n\n          d.blackboard.weightTextureMask = SAMPLE_TEXTURE2D(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw);\n      #endif\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap);\n   SAMPLER(sampler_LayerAlbedoMap);\n   TEXTURE2D(_LayerNormalMap);\n   TEXTURE2D(_LayerMaskMap);\n   TEXTURE2D(_LayerEmissionMap);\n\n   \n\n   void Ext_ModifyTessellatedVertex3 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER) && defined(_LAYERALBEDO) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n         half detailMask = 1;\n         #if _LAYERNOISE\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency,  _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin;\n            dt = saturate(dt * _LayerFalloff);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight) * _LayerFalloff);\n            if (_LayerInvertHeight > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength;\n         detailMask *= _LayerTessStrength;\n\n         #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast).a;\n         albedo = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo);\n\n         if (_LayerBlendMode == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction3 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n            // noise up the mask\n            #if _LAYERNOISE\n               mask = DoNoise(d, _LayerNoiseFrequency, _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend);\n\t    \n                dt -= _LayerAngleMin;\n                dt = saturate(dt * _LayerFalloff);\n\n                float hf = saturate((o.Height - _LayerHeight) * _LayerFalloff);\n                if (_LayerInvertHeight > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 0\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 0\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength;\n\n            #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint, 0.5);\n            #if defined(_LAYERALBEDO)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c, _LayerStochasticContrast, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c);\n                #endif\n                albedo.rgb *= _LayerTint;\n                albedo.a = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL || _LAYERMASK\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap, sampler_LayerAlbedoMap, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast);\n            albedo.rgb += _LayerAlbedoBrightness;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap, sampler_LayerAlbedoMap), c, d, _LayerNormalStrength * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO)\n                if (_LayerFuzzyShadingOn > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor.rgb, dnormal,\n                                            _LayerFuzzyShadingParams.x, _LayerFuzzyShadingParams.y, _LayerFuzzyShadingParams.z);\n                }\n\n                if (_LayerBlendMode == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast);\n                else if (_LayerBlendMode == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE\n                      float maskDif = (_LayerBlendContrast * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength);\n                   #if _LAYERNOISE\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap, sampler_LayerAlbedoMap), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength);\n                }\n\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap, sampler_LayerAlbedoMap), c).rgb * _LayerEmissionColor;\n                #if _LAYERALBEDO\n                    if (_LayerBlendMode > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_1);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_1);\n   TEXTURE2D(_LayerNormalMap_Ext_1);\n   TEXTURE2D(_LayerMaskMap_Ext_1);\n   TEXTURE2D(_LayerEmissionMap_Ext_1);\n\n   \n\n   void Ext_ModifyTessellatedVertex4 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_1) && defined(_LAYERALBEDO_DEF_1) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_1\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_1,  _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_1\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_1;\n            dt = saturate(dt * _LayerFalloff_Ext_1);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n            if (_LayerInvertHeight_Ext_1 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_1;\n         detailMask *= _LayerTessStrength_Ext_1;\n\n         #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_1).a;\n         albedo = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo);\n\n         if (_LayerBlendMode_Ext_1 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_1);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_1 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction4 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_1)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_1\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_1, _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_1\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_1);\n\t    \n                dt -= _LayerAngleMin_Ext_1;\n                dt = saturate(dt * _LayerFalloff_Ext_1);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n                if (_LayerInvertHeight_Ext_1 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 01\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 01\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_1;\n\n            #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_1, 0.5);\n            #if defined(_LAYERALBEDO_DEF_1)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, _LayerStochasticContrast_Ext_1, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_1;\n                albedo.a = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_1 || _LAYERMASK_DEF_1\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_1);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_1;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, d, _LayerNormalStrength_Ext_1 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_1)\n                if (_LayerFuzzyShadingOn_Ext_1 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_1.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_1.x, _LayerFuzzyShadingParams_Ext_1.y, _LayerFuzzyShadingParams_Ext_1.z);\n                }\n\n                if (_LayerBlendMode_Ext_1 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_1);\n                else if (_LayerBlendMode_Ext_1 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_1 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_1);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_1\n                      float maskDif = (_LayerBlendContrast_Ext_1 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_1 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                   #if _LAYERNOISE_DEF_1\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_1));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_1 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_1);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_1) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_1 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_1);\n                }\n\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_1);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_1, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_1, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_1\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c).rgb * _LayerEmissionColor_Ext_1;\n                #if _LAYERALBEDO_DEF_1\n                    if (_LayerBlendMode_Ext_1 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_2);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_2);\n   TEXTURE2D(_LayerNormalMap_Ext_2);\n   TEXTURE2D(_LayerMaskMap_Ext_2);\n   TEXTURE2D(_LayerEmissionMap_Ext_2);\n\n   \n\n   void Ext_ModifyTessellatedVertex5 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_2) && defined(_LAYERALBEDO_DEF_2) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_2\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_2,  _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_2\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_2;\n            dt = saturate(dt * _LayerFalloff_Ext_2);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n            if (_LayerInvertHeight_Ext_2 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_2;\n         detailMask *= _LayerTessStrength_Ext_2;\n\n         #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_2).a;\n         albedo = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo);\n\n         if (_LayerBlendMode_Ext_2 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_2);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_2 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction5 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_2)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_2\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_2, _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_2\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_2);\n\t    \n                dt -= _LayerAngleMin_Ext_2;\n                dt = saturate(dt * _LayerFalloff_Ext_2);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n                if (_LayerInvertHeight_Ext_2 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 02\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 02\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_2;\n\n            #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_2, 0.5);\n            #if defined(_LAYERALBEDO_DEF_2)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, _LayerStochasticContrast_Ext_2, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_2;\n                albedo.a = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_2 || _LAYERMASK_DEF_2\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_2);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_2;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, d, _LayerNormalStrength_Ext_2 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_2)\n                if (_LayerFuzzyShadingOn_Ext_2 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_2.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_2.x, _LayerFuzzyShadingParams_Ext_2.y, _LayerFuzzyShadingParams_Ext_2.z);\n                }\n\n                if (_LayerBlendMode_Ext_2 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_2);\n                else if (_LayerBlendMode_Ext_2 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_2 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_2);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_2\n                      float maskDif = (_LayerBlendContrast_Ext_2 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_2 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                   #if _LAYERNOISE_DEF_2\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_2));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_2 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_2);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_2) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_2 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_2);\n                }\n\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_2);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_2, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_2, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_2\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c).rgb * _LayerEmissionColor_Ext_2;\n                #if _LAYERALBEDO_DEF_2\n                    if (_LayerBlendMode_Ext_2 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   #if _TRAX_ON\n   TEXTURE2D(_TraxAlbedo);\n   SAMPLER(sampler_TraxAlbedo);\n   TEXTURE2D(_TraxPackedNormal);\n   TEXTURE2D(_TraxMask);\n\n   sampler2D_float _GMSTraxBuffer;\n\n   float4 _GMSTraxBuffer_TexelSize;\n   float3 _GMSTraxBufferPosition;\n   float _GMSTraxBufferWorldSize;\n   float _GMSTraxFudgeFactor;\n\n   float SampleTraxBufferLOD(float3 worldPos)\n   {    \n      // generate UVs for the buffer, which is moving\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 8);\n      uv *= 0.5;\n      uv += 0.5;\n            \n      float s =  tex2Dlod(_GMSTraxBuffer, float4(uv, 0, 0)).r;\n\n      return 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n   }\n         \n        \n   float SampleTraxBuffer(float3 worldPos, out float3 norm)\n   {\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 3);\n      uv *= 0.5;\n      uv += 0.5;\n            \n\n      float2 offset = _GMSTraxBuffer_TexelSize.xy;\n\n      float s = tex2D(_GMSTraxBuffer, uv).r;\n               \n      float s1 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, -1)).r;\n      float s2 = tex2D(_GMSTraxBuffer, uv + offset * float2(-1, 0)).r;\n      float s3 = tex2D(_GMSTraxBuffer, uv + offset * float2(1, 0)).r;\n      float s4 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, 1)).r;\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      float r = 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n \n      // generate normals\n      norm.x = (s1 - s4) * 0.25; \n      norm.y = (s2 - s3) * 0.25;\n      norm.z = 2;\n      norm = normalize(norm);\n     \n      norm.xy *= 1 - r;\n            \n      return r;\n   }\n   #endif\n\n   void Ext_ModifyTessellatedVertex6 (inout VertexData v, inout ExtraV2F d)\n   {\n       #if _TESSELLATION_ON && _TRAX_ON && _HAS_LIT_TESSELLATION\n          \n           float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n           float3 worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n           float traxBuffer = SampleTraxBufferLOD(worldSpacePosition);\n           d.blackboard.traxBuffer = traxBuffer;\n           float2 uv = worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n           half albedo = SAMPLE_TEXTURE2D_LOD(_TraxAlbedo, sampler_TraxAlbedo, uv, _TraxMipBias).a;\n\n           float traxOffset = albedo * _TraxDisplacementStrength;\n           traxOffset *= 1 - v.texcoord0.z;\n           traxOffset *= _TessellationDisplacement;\n           float dig = _TraxDisplacementDepth * (1 - v.texcoord0.z);\n           float3 traxVertex = d.blackboard.originalVertexPosition + (v.normal * (traxOffset - dig));\n           v.vertex.xyz = lerp(traxVertex, v.vertex.xyz, traxBuffer);\n\n           d.blackboard.vertexHeightOffset = lerp(traxOffset-dig, d.blackboard.vertexHeightOffset, traxBuffer);\n\n       #endif\n\n   }\n\n   void Ext_SurfaceFunction6 (inout Surface o, inout ShaderData d)\n   {\n      #if _TRAX_ON\n        float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n        float2 fsdx = ddx(uv);\n        float2 fsdy = ddy(uv);\n\n        float3 traxNormal;\n        float traxBuffer = SampleTraxBuffer(d.worldSpacePosition, traxNormal);\n        \n        #if _TESSELLATION_ON\n            traxBuffer -= _TraxDisplacementDepth;\n        #endif\n\n        d.blackboard.traxBuffer = traxBuffer;\n\n        UNITY_BRANCH\n        if (traxBuffer > 0)\n        {\n            half4 albedo = SAMPLE_TEXTURE2D_GRAD(_TraxAlbedo, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            albedo.rgb *= _TraxTint.rgb;\n            half4 normalSample = SAMPLE_TEXTURE2D_GRAD(_TraxPackedNormal, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n\n            half smoothness = normalSample.r;\n            half ao = normalSample.b;\n            half3 normal;\n            normal.xy = (normalSample.ag * 2 - 1) * _TraxNormalStrength;\n            normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n\n            \n            half h = HeightBlend(albedo.a, o.Alpha, traxBuffer, _TraxHeightContrast);\n\n            h = lerp(traxBuffer, h, _TraxInterpContrast);\n\n            o.Albedo = lerp(albedo, o.Albedo, h);\n\n            #if _SURFACEGRADIENT\n                o.Normal = lerp(normal, o.Normal, h);\n            #else\n                o.Normal = lerp(normal + traxNormal, o.Normal, h);\n            #endif\n        \n            o.Smoothness = lerp(smoothness, o.Smoothness, h);\n            o.Occlusion = lerp(ao, o.Occlusion, h);\n        }\n      #endif\n   }\n\n\n\n\n    #if _RAINDROPS\n       TEXTURE2D(_RainDropTexture);\n       SAMPLER(sampler_RainDropTexture);\n       half _Global_RainIntensity;\n    #endif\n\n    #if _WETNESS\n       half2 _Global_WetnessParams; // global, not in cbuffer\n    #endif\n   \n    #if _RAINDROPS\n    half2 ComputeRipple(float2 uv, half time, half weight)\n    {\n        half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_RainDropTexture, uv);\n        COUNTSAMPLE\n        ripple.yz = ripple.yz * 2 - 1;\n\n        half dropFrac = frac(ripple.w + time);\n        half timeFrac = dropFrac - 1.0 + ripple.x;\n        half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);\n        half finalFactor = dropFactor * ripple.x * \n                                sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);\n\n        return half2(ripple.yz * finalFactor);\n    }\n    #endif\n\n    half2 DoRain(half2 waterNorm, float2 uv, out half2 ripple)\n    {\n        #if _RAINDROPS\n            float rainIntensity = _RainIntensityScale.x;\n            if (_RainMode > 1)\n            {\n                rainIntensity = _Global_RainIntensity;\n            }\n\n            half dropStrength = rainIntensity;\n            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); \n            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);\n            half4 times = _Time.yyyy;\n            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);\n\n            float2 ruv1 = uv * _RainIntensityScale.yy;\n            float2 ruv2 = ruv1;\n\n            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);\n            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);\n            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);\n            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);\n            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);\n            weights = saturate(weights * 4);\n\n            half2 rippleNormal = half2( weights.x * ripple1.xy +\n                        weights.y * ripple2.xy + \n                        weights.z * ripple3.xy + \n                        weights.w * ripple4.xy);\n\n            ripple = rippleNormal * dropStrength * rainIntensity;\n            waterNorm = lerp(waterNorm, normalize(half3(rippleNormal.xy + rippleNormal.xy, 1)).xy, rainIntensity * dropStrength); \n            return waterNorm;                        \n        #else\n            return waterNorm;\n        #endif\n    }\n\n   half2 _Global_PuddleParams;   // this is a global, so keep it out of the cbuffer\n   void GetPuddleParams(ShaderData d, inout float puddleMask, inout float pudHeight)\n   {\n      #if _PUDDLES || _GLOBALPUDDLES\n          pudHeight = _PuddleAmount;\n          if (_PuddleMode > 0)\n             pudHeight = _Global_PuddleParams.x;    \n      \n\n          half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t      dt -= _PuddleAngleMin;\n          dt = saturate(dt * _PuddleFalloff);\n          puddleMask *= dt;\n      #endif\n   }\n   \n   void Ext_ModifyTessellatedVertex7 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _PUDDLES && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n         half mask = 1;\n         half pudHeight = 1;\n\n         // save some ops by doing this in 2d\n         #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2DLOD(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2DLOD(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #else\n                mask = (FBM2DLOD(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n         #endif\n\n         GetPuddleParams(d, mask, pudHeight);\n         float height = pudHeight * mask;\n         if (e.blackboard.vertexHeightOffset < height)\n         {\n            e.blackboard.vertexHeightOffset = height;\n            height -= _TessellationOffset; \n            // dampen cracks\n            height *= 1 - v.texcoord0.z;\n            height *= _TessellationDisplacement;\n            v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n            \n        }\n      #endif\n   }\n\n\n#if _WETNESS\n\n   float GetWetnessLevel(Surface o, ShaderData d, float wetnessMask)\n   {\n      float wetLevel = clamp(_WetnessAmount, _WetnessMin, _WetnessMax);\n      \n      if (_WetnessMode > 0)\n         wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);\n\n      wetLevel = saturate(wetLevel + (1 - saturate(d.worldSpacePosition.y - _WetnessShoreline)));\n      float3x3 tbn = float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal);\n      float dt = dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0));\n      dt -= _WetnessAngleMin;\n      dt = saturate(dt * _WetnessFalloff * wetLevel);\n      dt *= wetnessMask;\n      return dt;\n   }\n#endif\n   \n\n   void Ext_SurfaceFunction7 (inout Surface o, ShaderData d)\n   {\n      half wetnessLevel = 0;\n      #if _WETNESS\n          wetnessLevel = GetWetnessLevel(o, d, 1); // mask one day?\n      #endif\n\n      half depthMask = 0;\n      half depth = 0;\n\n      #if _PUDDLES\n          half mask = 1;\n          half pudHeight = 1;\n          #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2D(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2D(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);      \n            #else\n                mask = (FBM2D(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n          #endif\n\n          GetPuddleParams(d, mask, pudHeight);\n          pudHeight *= mask;\n          depth = pudHeight - o.Height;\n          depthMask = saturate(depth * _PuddleFalloff);\n          depthMask *= _PuddleColor.a;\n          depth = o.Height - pudHeight;\n\n          // extend wetness slighting higher than the puddle\n          half wetmask = saturate((pudHeight + 0.05 - o.Height) * _PuddleFalloff);\n          wetnessLevel = max(wetmask, wetnessLevel);\n       #endif\n\n       \n       #if _WETNESS || _PUDDLES\n          half3 waterNorm = half3(0,0,1);\n          half3 wetAlbedo = o.Albedo;\n          half wetSmoothness = o.Smoothness;\n          #if _PUDDLES\n             wetAlbedo *= _PuddleColor.rgb;\n          #endif\n          WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetnessLevel, _Porosity);\n\n          half ri = 0;\n          half2 ripple = 0;\n          #if (_RAINDROPS || _GLOBALRAIN) && (_PUDDLES || _GLOBALPUDDLES)\n             ri = _RainIntensityScale.z;\n             waterNorm.xy = DoRain(waterNorm.xy, d.texcoord0.xy, ripple) * depthMask;\n          #endif\n\n          o.Normal = lerp(o.Normal, waterNorm, depthMask);\n          o.Normal = lerp(o.Normal, LitBlendDetailNormal(o.Normal, half3(ripple.xy, 1)), saturate(ri - depthMask) * wetnessLevel);\n          o.Occlusion = lerp(o.Occlusion, 1, depthMask);\n          o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetnessLevel);\n          o.Albedo = lerp(o.Albedo, wetAlbedo, wetnessLevel);\n          o.Emission *= 1 + depth;\n          o.Metallic *= 1 + depth;\n          o.Specular *= 1 + depth;\n\n       #endif\n\n   }\n\n\n\n\n    #if _SNOW\n       TEXTURE2D(_SnowAlbedo);\n       SAMPLER(sampler_SnowAlbedo);\n       TEXTURE2D(_SnowNormal);\n       TEXTURE2D(_SnowMaskMap);\n       #if _TRAX_ON\n          TEXTURE2D(_SnowTraxAlbedo);\n          TEXTURE2D(_SnowTraxNormal);\n          TEXTURE2D(_SnowTraxMaskMap);\n       #endif\n    #endif\n\n   float _Global_SnowLevel;\n\n\n   void Ext_ModifyVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n    #if (_SNOW)\n        float amount = _SnowAmount;\n        if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n        float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n        float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n        snowAmount -= _SnowAngle;\n        snowAmount *= _SnowContrast * 0.5;\n        snowAmount = saturate(snowAmount) * amount;\n        float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n        if (_SnowWorldFade.z > 0)\n        {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n        }\n        #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n        #endif\n        snowAmount = saturate(snowAmount);\n\n        #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n        #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n        #endif\n\n        float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n        v.vertex.xyz = v.vertex.xyz + displacementVec * snowAmount * snowAmount * _SnowVertexHeight;\n    #endif\n   }\n\n   void Ext_ModifyTessellatedVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _SNOW && _HAS_LIT_TESSELLATION\n         float amount = _SnowAmount;\n         if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n         float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n         float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n         snowAmount -= _SnowAngle;\n         snowAmount *= _SnowContrast * 0.5;\n         float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n         if (_SnowWorldFade.z > 0)\n         {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n         }\n\n         snowAmount = saturate(snowAmount) * amount;\n\n         #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n         #endif\n         snowAmount = saturate(snowAmount);\n\n         #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n         #endif\n\n         float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n         half heightMap = SAMPLE_TEXTURE2D_LOD(_SnowAlbedo, sampler_SnowAlbedo, worldPos.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw, 2);\n\n         float height = max(_SnowVertexHeight * 3 * snowAmount + snowAmount * heightMap, e.blackboard.vertexHeightOffset);\n         #if _TRAX_ON\n            height *= e.blackboard.traxBuffer;\n         #endif\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n\n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n         \n      #endif\n\n   }\n\n   void SampleSnowSurface(TEXTURE2D_PARAM(alb, ss), TEXTURE2D_PARAM(norm, ss2), TEXTURE2D_PARAM(mask, ss3),\n        ShaderData d, float2 uv, float2 dx, float2 dy, out half4 albedo, out half3 normal, out half2 smoothAO)\n   {\n      #if _SNOWSTOCHASTIC\n         float w1, w2, w3;\n         int2 vertex1, vertex2, vertex3;\n         TriangleGrid(uv, _SnowStochasticScale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n         // Assign random offset to each triangle vertex\n         float2 uv0 = uv;\n         float2 uv1 = uv;\n         float2 uv2 = uv;\n   \n         uv0.xy += SimpleHash2(vertex1);\n         uv1.xy += SimpleHash2(vertex2);\n         uv2.xy += SimpleHash2(vertex3);\n         half3 weights = half3(w1, w2, w3);\n\n         half4 albedo0 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv0, dx, dy);\n         half4 albedo1 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv1, dx, dy);\n         half4 albedo2 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv2, dx, dy);\n         COUNTSAMPLE\n         COUNTSAMPLE\n         COUNTSAMPLE\n         weights = BaryWeightBlend(weights, albedo0.a, albedo1.a, albedo2.a, _SnowStochasticContrast);\n         albedo = albedo0 * weights.x + albedo1 * weights.y + albedo2 * weights.z;\n\n         normal = half3(0,0,1);\n         smoothAO = half2(0, 1);\n\n         #if !_AUTONORMAL\n            half4 n0 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv0, dx, dy);\n            half4 n1 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv1, dx, dy);\n            half4 n2 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n            half4 snowNormSamp = n0 * weights.x + n1 * weights.y + n2 * weights.z;\n\n            normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n                \n            #if _PACKEDFAST\n               smoothAO.x = snowNormSamp.r;\n               smoothAO.y = snowNormSamp.b;\n            #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask0 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv0, dx, dy);\n            half4 snowMask1 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv1, dx, dy);\n            half4 snowMask2 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n            half4 snowMask = snowMask0 * weights.x + snowMask1 * weights.y + snowMask2 * weights.z;\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n      #else // not stochastic\n          albedo = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv, dx, dy);\n          COUNTSAMPLE\n\n          normal = half3(0,0,1);\n          smoothAO = half2(0, 1);\n\n          #if !_AUTONORMAL\n             half4 snowNormSamp = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv, dx, dy);\n             COUNTSAMPLE\n             normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n             #if _SURFACEGRADIENT\n                normal = ConvertNormalToGradient(d, normal);\n             #endif\n                 \n             #if _PACKEDFAST\n                smoothAO.x = snowNormSamp.r;\n                smoothAO.y = snowNormSamp.b;\n             #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv, dx, dy);\n            COUNTSAMPLE\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n     #endif // stochastic\n   }\n\n   \n   void Ext_SurfaceFunction8 (inout Surface o, ShaderData d)\n   {\n      #if _SNOW\n          float amount = _SnowAmount;\n          if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n          float snowAmount = lerp(dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), dot(d.worldSpaceNormal, float3(0,1,0)), amount * 0.8) + 1;\n          snowAmount -= _SnowAngle;\n          snowAmount *= _SnowContrast;\n          snowAmount = saturate(snowAmount) - (1-amount) * (1-amount);\n\n          if (_SnowWorldFade.z > 0)\n          {\n             float worldFade = saturate((d.worldSpacePosition.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n             snowAmount *= worldFade;\n          }\n\n          #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(d.worldSpacePosition.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n          #endif\n          snowAmount = saturate(snowAmount);\n\n          float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw;\n          float2 dx = ddx(uv);\n          float2 dy = ddy(uv);\n\n          #if _TRAX_ON\n              float2 tuv = d.worldSpacePosition.xz * float2(1, -1) * _SnowTraxAlbedo_ST.xy + _SnowTraxAlbedo_ST.zw;\n              float2 tdx = ddx(uv);\n              float2 tdy = ddy(uv);\n          #endif\n\n          #if _LAYERVERTEXMASK\n              snowAmount *= d.vertexColor.a;\n          #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n              snowAmount *= d.blackboard.weightTextureMask.a;\n          #endif\n\n          UNITY_BRANCH\n          if (snowAmount > 0)\n          {\n             half4 snowAlbedo;\n             half3 snowNormal;\n             half2 snowSmoothAO;\n             SampleSnowSurface(TEXTURE2D_ARGS(_SnowAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowNormal, sampler_SnowAlbedo),\n                    TEXTURE2D_ARGS(_SnowMaskMap, sampler_SnowAlbedo), d, uv, dx, dy, snowAlbedo, snowNormal, snowSmoothAO);\n\n             snowAlbedo.rgb *= _SnowTint.rgb;\n\n             #if _TRAX_ON\n                half traxBuffer = 1 - d.blackboard.traxBuffer;\n                UNITY_BRANCH\n                if (traxBuffer > 0)\n                {\n                    half4 tsnowAlbedo;\n                    half3 tsnowNormal;\n                    half2 tsnowSmoothAO;\n                    SampleSnowSurface(TEXTURE2D_ARGS(_SnowTraxAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowTraxNormal, sampler_SnowAlbedo),\n                        TEXTURE2D_ARGS(_SnowTraxMaskMap, sampler_SnowAlbedo), d, tuv, tdx, tdy, tsnowAlbedo, tsnowNormal, tsnowSmoothAO);\n\n                    tsnowAlbedo.rgb *= _SnowTraxTint;\n                    half h = HeightBlend(snowAlbedo.a, tsnowAlbedo.a, traxBuffer, 0.5);\n                    snowAlbedo = lerp(snowAlbedo, tsnowAlbedo, h);\n                    snowNormal = lerp(snowNormal, tsnowNormal, h);\n                    snowSmoothAO = lerp(snowSmoothAO, tsnowSmoothAO, h);\n                }\n             #endif\n\n             #if !_AUTONORMAL\n                o.Normal = lerp(o.Normal, snowNormal, snowAmount);\n             #endif\n             o.Albedo = lerp(o.Albedo, snowAlbedo.rgb, snowAmount);\n             o.Alpha = lerp(o.Alpha, snowAlbedo.a, snowAmount);\n             o.Smoothness = lerp(o.Smoothness, snowSmoothAO.x, snowAmount);\n             o.Occlusion = lerp(o.Occlusion, snowSmoothAO.y, snowAmount);\n             o.Height = o.Alpha;\n\n          }\n      #endif\n   }\n\n   \n\n\n\n\n\n   TEXTURE2D(_WindParticulate);\n   SAMPLER(sampler_WindParticulate);\n\n// In case we want to read it more than once..\n\n#ifndef __STACKABLE_WIND_INCLUDES__\n#define __STACKABLE_WIND_INCLUDES__\n\n\n   half FilterRange(float4 range, float y)\n   {\n      half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));\n      w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));\n      return w;\n   }\n\n   \n   float2 RotateUV(float2 uv, float amt)\n   {\n      uv -=0.5;\n      float s = sin ( amt);\n      float c = cos ( amt );\n      float2x2 mtx = float2x2( c, -s, s, c);\n      mtx *= 0.5;\n      mtx += 0.5;\n      mtx = mtx * 2-1;\n      uv = mul ( uv, mtx );\n      uv += 0.5;\n      return uv;\n   }\n\n\n   half FilterWindParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)\n   {\n      float2 windDir = RotateUV(float2(1, 0), windRot);\n      float2 flow = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));\n      float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill\n      return FilterRange(range, cofacing);\n   }\n\n   half ProcessWindParticulateMask(inout half mask, float contrast)\n   {\n      mask = pow(abs(mask), abs(contrast));\n      half invMask = 1.0 - mask;\n      invMask *= invMask; \n      invMask *= invMask;\n      return invMask;\n   }\n#endif // include guard\n\n   void Ext_SurfaceFunction9 (inout Surface o, ShaderData d)\n   {\n      #if _WIND_ON && !_PASSMETA\n   \n         float3 upVector = float3(0,0,1);\n\n         half upDot = max(0.0, dot(d.worldSpaceNormal, float3(0, 1, 0)));\n\n         float2 uv = d.worldSpacePosition.xz;\n         if (_WindParticulateSpace > 0.5)\n            uv = d.texcoord0.xy;\n         float windRotation = _WindParticulateRotation;\n         float windStrength = _WindParticulateStrength;\n\n         float2 wuv = RotateUV(uv, windRotation);\n\n         half windBlend = 1.0;\n\n         float windWorldMask = FilterRange(_WindParticulateWorldHeightMask, d.worldSpacePosition.y);\n         windWorldMask *= FilterRange(_WindParticulateAngleMask, upDot);\n\n         // compute mask\n         wuv *= float2(_WindParticulate_ST.x, 1) * _WindParticulate_ST.y + _WindParticulate_ST.zw;\n         float speed = _Time.x * _WindParticulateSpeed;\n         half w1 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv * 3 + speed * float2(1,0)).g;\n         half w2 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv + speed * float2(1.1,0)).a;\n         half windMask = (w1 * w2);\n\n         windMask *= windStrength * windBlend * windWorldMask;\n         windMask *= saturate((_WindParticulateTextureHeight - o.Height) * 10);\n\n         half windInvMask = ProcessWindParticulateMask(windMask, _WindParticulatePower);\n    \n         o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);\n         o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindParticulateEmissive.rgb;\n         o.Normal.xy *= windInvMask;\n         o.Smoothness *= windInvMask;\n         o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;\n         o.Metallic *= windInvMask;\n      #endif\n\n   }\n\n\n\n\n\tvoid Ext_SurfaceFunction10 (inout Surface o, ShaderData d)\n\t{\n        if (_DoubleSidedNormalMode == 0)\n        {\n           o.Normal *= d.isFrontFace ? 1 : -1;\n        }\n        else if (_DoubleSidedNormalMode == 1)\n        {\n\t\t   o.Normal.z *= d.isFrontFace ? 1 : -1;\n        }\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction11 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _SURFACEGRADIENT\n\t\t\to.Normal = ResolveNormalFromSurfaceGradient(d, o.Normal);\n\t    #elif _AUTONORMAL\n\t        float3 dx = ddx(d.worldSpacePosition);\n\t\t\tfloat3 dy = ddy(d.worldSpacePosition);\n\t\t\tfloat3 crossX = cross(float3(0,1,0), dx);\n\t\t\tfloat3 crossY = cross(float3(0,1,0), dy);\n\t\t\tfloat3 dt = abs(dot(crossY, dx));\n\t\t\tfloat height = _AutoNormalStrength * 0.5 * o.Alpha;\n\t\t\tfloat3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n\t\t\tn.y *= -1.0;\n\t\t\to.Normal = normalize((dt * float3(0,1,0)) - n).xzy;\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#else\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#endif\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction12 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DEBUG_SAMPLECOUNT\n\t\t\tif (_sampleCount > _DebugSampleCountThreshold)\n\t\t\t{\n\t\t\t\to.Albedo.r = 1;\n\t\t\t\to.Albedo.gb *= 0.2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\to.Albedo.b = 1;\n\t\t\t}\n\n        #endif\n\t}\n\n\n\n\n\tSAMPLER(sampler_DissolveTexture);\n\tTEXTURE2D(_DissolveTexture);\n\tTEXTURE2D(_DissolveGradient);\n\n\tvoid Ext_SurfaceFunction13 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DISSOLVE\n\t\tfloat2 uv = d.texcoord0.xy * _DissolveTexture_ST.xy + _DissolveTexture_ST.zw;\n\t\tfloat2 dx = ddx(uv);\n\t\tfloat2 dy = ddy(uv);\n\n\t\tUNITY_BRANCH\n\t\tif (_DissolveAmount > 0)\n\t\t{\n\t\t\thalf dissolve = SAMPLE_TEXTURE2D_GRAD(_DissolveTexture, sampler_DissolveTexture, uv, dx, dy).g;\n\t\t\thalf cp =  saturate(_DissolveAmount - (dissolve - _DissolveAmount) * _DissolveEdgeContrast) + _DissolveAmount;\n\t\t\thalf cp2 = saturate(1.0 - abs((dissolve - _DissolveAmount) * _DissolveEdgeContrast));\n\t\t\tclip(1.0 - cp);\n\t\t\tfloat2 fuv = float2(cp2, 0.5);\n\t\t\thalf3 col = SAMPLE_TEXTURE2D_LOD(_DissolveGradient, sampler_DissolveTexture, fuv, 0).rgb;\n\t\t\t\t\n\t\t\to.Albedo = lerp(o.Albedo, col, _DissolveColoration * cp2);\n\t\t\to.Emission = lerp(o.Emission, col * _DissolveEmissiveStr, _DissolveColoration * cp2);\n\t\t}\n\t\t#endif\n\t}\n\n\n\n\n    float Dither8x8Bayer( int x, int y )\n    {\n        const float dither[ 64 ] = {\n                1, 49, 13, 61,  4, 52, 16, 64,\n            33, 17, 45, 29, 36, 20, 48, 32,\n                9, 57,  5, 53, 12, 60,  8, 56,\n            41, 25, 37, 21, 44, 28, 40, 24,\n                3, 51, 15, 63,  2, 50, 14, 62,\n            35, 19, 47, 31, 34, 18, 46, 30,\n            11, 59,  7, 55, 10, 58,  6, 54,\n            43, 27, 39, 23, 42, 26, 38, 22};\n        int r = y * 8 + x;\n        return dither[r] / 64; \n    }\n\n    void ApplyDitherCrossFadeVSP(float2 vpos, float fadeValue)\n    {\n        float dither = Dither8x8Bayer( fmod(vpos.x, 8), fmod(vpos.y, 8) );\n        float sgn = fadeValue > 0 ? 1.0f : -1.0f;\n        clip(dither - (1-fadeValue) * sgn);\n    }\n    \n\n\tvoid Ext_SurfaceFunction14 (inout Surface o, ShaderData d)\n\t{\n\t\t#if LOD_FADE_CROSSFADE\n            float4 screenPosNorm = d.screenPos / d.screenPos.w;\n            screenPosNorm.z = ( UNITY_NEAR_CLIP_VALUE >= 0 ) ? screenPosNorm.z : screenPosNorm.z * 0.5 + 0.5;\n            float2 clipScreen = screenPosNorm.xy * _ScreenParams.xy;\n            ApplyDitherCrossFadeVSP(clipScreen,unity_LODFade.x);\n        #endif\n\t}\n\n\n\n\n\n\n// declare outside of CBuffer\n\nfloat4x4 _GlobalVolumeMatrix;\nfloat4x4 _VolumeMatrix;\nfloat3 _VolumeMin;\nfloat3 _VolumeInvSize;\nfloat3 _GlobalVolumeMin;\nfloat3 _GlobalVolumeInvSize;\n\n// I inlined a section of your include. You can use includes in better shaders, but doing it via a subshader or this way\n// is much better. The reason is that this allows your shader to be all inclusive, and packed up for asset store distribition,\n// without requiring specific paths to other files, etc.\n//\n\n#ifndef BAKERY_INCLUDED\n#define BAKERY_INCLUDED\n\n#define BAKERYMODE_DEFAULT 0\n#define BAKERYMODE_VERTEXLM 1.0f\n#define BAKERYMODE_RNM 2.0f\n#define BAKERYMODE_SH 3.0f\n\n\n// can't fit vertexLM SH to sm3_0 interpolators\n#ifndef SHADER_API_D3D11\n    #undef _LIGHTMAPMODE_VERTEXSH\n#endif\n\n// can't do stuff on sm2_0 due to standard shader alrady taking up all instructions\n#if SHADER_TARGET < 30\n    #undef BAKERY_BICUBIC\n    #undef BAKERY_LMSPEC\n\n    #undef _LIGHTMAPMODE_RNM\n    #undef _LIGHTMAPMODE_SH\n    #undef _LIGHTMAPMODE_VERTEX\n#endif\n\n#define lumaConv float3(0.2125f, 0.7154f, 0.0721f)\n\n#ifdef BAKERY_VOLUME\n    #ifdef BAKERY_COMPRESSED_VOLUME\n        Texture3D _Volume3;\n    #endif\n#endif\n\n\nhalf3 LinearToGamma (half3 linRGB)\n{\n    linRGB = max(linRGB, half3(0.h, 0.h, 0.h));\n    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n    return max(1.055h * pow(linRGB, 0.416666667h) - 0.055h, 0.h);\n}\n\nfloat shEvaluateDiffuseL1Geomerics(float L0, float3 L1, float3 n)\n{\n    // average energy\n    float R0 = L0;\n\n    // avg direction of incoming light\n    float3 R1 = 0.5f * L1;\n\n    // directional brightness\n    float lenR1 = length(R1);\n\n    // linear angle between normal and direction 0-1\n    //float q = 0.5f * (1.0f + dot(R1 / lenR1, n));\n    //float q = dot(R1 / lenR1, n) * 0.5 + 0.5;\n    float q = dot(normalize(R1), n) * 0.5 + 0.5;\n\n    // power for q\n    // lerps from 1 (linear) to 3 (cubic) based on directionality\n    float p = 1.0f + 2.0f * lenR1 / R0;\n\n    // dynamic range constant\n    // should vary between 4 (highly directional) and 0 (ambient)\n    float a = (1.0f - lenR1 / R0) / (1.0f + lenR1 / R0);\n\n    return R0 * (a + (1.0f - a) * (p + 1.0f) * pow(q, p));\n}\n\n#ifdef BAKERY_VERTEXLMMASK\n    float4 unpack4NFloats(float src)\n\t{\n        //return fmod(float4(src / 262144.0, src / 4096.0, src / 64.0, src), 64.0)/64.0;\n        return frac(float4(src / (262144.0*64), src / (4096.0*64), src / (64.0*64), src));\n    }\n#endif\n\n#if defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n    float3 unpack3NFloats(float src)\n\t{\n        float r = frac(src);\n        float g = frac(src * 256.0);\n        float b = frac(src * 65536.0);\n        return float3(r, g, b);\n    }\n#endif\n\n// Unity defines these under different names in each SRP, so use our own\ninline float3 Bakery_SafeNormalize(float3 inVec)\n{\n    float dp3 = max(0.001f, dot(inVec, inVec));\n    return inVec * rsqrt(dp3);\n}\n\n#if _URP || _HDRP\n\nfloat SmoothnessToPerceptualRoughness(float smoothness)\n{\n    return (1 - smoothness);\n}\n#endif\n\n#if !_STANDARD\nhalf4 unity_Lightmap_HDR;\ninline half3 DecodeLightmap( half4 color )\n{\n    return DecodeLightmap( color, unity_Lightmap_HDR );\n}\n\n#define UNITY_INV_PI        0.31830988618f\ninline float GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return UNITY_INV_PI * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n    void BakeryVertexLMDirection(inout float3 diffuseColor, inout float3 specularColor, float3 lightDirection, float3 vertexNormalWorld, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 dominantDir = Bakery_SafeNormalize(lightDirection);\n        half halfLambert = dot(normalWorld, dominantDir) * 0.5 + 0.5;\n        half flatNormalHalfLambert = dot(vertexNormalWorld, dominantDir) * 0.5 + 0.5;\n\n        #ifdef BAKERY_LMSPEC\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = spec * diffuseColor;\n        #endif\n\n        diffuseColor *= halfLambert / max(1e-4h, flatNormalHalfLambert);\n    }\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXSH\n    void BakeryVertexLMSH(inout float3 diffuseColor, inout float3 specularColor, float3 shL1x, float3 shL1y, float3 shL1z, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 L0 = diffuseColor;\n        float3 nL1x = shL1x;\n        float3 nL1y = shL1y;\n        float3 nL1z = shL1z;\n        float3 L1x = nL1x * L0 * 2;\n        float3 L1y = nL1y * L0 * 2;\n        float3 L1z = nL1z * L0 * 2;\n\n        float3 sh;\n    #if BAKERY_SHNONLINEAR\n        //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n        //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n        //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n        float lumaL0 = dot(L0, 1);\n        float lumaL1x = dot(L1x, 1);\n        float lumaL1y = dot(L1y, 1);\n        float lumaL1z = dot(L1z, 1);\n        float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n        float regularLumaSH = dot(sh, 1);\n        //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n        sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    #else\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    #endif\n\n        diffuseColor = max(sh, 0.0);\n\n        #ifdef BAKERY_LMSPEC\n            float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n            float focus = saturate(length(dominantDir));\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = max(spec * sh, 0.0);\n        #endif\n    }\n#endif\n\n\n\n#ifdef BAKERY_BICUBIC\nfloat BakeryBicubic_w0(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-a + 3.0f) - 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w1(float a)\n{\n    return (1.0f/6.0f)*(a*a*(3.0f*a - 6.0f) + 4.0f);\n}\n\nfloat BakeryBicubic_w2(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-3.0f*a + 3.0f) + 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w3(float a)\n{\n    return (1.0f/6.0f)*(a*a*a);\n}\n\nfloat BakeryBicubic_g0(float a)\n{\n    return BakeryBicubic_w0(a) + BakeryBicubic_w1(a);\n}\n\nfloat BakeryBicubic_g1(float a)\n{\n    return BakeryBicubic_w2(a) + BakeryBicubic_w3(a);\n}\n\nfloat BakeryBicubic_h0(float a)\n{\n    return -1.0f + BakeryBicubic_w1(a) / (BakeryBicubic_w0(a) + BakeryBicubic_w1(a)) + 0.5f;\n}\n\nfloat BakeryBicubic_h1(float a)\n{\n    return 1.0f + BakeryBicubic_w3(a) / (BakeryBicubic_w2(a) + BakeryBicubic_w3(a)) + 0.5f;\n}\n#endif\n\n\n#if defined(_LIGHTMAPMODE_RNM) || defined(_LIGHTMAPMODE_SH)\nTexture2D _RNM0, _RNM1, _RNM2;\n#endif\n\n#ifdef BAKERY_VOLUME\nTexture3D _Volume0, _Volume1, _Volume2, _VolumeMask;\nSamplerState sampler_Volume0;\n#endif\n\n#if defined(BAKERY_BICUBIC) && defined(LIGHTMAP_ON) && defined(SHADER_API_D3D11)\n    // Bicubic\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\tfloat width, height;\n\t\ttex.GetDimensions(width, height);\n\t\tfloat texelSize = 1.0f / width;\n\n        float x = uv.x * width;\n        float y = uv.y * width;\n\n        x -= 0.5f;\n        y -= 0.5f;\n\n        float px = floor(x);\n        float py = floor(y);\n\n        float fx = x - px;\n        float fy = y - py;\n\n        float g0x = BakeryBicubic_g0(fx);\n        float g1x = BakeryBicubic_g1(fx);\n        float h0x = BakeryBicubic_h0(fx);\n        float h1x = BakeryBicubic_h1(fx);\n        float h0y = BakeryBicubic_h0(fy);\n        float h1y = BakeryBicubic_h1(fy);\n\n        return     BakeryBicubic_g0(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h0y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h0y) * texelSize))) +\n\n                   BakeryBicubic_g1(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h1y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h1y) * texelSize)));\n    }\n#else\n    // Bilinear\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\t#ifdef LIGHTMAP_ON\n\t\t\treturn tex.Sample(samplerunity_Lightmap, uv);\n\t\t#else\n\t\t\treturn float4(1,0,0,1);\n\t\t#endif\n    }\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\n#ifdef BAKERY_LMSPEC\nfloat BakeryDirectionalLightmapSpecular(float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 dominantDir = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap, lmUV).xyz * 2 - 1;\n    half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n    half nh = saturate(dot(normalWorld, halfDir));\n    half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n    half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n    half spec = GGXTerm(nh, roughness);\n    return spec;\n}\n#endif\n#endif\n\n\n\n#ifdef _LIGHTMAPMODE_RNM\nvoid BakeryRNM(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalMap, float smoothness, float3 viewDirT)\n{\n    const float3 rnmBasis0 = float3(0.816496580927726f, 0, 0.5773502691896258f);\n    const float3 rnmBasis1 = float3(-0.4082482904638631f, 0.7071067811865475f, 0.5773502691896258f);\n    const float3 rnmBasis2 = float3(-0.4082482904638631f, -0.7071067811865475f, 0.5773502691896258f);\n\n    float3 rnm0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 rnm1 = DecodeLightmap(BakeryTex2D(_RNM1, lmUV));\n    float3 rnm2 = DecodeLightmap(BakeryTex2D(_RNM2, lmUV));\n\n    #ifdef BAKERY_SSBUMP\n        diffuseColor = normalMap.x * rnm0\n                     + normalMap.z * rnm1\n                     + normalMap.y * rnm2;\n         diffuseColor *= 2;\n    #else\n        diffuseColor = saturate(dot(rnmBasis0, normalMap)) * rnm0\n                     + saturate(dot(rnmBasis1, normalMap)) * rnm1\n                     + saturate(dot(rnmBasis2, normalMap)) * rnm2;\n    #endif\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDirT = rnmBasis0 * dot(rnm0, lumaConv) +\n                              rnmBasis1 * dot(rnm1, lumaConv) +\n                              rnmBasis2 * dot(rnm2, lumaConv);\n\n        float3 dominantDirTN = normalize(dominantDirT);\n        float3 specColor = saturate(dot(rnmBasis0, dominantDirTN)) * rnm0 +\n                           saturate(dot(rnmBasis1, dominantDirTN)) * rnm1 +\n                           saturate(dot(rnmBasis2, dominantDirTN)) * rnm2;\n\n        half3 halfDir = Bakery_SafeNormalize(dominantDirTN - viewDirT);\n        half nh = saturate(dot(normalMap, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n        specularColor = spec * specColor;\n    #endif\n}\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\ninline half3 Unity_DecodeDirectionalLightmap(half3 color, half4 dirTex, half3 normalWorld)\n{\n    // In directional (non-specular) mode Enlighten bakes dominant light direction\n    // in a way, that using it for half Lambert and then dividing by a \"rebalancing coefficient\"\n    // gives a result close to plain diffuse response lightmaps, but normalmapped.\n\n    // Note that dir is not unit length on purpose. Its length is \"directionality\", like\n    // for the directional specular lightmaps.\n\n    half halfLambert = dot(normalWorld, dirTex.xyz - 0.5) + 0.5;\n\n    return color * halfLambert / max(1e-4h, dirTex.w);\n}\n#endif\n\n#ifdef _LIGHTMAPMODE_SH\nvoid BakerySH(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 L0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 nL1x = BakeryTex2D(_RNM0, lmUV) * 2 - 1;\n    float3 nL1y = BakeryTex2D(_RNM1, lmUV) * 2 - 1;\n    float3 nL1z = BakeryTex2D(_RNM2, lmUV) * 2 - 1;\n    float3 L1x = nL1x * L0 * 2;\n    float3 L1y = nL1y * L0 * 2;\n    float3 L1z = nL1z * L0 * 2;\n\n    float3 sh;\n#if BAKERY_SHNONLINEAR\n    float lumaL0 = dot(L0, 1);\n    float lumaL1x = dot(L1x, 1);\n    float lumaL1y = dot(L1y, 1);\n    float lumaL1z = dot(L1z, 1);\n    float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    float regularLumaSH = dot(sh, 1);\n    //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n    sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n    //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n    //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n#else\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n#endif\n\n    diffuseColor = max(sh, 0.0);\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n        float focus = saturate(length(dominantDir));\n        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n        half nh = saturate(dot(normalWorld, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n\n        sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n\n        specularColor = max(spec * sh, 0.0);\n    #endif\n}\n#endif\n\n#endif // include guards\n\n\n    void Ext_ModifyVertex15 (inout VertexData v, inout ExtraV2F e)\n    {\n        #if _USEBAKERY\n\t\t    #if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\t\t\t    // Unpack from RGBM\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.a * 8.0f;\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.rgb;\n\n\t\t\t    #ifdef BAKERY_VERTEXLMMASK\n\t\t\t\t    e.extraV2F4.xyzw = unpack4NFloats(v.texcoord1);\n\t\t\t    #endif\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXSH\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n                e.extraV2F6.xyz = unpack3NFloats(v.texcoord3.x) * 2 - 1;\n                e.extraV2F7.xyz = unpack3NFloats(v.texcoord3.y) * 2 - 1;\n            #endif\n       #endif\n    }\n\n#if _HDRP || _URP\n    half3 SHEvalLinearL0L1 (half4 normal)\n    {\n        half3 x;\n\n        // Linear (L1) + constant (L0) polynomial terms\n        x.r = dot(unity_SHAr,normal);\n        x.g = dot(unity_SHAg,normal);\n        x.b = dot(unity_SHAb,normal);\n\n        return x;\n    }\n\n    // normal should be normalized, w=1.0\n    half3 SHEvalLinearL2 (half4 normal)\n    {\n        half3 x1, x2;\n        // 4 of the quadratic (L2) polynomials\n        half4 vB = normal.xyzz * normal.yzzx;\n        x1.r = dot(unity_SHBr,vB);\n        x1.g = dot(unity_SHBg,vB);\n        x1.b = dot(unity_SHBb,vB);\n\n        // Final (5th) quadratic (L2) polynomial\n        half vC = normal.x*normal.x - normal.y*normal.y;\n        x2 = unity_SHC.rgb * vC;\n\n        return x1 + x2;\n    }\n\n    half3 ShadeSH9 (half4 normal)\n    {\n        // Linear + constant polynomial terms\n        half3 res = SHEvalLinearL0L1 (normal);\n\n        // Quadratic polynomials\n        res += SHEvalLinearL2 (normal);\n\n        #ifdef UNITY_COLORSPACE_GAMMA\n            res = LinearToGamma (res);\n        #endif\n\n        return res;\n\n    }\n#endif\n\n\n\n\tvoid DoBakeryStuff(inout float3 indDif, inout float3 indSpec, inout float4 shadowmask, float3 tangentNormal, float smoothness, ShaderData d)\n\t{\n\t\t// Quality!\n\t\tindDif = 1;\n\t\tindSpec = 0;\n\n        #if defined(_PASSFORWARD) || defined(_PASSGBUFFER) // forward pass on URP/Standard/HDRP + built-in deferred\n\n            float3 normalWorld = mul(tangentNormal, d.TBNMatrix);\n\n\t\t\t#ifdef LIGHTMAP_ON\n\n                // Static\n\n\t\t\t\tfloat2 lmUV = d.texcoord1 * unity_LightmapST.xy + unity_LightmapST.zw;\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_STANDARD\n\t\t\t\t\tindDif = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n\n\t\t\t\t\t#ifdef DIRLIGHTMAP_COMBINED\n\t\t\t\t\t\tfloat4 dirMap = BakeryTex2D(unity_LightmapInd, lmUV);\n\t\t\t\t\t\tindDif = Unity_DecodeDirectionalLightmap(indDif, dirMap, normalWorld);\n\n\t\t\t\t\t\t#ifdef BAKERY_LMSPEC\n\t\t\t\t\t\t\tindSpec = BakeryDirectionalLightmapSpecular(lmUV, normalWorld, -d.worldSpaceViewDir, smoothness) * indDif;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\n\t\t\t\t\tindDif = d.vertexColor;\n\n                    #ifdef BAKERY_VERTEXLMMASK\n                        shadowmask = d.extraV2F4;\n                    #endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n\t\t\t\t\t\t// worldSpaceNormal is per-vertex\n\t\t\t\t\t\t// normalWorld is per-pixel\n\t\t\t\t\t\tfloat3 bakedLightDirection = d.extraV2F5;\n\t\t\t\t\t\tBakeryVertexLMDirection(indDif, indSpec, bakedLightDirection, d.worldSpaceNormal, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXSH\n\t\t\t\t\t\tBakeryVertexLMSH(indDif, indSpec, d.extraV2F5, d.extraV2F6, d.extraV2F7, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_RNM\n\t\t\t\t\tBakeryRNM(indDif, indSpec, lmUV, tangentNormal, smoothness, -d.tangentSpaceViewDir);\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_SH\n\t\t\t\t\tBakerySH(indDif, indSpec, lmUV, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t#endif\n\n            #else\n\n                // Dynamic\n\n                #ifdef BAKERY_VOLUME\n\n                    bool isGlobal = dot(abs(_VolumeInvSize),1) == 0;\n                    float3 volViewDir = -d.worldSpaceViewDir;\n                    #ifdef BAKERY_VOLROTATION\n                        float4x4 volMatrix = (isGlobal ? _GlobalVolumeMatrix : _VolumeMatrix);\n                        float3 volInvSize = (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 lpUV = mul(volMatrix, float4(d.worldSpacePosition,1)).xyz * volInvSize + 0.5f;\n                        float3 volNormal = mul((float3x3)volMatrix, normalWorld);\n                        #ifdef BAKERY_LMSPEC\n                            volViewDir = mul((float3x3)volMatrix, volViewDir);\n                        #endif\n                    #else\n                        float3 lpUV = (d.worldSpacePosition - (isGlobal ? _GlobalVolumeMin : _VolumeMin)) * (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 volNormal = normalWorld;\n                    #endif\n\n                    #ifdef BAKERY_COMPRESSED_VOLUME\n                        float4 tex0, tex1, tex2, tex3;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex3 = _Volume3.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz * L0;\n                        L1y = tex2.xyz * L0;\n                        L1z = tex3.xyz * L0;\n                    #else\n                        float4 tex0, tex1, tex2;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV);\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV);\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz;\n                        L1y = tex2.xyz;\n                        L1z = float3(tex0.w, tex1.w, tex2.w);\n                    #endif\n                    indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), volNormal);\n                    indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), volNormal);\n                    indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), volNormal);\n\n                    #ifdef UNITY_COLORSPACE_GAMMA\n                        indDif = pow(indDif, 1.0f / 2.2f);\n                    #endif\n\n                    #ifdef BAKERY_LMSPEC\n                        float3 nL1x = L1x / L0;\n                        float3 nL1y = L1y / L0;\n                        float3 nL1z = L1z / L0;\n                        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n                        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - volViewDir);\n                        half nh = saturate(dot(volNormal, halfDir));\n                        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n                        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n                        half spec = GGXTerm(nh, roughness);\n                        float3 sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n                        indSpec = max(spec * sh, 0.0);\n                    #endif\n\n                    shadowmask = _VolumeMask.Sample(sampler_Volume0, lpUV);\n\n                #else\n\n                    #ifdef BAKERY_SHNONLINEAR\n                        float3 L0 = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);\n                        indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, unity_SHAr.xyz, normalWorld);\n                        indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, unity_SHAg.xyz, normalWorld);\n                        indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, unity_SHAb.xyz, normalWorld);\n                    #else\n                        indDif = ShadeSH9(float4(normalWorld,1));\n                    #endif\n\n                #endif\n\n\t\t\t#endif\n\n        #endif\n\t}\n\n\t// this is the main surface function. Surface is like a surface shader output structure, but\n\t// with our new outputs as well.\n\tvoid Ext_SurfaceFunction15 (inout Surface o, ShaderData d)\n\t{\n        #if _USEBAKERY\n\t\t    float3 indDif;\n\t\t    float3 indSpec;\n            float4 shadowmask = 1;\n\t\t    DoBakeryStuff(indDif, indSpec, shadowmask, o.Normal, o.Smoothness, d);\n\t\t    o.DiffuseGI = indDif;\n\t\t    o.BackDiffuseGI = indDif;\n\t\t    o.SpecularGI = indSpec;\n            o.ShadowMask = shadowmask;\n        #endif\n\t}\n\n\n\n\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                  Ext_SurfaceFunction1(l, d);\n                  Ext_SurfaceFunction2(l, d);\n                  Ext_SurfaceFunction3(l, d);\n                  Ext_SurfaceFunction4(l, d);\n                  Ext_SurfaceFunction5(l, d);\n                  Ext_SurfaceFunction6(l, d);\n                  Ext_SurfaceFunction7(l, d);\n                  Ext_SurfaceFunction8(l, d);\n                  Ext_SurfaceFunction9(l, d);\n\t\t            Ext_SurfaceFunction10(l, d);\n                  Ext_SurfaceFunction11(l, d);\n                  Ext_SurfaceFunction12(l, d);\n                  Ext_SurfaceFunction13(l, d);\n                  Ext_SurfaceFunction14(l, d);\n                  Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraV2F d;\n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                  Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                  Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                  #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                  v2p.extraV2F4 = d.extraV2F4;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                  v2p.extraV2F5 = d.extraV2F5;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F6 = d.extraV2F6;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F7 = d.extraV2F7;\n                  #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                d.extraV2F4 = v2p.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                d.extraV2F5 = v2p.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F6 = v2p.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F7 = v2p.extraV2F7;\n                #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n                Ext_ModifyTessellatedVertex2(v, d);\n                Ext_ModifyTessellatedVertex3(v, d);\n                Ext_ModifyTessellatedVertex4(v, d);\n                Ext_ModifyTessellatedVertex5(v, d);\n                Ext_ModifyTessellatedVertex6(v, d);\n                Ext_ModifyTessellatedVertex7(v, d);\n                Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                v2p.extraV2F4 = d.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                v2p.extraV2F5 = d.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F6 = d.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F7 = d.extraV2F7;\n                #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n\n\n\n         \n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n            // d.texcoord3 = i.texcoord3;\n             #endif\n\n             d.isFrontFace = facing;\n             #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n             d.vertexColor = i.vertexColor;\n             #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(i.worldPos, 1)).xyz;\n            #endif\n             d.localSpaceNormal = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n             #if LOD_FADE_CROSSFADE\n             d.screenPos = i.screenPos;\n             d.screenUV = (i.screenPos.xy / i.screenPos.w);\n             #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n             #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n             d.extraV2F4 = i.extraV2F4;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n             d.extraV2F5 = i.extraV2F5;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F6 = i.extraV2F6;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F7 = i.extraV2F7;\n             #endif\n\n            return d;\n         }\n         \n\n         \n         #if defined(SHADERPASS_SHADOWCASTER)\n            float3 _LightDirection;\n         #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n            o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n            #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n           // o.texcoord3 = v.texcoord3;\n            #endif\n\n            #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n            o.vertexColor = v.vertexColor;\n            #endif\n           \n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n           o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n\n          #if defined(SHADERPASS_SHADOWCASTER)\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, _LightDirection));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif defined(SHADERPASS_META)\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1, v.texcoord2, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n           #if LOD_FADE_CROSSFADE\n           o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n           #endif\n\n          #if defined(SHADERPASS_FORWARD)\n              OUTPUT_LIGHTMAP_UV(v.texcoord1, unity_LightmapST, o.lightmapUV);\n              OUTPUT_SH(o.worldNormal, o.sh);\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n              half fogFactor = ComputeFogFactor(o.pos.z);\n              o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n          #endif\n\n          #ifdef _MAIN_LIGHT_SHADOWS\n              o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n           return o;\n         }\n\n\n         \n\n         // fragment shader\n         half4 Frag (VertexToPixel IN\n            #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n         ) : SV_Target\n         {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n\n           ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                     , facing\n                  #endif\n               );\n           Surface l = (Surface)0;\n\n           #ifdef _DEPTHOFFSET_ON\n              l.outputDepth = outputDepth;\n           #endif\n\n           l.Albedo = half3(0.5, 0.5, 0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n           l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n           #ifdef _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n           #endif\n\n           #if defined(_USESPECULAR) || _SIMPLELIT\n              float3 specular = l.Specular;\n              float metallic = 1;\n           #else   \n              float3 specular = 0;\n              float metallic = l.Metallic;\n           #endif\n\n           \n            InputData inputData;\n\n            inputData.positionWS = IN.worldPos;\n            #if _WORLDSPACENORMAL\n              inputData.normalWS = l.Normal;\n            #else\n              inputData.normalWS = normalize(TangentToWorldSpace(d, l.Normal));\n            #endif\n            \n            inputData.viewDirectionWS = SafeNormalize(d.worldSpaceViewDir);\n\n\n            #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n                  inputData.shadowCoord = IN.shadowCoord;\n            #elif defined(MAIN_LIGHT_CALCULATE_SHADOWS)\n                  inputData.shadowCoord = TransformWorldToShadowCoord(IN.worldPos);\n            #else\n                  inputData.shadowCoord = float4(0, 0, 0, 0);\n            #endif\n\n            inputData.fogCoord = IN.fogFactorAndVertexLight.x;\n            inputData.vertexLighting = IN.fogFactorAndVertexLight.yzw;\n            #if defined(_OVERRIDE_BAKEDGI)\n               inputData.bakedGI = l.DiffuseGI;\n            #else\n               inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.sh, inputData.normalWS);\n            #endif\n\n            #if !_UNLIT\n               #if _SIMPLELIT\n                  half4 color = UniversalFragmentBlinnPhong(\n                     inputData,\n                     l.Albedo,\n                     float4(specular * l.Smoothness, 0),\n                     l.SpecularPower * 128,\n                     l.Emission,\n                     l.Alpha);\n                  color.a = l.Alpha;\n               #else\n                  half4 color = UniversalFragmentPBR(\n                  inputData,\n                  l.Albedo,\n                  metallic,\n                  specular,\n                  l.Smoothness,\n                  l.Occlusion,\n                  l.Emission,\n                  l.Alpha); \n               #endif\n               color.rgb = MixFog(color.rgb, inputData.fogCoord);\n\n            #else\n               half4 color = half4(l.Albedo, l.Alpha);\n               color.rgb = MixFog(color.rgb, inputData.fogCoord);\n            #endif\n            ChainFinalColorForward(l, d, color);\n\n            return color;\n\n         }\n\n         ENDHLSL\n\n      }\n\n\n      \n      \n      \n        Pass\n        {\n            Name \"Meta\"\n            Tags \n            { \n                \"LightMode\" = \"Meta\"\n            }\n\n             // Render State\n            Blend One Zero, One Zero\n            Cull Back\n            ZTest LEqual\n            ZWrite On\n            // ColorMask: <None>\n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n        \n            #define SHADERPASS_META\n            #define _PASSMETA 1\n\n\n            \n\n\n   #pragma shader_feature_local_fragment _ _PACKEDFAST\n   #pragma shader_feature_local _ _TRIPLANAR\n   #pragma shader_feature_local_fragment _ _NORMALMAP \n   #pragma shader_feature_local_fragment _ _MASKMAP\n   #pragma shader_feature_local_fragment _ _DETAIL\n   #pragma shader_feature_local_fragment _ _DETAILTRIPLANAR\n   #pragma shader_feature_local_fragment _ _DETAILSTOCHASTIC\n   #pragma shader_feature_local_fragment _ _EMISSION\n   #pragma shader_feature_local_fragment _ _FLATSHADE\n   #pragma shader_feature_local _ _STOCHASTIC\n   #pragma shader_feature_local_fragment _ _PARALLAX //_POM\n   #pragma shader_feature_local_fragment _ _SPECULAR\n   #pragma shader_feature_local _ _NOISEWORLD _NOISELOCAL\n   #pragma shader_feature_local _ _NOISEHQ _NOISETEXTURE _NOISEWORLEY\n   // only for URP/Standard Forward\n   #pragma shader_feature_local_fragment _ _SIMPLELIT\n\n\n   #pragma shader_feature_local_fragment _ _TINTMASK\n\n\n    #pragma shader_feature_local _ _LAYERVERTEXMASK _LAYERTEXTUREMASK\n\n    #define _HAS_WEIGHTTEXTURE_MASK 1\n\n\n   #pragma shader_feature_local _ _USELAYER\n   #pragma shader_feature_local _ _LAYERTRIPLANAR\n   #pragma shader_feature_local _ _LAYERALBEDO\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL\n   #pragma shader_feature_local _ _LAYERMASK\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION\n   #pragma shader_feature_local _ _LAYERNOISE\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC\n   #pragma shader_feature_local _ _LAYERANGLEFILTER\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_1\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_1\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_1\n   #pragma shader_feature_local _ _LAYERMASK_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_1\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_1\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_1\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_1\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_2\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_2\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_2\n   #pragma shader_feature_local _ _LAYERMASK_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_2\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_2\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_2\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_2\n\n\n   #pragma shader_feature_local _ _TRAX_ON\n\n\n   #pragma shader_feature_local_fragment _ _WETNESS\n   #pragma shader_feature_local_fragment _ _PUDDLES\n   #pragma shader_feature_local_fragment _ _PUDDLENOISE\n   #pragma shader_feature_local_fragment _ _RAINDROPS\n\n\n   #pragma shader_feature_local _ _SNOW\n   #pragma shader_feature_local _ _SNOWMASKMAP\n   #pragma shader_feature_local _ _SNOWNOISE\n   #pragma shader_feature_local_fragment _SNOWSTOCHASTIC\n\n\n   #pragma shader_feature_local_fragment _ _WIND_ON\n\n\n\n\n   #pragma shader_feature_local_fragment _ _SURFACEGRADIENT _AUTONORMAL\n   #define _WORLDSPACENORMAL 1\n\n\n   #pragma shader_feature_local _ _DEBUG_SAMPLECOUNT\n\n\n\t#pragma shader_feature_local_fragment _ _DISSOLVE\n\n\n   #pragma multi_compile_local  LOD_FADE_CROSSFADE\n\n\n\n#pragma instancing_options procedural:setupVSPro forwardadd\n\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\nstruct IndirectShaderData\n{\n\tfloat4x4 PositionMatrix;\n\tfloat4x4 InversePositionMatrix;\n\tfloat4 ControlData;\n};\n\n#if defined(SHADER_API_GLCORE) || defined(SHADER_API_D3D11) || defined(SHADER_API_GLES3) || defined(SHADER_API_METAL) || defined(SHADER_API_VULKAN) || defined(SHADER_API_PSSL) || defined(SHADER_API_XBOXONE)\n\tuniform StructuredBuffer<IndirectShaderData> VisibleShaderDataBuffer;\n#endif\n\n#endif\n\nfloat VSPRenderingLayerMask;\n\nvoid setupVSPro()\n{\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\n    #if _HDRP\n\t    unity_RenderingLayer.x = VSPRenderingLayerMask;\n    #endif\n\n\t#ifdef unity_ObjectToWorld\n\t#undef unity_ObjectToWorld\n\t#endif\n\n\t#ifdef unity_WorldToObject\n\t#undef unity_WorldToObject\n\t#endif\n\n\tunity_ObjectToWorld = VisibleShaderDataBuffer[unity_InstanceID].PositionMatrix;\n\tunity_WorldToObject = VisibleShaderDataBuffer[unity_InstanceID].InversePositionMatrix;\n#endif\n\n}\n\n\n\t#pragma multi_compile _LIGHTMAPMODE_STANDARD _LIGHTMAPMODE_RNM _LIGHTMAPMODE_SH _LIGHTMAPMODE_VERTEX _LIGHTMAPMODE_VERTEXDIRECTIONAL _LIGHTMAPMODE_VERTEXSH\n\n    #pragma shader_feature USEBAKERY\n    #pragma shader_feature BAKERY_VERTEXLMMASK\n    #pragma shader_feature BAKERY_SHNONLINEAR\n    #pragma shader_feature BAKERY_LMSPEC\n    #pragma shader_feature BAKERY_BICUBIC\n    #pragma shader_feature BAKERY_VOLUME\n    #pragma shader_feature BAKERY_VOLROTATION\n    #pragma shader_feature BAKERY_COMPRESSED_VOLUME\n\n    #if _USEBAKERY\n\t    #define _OVERRIDE_BAKEDGI\n        #if BAKERY_VOLUME || (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)) && defined(BAKERY_VERTEXLMMASK)\n            #define _OVERRIDE_SHADOWMASK\n        #endif\n    #endif\n\n\n\n\n\n\n\n\n   #define _URP 1\n\n   #define _ALPHABLEND_ON 1\n#define _ALPHABLEND_ON 1\n#define _SURFACE_TYPE_TRANSPARENT 1\n#define NEED_FACING 1\n\n\n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/MetaInput.hlsl\"\n            #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl\"\n        \n\n                  #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n\n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCCOORD3;\n          float4 texcoord1 : TEXCCOORD4;\n         // float4 texcoord2 : TEXCCOORD5;\n\n          #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n         // float4 texcoord3 : TEXCCOORD6;\n          #endif\n\n          #if LOD_FADE_CROSSFADE\n          float4 screenPos : TEXCOORD7;\n          #endif\n\n          #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n          half4 vertexColor : COLOR_centroid;\n          #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n         // float4 extraV2F0 : TEXCOORD12;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n         // float4 extraV2F1 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n         // float4 extraV2F2 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n         // float4 extraV2F3 : TEXCOORD15;\n         // #endif\n\n          #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n          float4 extraV2F4 : TEXCOORD16_centroid;\n          #endif\n\n          #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n          float4 extraV2F5 : TEXCOORD17_centroid;\n          #endif\n\n          #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n          float4 extraV2F6 : TEXCOORD18_centroid;\n          #endif\n\n          #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n          float4 extraV2F7 : TEXCOORD19_centroid;\n          #endif\n            \n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD9;\n         #endif\n            float4 fogFactorAndVertexLight : TEXCOORD10;\n            float4 shadowCoord : TEXCOORD11;\n         #if UNITY_ANY_INSTANCING_ENABLED\n            uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n            uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n            uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n            FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n      };\n\n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n   half4 weightTextureMask;\n   \n\n\n   float traxBuffer;\n\n\n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // would love to strip these, but they are used in certain\n               // combinations of the lighting system, and may be used\n               // by the user as well, so no easy way to strip them.\n\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR_centroid;\n                #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                float4 extraV2F4 : TEXCOORD9_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                float4 extraV2F5 : TEXCOORD10_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F6 : TEXCOORD11_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F7 : TEXCOORD12_centroid;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n               #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n               #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n               #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n               #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()     unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n               #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V   unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n               #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V    mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n               #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n               #endif\n               #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n            CBUFFER_START(UnityPerMaterial)\n\n               \n\n\n   half4 _Tint;\n   half _UVSource;\n   half _TriplanarContrast;\n   half _AlbedoContrast;\n   half _AlbedoBrightness;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half3 _EmissionColor;\n   float _DetailUVSource;\n   half _StochasticScale;\n   half _DetailStochasticScale;\n   half _Smoothness;\n   half _Metallic;\n   half2 _SmoothnessRemap;\n   half2 _AORemap;\n   half2 _MetallicRemap;\n   half2 _HeightRemap;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n   half _AlphaThreshold;\n   half _Cutoff; // for Unity's light mapper\n   half _TriplanarSpace;\n   half _DetailTriplanarSpace;\n   half _DetailTriplanarContrast;\n   half _MicroShadowStrength;\n   half3 _FuzzyShadingColor;\n   half _FuzzyShadingOn;\n   half3 _FuzzyShadingParams;\n\n   //int _POMMaxSamples;\n   //float _POMMin;\n   //float _POMFade;\n#if _FLATSHADE\n   half _FlatShadingBlend;\n#endif\n\n   half _StochasticContrast;\n   half _DetailStochasticContrast;\n\n#if _PARALLAX || _POM\n   half _ParallaxHeight;\n#endif\n\n\n\n\tfloat4 _TintMask_ST;\n\thalf3 _RColor;\n\thalf3 _GColor;\n\thalf3 _BColor;\n\thalf3 _AColor;\n\n\n\thalf _LayerTextureMaskUVMode;\n    float4 _LayerTextureMask_ST;\n\n\n   //#if _USELAYER\n       float4 _LayerAlbedoMap_ST;\n       half3 _LayerTint;\n       half _LayerBlendMode;\n       float _LayerUVSource;\n       half _LayerAlbedoBrightness;\n       half _LayerAlbedoContrast;\n       half _LayerHeightContrast;\n       half _LayerStrength;\n       half _LayerAlbedoStrength;\n       half _LayerNormalStrength;\n       half _LayerSmoothnessStrength;\n       half _LayerSmoothness;\n       half _LayerMetallic;\n       half _LayerStochasticScale;\n       half2 _LayerSmoothnessRemap;\n       half2 _LayerAORemap;\n       half2 _LayerMetallicRemap;\n       half2 _LayerHeightRemap;\n       float4 _LayerWeightOverDistance;\n       half _LayerMicroShadowStrength;\n       //#if _LAYERNOISE\n           float _LayerNoiseFrequency;\n           float _LayerNoiseAmplitude;\n           float _LayerNoiseOffset;\n           float _LayerNoiseCenter;\n           half3 _LayerBlendTint;\n       //#endif\n       //#if _LAYERANGLEFILTER\n           half _LayerFalloff;\n           half _LayerAngleMin;\n           half _LayerHeight;\n           half _LayerInvertHeight;\n           half _LayerVertexNormalBlend;\n       //#endif\n       half _LayerTriplanarSpace;\n       half _LayerTriplanarContrast;\n       half _LayerBlendContrast;\n       half3 _LayerEmissionColor;\n       half _LayerStochasticContrast;\n       half _LayerTessStrength;\n       half3 _LayerFuzzyShadingColor;\n       half _LayerFuzzyShadingOn;\n       half3 _LayerFuzzyShadingParams;\n   //#endif\n\n\n   //#if _USELAYER_DEF_1\n       float4 _LayerAlbedoMap_Ext_1_ST;\n       half3 _LayerTint_Ext_1;\n       half _LayerBlendMode_Ext_1;\n       float _LayerUVSource_Ext_1;\n       half _LayerAlbedoBrightness_Ext_1;\n       half _LayerAlbedoContrast_Ext_1;\n       half _LayerHeightContrast_Ext_1;\n       half _LayerStrength_Ext_1;\n       half _LayerAlbedoStrength_Ext_1;\n       half _LayerNormalStrength_Ext_1;\n       half _LayerSmoothnessStrength_Ext_1;\n       half _LayerSmoothness_Ext_1;\n       half _LayerMetallic_Ext_1;\n       half _LayerStochasticScale_Ext_1;\n       half2 _LayerSmoothnessRemap_Ext_1;\n       half2 _LayerAORemap_Ext_1;\n       half2 _LayerMetallicRemap_Ext_1;\n       half2 _LayerHeightRemap_Ext_1;\n       float4 _LayerWeightOverDistance_Ext_1;\n       half _LayerMicroShadowStrength_Ext_1;\n       //#if _LAYERNOISE_DEF_1\n           float _LayerNoiseFrequency_Ext_1;\n           float _LayerNoiseAmplitude_Ext_1;\n           float _LayerNoiseOffset_Ext_1;\n           float _LayerNoiseCenter_Ext_1;\n           half3 _LayerBlendTint_Ext_1;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_1\n           half _LayerFalloff_Ext_1;\n           half _LayerAngleMin_Ext_1;\n           half _LayerHeight_Ext_1;\n           half _LayerInvertHeight_Ext_1;\n           half _LayerVertexNormalBlend_Ext_1;\n       //#endif\n       half _LayerTriplanarSpace_Ext_1;\n       half _LayerTriplanarContrast_Ext_1;\n       half _LayerBlendContrast_Ext_1;\n       half3 _LayerEmissionColor_Ext_1;\n       half _LayerStochasticContrast_Ext_1;\n       half _LayerTessStrength_Ext_1;\n       half3 _LayerFuzzyShadingColor_Ext_1;\n       half _LayerFuzzyShadingOn_Ext_1;\n       half3 _LayerFuzzyShadingParams_Ext_1;\n   //#endif\n\n\n   //#if _USELAYER_DEF_2\n       float4 _LayerAlbedoMap_Ext_2_ST;\n       half3 _LayerTint_Ext_2;\n       half _LayerBlendMode_Ext_2;\n       float _LayerUVSource_Ext_2;\n       half _LayerAlbedoBrightness_Ext_2;\n       half _LayerAlbedoContrast_Ext_2;\n       half _LayerHeightContrast_Ext_2;\n       half _LayerStrength_Ext_2;\n       half _LayerAlbedoStrength_Ext_2;\n       half _LayerNormalStrength_Ext_2;\n       half _LayerSmoothnessStrength_Ext_2;\n       half _LayerSmoothness_Ext_2;\n       half _LayerMetallic_Ext_2;\n       half _LayerStochasticScale_Ext_2;\n       half2 _LayerSmoothnessRemap_Ext_2;\n       half2 _LayerAORemap_Ext_2;\n       half2 _LayerMetallicRemap_Ext_2;\n       half2 _LayerHeightRemap_Ext_2;\n       float4 _LayerWeightOverDistance_Ext_2;\n       half _LayerMicroShadowStrength_Ext_2;\n       //#if _LAYERNOISE_DEF_2\n           float _LayerNoiseFrequency_Ext_2;\n           float _LayerNoiseAmplitude_Ext_2;\n           float _LayerNoiseOffset_Ext_2;\n           float _LayerNoiseCenter_Ext_2;\n           half3 _LayerBlendTint_Ext_2;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_2\n           half _LayerFalloff_Ext_2;\n           half _LayerAngleMin_Ext_2;\n           half _LayerHeight_Ext_2;\n           half _LayerInvertHeight_Ext_2;\n           half _LayerVertexNormalBlend_Ext_2;\n       //#endif\n       half _LayerTriplanarSpace_Ext_2;\n       half _LayerTriplanarContrast_Ext_2;\n       half _LayerBlendContrast_Ext_2;\n       half3 _LayerEmissionColor_Ext_2;\n       half _LayerStochasticContrast_Ext_2;\n       half _LayerTessStrength_Ext_2;\n       half3 _LayerFuzzyShadingColor_Ext_2;\n       half _LayerFuzzyShadingOn_Ext_2;\n       half3 _LayerFuzzyShadingParams_Ext_2;\n   //#endif\n\n\n    half _TraxDisplacementDepth;\n    half _TraxDisplacementStrength;\n    half _TraxMipBias;\n    half _TraxNormalStrength;\n    float4 _TraxAlbedo_ST;\n    half _TraxInterpContrast;\n    half _TraxHeightContrast;\n    half3 _TraxTint;\n\n\n\n    half _Porosity;\n    int _WetnessMode;\n    int _PuddleMode;\n\n    half  _PuddleAmount;\n    half  _PuddleFalloff;\n    half4 _PuddleColor;\n    half _PuddleNoiseFrequency;\n    half _PuddleNoiseAmplitude;\n    half _PuddleNoiseOffset;\n    half _PuddleNoiseCenter;\n    half _PuddleAngleMin;\n\n    half _WetnessAmount;\n\thalf _WetnessMin;\n    half _WetnessMax;\n    half _WetnessFalloff;\n\thalf _WetnessAngleMin;\n    float _WetnessShoreline;\n\n    int _RainMode;\n    half3 _RainIntensityScale;\n\n\n\n\n    float4 _SnowAlbedo_ST;\n    half3 _SnowTint;\n    half _SnowAmount;\n    half _SnowAngle;\n    half _SnowContrast;\n    half _SnowVertexHeight;\n    half _SnowMode;\n    half3 _SnowWorldFade; // z is on/off\n    float4 _SnowTraxAlbedo_ST;\n    half3 _SnowTraxTint;\n\n    half _SnowNoiseFreq; \n    half _SnowNoiseAmp;\n    half _SnowNoiseOffset;\n    half _SnowStochasticContrast;\n    half _SnowStochasticScale;\n\n\n    half     _WindParticulateSpace;\n    half     _WindParticulateRotation;\n    half      _WindParticulateSpeed;\n    float4     _WindParticulate_ST;\n    half      _WindParticulatePower;\n    half4    _WindParticulateColor;\n    half4    _WindParticulateWorldHeightMask;\n    half4    _WindParticulateAngleMask;\n    half      _WindParticulateOcclusionStrength;\n    half      _WindParticulateStrength;\n    half4    _WindParticulateEmissive;\n    half     _WindParticulateTextureHeight;\n\n\n   float _DoubleSidedNormalMode;\n\n\n\thalf _AutoNormalStrength;\n\n\n\tint _DebugSampleCountThreshold;\n\n\n\thalf _DissolveAmount;\n\thalf _DissolveEmissiveStr;\n\thalf _DissolveEdgeContrast;\n\thalf _DissolveColoration;\n\tfloat4 _DissolveTexture_ST;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n\n            \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\n#ifndef __STACKABLEFUNCLIBRARY_INCLUDES__\n#define __STACKABLEFUNCLIBRARY_INCLUDES__\n\n   #if _DEBUG_SAMPLECOUNT\n      int _sampleCount;\n      #define COUNTSAMPLE { _sampleCount++; }\n   #else\n      #define COUNTSAMPLE\n   #endif\n\n   TEXTURE2D(_NoiseTex);\n   SAMPLER(sampler_NoiseTex);\n\n\n\n   half3 AdjustContrast(half3 color, half contrast)\n   {\n       half3 comp = 0.5;\n   #if !UNITY_COLORSPACE_GAMMA\n       comp = 0.22;\n   #endif\n       color = saturate(lerp(comp, color, contrast));\n       return color;\n   }\n\n   float2 DoParallaxOffset( half h, half height, half3 viewDir)\n   {\n      h = h * height - height/2.0;\n      float3 v = normalize(viewDir);\n      v.z += 0.42;\n      return h * (v.xy / v.z);\n   }\n\n\n\n   #define SAMPLEBARY SampleTexBary\n\n   struct SampleConfig\n   {\n      float2 uv0;\n      float2 uv1;\n      float2 uv2;\n      float2 dx0;\n      float2 dy0;\n      float2 dx1;\n      float2 dy1;\n      float2 dx2;\n      float2 dy2;\n      float3 weights;\n      float3 origWeights;\n   };\n\n   struct Config\n   {\n      float2 origUV; // unscaled uv\n      float2 origScale;\n      float2 uv;        // no stocastic or triplanar\n      float2 dx;\n      float2 dy;\n      SampleConfig uvT; // just stochastic, or just triplanar\n      SampleConfig uvX; // stochastic and triplanar\n      SampleConfig uvY;\n      SampleConfig uvZ;\n\n      \n      float3 absVertNormal;\n      half3 axisSign;\n      float3 normal;\n   };\n\n\n    float2 Hash2D( float2 x )\n    {\n        float2 k = float2( 0.3183099, 0.3678794 );\n        x = x*k + k.yx;\n        return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );\n    }\n\n    float Noise2D(float2 p )\n    {\n        float2 i = floor( p );\n        float2 f = frac( p );\n         \n        float2 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), \n                        dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),\n                    lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), \n                        dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);\n    }\n      \n\n    float2 WorleyHash2D(float2 p)\n    {\n \t    return frac(cos(mul(p, float2x2(-64.2,71.3,81.4,-29.8)))*8321.3); \n    }\n    float WorleyNoise2D(float2 p)\n    {\n        float dist = 1;\n        float2 i = floor(p);\n        float2 f = frac(p);\n    \n        for(int x = -1;x<=1;x++)\n        {\n            for(int y = -1;y<=1;y++)\n            {\n                float d = distance(WorleyHash2D(i+float2(x,y))+float2(x,y),f);\n                dist = min(dist,d);\n            }\n        }\n        return dist;\n\t\n    }\n\n#ifndef PI\n    #define PI 3.14159265359\n#endif\n\n    float GetIntegerNoise(float2 p)\n    {\n        p  = 53.7 * frac( (p*0.3183099) + float2(0.71,0.113));\n        return frac( p.x*p.y*(p.x+p.y) );\n    }\n\n    float WorleyHash3D(float f)\n    {\n        return frac(sin(f)*43758.5453);\n    }\n\n    float WorleyHash31(float3 v)\n    {\n        return WorleyHash3D(dot(v, float3(253.14, 453.74, 183.3)));\n    }\n\n    float3 WorleyRandom3D( float3 p )\n    {\n        return frac(sin(float3(dot(p,float3(127.1,311.7,217.3)),dot(p,float3(269.5,183.3,431.1)), dot(p,float3(365.6,749.9,323.7))))*437158.5453);\n    }\n\n    float WorleyNoise3D(float3 uvw)\n    {\n        float noise = 0.0;\n    \n        float3 p = floor(uvw);\n        float3 f = frac(uvw);\n    \n        float4 res = 1;\n        for(int x = -1; x <=1; ++x)\n        {\n            for(int y = -1; y <=1; ++y)\n            {\n                for(int z = -1; z <=1; ++z)\n                {\n                    float3 gp = p + float3(x, y, z);\n\n                    float3 v = WorleyRandom3D(gp);\n\n\t\t\t\t    float3 diff = gp + v - uvw;\n                \n                    float d = length(diff);\n                \n                    if(d < res.x)\n                    {\n                        res.xyz = float3(d, res.x, res.y);\n                    }\n                    else if(d < res.y)\n                    {\n                        res.xyz = float3(res.x, d, res.y);\n                    }\n                    else if(d < res.z)\n                    {\n                        res.z = d;\n                    }\n                \n                    res.w = WorleyHash31(gp);\n                }\n            }\n        }\n\n        return res.x;\n    }\n    \n      \n    float3 Hash3D( float3 p )\n    {\n        p = float3( dot(p,float3(127.1,311.7, 74.7)),\n                dot(p,float3(269.5,183.3,246.1)),\n                dot(p,float3(113.5,271.9,124.6)));\n\n        return -1.0 + 2.0*frac(sin(p)*437.5453123);\n    }\n\n    float Noise3D( float3 p )\n    {\n        float3 i = floor( p );\n        float3 f = frac( p );\n         \n        float3 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),\n                    lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n    }\n\n    \n    float FBM2D(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           return SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n\n    }\n      \n    float FBM3D(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           half A = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.zy).g;\n           half B = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33).g;\n           half C = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoise(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3D(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3D(d.localSpacePosition * frequency+ offset, d.localSpaceNormal);\n        #else\n           return FBM2D(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n    \n    #if _SURFACEGRADIENT  \n\n    #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)\n\n      \n      \n    half3 SurfaceGradientFromTBN(ShaderData d, half2 deriv)\n    {\n        return deriv.x * d.TBNMatrix[0] + deriv.y * d.TBNMatrix[1];\n    }\n\n    half2 TspaceNormalToDerivative(half3 vM)\n    {\n        const half scale = 1.0/128.0;\n        const half3 vMa = abs(vM);\n        const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));\n\n        return -half2(vM.x, vM.y)/z_ma;\n    }\n\n    half3 SurfgradFromVolumeGradient(ShaderData d, half3 grad)\n    {\n        return grad - dot(d.worldSpaceNormal, grad) * d.worldSpaceNormal;\n    }\n\n    half3 SurfgradFromTriplanarProjection(ShaderData d, half3 pN, half3 xN, half3 yN, half3 zN)\n    {\n        const half w0 = pN.x;\n        const half w1 = pN.y;\n        const half w2 = pN.z;\n\n        half2 xD = TspaceNormalToDerivative(xN);\n        half2 yD = TspaceNormalToDerivative(yN);\n        half2 zD = TspaceNormalToDerivative(zN);\n\n        half3 volumeGrad = half3(w2 * zD.x + w1 * yD.y, w2 * zD.y + w0 * xD.y, w0 * xD.x + w1 * yD.x);\n\n        return SurfgradFromVolumeGradient(d, volumeGrad);\n    }\n\n    half3 ConvertNormalToGradient(ShaderData d, half3 normal)\n    {\n        half2 deriv = TspaceNormalToDerivative(normal);\n\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n    half3 ConvertNormal2ToGradient(ShaderData d, half2 packedNormal)\n    {\n        half2 tNormal = packedNormal;\n        half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF\n        half2 deriv = tNormal * -rcpZ;\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n\n    half3 ResolveNormalFromSurfaceGradient(ShaderData d, half3 gradient)\n    {\n        return normalize(d.worldSpaceNormal - gradient);\n    }\n\n    #endif // _SURFACEGRADIENT\n\n\n    // normals are in surface gradient or world space depending on settings, and can also be generated by height\n    half3 GetWorldSpaceNormal(ShaderData d, half3 normal, half pheight)\n    {\n       #if _SURFACEGRADIENT\n          return ResolveNormalFromSurfaceGradient(d, normal);\n       #elif _AUTONORMAL\n          float3 dx = ddx(d.worldSpacePosition);\n          float3 dy = ddy(d.worldSpacePosition);\n          float3 crossX = cross(float3(0,1,0), dx);\n          float3 crossY = cross(float3(0,1,0), dy);\n          float3 dt = abs(dot(crossY, dx));\n          float height = _AutoNormalStrength * 0.5 * pheight;\n          float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n          n.y *= -1.0;\n          return TangentToWorldSpace(d, normalize((dt * float3(0,1,0)) - n).xzy);\n       #else\n          return TangentToWorldSpace(d, normal);\n          \n       #endif\n       \n    }\n\n   void WaterBRDF (inout half3 albedo, inout half smoothness, half metallic, half wetFactor, half surfPorosity) \n   {\n      half porosity = saturate((( (1 - smoothness) - 0.5)) / max(surfPorosity, 0.001));\n      half factor = lerp(1, 0.2, (1 - metallic) * porosity);\n      albedo *= lerp(1.0, factor, wetFactor);\n      smoothness = lerp(smoothness, 0.92f, wetFactor);\n   }\n\n   void OffsetUV(inout Config c, float2 offset)\n   {\n       c.uv += offset;\n       c.uvT.uv0 += offset;\n       c.uvT.uv1 += offset;\n       c.uvT.uv2 += offset;\n       c.uvX.uv0 += offset;\n       c.uvX.uv1 += offset;\n       c.uvX.uv2 += offset;\n       c.uvY.uv0 += offset;\n       c.uvY.uv1 += offset;\n       c.uvY.uv2 += offset;\n       c.uvZ.uv0 += offset;\n       c.uvZ.uv1 += offset;\n       c.uvZ.uv2 += offset;\n   }\n\n\n    void TriangleGrid(float2 uv, float scale,\n       out float w1, out float w2, out float w3,\n       out int2 vertex1, out int2 vertex2, out int2 vertex3)\n    {\n       // Scaling of the input\n       uv *= 3.464 * scale; // 2 * sqrt(3)\n\n       // Skew input space into simplex triangle grid\n       const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);\n       float2 skewedCoord = mul(gridToSkewedGrid, uv);\n\n       // Compute local triangle vertex IDs and local barycentric coordinates\n       int2 baseId = int2(floor(skewedCoord));\n       float3 temp = float3(frac(skewedCoord), 0);\n       temp.z = 1.0 - temp.x - temp.y;\n       if (temp.z > 0.0)\n       {\n          w1 = temp.z;\n          w2 = temp.y;\n          w3 = temp.x;\n          vertex1 = baseId;\n          vertex2 = baseId + int2(0, 1);\n          vertex3 = baseId + int2(1, 0);\n       }\n       else\n       {\n          w1 = -temp.z;\n          w2 = 1.0 - temp.y;\n          w3 = 1.0 - temp.x;\n          vertex1 = baseId + int2(1, 1);\n          vertex2 = baseId + int2(1, 0);\n          vertex3 = baseId + int2(0, 1);\n       }\n    }\n\n    // Fast random hash function\n    float2 SimpleHash2(float2 p)\n    {\n       return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 43758.5453);\n    }\n\n\n    half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)\n    {\n        // compute weight with height map\n        const half epsilon = 1.0f / 1024.0f;\n        half3 weights = half3(iWeights.x * (tex0 + epsilon), \n                                 iWeights.y * (tex1 + epsilon),\n                                 iWeights.z * (tex2 + epsilon));\n\n        // Contrast weights\n        half maxWeight = max(weights.x, max(weights.y, weights.z));\n        half transition = contrast * maxWeight;\n        half threshold = maxWeight - transition;\n        half scale = 1.0f / transition;\n        weights = saturate((weights - threshold) * scale);\n        // Normalize weights.\n        half weightScale = 1.0f / (weights.x + weights.y + weights.z);\n        weights *= weightScale;\n        return weights;\n    }\n\n\n    half3 PackedUnpackScaleNormal(half4 packedNormal, float scale)\n   {\n       #if _PACKEDFAST\n          half3 normal;\n          normal.xy = (packedNormal.ag * 2 - 1) * scale;\n          normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n          return normal;  \n       #endif\n       return UnpackScaleNormal(packedNormal, scale);\n   }\n\n    void InitStochasticDxDy(inout SampleConfig c, Config cfg)\n    {\n      c.dx0 = ddx(cfg.origUV) * cfg.origScale;\n      c.dy0 = ddy(cfg.origUV) * cfg.origScale;\n      c.dx1 = c.dx0; c.dx1 = c.dx0;\n      c.dx2 = c.dy0; c.dy2 = c.dy0;\n    }\n\n    void PrepareStochasticUVs(float scale, float2 uv, out SampleConfig c)\n    {\n       // Get triangle info\n       ZERO_INITIALIZE(SampleConfig, c);\n       float w1, w2, w3;\n       int2 vertex1, vertex2, vertex3;\n       TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n       // Assign random offset to each triangle vertex\n       c.uv0 = uv;\n       c.uv1 = uv;\n       c.uv2 = uv;\n   \n       c.uv0.xy += SimpleHash2(vertex1);\n       c.uv1.xy += SimpleHash2(vertex2);\n       c.uv2.xy += SimpleHash2(vertex3);\n       c.weights = half3(w1, w2, w3);\n       c.origWeights = half3(w1, w2, w3);\n    }\n\n\n   half3 LitBlendDetailNormal(half3 n1, half3 n2)\n   {\n      #if _SURFACEGRADIENT\n         return n1 + n2;\n      #else\n         return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n      #endif\n   }\n\n   float3 TriplanarBlendUnpackedRNM(float3 n1, float3 n2)\n   {\n       n1.z += 1;\n       n2.xy = -n2.xy;\n       return n1 * dot(n1, n2) / n1.z - n2;\n   }\n\n   void InitConfigDxDy(inout Config c)\n   {\n      c.uvT.dx0 = ddx(c.uvT.uv0);\n      c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1);\n      c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2);\n      c.uvT.dy2 = ddy(c.uvT.uv2);\n   }\n\n   Config CreateConfig(ShaderData d, float4 scale, float space, int uvsource, half triplanarContrast)\n   {\n      Config c;\n      ZERO_INITIALIZE(Config, c);\n\n      float3 pos = d.worldSpacePosition;\n      float3 normal = d.worldSpaceNormal;\n      if (space > 0)\n      {\n         pos = d.localSpacePosition;\n         normal = d.localSpaceNormal;\n      }\n\n      c.uv = d.texcoord0.xy;\n      \n      if (uvsource == 1)\n        c.uv = d.texcoord1.xy;\n      else if (uvsource == 2)\n        c.uv = pos.yz * float2(1, -1);\n      else if (uvsource == 3)\n        c.uv = pos.xz * float2(1, -1);\n      else if (uvsource == 4)\n        c.uv = pos.xy * float2(1, -1);\n\n      c.origUV = c.uv;\n      c.origScale = scale.xy;\n\n      c.uv = c.uv * scale.xy + scale.zw;\n      c.dx = ddx(c.uv);\n      c.dy = ddy(c.uv);\n\n      c.normal = normal;\n      c.uvT.uv0 = pos.zy * scale.xy + scale.zw;\n      c.uvT.uv1 = pos.xz * scale.xy + scale.zw;\n      c.uvT.uv2 = pos.xy * scale.xy + scale.zw;\n        \n      c.uvT.uv1 += 0.33;\n      c.uvT.uv2 += 0.67;\n\n      c.uvT.dx0 = ddx(c.uvT.uv0); c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1); c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2); c.uvT.dy2 = ddy(c.uvT.uv2);\n\n      half3 triblend = saturate(pow(abs(c.normal), triplanarContrast));\n      triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n      c.uvT.weights = triblend;\n      c.uvT.origWeights = triblend;\n      c.axisSign = d.worldSpaceNormal < 0 ? -1 : 1;\n      c.absVertNormal = abs(d.worldSpaceNormal);\n     \n\n      return c;\n   }\n\n\n   half4 TriSample(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0) * c.weights.x;\n      }\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1) * c.weights.y;\n      }  \n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2) * c.weights.z;\n      }\n\n      return res;\n   }\n\n   half4 TriSampleBary(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      c.weights = BaryWeightBlend(c.origWeights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   half4 TriSampleGrad(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvX, contrast, d) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvY, contrast, d) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n           res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvZ, contrast, d) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   \n   half4 SampleTexBaryStochastic(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   half4 SampleTexBaryTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleGrad(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   \n   half4 SampleTexBary(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        COUNTSAMPLE\n        return SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv, c.dx, c.dy);\n   }\n\n   half4 SampleTexStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ) * c.uvT.weights.z;\n\n        return res;     \n   }\n\n   \n   half4 SampleTexStochastic(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n\n   half4 SampleTexTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n   \n   half4 SampleTex(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       COUNTSAMPLE\n       return SAMPLE_TEXTURE2D(tex, ss, c.uv);\n   }\n   \n\n \n   half3 SampleNormalStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n         dataX = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n         dataY = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n         dataZ = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ));\n\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n\n          return WorldToTangentSpace(d, worldNormal);\n       #endif\n   }\n\n\n   half3 SampleNormalTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n      {\n          COUNTSAMPLE\n          dataX = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv0, c.uvT.dx0, c.uvT.dy0));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n      {\n          COUNTSAMPLE\n          dataY = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv1, c.uvT.dx1, c.uvT.dy1));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n      {\n         COUNTSAMPLE\n         dataZ = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv2, c.uvT.dx2, c.uvT.dy2));\n      }\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n          return WorldToTangentSpace(d, worldNormal);\n      #endif\n   }\n\n   half3 SampleNormalStochastic(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n     half4 normal = TriSample(tex, ss, c.uvT);\n     #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half3 SampleNormal(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 normal = SAMPLE_TEXTURE2D(tex, ss, c.uv);\n      #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half HeightBlend(half h1, half h2, half slope, half contrast)\n   {\n      h2 = 1 - h2;\n      half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); \n      half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));\n      return blend;\n   }\n\n\n    #if _POM\n    float2 POM(TEXTURE2D_PARAM(tex, ss), Config c, float contrast, ShaderData d)\n    {\n       float2 curv = float2(0, 0);\n       float refPlane = 0;\n\n       float result = 0;\n       int stepIndex = 0;\n       int maxSamples = _POMMaxSamples;\n       int minSamples = 4;\n       float camDist = distance(_WorldSpaceCameraPos, d.worldSpacePosition);\n       float distanceFade = 1 - saturate((camDist - _POMMin) / max(1, _POMFade));\n       int numSteps = ( int )lerp( maxSamples, minSamples, dot( d.worldSpaceNormal, d.worldSpaceViewDir )) * distanceFade;\n       if (numSteps < 1)\n           numSteps = 1;\n       float layerHeight = 1.0 / numSteps;\n       float2 plane = _ParallaxHeight * ( d.tangentSpaceViewDir.xy / d.tangentSpaceViewDir.z ) * distanceFade;\n       OffsetUV(c, refPlane * plane);\n       float2 deltaTex = -plane * layerHeight;\n       float2 prevTexOffset = 0;\n       float prevRayZ = 1.0f;\n       float prevHeight = 0.0f;\n       float2 currTexOffset = deltaTex;\n       float currRayZ = 1.0f - layerHeight;\n       float currHeight = 0.0f;\n       float intersection = 0;\n       float2 finalTexOffset = 0;\n\n       while ( stepIndex < numSteps + 1 )\n       {\n          result = dot( curv, currTexOffset * currTexOffset );\n          Config cfg = c;\n          OffsetUV(cfg, currTexOffset);\n          currHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( currHeight > currRayZ )\n          {\n             stepIndex = numSteps + 1;\n          }\n          else\n          {\n             stepIndex++;\n             prevTexOffset = currTexOffset;\n             prevRayZ = currRayZ;\n             prevHeight = currHeight;\n             currTexOffset += deltaTex;\n             currRayZ -= layerHeight * ( 1 - result );\n          }\n       }\n       int sectionSteps = 10;\n       int sectionIndex = 0;\n       float newZ = 0;\n       float newHeight = 0;\n       while ( sectionIndex < sectionSteps )\n       {\n          intersection = ( prevHeight - prevRayZ ) / ( prevHeight - currHeight + currRayZ - prevRayZ );\n          finalTexOffset = prevTexOffset + intersection * deltaTex;\n          newZ = prevRayZ - intersection * layerHeight;\n          Config cfg = c;\n          OffsetUV(cfg, finalTexOffset);\n          newHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( newHeight > newZ )\n          {\n             currTexOffset = finalTexOffset;\n             currHeight = newHeight;\n             currRayZ = newZ;\n             deltaTex = intersection * deltaTex;\n             layerHeight = intersection * layerHeight;\n          }\n          else\n          {\n             prevTexOffset = finalTexOffset;\n             prevHeight = newHeight;\n             prevRayZ = newZ;\n             deltaTex = ( 1 - intersection ) * deltaTex;\n             layerHeight = ( 1 - intersection ) * layerHeight;\n          }\n          sectionIndex++;\n       }\n       #if _PASSHADOWS\n       if ( unity_LightShadowBias.z == 0.0 )\n       {\n       #endif\n          if ( result > 1 )\n             clip( -1 );\n       #if _PASSHADOWS\n       }\n       #endif\n       return finalTexOffset;\n    }\n    #endif\n\n   \n\n   // tess versions\n   #if _TESSELLATION_ON\n   half4 TriSampleLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias) * c.weights.x;\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias) * c.weights.y;\n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias) * c.weights.z;\n\n      return res;\n   }\n\n   half4 TriSampleBaryLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias, float contrast)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias);\n      half4 r2 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias);\n      half4 r3 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias);\n      c.weights = BaryWeightBlend(c.weights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryLODStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvX, bias, contrast) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvY, bias, contrast) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvZ, bias, contrast) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   half4 SampleTexBaryLODStochastic(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n       return TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias, contrast);\n   }\n\n   half4 SampleTexBaryLODTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return TriSampleLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias);\n   }\n\n   half4 SampleTexBaryLOD(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv, bias);\n   }\n\n\n    float FBM2DLOD(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           return SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv, _TessellationMipBias).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n        \n        \n    }\n\n    float FBM3DLOD(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           half A = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.zy, _TessellationMipBias).g;\n           half B = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33, _TessellationMipBias).g;\n           half C = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67, _TessellationMipBias).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoiseLOD(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3DLOD(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3DLOD(d.localSpacePosition * frequency + offset, d.localSpaceNormal);\n        #else\n           return FBM2DLOD(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n   #endif //_TESSELLATION_ON\n\n\n    half3 FuzzyShade(ShaderData d, half height, half3 color, half3 normal, half coreMult, half edgeMult, half power)\n    {\n        float3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half dt = saturate(dot(d.worldSpaceViewDir, worldNormal));\n        half dark = 1.0 - (coreMult * dt);\n        half edge = pow(1-dt, abs(power)) * edgeMult;\n        return color * (dark + edge);\n    }\n\n\thalf MicroShadow(ShaderData d, half3 normal, half height, half ao, half strength)\n\t{\n        float3 sun;\n\t\tfloat3 sunColor;\n\t\tGetSun(sun, sunColor);\n\t\tfloat3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half shadow = saturate(abs(dot(worldNormal, sun)) + (ao * ao * 2.0) - 1.0);\n        return 1 - ((1-shadow) * strength);\n\t}\n\n\n#endif\n\n\n\n   #if defined(_SPECULAR)\n      #define _USESPECULAR 1\n      #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n   #endif\n\n   \n   TEXTURE2D(_AlbedoMap);\n   SAMPLER(sampler_AlbedoMap);\n   TEXTURE2D(_NormalMap);\n   SAMPLER(sampler_NormalMap);\n   TEXTURE2D(_MaskMap);\n   TEXTURE2D(_DetailMap);\n   TEXTURE2D(_EmissionMap);\n\n   #if _SPECULAR\n       TEXTURE2D(_SpecularMap);\n   #endif\n\n   \n   \n   void Ext_SurfaceFunction0 (inout Surface o, inout ShaderData d)\n   {\n      // define samplers based on settings\n      #undef SAMPLEBARY\n      #undef SAMPLE\n      #undef SAMPLENORMAL\n      #if _STOCHASTIC && _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n        #define SAMPLE     SampleTexStochasticTriplanar\n        #define SAMPLENORMAL SampleNormalStochasticTriplanar\n      #elif _STOCHASTIC\n        #define SAMPLEBARY SampleTexBaryStochastic\n        #define SAMPLE     SampleTexStochastic\n        #define SAMPLENORMAL SampleNormalStochastic\n      #elif _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryTriplanar\n        #define SAMPLE     SampleTexTriplanar\n        #define SAMPLENORMAL SampleNormalTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBary\n        #define SAMPLE     SampleTex\n        #define SAMPLENORMAL SampleNormal\n      #endif\n\n      Config c = CreateConfig(d, _AlbedoMap_ST, _TriplanarSpace, _UVSource, _TriplanarContrast);\n      InitConfigDxDy(c);\n      #if _STOCHASTIC && !_TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uv, c.uvT);\n         InitStochasticDxDy(c.uvT, c);\n      #elif _STOCHASTIC && _TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv0, c.uvX);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv1, c.uvY);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv2, c.uvZ);\n         InitStochasticDxDy(c.uvX, c);\n         InitStochasticDxDy(c.uvY, c);\n         InitStochasticDxDy(c.uvZ, c);\n      #endif\n\n      #if _POM\n          // would need to handle height remapping if we ever want to ship this\n          float2 pomOffset = POM(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n          OffsetUV(c, pomOffset);\n      #endif\n\n      half4 albedo = SAMPLEBARY(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n      \n      #if _PARALLAX\n         float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n         OffsetUV(c, offset);\n         albedo = SAMPLE(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c);\n         \n      #endif\n      albedo.a = lerp(_HeightRemap.x, _HeightRemap.y, albedo.a);\n      albedo.rgb *= _Tint.rgb;\n\n      albedo.rgb = AdjustContrast(albedo.rgb, _AlbedoContrast);\n      albedo.rgb += _AlbedoBrightness;\n\n\n      if (_AlphaThreshold > 0)\n      {\n         clip(albedo.a - _AlphaThreshold);\n      }\n\n      #if defined(_FLATSHADE)\n\t\t     float3 dx = ddx(d.worldSpacePosition);\n\t\t     float3 dy = ddy(d.worldSpacePosition);\n\t\t     float3 worldNormal = normalize(cross(dy, dx));\n\t\t     worldNormal = lerp(d.worldSpaceNormal, worldNormal, _FlatShadingBlend);\n\t\t     d.worldSpaceNormal = worldNormal;\n\t\t     d.TBNMatrix[2] = worldNormal;\n      #endif\n\n\n\n      o.Albedo = albedo.rgb;\n      o.Alpha = albedo.a;\n\n      float smoothness = _Smoothness;\n      float ao = 1;\n\n      #if defined(_NORMALMAP) && !defined(_AUTONORMAL)\n         o.Normal = SAMPLENORMAL(TEXTURE2D_ARGS(_NormalMap, sampler_NormalMap), c, d, _NormalStrength, smoothness, ao);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, ao);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n      #endif\n\n      half detailMask = 1;\n      o.Smoothness = smoothness;\n      o.Occlusion = ao;\n      o.Metallic = _Metallic;\n      #if defined(_MASKMAP) && !_PACKEDFAST\n         // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = SampleTex(TEXTURE2D_ARGS(_MaskMap, sampler_AlbedoMap), c);\n         o.Metallic = lerp(_MetallicRemap.x, _MetallicRemap.y, mask.r);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, mask.g);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, mask.a);\n         detailMask = mask.b;\n      #endif // separate maps\n\n      #if _SPECULAR\n         o.Specular = SAMPLE(TEXTURE2D_ARGS(_SpecularMap, sampler_AlbedoMap), c).rgb;\n      #endif\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = SAMPLE(TEXTURE2D_ARGS(_EmissionMap, sampler_AlbedoMap), c).rgb * _EmissionColor;\n      #endif\n\n      if (_FuzzyShadingOn > 0)\n      {\n        o.Albedo *= FuzzyShade(d, albedo.a, _FuzzyShadingColor, o.Normal, _FuzzyShadingParams.x, _FuzzyShadingParams.y, _FuzzyShadingParams.z);\n      }\n\n\n      // HDRP style detail texturing\n\n      #if defined(_DETAIL)\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _DETAILSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n         Config dc = CreateConfig(d, _DetailMap_ST, _DetailTriplanarSpace, _DetailUVSource, _DetailTriplanarContrast);\n         InitConfigDxDy(dc);\n         #if _DETAILSTOCHASTIC && !_DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uv, dc.uvT);\n             InitStochasticDxDy(dc.uvT, dc);\n         #elif _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv0, dc.uvX);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv1, dc.uvY);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv2, dc.uvZ);\n             InitStochasticDxDy(dc.uvX, dc);\n             InitStochasticDxDy(dc.uvY, dc);\n             InitStochasticDxDy(dc.uvZ, dc);\n         #endif\n\n         half4 detailSample = SAMPLEBARY(TEXTURE2D_ARGS(_DetailMap, sampler_AlbedoMap), dc, _DetailStochasticContrast, d);\n         smoothness = detailSample.z;\n         #if !_AUTONORMAL\n            half3 dnormal = float3(detailSample.ag * 2 - 1, 1) * detailMask * _DetailNormalStrength;\n            dnormal.z = sqrt(1 - dnormal.x * dnormal.x - dnormal.y * dnormal.y);\n            #if _SURFACEGRADIENT\n               dnormal = ConvertNormalToGradient(d, dnormal);\n            #endif\n            o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n         #endif\n     \n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * smoothness, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n      if (_MicroShadowStrength > 0)\n      {\n        o.Occlusion *= MicroShadow(d, o.Normal, o.Alpha, o.Occlusion, _MicroShadowStrength);\n      }\n  \n      // in case something needs height in the stack..\n      o.Height = o.Alpha;\n\n\n      \n   }\n\n\n\n\t#if _TINTMASK\n\t\tTEXTURE2D(_TintMask);\n\t\tSAMPLER(sampler_TintMask);\n\t#endif\n\n\tvoid Ext_SurfaceFunction1 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _TINTMASK\n\t\t   half4 w = SAMPLE_TEXTURE2D(_TintMask, sampler_TintMask, d.texcoord0.xy * _TintMask_ST.xy + _TintMask_ST.zw);\n\t\t   // allow black to be no tint..\n\t\t   half3 tint = o.Albedo * (_RColor.rgb * 2 * w.r + _GColor.rgb * 2 * w.g + _BColor.rgb * 2 * w.b + _AColor.rgb * 2 * w.a);\n\t\t   o.Albedo = lerp(o.Albedo, tint, saturate(w.r + w.g + w.b + w.a));\n\t\t#endif\n\t}\n\n\n\n\n\t#if _LAYERTEXTUREMASK\n       TEXTURE2D(_LayerTextureMask);\n       SAMPLER(sampler_LayerTextureMask); \n    #endif\n\n   void Ext_ModifyTessellatedVertex2 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON\n          float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n\n          #if _LAYERTEXTUREMASK\n               float2 layerUV = v.texcoord0.xy;\n               if (_LayerTextureMaskUVMode == 1)\n                  layerUV = v.texcoord1.xy;\n               else if (_LayerTextureMaskUVMode == 2)\n                  layerUV = worldSpacePosition.yz;\n               else if (_LayerTextureMaskUVMode == 3)\n                  layerUV = worldSpacePosition.xz;\n               else if (_LayerTextureMaskUVMode == 4)\n                  layerUV = worldSpacePosition.xy;\n\n              e.blackboard.weightTextureMask = SAMPLE_TEXTURE2D_LOD(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw, _TessellationMipBias);\n          #endif\n      #endif\n    }\n\n\n\tvoid Ext_SurfaceFunction2 (inout Surface o, inout ShaderData d)\n\t{\n\t\t#if _LAYERTEXTUREMASK\n           float2 layerUV = d.texcoord0.xy;\n           if (_LayerTextureMaskUVMode == 1)\n              layerUV = d.texcoord1.xy;\n           else if (_LayerTextureMaskUVMode == 2)\n              layerUV = d.worldSpacePosition.yz;\n           else if (_LayerTextureMaskUVMode == 3)\n              layerUV = d.worldSpacePosition.xz;\n           else if (_LayerTextureMaskUVMode == 4)\n              layerUV = d.worldSpacePosition.xy;\n\n          d.blackboard.weightTextureMask = SAMPLE_TEXTURE2D(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw);\n      #endif\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap);\n   SAMPLER(sampler_LayerAlbedoMap);\n   TEXTURE2D(_LayerNormalMap);\n   TEXTURE2D(_LayerMaskMap);\n   TEXTURE2D(_LayerEmissionMap);\n\n   \n\n   void Ext_ModifyTessellatedVertex3 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER) && defined(_LAYERALBEDO) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n         half detailMask = 1;\n         #if _LAYERNOISE\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency,  _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin;\n            dt = saturate(dt * _LayerFalloff);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight) * _LayerFalloff);\n            if (_LayerInvertHeight > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength;\n         detailMask *= _LayerTessStrength;\n\n         #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast).a;\n         albedo = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo);\n\n         if (_LayerBlendMode == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction3 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n            // noise up the mask\n            #if _LAYERNOISE\n               mask = DoNoise(d, _LayerNoiseFrequency, _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend);\n\t    \n                dt -= _LayerAngleMin;\n                dt = saturate(dt * _LayerFalloff);\n\n                float hf = saturate((o.Height - _LayerHeight) * _LayerFalloff);\n                if (_LayerInvertHeight > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 0\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 0\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength;\n\n            #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint, 0.5);\n            #if defined(_LAYERALBEDO)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c, _LayerStochasticContrast, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c);\n                #endif\n                albedo.rgb *= _LayerTint;\n                albedo.a = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL || _LAYERMASK\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap, sampler_LayerAlbedoMap, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast);\n            albedo.rgb += _LayerAlbedoBrightness;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap, sampler_LayerAlbedoMap), c, d, _LayerNormalStrength * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO)\n                if (_LayerFuzzyShadingOn > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor.rgb, dnormal,\n                                            _LayerFuzzyShadingParams.x, _LayerFuzzyShadingParams.y, _LayerFuzzyShadingParams.z);\n                }\n\n                if (_LayerBlendMode == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast);\n                else if (_LayerBlendMode == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE\n                      float maskDif = (_LayerBlendContrast * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength);\n                   #if _LAYERNOISE\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap, sampler_LayerAlbedoMap), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength);\n                }\n\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap, sampler_LayerAlbedoMap), c).rgb * _LayerEmissionColor;\n                #if _LAYERALBEDO\n                    if (_LayerBlendMode > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_1);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_1);\n   TEXTURE2D(_LayerNormalMap_Ext_1);\n   TEXTURE2D(_LayerMaskMap_Ext_1);\n   TEXTURE2D(_LayerEmissionMap_Ext_1);\n\n   \n\n   void Ext_ModifyTessellatedVertex4 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_1) && defined(_LAYERALBEDO_DEF_1) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_1\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_1,  _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_1\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_1;\n            dt = saturate(dt * _LayerFalloff_Ext_1);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n            if (_LayerInvertHeight_Ext_1 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_1;\n         detailMask *= _LayerTessStrength_Ext_1;\n\n         #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_1).a;\n         albedo = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo);\n\n         if (_LayerBlendMode_Ext_1 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_1);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_1 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction4 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_1)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_1\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_1, _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_1\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_1);\n\t    \n                dt -= _LayerAngleMin_Ext_1;\n                dt = saturate(dt * _LayerFalloff_Ext_1);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n                if (_LayerInvertHeight_Ext_1 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 01\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 01\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_1;\n\n            #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_1, 0.5);\n            #if defined(_LAYERALBEDO_DEF_1)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, _LayerStochasticContrast_Ext_1, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_1;\n                albedo.a = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_1 || _LAYERMASK_DEF_1\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_1);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_1;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, d, _LayerNormalStrength_Ext_1 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_1)\n                if (_LayerFuzzyShadingOn_Ext_1 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_1.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_1.x, _LayerFuzzyShadingParams_Ext_1.y, _LayerFuzzyShadingParams_Ext_1.z);\n                }\n\n                if (_LayerBlendMode_Ext_1 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_1);\n                else if (_LayerBlendMode_Ext_1 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_1 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_1);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_1\n                      float maskDif = (_LayerBlendContrast_Ext_1 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_1 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                   #if _LAYERNOISE_DEF_1\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_1));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_1 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_1);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_1) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_1 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_1);\n                }\n\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_1);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_1, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_1, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_1\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c).rgb * _LayerEmissionColor_Ext_1;\n                #if _LAYERALBEDO_DEF_1\n                    if (_LayerBlendMode_Ext_1 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_2);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_2);\n   TEXTURE2D(_LayerNormalMap_Ext_2);\n   TEXTURE2D(_LayerMaskMap_Ext_2);\n   TEXTURE2D(_LayerEmissionMap_Ext_2);\n\n   \n\n   void Ext_ModifyTessellatedVertex5 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_2) && defined(_LAYERALBEDO_DEF_2) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_2\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_2,  _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_2\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_2;\n            dt = saturate(dt * _LayerFalloff_Ext_2);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n            if (_LayerInvertHeight_Ext_2 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_2;\n         detailMask *= _LayerTessStrength_Ext_2;\n\n         #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_2).a;\n         albedo = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo);\n\n         if (_LayerBlendMode_Ext_2 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_2);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_2 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction5 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_2)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_2\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_2, _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_2\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_2);\n\t    \n                dt -= _LayerAngleMin_Ext_2;\n                dt = saturate(dt * _LayerFalloff_Ext_2);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n                if (_LayerInvertHeight_Ext_2 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 02\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 02\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_2;\n\n            #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_2, 0.5);\n            #if defined(_LAYERALBEDO_DEF_2)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, _LayerStochasticContrast_Ext_2, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_2;\n                albedo.a = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_2 || _LAYERMASK_DEF_2\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_2);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_2;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, d, _LayerNormalStrength_Ext_2 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_2)\n                if (_LayerFuzzyShadingOn_Ext_2 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_2.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_2.x, _LayerFuzzyShadingParams_Ext_2.y, _LayerFuzzyShadingParams_Ext_2.z);\n                }\n\n                if (_LayerBlendMode_Ext_2 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_2);\n                else if (_LayerBlendMode_Ext_2 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_2 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_2);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_2\n                      float maskDif = (_LayerBlendContrast_Ext_2 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_2 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                   #if _LAYERNOISE_DEF_2\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_2));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_2 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_2);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_2) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_2 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_2);\n                }\n\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_2);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_2, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_2, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_2\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c).rgb * _LayerEmissionColor_Ext_2;\n                #if _LAYERALBEDO_DEF_2\n                    if (_LayerBlendMode_Ext_2 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   #if _TRAX_ON\n   TEXTURE2D(_TraxAlbedo);\n   SAMPLER(sampler_TraxAlbedo);\n   TEXTURE2D(_TraxPackedNormal);\n   TEXTURE2D(_TraxMask);\n\n   sampler2D_float _GMSTraxBuffer;\n\n   float4 _GMSTraxBuffer_TexelSize;\n   float3 _GMSTraxBufferPosition;\n   float _GMSTraxBufferWorldSize;\n   float _GMSTraxFudgeFactor;\n\n   float SampleTraxBufferLOD(float3 worldPos)\n   {    \n      // generate UVs for the buffer, which is moving\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 8);\n      uv *= 0.5;\n      uv += 0.5;\n            \n      float s =  tex2Dlod(_GMSTraxBuffer, float4(uv, 0, 0)).r;\n\n      return 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n   }\n         \n        \n   float SampleTraxBuffer(float3 worldPos, out float3 norm)\n   {\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 3);\n      uv *= 0.5;\n      uv += 0.5;\n            \n\n      float2 offset = _GMSTraxBuffer_TexelSize.xy;\n\n      float s = tex2D(_GMSTraxBuffer, uv).r;\n               \n      float s1 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, -1)).r;\n      float s2 = tex2D(_GMSTraxBuffer, uv + offset * float2(-1, 0)).r;\n      float s3 = tex2D(_GMSTraxBuffer, uv + offset * float2(1, 0)).r;\n      float s4 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, 1)).r;\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      float r = 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n \n      // generate normals\n      norm.x = (s1 - s4) * 0.25; \n      norm.y = (s2 - s3) * 0.25;\n      norm.z = 2;\n      norm = normalize(norm);\n     \n      norm.xy *= 1 - r;\n            \n      return r;\n   }\n   #endif\n\n   void Ext_ModifyTessellatedVertex6 (inout VertexData v, inout ExtraV2F d)\n   {\n       #if _TESSELLATION_ON && _TRAX_ON && _HAS_LIT_TESSELLATION\n          \n           float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n           float3 worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n           float traxBuffer = SampleTraxBufferLOD(worldSpacePosition);\n           d.blackboard.traxBuffer = traxBuffer;\n           float2 uv = worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n           half albedo = SAMPLE_TEXTURE2D_LOD(_TraxAlbedo, sampler_TraxAlbedo, uv, _TraxMipBias).a;\n\n           float traxOffset = albedo * _TraxDisplacementStrength;\n           traxOffset *= 1 - v.texcoord0.z;\n           traxOffset *= _TessellationDisplacement;\n           float dig = _TraxDisplacementDepth * (1 - v.texcoord0.z);\n           float3 traxVertex = d.blackboard.originalVertexPosition + (v.normal * (traxOffset - dig));\n           v.vertex.xyz = lerp(traxVertex, v.vertex.xyz, traxBuffer);\n\n           d.blackboard.vertexHeightOffset = lerp(traxOffset-dig, d.blackboard.vertexHeightOffset, traxBuffer);\n\n       #endif\n\n   }\n\n   void Ext_SurfaceFunction6 (inout Surface o, inout ShaderData d)\n   {\n      #if _TRAX_ON\n        float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n        float2 fsdx = ddx(uv);\n        float2 fsdy = ddy(uv);\n\n        float3 traxNormal;\n        float traxBuffer = SampleTraxBuffer(d.worldSpacePosition, traxNormal);\n        \n        #if _TESSELLATION_ON\n            traxBuffer -= _TraxDisplacementDepth;\n        #endif\n\n        d.blackboard.traxBuffer = traxBuffer;\n\n        UNITY_BRANCH\n        if (traxBuffer > 0)\n        {\n            half4 albedo = SAMPLE_TEXTURE2D_GRAD(_TraxAlbedo, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            albedo.rgb *= _TraxTint.rgb;\n            half4 normalSample = SAMPLE_TEXTURE2D_GRAD(_TraxPackedNormal, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n\n            half smoothness = normalSample.r;\n            half ao = normalSample.b;\n            half3 normal;\n            normal.xy = (normalSample.ag * 2 - 1) * _TraxNormalStrength;\n            normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n\n            \n            half h = HeightBlend(albedo.a, o.Alpha, traxBuffer, _TraxHeightContrast);\n\n            h = lerp(traxBuffer, h, _TraxInterpContrast);\n\n            o.Albedo = lerp(albedo, o.Albedo, h);\n\n            #if _SURFACEGRADIENT\n                o.Normal = lerp(normal, o.Normal, h);\n            #else\n                o.Normal = lerp(normal + traxNormal, o.Normal, h);\n            #endif\n        \n            o.Smoothness = lerp(smoothness, o.Smoothness, h);\n            o.Occlusion = lerp(ao, o.Occlusion, h);\n        }\n      #endif\n   }\n\n\n\n\n    #if _RAINDROPS\n       TEXTURE2D(_RainDropTexture);\n       SAMPLER(sampler_RainDropTexture);\n       half _Global_RainIntensity;\n    #endif\n\n    #if _WETNESS\n       half2 _Global_WetnessParams; // global, not in cbuffer\n    #endif\n   \n    #if _RAINDROPS\n    half2 ComputeRipple(float2 uv, half time, half weight)\n    {\n        half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_RainDropTexture, uv);\n        COUNTSAMPLE\n        ripple.yz = ripple.yz * 2 - 1;\n\n        half dropFrac = frac(ripple.w + time);\n        half timeFrac = dropFrac - 1.0 + ripple.x;\n        half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);\n        half finalFactor = dropFactor * ripple.x * \n                                sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);\n\n        return half2(ripple.yz * finalFactor);\n    }\n    #endif\n\n    half2 DoRain(half2 waterNorm, float2 uv, out half2 ripple)\n    {\n        #if _RAINDROPS\n            float rainIntensity = _RainIntensityScale.x;\n            if (_RainMode > 1)\n            {\n                rainIntensity = _Global_RainIntensity;\n            }\n\n            half dropStrength = rainIntensity;\n            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); \n            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);\n            half4 times = _Time.yyyy;\n            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);\n\n            float2 ruv1 = uv * _RainIntensityScale.yy;\n            float2 ruv2 = ruv1;\n\n            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);\n            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);\n            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);\n            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);\n            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);\n            weights = saturate(weights * 4);\n\n            half2 rippleNormal = half2( weights.x * ripple1.xy +\n                        weights.y * ripple2.xy + \n                        weights.z * ripple3.xy + \n                        weights.w * ripple4.xy);\n\n            ripple = rippleNormal * dropStrength * rainIntensity;\n            waterNorm = lerp(waterNorm, normalize(half3(rippleNormal.xy + rippleNormal.xy, 1)).xy, rainIntensity * dropStrength); \n            return waterNorm;                        \n        #else\n            return waterNorm;\n        #endif\n    }\n\n   half2 _Global_PuddleParams;   // this is a global, so keep it out of the cbuffer\n   void GetPuddleParams(ShaderData d, inout float puddleMask, inout float pudHeight)\n   {\n      #if _PUDDLES || _GLOBALPUDDLES\n          pudHeight = _PuddleAmount;\n          if (_PuddleMode > 0)\n             pudHeight = _Global_PuddleParams.x;    \n      \n\n          half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t      dt -= _PuddleAngleMin;\n          dt = saturate(dt * _PuddleFalloff);\n          puddleMask *= dt;\n      #endif\n   }\n   \n   void Ext_ModifyTessellatedVertex7 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _PUDDLES && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n         half mask = 1;\n         half pudHeight = 1;\n\n         // save some ops by doing this in 2d\n         #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2DLOD(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2DLOD(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #else\n                mask = (FBM2DLOD(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n         #endif\n\n         GetPuddleParams(d, mask, pudHeight);\n         float height = pudHeight * mask;\n         if (e.blackboard.vertexHeightOffset < height)\n         {\n            e.blackboard.vertexHeightOffset = height;\n            height -= _TessellationOffset; \n            // dampen cracks\n            height *= 1 - v.texcoord0.z;\n            height *= _TessellationDisplacement;\n            v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n            \n        }\n      #endif\n   }\n\n\n#if _WETNESS\n\n   float GetWetnessLevel(Surface o, ShaderData d, float wetnessMask)\n   {\n      float wetLevel = clamp(_WetnessAmount, _WetnessMin, _WetnessMax);\n      \n      if (_WetnessMode > 0)\n         wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);\n\n      wetLevel = saturate(wetLevel + (1 - saturate(d.worldSpacePosition.y - _WetnessShoreline)));\n      float3x3 tbn = float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal);\n      float dt = dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0));\n      dt -= _WetnessAngleMin;\n      dt = saturate(dt * _WetnessFalloff * wetLevel);\n      dt *= wetnessMask;\n      return dt;\n   }\n#endif\n   \n\n   void Ext_SurfaceFunction7 (inout Surface o, ShaderData d)\n   {\n      half wetnessLevel = 0;\n      #if _WETNESS\n          wetnessLevel = GetWetnessLevel(o, d, 1); // mask one day?\n      #endif\n\n      half depthMask = 0;\n      half depth = 0;\n\n      #if _PUDDLES\n          half mask = 1;\n          half pudHeight = 1;\n          #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2D(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2D(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);      \n            #else\n                mask = (FBM2D(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n          #endif\n\n          GetPuddleParams(d, mask, pudHeight);\n          pudHeight *= mask;\n          depth = pudHeight - o.Height;\n          depthMask = saturate(depth * _PuddleFalloff);\n          depthMask *= _PuddleColor.a;\n          depth = o.Height - pudHeight;\n\n          // extend wetness slighting higher than the puddle\n          half wetmask = saturate((pudHeight + 0.05 - o.Height) * _PuddleFalloff);\n          wetnessLevel = max(wetmask, wetnessLevel);\n       #endif\n\n       \n       #if _WETNESS || _PUDDLES\n          half3 waterNorm = half3(0,0,1);\n          half3 wetAlbedo = o.Albedo;\n          half wetSmoothness = o.Smoothness;\n          #if _PUDDLES\n             wetAlbedo *= _PuddleColor.rgb;\n          #endif\n          WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetnessLevel, _Porosity);\n\n          half ri = 0;\n          half2 ripple = 0;\n          #if (_RAINDROPS || _GLOBALRAIN) && (_PUDDLES || _GLOBALPUDDLES)\n             ri = _RainIntensityScale.z;\n             waterNorm.xy = DoRain(waterNorm.xy, d.texcoord0.xy, ripple) * depthMask;\n          #endif\n\n          o.Normal = lerp(o.Normal, waterNorm, depthMask);\n          o.Normal = lerp(o.Normal, LitBlendDetailNormal(o.Normal, half3(ripple.xy, 1)), saturate(ri - depthMask) * wetnessLevel);\n          o.Occlusion = lerp(o.Occlusion, 1, depthMask);\n          o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetnessLevel);\n          o.Albedo = lerp(o.Albedo, wetAlbedo, wetnessLevel);\n          o.Emission *= 1 + depth;\n          o.Metallic *= 1 + depth;\n          o.Specular *= 1 + depth;\n\n       #endif\n\n   }\n\n\n\n\n    #if _SNOW\n       TEXTURE2D(_SnowAlbedo);\n       SAMPLER(sampler_SnowAlbedo);\n       TEXTURE2D(_SnowNormal);\n       TEXTURE2D(_SnowMaskMap);\n       #if _TRAX_ON\n          TEXTURE2D(_SnowTraxAlbedo);\n          TEXTURE2D(_SnowTraxNormal);\n          TEXTURE2D(_SnowTraxMaskMap);\n       #endif\n    #endif\n\n   float _Global_SnowLevel;\n\n\n   void Ext_ModifyVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n    #if (_SNOW)\n        float amount = _SnowAmount;\n        if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n        float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n        float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n        snowAmount -= _SnowAngle;\n        snowAmount *= _SnowContrast * 0.5;\n        snowAmount = saturate(snowAmount) * amount;\n        float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n        if (_SnowWorldFade.z > 0)\n        {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n        }\n        #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n        #endif\n        snowAmount = saturate(snowAmount);\n\n        #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n        #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n        #endif\n\n        float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n        v.vertex.xyz = v.vertex.xyz + displacementVec * snowAmount * snowAmount * _SnowVertexHeight;\n    #endif\n   }\n\n   void Ext_ModifyTessellatedVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _SNOW && _HAS_LIT_TESSELLATION\n         float amount = _SnowAmount;\n         if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n         float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n         float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n         snowAmount -= _SnowAngle;\n         snowAmount *= _SnowContrast * 0.5;\n         float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n         if (_SnowWorldFade.z > 0)\n         {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n         }\n\n         snowAmount = saturate(snowAmount) * amount;\n\n         #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n         #endif\n         snowAmount = saturate(snowAmount);\n\n         #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n         #endif\n\n         float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n         half heightMap = SAMPLE_TEXTURE2D_LOD(_SnowAlbedo, sampler_SnowAlbedo, worldPos.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw, 2);\n\n         float height = max(_SnowVertexHeight * 3 * snowAmount + snowAmount * heightMap, e.blackboard.vertexHeightOffset);\n         #if _TRAX_ON\n            height *= e.blackboard.traxBuffer;\n         #endif\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n\n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n         \n      #endif\n\n   }\n\n   void SampleSnowSurface(TEXTURE2D_PARAM(alb, ss), TEXTURE2D_PARAM(norm, ss2), TEXTURE2D_PARAM(mask, ss3),\n        ShaderData d, float2 uv, float2 dx, float2 dy, out half4 albedo, out half3 normal, out half2 smoothAO)\n   {\n      #if _SNOWSTOCHASTIC\n         float w1, w2, w3;\n         int2 vertex1, vertex2, vertex3;\n         TriangleGrid(uv, _SnowStochasticScale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n         // Assign random offset to each triangle vertex\n         float2 uv0 = uv;\n         float2 uv1 = uv;\n         float2 uv2 = uv;\n   \n         uv0.xy += SimpleHash2(vertex1);\n         uv1.xy += SimpleHash2(vertex2);\n         uv2.xy += SimpleHash2(vertex3);\n         half3 weights = half3(w1, w2, w3);\n\n         half4 albedo0 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv0, dx, dy);\n         half4 albedo1 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv1, dx, dy);\n         half4 albedo2 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv2, dx, dy);\n         COUNTSAMPLE\n         COUNTSAMPLE\n         COUNTSAMPLE\n         weights = BaryWeightBlend(weights, albedo0.a, albedo1.a, albedo2.a, _SnowStochasticContrast);\n         albedo = albedo0 * weights.x + albedo1 * weights.y + albedo2 * weights.z;\n\n         normal = half3(0,0,1);\n         smoothAO = half2(0, 1);\n\n         #if !_AUTONORMAL\n            half4 n0 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv0, dx, dy);\n            half4 n1 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv1, dx, dy);\n            half4 n2 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n            half4 snowNormSamp = n0 * weights.x + n1 * weights.y + n2 * weights.z;\n\n            normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n                \n            #if _PACKEDFAST\n               smoothAO.x = snowNormSamp.r;\n               smoothAO.y = snowNormSamp.b;\n            #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask0 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv0, dx, dy);\n            half4 snowMask1 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv1, dx, dy);\n            half4 snowMask2 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n            half4 snowMask = snowMask0 * weights.x + snowMask1 * weights.y + snowMask2 * weights.z;\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n      #else // not stochastic\n          albedo = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv, dx, dy);\n          COUNTSAMPLE\n\n          normal = half3(0,0,1);\n          smoothAO = half2(0, 1);\n\n          #if !_AUTONORMAL\n             half4 snowNormSamp = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv, dx, dy);\n             COUNTSAMPLE\n             normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n             #if _SURFACEGRADIENT\n                normal = ConvertNormalToGradient(d, normal);\n             #endif\n                 \n             #if _PACKEDFAST\n                smoothAO.x = snowNormSamp.r;\n                smoothAO.y = snowNormSamp.b;\n             #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv, dx, dy);\n            COUNTSAMPLE\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n     #endif // stochastic\n   }\n\n   \n   void Ext_SurfaceFunction8 (inout Surface o, ShaderData d)\n   {\n      #if _SNOW\n          float amount = _SnowAmount;\n          if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n          float snowAmount = lerp(dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), dot(d.worldSpaceNormal, float3(0,1,0)), amount * 0.8) + 1;\n          snowAmount -= _SnowAngle;\n          snowAmount *= _SnowContrast;\n          snowAmount = saturate(snowAmount) - (1-amount) * (1-amount);\n\n          if (_SnowWorldFade.z > 0)\n          {\n             float worldFade = saturate((d.worldSpacePosition.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n             snowAmount *= worldFade;\n          }\n\n          #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(d.worldSpacePosition.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n          #endif\n          snowAmount = saturate(snowAmount);\n\n          float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw;\n          float2 dx = ddx(uv);\n          float2 dy = ddy(uv);\n\n          #if _TRAX_ON\n              float2 tuv = d.worldSpacePosition.xz * float2(1, -1) * _SnowTraxAlbedo_ST.xy + _SnowTraxAlbedo_ST.zw;\n              float2 tdx = ddx(uv);\n              float2 tdy = ddy(uv);\n          #endif\n\n          #if _LAYERVERTEXMASK\n              snowAmount *= d.vertexColor.a;\n          #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n              snowAmount *= d.blackboard.weightTextureMask.a;\n          #endif\n\n          UNITY_BRANCH\n          if (snowAmount > 0)\n          {\n             half4 snowAlbedo;\n             half3 snowNormal;\n             half2 snowSmoothAO;\n             SampleSnowSurface(TEXTURE2D_ARGS(_SnowAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowNormal, sampler_SnowAlbedo),\n                    TEXTURE2D_ARGS(_SnowMaskMap, sampler_SnowAlbedo), d, uv, dx, dy, snowAlbedo, snowNormal, snowSmoothAO);\n\n             snowAlbedo.rgb *= _SnowTint.rgb;\n\n             #if _TRAX_ON\n                half traxBuffer = 1 - d.blackboard.traxBuffer;\n                UNITY_BRANCH\n                if (traxBuffer > 0)\n                {\n                    half4 tsnowAlbedo;\n                    half3 tsnowNormal;\n                    half2 tsnowSmoothAO;\n                    SampleSnowSurface(TEXTURE2D_ARGS(_SnowTraxAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowTraxNormal, sampler_SnowAlbedo),\n                        TEXTURE2D_ARGS(_SnowTraxMaskMap, sampler_SnowAlbedo), d, tuv, tdx, tdy, tsnowAlbedo, tsnowNormal, tsnowSmoothAO);\n\n                    tsnowAlbedo.rgb *= _SnowTraxTint;\n                    half h = HeightBlend(snowAlbedo.a, tsnowAlbedo.a, traxBuffer, 0.5);\n                    snowAlbedo = lerp(snowAlbedo, tsnowAlbedo, h);\n                    snowNormal = lerp(snowNormal, tsnowNormal, h);\n                    snowSmoothAO = lerp(snowSmoothAO, tsnowSmoothAO, h);\n                }\n             #endif\n\n             #if !_AUTONORMAL\n                o.Normal = lerp(o.Normal, snowNormal, snowAmount);\n             #endif\n             o.Albedo = lerp(o.Albedo, snowAlbedo.rgb, snowAmount);\n             o.Alpha = lerp(o.Alpha, snowAlbedo.a, snowAmount);\n             o.Smoothness = lerp(o.Smoothness, snowSmoothAO.x, snowAmount);\n             o.Occlusion = lerp(o.Occlusion, snowSmoothAO.y, snowAmount);\n             o.Height = o.Alpha;\n\n          }\n      #endif\n   }\n\n   \n\n\n\n\n\n   TEXTURE2D(_WindParticulate);\n   SAMPLER(sampler_WindParticulate);\n\n// In case we want to read it more than once..\n\n#ifndef __STACKABLE_WIND_INCLUDES__\n#define __STACKABLE_WIND_INCLUDES__\n\n\n   half FilterRange(float4 range, float y)\n   {\n      half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));\n      w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));\n      return w;\n   }\n\n   \n   float2 RotateUV(float2 uv, float amt)\n   {\n      uv -=0.5;\n      float s = sin ( amt);\n      float c = cos ( amt );\n      float2x2 mtx = float2x2( c, -s, s, c);\n      mtx *= 0.5;\n      mtx += 0.5;\n      mtx = mtx * 2-1;\n      uv = mul ( uv, mtx );\n      uv += 0.5;\n      return uv;\n   }\n\n\n   half FilterWindParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)\n   {\n      float2 windDir = RotateUV(float2(1, 0), windRot);\n      float2 flow = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));\n      float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill\n      return FilterRange(range, cofacing);\n   }\n\n   half ProcessWindParticulateMask(inout half mask, float contrast)\n   {\n      mask = pow(abs(mask), abs(contrast));\n      half invMask = 1.0 - mask;\n      invMask *= invMask; \n      invMask *= invMask;\n      return invMask;\n   }\n#endif // include guard\n\n   void Ext_SurfaceFunction9 (inout Surface o, ShaderData d)\n   {\n      #if _WIND_ON && !_PASSMETA\n   \n         float3 upVector = float3(0,0,1);\n\n         half upDot = max(0.0, dot(d.worldSpaceNormal, float3(0, 1, 0)));\n\n         float2 uv = d.worldSpacePosition.xz;\n         if (_WindParticulateSpace > 0.5)\n            uv = d.texcoord0.xy;\n         float windRotation = _WindParticulateRotation;\n         float windStrength = _WindParticulateStrength;\n\n         float2 wuv = RotateUV(uv, windRotation);\n\n         half windBlend = 1.0;\n\n         float windWorldMask = FilterRange(_WindParticulateWorldHeightMask, d.worldSpacePosition.y);\n         windWorldMask *= FilterRange(_WindParticulateAngleMask, upDot);\n\n         // compute mask\n         wuv *= float2(_WindParticulate_ST.x, 1) * _WindParticulate_ST.y + _WindParticulate_ST.zw;\n         float speed = _Time.x * _WindParticulateSpeed;\n         half w1 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv * 3 + speed * float2(1,0)).g;\n         half w2 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv + speed * float2(1.1,0)).a;\n         half windMask = (w1 * w2);\n\n         windMask *= windStrength * windBlend * windWorldMask;\n         windMask *= saturate((_WindParticulateTextureHeight - o.Height) * 10);\n\n         half windInvMask = ProcessWindParticulateMask(windMask, _WindParticulatePower);\n    \n         o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);\n         o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindParticulateEmissive.rgb;\n         o.Normal.xy *= windInvMask;\n         o.Smoothness *= windInvMask;\n         o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;\n         o.Metallic *= windInvMask;\n      #endif\n\n   }\n\n\n\n\n\tvoid Ext_SurfaceFunction10 (inout Surface o, ShaderData d)\n\t{\n        if (_DoubleSidedNormalMode == 0)\n        {\n           o.Normal *= d.isFrontFace ? 1 : -1;\n        }\n        else if (_DoubleSidedNormalMode == 1)\n        {\n\t\t   o.Normal.z *= d.isFrontFace ? 1 : -1;\n        }\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction11 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _SURFACEGRADIENT\n\t\t\to.Normal = ResolveNormalFromSurfaceGradient(d, o.Normal);\n\t    #elif _AUTONORMAL\n\t        float3 dx = ddx(d.worldSpacePosition);\n\t\t\tfloat3 dy = ddy(d.worldSpacePosition);\n\t\t\tfloat3 crossX = cross(float3(0,1,0), dx);\n\t\t\tfloat3 crossY = cross(float3(0,1,0), dy);\n\t\t\tfloat3 dt = abs(dot(crossY, dx));\n\t\t\tfloat height = _AutoNormalStrength * 0.5 * o.Alpha;\n\t\t\tfloat3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n\t\t\tn.y *= -1.0;\n\t\t\to.Normal = normalize((dt * float3(0,1,0)) - n).xzy;\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#else\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#endif\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction12 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DEBUG_SAMPLECOUNT\n\t\t\tif (_sampleCount > _DebugSampleCountThreshold)\n\t\t\t{\n\t\t\t\to.Albedo.r = 1;\n\t\t\t\to.Albedo.gb *= 0.2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\to.Albedo.b = 1;\n\t\t\t}\n\n        #endif\n\t}\n\n\n\n\n\tSAMPLER(sampler_DissolveTexture);\n\tTEXTURE2D(_DissolveTexture);\n\tTEXTURE2D(_DissolveGradient);\n\n\tvoid Ext_SurfaceFunction13 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DISSOLVE\n\t\tfloat2 uv = d.texcoord0.xy * _DissolveTexture_ST.xy + _DissolveTexture_ST.zw;\n\t\tfloat2 dx = ddx(uv);\n\t\tfloat2 dy = ddy(uv);\n\n\t\tUNITY_BRANCH\n\t\tif (_DissolveAmount > 0)\n\t\t{\n\t\t\thalf dissolve = SAMPLE_TEXTURE2D_GRAD(_DissolveTexture, sampler_DissolveTexture, uv, dx, dy).g;\n\t\t\thalf cp =  saturate(_DissolveAmount - (dissolve - _DissolveAmount) * _DissolveEdgeContrast) + _DissolveAmount;\n\t\t\thalf cp2 = saturate(1.0 - abs((dissolve - _DissolveAmount) * _DissolveEdgeContrast));\n\t\t\tclip(1.0 - cp);\n\t\t\tfloat2 fuv = float2(cp2, 0.5);\n\t\t\thalf3 col = SAMPLE_TEXTURE2D_LOD(_DissolveGradient, sampler_DissolveTexture, fuv, 0).rgb;\n\t\t\t\t\n\t\t\to.Albedo = lerp(o.Albedo, col, _DissolveColoration * cp2);\n\t\t\to.Emission = lerp(o.Emission, col * _DissolveEmissiveStr, _DissolveColoration * cp2);\n\t\t}\n\t\t#endif\n\t}\n\n\n\n\n    float Dither8x8Bayer( int x, int y )\n    {\n        const float dither[ 64 ] = {\n                1, 49, 13, 61,  4, 52, 16, 64,\n            33, 17, 45, 29, 36, 20, 48, 32,\n                9, 57,  5, 53, 12, 60,  8, 56,\n            41, 25, 37, 21, 44, 28, 40, 24,\n                3, 51, 15, 63,  2, 50, 14, 62,\n            35, 19, 47, 31, 34, 18, 46, 30,\n            11, 59,  7, 55, 10, 58,  6, 54,\n            43, 27, 39, 23, 42, 26, 38, 22};\n        int r = y * 8 + x;\n        return dither[r] / 64; \n    }\n\n    void ApplyDitherCrossFadeVSP(float2 vpos, float fadeValue)\n    {\n        float dither = Dither8x8Bayer( fmod(vpos.x, 8), fmod(vpos.y, 8) );\n        float sgn = fadeValue > 0 ? 1.0f : -1.0f;\n        clip(dither - (1-fadeValue) * sgn);\n    }\n    \n\n\tvoid Ext_SurfaceFunction14 (inout Surface o, ShaderData d)\n\t{\n\t\t#if LOD_FADE_CROSSFADE\n            float4 screenPosNorm = d.screenPos / d.screenPos.w;\n            screenPosNorm.z = ( UNITY_NEAR_CLIP_VALUE >= 0 ) ? screenPosNorm.z : screenPosNorm.z * 0.5 + 0.5;\n            float2 clipScreen = screenPosNorm.xy * _ScreenParams.xy;\n            ApplyDitherCrossFadeVSP(clipScreen,unity_LODFade.x);\n        #endif\n\t}\n\n\n\n\n\n\n// declare outside of CBuffer\n\nfloat4x4 _GlobalVolumeMatrix;\nfloat4x4 _VolumeMatrix;\nfloat3 _VolumeMin;\nfloat3 _VolumeInvSize;\nfloat3 _GlobalVolumeMin;\nfloat3 _GlobalVolumeInvSize;\n\n// I inlined a section of your include. You can use includes in better shaders, but doing it via a subshader or this way\n// is much better. The reason is that this allows your shader to be all inclusive, and packed up for asset store distribition,\n// without requiring specific paths to other files, etc.\n//\n\n#ifndef BAKERY_INCLUDED\n#define BAKERY_INCLUDED\n\n#define BAKERYMODE_DEFAULT 0\n#define BAKERYMODE_VERTEXLM 1.0f\n#define BAKERYMODE_RNM 2.0f\n#define BAKERYMODE_SH 3.0f\n\n\n// can't fit vertexLM SH to sm3_0 interpolators\n#ifndef SHADER_API_D3D11\n    #undef _LIGHTMAPMODE_VERTEXSH\n#endif\n\n// can't do stuff on sm2_0 due to standard shader alrady taking up all instructions\n#if SHADER_TARGET < 30\n    #undef BAKERY_BICUBIC\n    #undef BAKERY_LMSPEC\n\n    #undef _LIGHTMAPMODE_RNM\n    #undef _LIGHTMAPMODE_SH\n    #undef _LIGHTMAPMODE_VERTEX\n#endif\n\n#define lumaConv float3(0.2125f, 0.7154f, 0.0721f)\n\n#ifdef BAKERY_VOLUME\n    #ifdef BAKERY_COMPRESSED_VOLUME\n        Texture3D _Volume3;\n    #endif\n#endif\n\n\nhalf3 LinearToGamma (half3 linRGB)\n{\n    linRGB = max(linRGB, half3(0.h, 0.h, 0.h));\n    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n    return max(1.055h * pow(linRGB, 0.416666667h) - 0.055h, 0.h);\n}\n\nfloat shEvaluateDiffuseL1Geomerics(float L0, float3 L1, float3 n)\n{\n    // average energy\n    float R0 = L0;\n\n    // avg direction of incoming light\n    float3 R1 = 0.5f * L1;\n\n    // directional brightness\n    float lenR1 = length(R1);\n\n    // linear angle between normal and direction 0-1\n    //float q = 0.5f * (1.0f + dot(R1 / lenR1, n));\n    //float q = dot(R1 / lenR1, n) * 0.5 + 0.5;\n    float q = dot(normalize(R1), n) * 0.5 + 0.5;\n\n    // power for q\n    // lerps from 1 (linear) to 3 (cubic) based on directionality\n    float p = 1.0f + 2.0f * lenR1 / R0;\n\n    // dynamic range constant\n    // should vary between 4 (highly directional) and 0 (ambient)\n    float a = (1.0f - lenR1 / R0) / (1.0f + lenR1 / R0);\n\n    return R0 * (a + (1.0f - a) * (p + 1.0f) * pow(q, p));\n}\n\n#ifdef BAKERY_VERTEXLMMASK\n    float4 unpack4NFloats(float src)\n\t{\n        //return fmod(float4(src / 262144.0, src / 4096.0, src / 64.0, src), 64.0)/64.0;\n        return frac(float4(src / (262144.0*64), src / (4096.0*64), src / (64.0*64), src));\n    }\n#endif\n\n#if defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n    float3 unpack3NFloats(float src)\n\t{\n        float r = frac(src);\n        float g = frac(src * 256.0);\n        float b = frac(src * 65536.0);\n        return float3(r, g, b);\n    }\n#endif\n\n// Unity defines these under different names in each SRP, so use our own\ninline float3 Bakery_SafeNormalize(float3 inVec)\n{\n    float dp3 = max(0.001f, dot(inVec, inVec));\n    return inVec * rsqrt(dp3);\n}\n\n#if _URP || _HDRP\n\nfloat SmoothnessToPerceptualRoughness(float smoothness)\n{\n    return (1 - smoothness);\n}\n#endif\n\n#if !_STANDARD\nhalf4 unity_Lightmap_HDR;\ninline half3 DecodeLightmap( half4 color )\n{\n    return DecodeLightmap( color, unity_Lightmap_HDR );\n}\n\n#define UNITY_INV_PI        0.31830988618f\ninline float GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return UNITY_INV_PI * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n    void BakeryVertexLMDirection(inout float3 diffuseColor, inout float3 specularColor, float3 lightDirection, float3 vertexNormalWorld, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 dominantDir = Bakery_SafeNormalize(lightDirection);\n        half halfLambert = dot(normalWorld, dominantDir) * 0.5 + 0.5;\n        half flatNormalHalfLambert = dot(vertexNormalWorld, dominantDir) * 0.5 + 0.5;\n\n        #ifdef BAKERY_LMSPEC\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = spec * diffuseColor;\n        #endif\n\n        diffuseColor *= halfLambert / max(1e-4h, flatNormalHalfLambert);\n    }\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXSH\n    void BakeryVertexLMSH(inout float3 diffuseColor, inout float3 specularColor, float3 shL1x, float3 shL1y, float3 shL1z, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 L0 = diffuseColor;\n        float3 nL1x = shL1x;\n        float3 nL1y = shL1y;\n        float3 nL1z = shL1z;\n        float3 L1x = nL1x * L0 * 2;\n        float3 L1y = nL1y * L0 * 2;\n        float3 L1z = nL1z * L0 * 2;\n\n        float3 sh;\n    #if BAKERY_SHNONLINEAR\n        //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n        //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n        //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n        float lumaL0 = dot(L0, 1);\n        float lumaL1x = dot(L1x, 1);\n        float lumaL1y = dot(L1y, 1);\n        float lumaL1z = dot(L1z, 1);\n        float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n        float regularLumaSH = dot(sh, 1);\n        //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n        sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    #else\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    #endif\n\n        diffuseColor = max(sh, 0.0);\n\n        #ifdef BAKERY_LMSPEC\n            float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n            float focus = saturate(length(dominantDir));\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = max(spec * sh, 0.0);\n        #endif\n    }\n#endif\n\n\n\n#ifdef BAKERY_BICUBIC\nfloat BakeryBicubic_w0(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-a + 3.0f) - 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w1(float a)\n{\n    return (1.0f/6.0f)*(a*a*(3.0f*a - 6.0f) + 4.0f);\n}\n\nfloat BakeryBicubic_w2(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-3.0f*a + 3.0f) + 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w3(float a)\n{\n    return (1.0f/6.0f)*(a*a*a);\n}\n\nfloat BakeryBicubic_g0(float a)\n{\n    return BakeryBicubic_w0(a) + BakeryBicubic_w1(a);\n}\n\nfloat BakeryBicubic_g1(float a)\n{\n    return BakeryBicubic_w2(a) + BakeryBicubic_w3(a);\n}\n\nfloat BakeryBicubic_h0(float a)\n{\n    return -1.0f + BakeryBicubic_w1(a) / (BakeryBicubic_w0(a) + BakeryBicubic_w1(a)) + 0.5f;\n}\n\nfloat BakeryBicubic_h1(float a)\n{\n    return 1.0f + BakeryBicubic_w3(a) / (BakeryBicubic_w2(a) + BakeryBicubic_w3(a)) + 0.5f;\n}\n#endif\n\n\n#if defined(_LIGHTMAPMODE_RNM) || defined(_LIGHTMAPMODE_SH)\nTexture2D _RNM0, _RNM1, _RNM2;\n#endif\n\n#ifdef BAKERY_VOLUME\nTexture3D _Volume0, _Volume1, _Volume2, _VolumeMask;\nSamplerState sampler_Volume0;\n#endif\n\n#if defined(BAKERY_BICUBIC) && defined(LIGHTMAP_ON) && defined(SHADER_API_D3D11)\n    // Bicubic\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\tfloat width, height;\n\t\ttex.GetDimensions(width, height);\n\t\tfloat texelSize = 1.0f / width;\n\n        float x = uv.x * width;\n        float y = uv.y * width;\n\n        x -= 0.5f;\n        y -= 0.5f;\n\n        float px = floor(x);\n        float py = floor(y);\n\n        float fx = x - px;\n        float fy = y - py;\n\n        float g0x = BakeryBicubic_g0(fx);\n        float g1x = BakeryBicubic_g1(fx);\n        float h0x = BakeryBicubic_h0(fx);\n        float h1x = BakeryBicubic_h1(fx);\n        float h0y = BakeryBicubic_h0(fy);\n        float h1y = BakeryBicubic_h1(fy);\n\n        return     BakeryBicubic_g0(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h0y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h0y) * texelSize))) +\n\n                   BakeryBicubic_g1(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h1y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h1y) * texelSize)));\n    }\n#else\n    // Bilinear\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\t#ifdef LIGHTMAP_ON\n\t\t\treturn tex.Sample(samplerunity_Lightmap, uv);\n\t\t#else\n\t\t\treturn float4(1,0,0,1);\n\t\t#endif\n    }\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\n#ifdef BAKERY_LMSPEC\nfloat BakeryDirectionalLightmapSpecular(float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 dominantDir = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap, lmUV).xyz * 2 - 1;\n    half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n    half nh = saturate(dot(normalWorld, halfDir));\n    half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n    half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n    half spec = GGXTerm(nh, roughness);\n    return spec;\n}\n#endif\n#endif\n\n\n\n#ifdef _LIGHTMAPMODE_RNM\nvoid BakeryRNM(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalMap, float smoothness, float3 viewDirT)\n{\n    const float3 rnmBasis0 = float3(0.816496580927726f, 0, 0.5773502691896258f);\n    const float3 rnmBasis1 = float3(-0.4082482904638631f, 0.7071067811865475f, 0.5773502691896258f);\n    const float3 rnmBasis2 = float3(-0.4082482904638631f, -0.7071067811865475f, 0.5773502691896258f);\n\n    float3 rnm0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 rnm1 = DecodeLightmap(BakeryTex2D(_RNM1, lmUV));\n    float3 rnm2 = DecodeLightmap(BakeryTex2D(_RNM2, lmUV));\n\n    #ifdef BAKERY_SSBUMP\n        diffuseColor = normalMap.x * rnm0\n                     + normalMap.z * rnm1\n                     + normalMap.y * rnm2;\n         diffuseColor *= 2;\n    #else\n        diffuseColor = saturate(dot(rnmBasis0, normalMap)) * rnm0\n                     + saturate(dot(rnmBasis1, normalMap)) * rnm1\n                     + saturate(dot(rnmBasis2, normalMap)) * rnm2;\n    #endif\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDirT = rnmBasis0 * dot(rnm0, lumaConv) +\n                              rnmBasis1 * dot(rnm1, lumaConv) +\n                              rnmBasis2 * dot(rnm2, lumaConv);\n\n        float3 dominantDirTN = normalize(dominantDirT);\n        float3 specColor = saturate(dot(rnmBasis0, dominantDirTN)) * rnm0 +\n                           saturate(dot(rnmBasis1, dominantDirTN)) * rnm1 +\n                           saturate(dot(rnmBasis2, dominantDirTN)) * rnm2;\n\n        half3 halfDir = Bakery_SafeNormalize(dominantDirTN - viewDirT);\n        half nh = saturate(dot(normalMap, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n        specularColor = spec * specColor;\n    #endif\n}\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\ninline half3 Unity_DecodeDirectionalLightmap(half3 color, half4 dirTex, half3 normalWorld)\n{\n    // In directional (non-specular) mode Enlighten bakes dominant light direction\n    // in a way, that using it for half Lambert and then dividing by a \"rebalancing coefficient\"\n    // gives a result close to plain diffuse response lightmaps, but normalmapped.\n\n    // Note that dir is not unit length on purpose. Its length is \"directionality\", like\n    // for the directional specular lightmaps.\n\n    half halfLambert = dot(normalWorld, dirTex.xyz - 0.5) + 0.5;\n\n    return color * halfLambert / max(1e-4h, dirTex.w);\n}\n#endif\n\n#ifdef _LIGHTMAPMODE_SH\nvoid BakerySH(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 L0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 nL1x = BakeryTex2D(_RNM0, lmUV) * 2 - 1;\n    float3 nL1y = BakeryTex2D(_RNM1, lmUV) * 2 - 1;\n    float3 nL1z = BakeryTex2D(_RNM2, lmUV) * 2 - 1;\n    float3 L1x = nL1x * L0 * 2;\n    float3 L1y = nL1y * L0 * 2;\n    float3 L1z = nL1z * L0 * 2;\n\n    float3 sh;\n#if BAKERY_SHNONLINEAR\n    float lumaL0 = dot(L0, 1);\n    float lumaL1x = dot(L1x, 1);\n    float lumaL1y = dot(L1y, 1);\n    float lumaL1z = dot(L1z, 1);\n    float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    float regularLumaSH = dot(sh, 1);\n    //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n    sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n    //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n    //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n#else\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n#endif\n\n    diffuseColor = max(sh, 0.0);\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n        float focus = saturate(length(dominantDir));\n        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n        half nh = saturate(dot(normalWorld, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n\n        sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n\n        specularColor = max(spec * sh, 0.0);\n    #endif\n}\n#endif\n\n#endif // include guards\n\n\n    void Ext_ModifyVertex15 (inout VertexData v, inout ExtraV2F e)\n    {\n        #if _USEBAKERY\n\t\t    #if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\t\t\t    // Unpack from RGBM\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.a * 8.0f;\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.rgb;\n\n\t\t\t    #ifdef BAKERY_VERTEXLMMASK\n\t\t\t\t    e.extraV2F4.xyzw = unpack4NFloats(v.texcoord1);\n\t\t\t    #endif\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXSH\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n                e.extraV2F6.xyz = unpack3NFloats(v.texcoord3.x) * 2 - 1;\n                e.extraV2F7.xyz = unpack3NFloats(v.texcoord3.y) * 2 - 1;\n            #endif\n       #endif\n    }\n\n#if _HDRP || _URP\n    half3 SHEvalLinearL0L1 (half4 normal)\n    {\n        half3 x;\n\n        // Linear (L1) + constant (L0) polynomial terms\n        x.r = dot(unity_SHAr,normal);\n        x.g = dot(unity_SHAg,normal);\n        x.b = dot(unity_SHAb,normal);\n\n        return x;\n    }\n\n    // normal should be normalized, w=1.0\n    half3 SHEvalLinearL2 (half4 normal)\n    {\n        half3 x1, x2;\n        // 4 of the quadratic (L2) polynomials\n        half4 vB = normal.xyzz * normal.yzzx;\n        x1.r = dot(unity_SHBr,vB);\n        x1.g = dot(unity_SHBg,vB);\n        x1.b = dot(unity_SHBb,vB);\n\n        // Final (5th) quadratic (L2) polynomial\n        half vC = normal.x*normal.x - normal.y*normal.y;\n        x2 = unity_SHC.rgb * vC;\n\n        return x1 + x2;\n    }\n\n    half3 ShadeSH9 (half4 normal)\n    {\n        // Linear + constant polynomial terms\n        half3 res = SHEvalLinearL0L1 (normal);\n\n        // Quadratic polynomials\n        res += SHEvalLinearL2 (normal);\n\n        #ifdef UNITY_COLORSPACE_GAMMA\n            res = LinearToGamma (res);\n        #endif\n\n        return res;\n\n    }\n#endif\n\n\n\n\tvoid DoBakeryStuff(inout float3 indDif, inout float3 indSpec, inout float4 shadowmask, float3 tangentNormal, float smoothness, ShaderData d)\n\t{\n\t\t// Quality!\n\t\tindDif = 1;\n\t\tindSpec = 0;\n\n        #if defined(_PASSFORWARD) || defined(_PASSGBUFFER) // forward pass on URP/Standard/HDRP + built-in deferred\n\n            float3 normalWorld = mul(tangentNormal, d.TBNMatrix);\n\n\t\t\t#ifdef LIGHTMAP_ON\n\n                // Static\n\n\t\t\t\tfloat2 lmUV = d.texcoord1 * unity_LightmapST.xy + unity_LightmapST.zw;\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_STANDARD\n\t\t\t\t\tindDif = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n\n\t\t\t\t\t#ifdef DIRLIGHTMAP_COMBINED\n\t\t\t\t\t\tfloat4 dirMap = BakeryTex2D(unity_LightmapInd, lmUV);\n\t\t\t\t\t\tindDif = Unity_DecodeDirectionalLightmap(indDif, dirMap, normalWorld);\n\n\t\t\t\t\t\t#ifdef BAKERY_LMSPEC\n\t\t\t\t\t\t\tindSpec = BakeryDirectionalLightmapSpecular(lmUV, normalWorld, -d.worldSpaceViewDir, smoothness) * indDif;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\n\t\t\t\t\tindDif = d.vertexColor;\n\n                    #ifdef BAKERY_VERTEXLMMASK\n                        shadowmask = d.extraV2F4;\n                    #endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n\t\t\t\t\t\t// worldSpaceNormal is per-vertex\n\t\t\t\t\t\t// normalWorld is per-pixel\n\t\t\t\t\t\tfloat3 bakedLightDirection = d.extraV2F5;\n\t\t\t\t\t\tBakeryVertexLMDirection(indDif, indSpec, bakedLightDirection, d.worldSpaceNormal, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXSH\n\t\t\t\t\t\tBakeryVertexLMSH(indDif, indSpec, d.extraV2F5, d.extraV2F6, d.extraV2F7, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_RNM\n\t\t\t\t\tBakeryRNM(indDif, indSpec, lmUV, tangentNormal, smoothness, -d.tangentSpaceViewDir);\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_SH\n\t\t\t\t\tBakerySH(indDif, indSpec, lmUV, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t#endif\n\n            #else\n\n                // Dynamic\n\n                #ifdef BAKERY_VOLUME\n\n                    bool isGlobal = dot(abs(_VolumeInvSize),1) == 0;\n                    float3 volViewDir = -d.worldSpaceViewDir;\n                    #ifdef BAKERY_VOLROTATION\n                        float4x4 volMatrix = (isGlobal ? _GlobalVolumeMatrix : _VolumeMatrix);\n                        float3 volInvSize = (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 lpUV = mul(volMatrix, float4(d.worldSpacePosition,1)).xyz * volInvSize + 0.5f;\n                        float3 volNormal = mul((float3x3)volMatrix, normalWorld);\n                        #ifdef BAKERY_LMSPEC\n                            volViewDir = mul((float3x3)volMatrix, volViewDir);\n                        #endif\n                    #else\n                        float3 lpUV = (d.worldSpacePosition - (isGlobal ? _GlobalVolumeMin : _VolumeMin)) * (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 volNormal = normalWorld;\n                    #endif\n\n                    #ifdef BAKERY_COMPRESSED_VOLUME\n                        float4 tex0, tex1, tex2, tex3;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex3 = _Volume3.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz * L0;\n                        L1y = tex2.xyz * L0;\n                        L1z = tex3.xyz * L0;\n                    #else\n                        float4 tex0, tex1, tex2;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV);\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV);\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz;\n                        L1y = tex2.xyz;\n                        L1z = float3(tex0.w, tex1.w, tex2.w);\n                    #endif\n                    indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), volNormal);\n                    indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), volNormal);\n                    indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), volNormal);\n\n                    #ifdef UNITY_COLORSPACE_GAMMA\n                        indDif = pow(indDif, 1.0f / 2.2f);\n                    #endif\n\n                    #ifdef BAKERY_LMSPEC\n                        float3 nL1x = L1x / L0;\n                        float3 nL1y = L1y / L0;\n                        float3 nL1z = L1z / L0;\n                        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n                        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - volViewDir);\n                        half nh = saturate(dot(volNormal, halfDir));\n                        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n                        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n                        half spec = GGXTerm(nh, roughness);\n                        float3 sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n                        indSpec = max(spec * sh, 0.0);\n                    #endif\n\n                    shadowmask = _VolumeMask.Sample(sampler_Volume0, lpUV);\n\n                #else\n\n                    #ifdef BAKERY_SHNONLINEAR\n                        float3 L0 = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);\n                        indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, unity_SHAr.xyz, normalWorld);\n                        indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, unity_SHAg.xyz, normalWorld);\n                        indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, unity_SHAb.xyz, normalWorld);\n                    #else\n                        indDif = ShadeSH9(float4(normalWorld,1));\n                    #endif\n\n                #endif\n\n\t\t\t#endif\n\n        #endif\n\t}\n\n\t// this is the main surface function. Surface is like a surface shader output structure, but\n\t// with our new outputs as well.\n\tvoid Ext_SurfaceFunction15 (inout Surface o, ShaderData d)\n\t{\n        #if _USEBAKERY\n\t\t    float3 indDif;\n\t\t    float3 indSpec;\n            float4 shadowmask = 1;\n\t\t    DoBakeryStuff(indDif, indSpec, shadowmask, o.Normal, o.Smoothness, d);\n\t\t    o.DiffuseGI = indDif;\n\t\t    o.BackDiffuseGI = indDif;\n\t\t    o.SpecularGI = indSpec;\n            o.ShadowMask = shadowmask;\n        #endif\n\t}\n\n\n\n\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                  Ext_SurfaceFunction1(l, d);\n                  Ext_SurfaceFunction2(l, d);\n                  Ext_SurfaceFunction3(l, d);\n                  Ext_SurfaceFunction4(l, d);\n                  Ext_SurfaceFunction5(l, d);\n                  Ext_SurfaceFunction6(l, d);\n                  Ext_SurfaceFunction7(l, d);\n                  Ext_SurfaceFunction8(l, d);\n                  Ext_SurfaceFunction9(l, d);\n\t\t            Ext_SurfaceFunction10(l, d);\n                  Ext_SurfaceFunction11(l, d);\n                  Ext_SurfaceFunction12(l, d);\n                  Ext_SurfaceFunction13(l, d);\n                  Ext_SurfaceFunction14(l, d);\n                  Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraV2F d;\n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                  Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                  Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                  #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                  v2p.extraV2F4 = d.extraV2F4;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                  v2p.extraV2F5 = d.extraV2F5;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F6 = d.extraV2F6;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F7 = d.extraV2F7;\n                  #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                d.extraV2F4 = v2p.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                d.extraV2F5 = v2p.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F6 = v2p.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F7 = v2p.extraV2F7;\n                #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n                Ext_ModifyTessellatedVertex2(v, d);\n                Ext_ModifyTessellatedVertex3(v, d);\n                Ext_ModifyTessellatedVertex4(v, d);\n                Ext_ModifyTessellatedVertex5(v, d);\n                Ext_ModifyTessellatedVertex6(v, d);\n                Ext_ModifyTessellatedVertex7(v, d);\n                Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                v2p.extraV2F4 = d.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                v2p.extraV2F5 = d.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F6 = d.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F7 = d.extraV2F7;\n                #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n            // d.texcoord3 = i.texcoord3;\n             #endif\n\n             d.isFrontFace = facing;\n             #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n             d.vertexColor = i.vertexColor;\n             #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(i.worldPos, 1)).xyz;\n            #endif\n             d.localSpaceNormal = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n             #if LOD_FADE_CROSSFADE\n             d.screenPos = i.screenPos;\n             d.screenUV = (i.screenPos.xy / i.screenPos.w);\n             #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n             #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n             d.extraV2F4 = i.extraV2F4;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n             d.extraV2F5 = i.extraV2F5;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F6 = i.extraV2F6;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F7 = i.extraV2F7;\n             #endif\n\n            return d;\n         }\n         \n\n            \n         #if defined(SHADERPASS_SHADOWCASTER)\n            float3 _LightDirection;\n         #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n            o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n            #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n           // o.texcoord3 = v.texcoord3;\n            #endif\n\n            #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n            o.vertexColor = v.vertexColor;\n            #endif\n           \n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n           o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n\n          #if defined(SHADERPASS_SHADOWCASTER)\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, _LightDirection));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif defined(SHADERPASS_META)\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1, v.texcoord2, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n           #if LOD_FADE_CROSSFADE\n           o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n           #endif\n\n          #if defined(SHADERPASS_FORWARD)\n              OUTPUT_LIGHTMAP_UV(v.texcoord1, unity_LightmapST, o.lightmapUV);\n              OUTPUT_SH(o.worldNormal, o.sh);\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n              half fogFactor = ComputeFogFactor(o.pos.z);\n              o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n          #endif\n\n          #ifdef _MAIN_LIGHT_SHADOWS\n              o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n           return o;\n         }\n\n\n            \n\n            // fragment shader\n            half4 Frag (VertexToPixel IN\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n            ) : SV_Target\n            {\n               UNITY_SETUP_INSTANCE_ID(IN);\n\n               ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                     , facing\n                  #endif\n               );\n\n               Surface l = (Surface)0;\n\n               l.Albedo = half3(0.5, 0.5, 0.5);\n               l.Normal = float3(0,0,1);\n               l.Occlusion = 1;\n               l.Alpha = 1;\n\n               ChainSurfaceFunction(l, d);\n\n               MetaInput metaInput = (MetaInput)0;\n               metaInput.Albedo = l.Albedo;\n               metaInput.Emission = l.Emission;\n\n               return MetaFragment(metaInput);\n\n            }\n\n         ENDHLSL\n\n      }\n\n\n      \n        Pass\n        {\n            // Name: <None>\n            Tags \n            { \n                \"LightMode\" = \"Universal2D\"\n            }\n           \n            // Render State\n            Blend One Zero, One Zero\n            Cull Back\n            ZTest LEqual\n            ZWrite On\n            // ColorMask: <None>\n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n            #pragma multi_compile_instancing\n        \n            #define SHADERPASS_2D\n\n            \n\n\n   #pragma shader_feature_local_fragment _ _PACKEDFAST\n   #pragma shader_feature_local _ _TRIPLANAR\n   #pragma shader_feature_local_fragment _ _NORMALMAP \n   #pragma shader_feature_local_fragment _ _MASKMAP\n   #pragma shader_feature_local_fragment _ _DETAIL\n   #pragma shader_feature_local_fragment _ _DETAILTRIPLANAR\n   #pragma shader_feature_local_fragment _ _DETAILSTOCHASTIC\n   #pragma shader_feature_local_fragment _ _EMISSION\n   #pragma shader_feature_local_fragment _ _FLATSHADE\n   #pragma shader_feature_local _ _STOCHASTIC\n   #pragma shader_feature_local_fragment _ _PARALLAX //_POM\n   #pragma shader_feature_local_fragment _ _SPECULAR\n   #pragma shader_feature_local _ _NOISEWORLD _NOISELOCAL\n   #pragma shader_feature_local _ _NOISEHQ _NOISETEXTURE _NOISEWORLEY\n   // only for URP/Standard Forward\n   #pragma shader_feature_local_fragment _ _SIMPLELIT\n\n\n   #pragma shader_feature_local_fragment _ _TINTMASK\n\n\n    #pragma shader_feature_local _ _LAYERVERTEXMASK _LAYERTEXTUREMASK\n\n    #define _HAS_WEIGHTTEXTURE_MASK 1\n\n\n   #pragma shader_feature_local _ _USELAYER\n   #pragma shader_feature_local _ _LAYERTRIPLANAR\n   #pragma shader_feature_local _ _LAYERALBEDO\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL\n   #pragma shader_feature_local _ _LAYERMASK\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION\n   #pragma shader_feature_local _ _LAYERNOISE\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC\n   #pragma shader_feature_local _ _LAYERANGLEFILTER\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_1\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_1\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_1\n   #pragma shader_feature_local _ _LAYERMASK_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_1\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_1\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_1\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_1\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_2\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_2\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_2\n   #pragma shader_feature_local _ _LAYERMASK_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_2\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_2\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_2\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_2\n\n\n   #pragma shader_feature_local _ _TRAX_ON\n\n\n   #pragma shader_feature_local_fragment _ _WETNESS\n   #pragma shader_feature_local_fragment _ _PUDDLES\n   #pragma shader_feature_local_fragment _ _PUDDLENOISE\n   #pragma shader_feature_local_fragment _ _RAINDROPS\n\n\n   #pragma shader_feature_local _ _SNOW\n   #pragma shader_feature_local _ _SNOWMASKMAP\n   #pragma shader_feature_local _ _SNOWNOISE\n   #pragma shader_feature_local_fragment _SNOWSTOCHASTIC\n\n\n   #pragma shader_feature_local_fragment _ _WIND_ON\n\n\n\n\n   #pragma shader_feature_local_fragment _ _SURFACEGRADIENT _AUTONORMAL\n   #define _WORLDSPACENORMAL 1\n\n\n   #pragma shader_feature_local _ _DEBUG_SAMPLECOUNT\n\n\n\t#pragma shader_feature_local_fragment _ _DISSOLVE\n\n\n   #pragma multi_compile_local  LOD_FADE_CROSSFADE\n\n\n\n#pragma instancing_options procedural:setupVSPro forwardadd\n\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\nstruct IndirectShaderData\n{\n\tfloat4x4 PositionMatrix;\n\tfloat4x4 InversePositionMatrix;\n\tfloat4 ControlData;\n};\n\n#if defined(SHADER_API_GLCORE) || defined(SHADER_API_D3D11) || defined(SHADER_API_GLES3) || defined(SHADER_API_METAL) || defined(SHADER_API_VULKAN) || defined(SHADER_API_PSSL) || defined(SHADER_API_XBOXONE)\n\tuniform StructuredBuffer<IndirectShaderData> VisibleShaderDataBuffer;\n#endif\n\n#endif\n\nfloat VSPRenderingLayerMask;\n\nvoid setupVSPro()\n{\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\n    #if _HDRP\n\t    unity_RenderingLayer.x = VSPRenderingLayerMask;\n    #endif\n\n\t#ifdef unity_ObjectToWorld\n\t#undef unity_ObjectToWorld\n\t#endif\n\n\t#ifdef unity_WorldToObject\n\t#undef unity_WorldToObject\n\t#endif\n\n\tunity_ObjectToWorld = VisibleShaderDataBuffer[unity_InstanceID].PositionMatrix;\n\tunity_WorldToObject = VisibleShaderDataBuffer[unity_InstanceID].InversePositionMatrix;\n#endif\n\n}\n\n\n\t#pragma multi_compile _LIGHTMAPMODE_STANDARD _LIGHTMAPMODE_RNM _LIGHTMAPMODE_SH _LIGHTMAPMODE_VERTEX _LIGHTMAPMODE_VERTEXDIRECTIONAL _LIGHTMAPMODE_VERTEXSH\n\n    #pragma shader_feature USEBAKERY\n    #pragma shader_feature BAKERY_VERTEXLMMASK\n    #pragma shader_feature BAKERY_SHNONLINEAR\n    #pragma shader_feature BAKERY_LMSPEC\n    #pragma shader_feature BAKERY_BICUBIC\n    #pragma shader_feature BAKERY_VOLUME\n    #pragma shader_feature BAKERY_VOLROTATION\n    #pragma shader_feature BAKERY_COMPRESSED_VOLUME\n\n    #if _USEBAKERY\n\t    #define _OVERRIDE_BAKEDGI\n        #if BAKERY_VOLUME || (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)) && defined(BAKERY_VERTEXLMMASK)\n            #define _OVERRIDE_SHADOWMASK\n        #endif\n    #endif\n\n\n\n\n\n\n\n\n   #define _URP 1\n\n   #define _ALPHABLEND_ON 1\n#define _ALPHABLEND_ON 1\n#define _SURFACE_TYPE_TRANSPARENT 1\n#define NEED_FACING 1\n\n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl\"\n        \n\n            \n\n                  #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n\n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCCOORD3;\n          float4 texcoord1 : TEXCCOORD4;\n         // float4 texcoord2 : TEXCCOORD5;\n\n          #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n         // float4 texcoord3 : TEXCCOORD6;\n          #endif\n\n          #if LOD_FADE_CROSSFADE\n          float4 screenPos : TEXCOORD7;\n          #endif\n\n          #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n          half4 vertexColor : COLOR_centroid;\n          #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n         // float4 extraV2F0 : TEXCOORD12;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n         // float4 extraV2F1 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n         // float4 extraV2F2 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n         // float4 extraV2F3 : TEXCOORD15;\n         // #endif\n\n          #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n          float4 extraV2F4 : TEXCOORD16_centroid;\n          #endif\n\n          #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n          float4 extraV2F5 : TEXCOORD17_centroid;\n          #endif\n\n          #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n          float4 extraV2F6 : TEXCOORD18_centroid;\n          #endif\n\n          #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n          float4 extraV2F7 : TEXCOORD19_centroid;\n          #endif\n            \n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD9;\n         #endif\n            float4 fogFactorAndVertexLight : TEXCOORD10;\n            float4 shadowCoord : TEXCOORD11;\n         #if UNITY_ANY_INSTANCING_ENABLED\n            uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n            uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n            uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n            FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n      };\n\n\n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n   half4 weightTextureMask;\n   \n\n\n   float traxBuffer;\n\n\n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // would love to strip these, but they are used in certain\n               // combinations of the lighting system, and may be used\n               // by the user as well, so no easy way to strip them.\n\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR_centroid;\n                #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                float4 extraV2F4 : TEXCOORD9_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                float4 extraV2F5 : TEXCOORD10_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F6 : TEXCOORD11_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F7 : TEXCOORD12_centroid;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n               #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n               #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n               #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n               #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()     unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n               #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V   unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n               #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V    mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n               #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n               #endif\n               #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n            CBUFFER_START(UnityPerMaterial)\n\n               \n\n\n   half4 _Tint;\n   half _UVSource;\n   half _TriplanarContrast;\n   half _AlbedoContrast;\n   half _AlbedoBrightness;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half3 _EmissionColor;\n   float _DetailUVSource;\n   half _StochasticScale;\n   half _DetailStochasticScale;\n   half _Smoothness;\n   half _Metallic;\n   half2 _SmoothnessRemap;\n   half2 _AORemap;\n   half2 _MetallicRemap;\n   half2 _HeightRemap;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n   half _AlphaThreshold;\n   half _Cutoff; // for Unity's light mapper\n   half _TriplanarSpace;\n   half _DetailTriplanarSpace;\n   half _DetailTriplanarContrast;\n   half _MicroShadowStrength;\n   half3 _FuzzyShadingColor;\n   half _FuzzyShadingOn;\n   half3 _FuzzyShadingParams;\n\n   //int _POMMaxSamples;\n   //float _POMMin;\n   //float _POMFade;\n#if _FLATSHADE\n   half _FlatShadingBlend;\n#endif\n\n   half _StochasticContrast;\n   half _DetailStochasticContrast;\n\n#if _PARALLAX || _POM\n   half _ParallaxHeight;\n#endif\n\n\n\n\tfloat4 _TintMask_ST;\n\thalf3 _RColor;\n\thalf3 _GColor;\n\thalf3 _BColor;\n\thalf3 _AColor;\n\n\n\thalf _LayerTextureMaskUVMode;\n    float4 _LayerTextureMask_ST;\n\n\n   //#if _USELAYER\n       float4 _LayerAlbedoMap_ST;\n       half3 _LayerTint;\n       half _LayerBlendMode;\n       float _LayerUVSource;\n       half _LayerAlbedoBrightness;\n       half _LayerAlbedoContrast;\n       half _LayerHeightContrast;\n       half _LayerStrength;\n       half _LayerAlbedoStrength;\n       half _LayerNormalStrength;\n       half _LayerSmoothnessStrength;\n       half _LayerSmoothness;\n       half _LayerMetallic;\n       half _LayerStochasticScale;\n       half2 _LayerSmoothnessRemap;\n       half2 _LayerAORemap;\n       half2 _LayerMetallicRemap;\n       half2 _LayerHeightRemap;\n       float4 _LayerWeightOverDistance;\n       half _LayerMicroShadowStrength;\n       //#if _LAYERNOISE\n           float _LayerNoiseFrequency;\n           float _LayerNoiseAmplitude;\n           float _LayerNoiseOffset;\n           float _LayerNoiseCenter;\n           half3 _LayerBlendTint;\n       //#endif\n       //#if _LAYERANGLEFILTER\n           half _LayerFalloff;\n           half _LayerAngleMin;\n           half _LayerHeight;\n           half _LayerInvertHeight;\n           half _LayerVertexNormalBlend;\n       //#endif\n       half _LayerTriplanarSpace;\n       half _LayerTriplanarContrast;\n       half _LayerBlendContrast;\n       half3 _LayerEmissionColor;\n       half _LayerStochasticContrast;\n       half _LayerTessStrength;\n       half3 _LayerFuzzyShadingColor;\n       half _LayerFuzzyShadingOn;\n       half3 _LayerFuzzyShadingParams;\n   //#endif\n\n\n   //#if _USELAYER_DEF_1\n       float4 _LayerAlbedoMap_Ext_1_ST;\n       half3 _LayerTint_Ext_1;\n       half _LayerBlendMode_Ext_1;\n       float _LayerUVSource_Ext_1;\n       half _LayerAlbedoBrightness_Ext_1;\n       half _LayerAlbedoContrast_Ext_1;\n       half _LayerHeightContrast_Ext_1;\n       half _LayerStrength_Ext_1;\n       half _LayerAlbedoStrength_Ext_1;\n       half _LayerNormalStrength_Ext_1;\n       half _LayerSmoothnessStrength_Ext_1;\n       half _LayerSmoothness_Ext_1;\n       half _LayerMetallic_Ext_1;\n       half _LayerStochasticScale_Ext_1;\n       half2 _LayerSmoothnessRemap_Ext_1;\n       half2 _LayerAORemap_Ext_1;\n       half2 _LayerMetallicRemap_Ext_1;\n       half2 _LayerHeightRemap_Ext_1;\n       float4 _LayerWeightOverDistance_Ext_1;\n       half _LayerMicroShadowStrength_Ext_1;\n       //#if _LAYERNOISE_DEF_1\n           float _LayerNoiseFrequency_Ext_1;\n           float _LayerNoiseAmplitude_Ext_1;\n           float _LayerNoiseOffset_Ext_1;\n           float _LayerNoiseCenter_Ext_1;\n           half3 _LayerBlendTint_Ext_1;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_1\n           half _LayerFalloff_Ext_1;\n           half _LayerAngleMin_Ext_1;\n           half _LayerHeight_Ext_1;\n           half _LayerInvertHeight_Ext_1;\n           half _LayerVertexNormalBlend_Ext_1;\n       //#endif\n       half _LayerTriplanarSpace_Ext_1;\n       half _LayerTriplanarContrast_Ext_1;\n       half _LayerBlendContrast_Ext_1;\n       half3 _LayerEmissionColor_Ext_1;\n       half _LayerStochasticContrast_Ext_1;\n       half _LayerTessStrength_Ext_1;\n       half3 _LayerFuzzyShadingColor_Ext_1;\n       half _LayerFuzzyShadingOn_Ext_1;\n       half3 _LayerFuzzyShadingParams_Ext_1;\n   //#endif\n\n\n   //#if _USELAYER_DEF_2\n       float4 _LayerAlbedoMap_Ext_2_ST;\n       half3 _LayerTint_Ext_2;\n       half _LayerBlendMode_Ext_2;\n       float _LayerUVSource_Ext_2;\n       half _LayerAlbedoBrightness_Ext_2;\n       half _LayerAlbedoContrast_Ext_2;\n       half _LayerHeightContrast_Ext_2;\n       half _LayerStrength_Ext_2;\n       half _LayerAlbedoStrength_Ext_2;\n       half _LayerNormalStrength_Ext_2;\n       half _LayerSmoothnessStrength_Ext_2;\n       half _LayerSmoothness_Ext_2;\n       half _LayerMetallic_Ext_2;\n       half _LayerStochasticScale_Ext_2;\n       half2 _LayerSmoothnessRemap_Ext_2;\n       half2 _LayerAORemap_Ext_2;\n       half2 _LayerMetallicRemap_Ext_2;\n       half2 _LayerHeightRemap_Ext_2;\n       float4 _LayerWeightOverDistance_Ext_2;\n       half _LayerMicroShadowStrength_Ext_2;\n       //#if _LAYERNOISE_DEF_2\n           float _LayerNoiseFrequency_Ext_2;\n           float _LayerNoiseAmplitude_Ext_2;\n           float _LayerNoiseOffset_Ext_2;\n           float _LayerNoiseCenter_Ext_2;\n           half3 _LayerBlendTint_Ext_2;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_2\n           half _LayerFalloff_Ext_2;\n           half _LayerAngleMin_Ext_2;\n           half _LayerHeight_Ext_2;\n           half _LayerInvertHeight_Ext_2;\n           half _LayerVertexNormalBlend_Ext_2;\n       //#endif\n       half _LayerTriplanarSpace_Ext_2;\n       half _LayerTriplanarContrast_Ext_2;\n       half _LayerBlendContrast_Ext_2;\n       half3 _LayerEmissionColor_Ext_2;\n       half _LayerStochasticContrast_Ext_2;\n       half _LayerTessStrength_Ext_2;\n       half3 _LayerFuzzyShadingColor_Ext_2;\n       half _LayerFuzzyShadingOn_Ext_2;\n       half3 _LayerFuzzyShadingParams_Ext_2;\n   //#endif\n\n\n    half _TraxDisplacementDepth;\n    half _TraxDisplacementStrength;\n    half _TraxMipBias;\n    half _TraxNormalStrength;\n    float4 _TraxAlbedo_ST;\n    half _TraxInterpContrast;\n    half _TraxHeightContrast;\n    half3 _TraxTint;\n\n\n\n    half _Porosity;\n    int _WetnessMode;\n    int _PuddleMode;\n\n    half  _PuddleAmount;\n    half  _PuddleFalloff;\n    half4 _PuddleColor;\n    half _PuddleNoiseFrequency;\n    half _PuddleNoiseAmplitude;\n    half _PuddleNoiseOffset;\n    half _PuddleNoiseCenter;\n    half _PuddleAngleMin;\n\n    half _WetnessAmount;\n\thalf _WetnessMin;\n    half _WetnessMax;\n    half _WetnessFalloff;\n\thalf _WetnessAngleMin;\n    float _WetnessShoreline;\n\n    int _RainMode;\n    half3 _RainIntensityScale;\n\n\n\n\n    float4 _SnowAlbedo_ST;\n    half3 _SnowTint;\n    half _SnowAmount;\n    half _SnowAngle;\n    half _SnowContrast;\n    half _SnowVertexHeight;\n    half _SnowMode;\n    half3 _SnowWorldFade; // z is on/off\n    float4 _SnowTraxAlbedo_ST;\n    half3 _SnowTraxTint;\n\n    half _SnowNoiseFreq; \n    half _SnowNoiseAmp;\n    half _SnowNoiseOffset;\n    half _SnowStochasticContrast;\n    half _SnowStochasticScale;\n\n\n    half     _WindParticulateSpace;\n    half     _WindParticulateRotation;\n    half      _WindParticulateSpeed;\n    float4     _WindParticulate_ST;\n    half      _WindParticulatePower;\n    half4    _WindParticulateColor;\n    half4    _WindParticulateWorldHeightMask;\n    half4    _WindParticulateAngleMask;\n    half      _WindParticulateOcclusionStrength;\n    half      _WindParticulateStrength;\n    half4    _WindParticulateEmissive;\n    half     _WindParticulateTextureHeight;\n\n\n   float _DoubleSidedNormalMode;\n\n\n\thalf _AutoNormalStrength;\n\n\n\tint _DebugSampleCountThreshold;\n\n\n\thalf _DissolveAmount;\n\thalf _DissolveEmissiveStr;\n\thalf _DissolveEdgeContrast;\n\thalf _DissolveColoration;\n\tfloat4 _DissolveTexture_ST;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n\n            \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\n#ifndef __STACKABLEFUNCLIBRARY_INCLUDES__\n#define __STACKABLEFUNCLIBRARY_INCLUDES__\n\n   #if _DEBUG_SAMPLECOUNT\n      int _sampleCount;\n      #define COUNTSAMPLE { _sampleCount++; }\n   #else\n      #define COUNTSAMPLE\n   #endif\n\n   TEXTURE2D(_NoiseTex);\n   SAMPLER(sampler_NoiseTex);\n\n\n\n   half3 AdjustContrast(half3 color, half contrast)\n   {\n       half3 comp = 0.5;\n   #if !UNITY_COLORSPACE_GAMMA\n       comp = 0.22;\n   #endif\n       color = saturate(lerp(comp, color, contrast));\n       return color;\n   }\n\n   float2 DoParallaxOffset( half h, half height, half3 viewDir)\n   {\n      h = h * height - height/2.0;\n      float3 v = normalize(viewDir);\n      v.z += 0.42;\n      return h * (v.xy / v.z);\n   }\n\n\n\n   #define SAMPLEBARY SampleTexBary\n\n   struct SampleConfig\n   {\n      float2 uv0;\n      float2 uv1;\n      float2 uv2;\n      float2 dx0;\n      float2 dy0;\n      float2 dx1;\n      float2 dy1;\n      float2 dx2;\n      float2 dy2;\n      float3 weights;\n      float3 origWeights;\n   };\n\n   struct Config\n   {\n      float2 origUV; // unscaled uv\n      float2 origScale;\n      float2 uv;        // no stocastic or triplanar\n      float2 dx;\n      float2 dy;\n      SampleConfig uvT; // just stochastic, or just triplanar\n      SampleConfig uvX; // stochastic and triplanar\n      SampleConfig uvY;\n      SampleConfig uvZ;\n\n      \n      float3 absVertNormal;\n      half3 axisSign;\n      float3 normal;\n   };\n\n\n    float2 Hash2D( float2 x )\n    {\n        float2 k = float2( 0.3183099, 0.3678794 );\n        x = x*k + k.yx;\n        return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );\n    }\n\n    float Noise2D(float2 p )\n    {\n        float2 i = floor( p );\n        float2 f = frac( p );\n         \n        float2 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), \n                        dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),\n                    lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), \n                        dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);\n    }\n      \n\n    float2 WorleyHash2D(float2 p)\n    {\n \t    return frac(cos(mul(p, float2x2(-64.2,71.3,81.4,-29.8)))*8321.3); \n    }\n    float WorleyNoise2D(float2 p)\n    {\n        float dist = 1;\n        float2 i = floor(p);\n        float2 f = frac(p);\n    \n        for(int x = -1;x<=1;x++)\n        {\n            for(int y = -1;y<=1;y++)\n            {\n                float d = distance(WorleyHash2D(i+float2(x,y))+float2(x,y),f);\n                dist = min(dist,d);\n            }\n        }\n        return dist;\n\t\n    }\n\n#ifndef PI\n    #define PI 3.14159265359\n#endif\n\n    float GetIntegerNoise(float2 p)\n    {\n        p  = 53.7 * frac( (p*0.3183099) + float2(0.71,0.113));\n        return frac( p.x*p.y*(p.x+p.y) );\n    }\n\n    float WorleyHash3D(float f)\n    {\n        return frac(sin(f)*43758.5453);\n    }\n\n    float WorleyHash31(float3 v)\n    {\n        return WorleyHash3D(dot(v, float3(253.14, 453.74, 183.3)));\n    }\n\n    float3 WorleyRandom3D( float3 p )\n    {\n        return frac(sin(float3(dot(p,float3(127.1,311.7,217.3)),dot(p,float3(269.5,183.3,431.1)), dot(p,float3(365.6,749.9,323.7))))*437158.5453);\n    }\n\n    float WorleyNoise3D(float3 uvw)\n    {\n        float noise = 0.0;\n    \n        float3 p = floor(uvw);\n        float3 f = frac(uvw);\n    \n        float4 res = 1;\n        for(int x = -1; x <=1; ++x)\n        {\n            for(int y = -1; y <=1; ++y)\n            {\n                for(int z = -1; z <=1; ++z)\n                {\n                    float3 gp = p + float3(x, y, z);\n\n                    float3 v = WorleyRandom3D(gp);\n\n\t\t\t\t    float3 diff = gp + v - uvw;\n                \n                    float d = length(diff);\n                \n                    if(d < res.x)\n                    {\n                        res.xyz = float3(d, res.x, res.y);\n                    }\n                    else if(d < res.y)\n                    {\n                        res.xyz = float3(res.x, d, res.y);\n                    }\n                    else if(d < res.z)\n                    {\n                        res.z = d;\n                    }\n                \n                    res.w = WorleyHash31(gp);\n                }\n            }\n        }\n\n        return res.x;\n    }\n    \n      \n    float3 Hash3D( float3 p )\n    {\n        p = float3( dot(p,float3(127.1,311.7, 74.7)),\n                dot(p,float3(269.5,183.3,246.1)),\n                dot(p,float3(113.5,271.9,124.6)));\n\n        return -1.0 + 2.0*frac(sin(p)*437.5453123);\n    }\n\n    float Noise3D( float3 p )\n    {\n        float3 i = floor( p );\n        float3 f = frac( p );\n         \n        float3 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),\n                    lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n    }\n\n    \n    float FBM2D(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           return SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n\n    }\n      \n    float FBM3D(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           half A = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.zy).g;\n           half B = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33).g;\n           half C = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoise(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3D(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3D(d.localSpacePosition * frequency+ offset, d.localSpaceNormal);\n        #else\n           return FBM2D(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n    \n    #if _SURFACEGRADIENT  \n\n    #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)\n\n      \n      \n    half3 SurfaceGradientFromTBN(ShaderData d, half2 deriv)\n    {\n        return deriv.x * d.TBNMatrix[0] + deriv.y * d.TBNMatrix[1];\n    }\n\n    half2 TspaceNormalToDerivative(half3 vM)\n    {\n        const half scale = 1.0/128.0;\n        const half3 vMa = abs(vM);\n        const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));\n\n        return -half2(vM.x, vM.y)/z_ma;\n    }\n\n    half3 SurfgradFromVolumeGradient(ShaderData d, half3 grad)\n    {\n        return grad - dot(d.worldSpaceNormal, grad) * d.worldSpaceNormal;\n    }\n\n    half3 SurfgradFromTriplanarProjection(ShaderData d, half3 pN, half3 xN, half3 yN, half3 zN)\n    {\n        const half w0 = pN.x;\n        const half w1 = pN.y;\n        const half w2 = pN.z;\n\n        half2 xD = TspaceNormalToDerivative(xN);\n        half2 yD = TspaceNormalToDerivative(yN);\n        half2 zD = TspaceNormalToDerivative(zN);\n\n        half3 volumeGrad = half3(w2 * zD.x + w1 * yD.y, w2 * zD.y + w0 * xD.y, w0 * xD.x + w1 * yD.x);\n\n        return SurfgradFromVolumeGradient(d, volumeGrad);\n    }\n\n    half3 ConvertNormalToGradient(ShaderData d, half3 normal)\n    {\n        half2 deriv = TspaceNormalToDerivative(normal);\n\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n    half3 ConvertNormal2ToGradient(ShaderData d, half2 packedNormal)\n    {\n        half2 tNormal = packedNormal;\n        half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF\n        half2 deriv = tNormal * -rcpZ;\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n\n    half3 ResolveNormalFromSurfaceGradient(ShaderData d, half3 gradient)\n    {\n        return normalize(d.worldSpaceNormal - gradient);\n    }\n\n    #endif // _SURFACEGRADIENT\n\n\n    // normals are in surface gradient or world space depending on settings, and can also be generated by height\n    half3 GetWorldSpaceNormal(ShaderData d, half3 normal, half pheight)\n    {\n       #if _SURFACEGRADIENT\n          return ResolveNormalFromSurfaceGradient(d, normal);\n       #elif _AUTONORMAL\n          float3 dx = ddx(d.worldSpacePosition);\n          float3 dy = ddy(d.worldSpacePosition);\n          float3 crossX = cross(float3(0,1,0), dx);\n          float3 crossY = cross(float3(0,1,0), dy);\n          float3 dt = abs(dot(crossY, dx));\n          float height = _AutoNormalStrength * 0.5 * pheight;\n          float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n          n.y *= -1.0;\n          return TangentToWorldSpace(d, normalize((dt * float3(0,1,0)) - n).xzy);\n       #else\n          return TangentToWorldSpace(d, normal);\n          \n       #endif\n       \n    }\n\n   void WaterBRDF (inout half3 albedo, inout half smoothness, half metallic, half wetFactor, half surfPorosity) \n   {\n      half porosity = saturate((( (1 - smoothness) - 0.5)) / max(surfPorosity, 0.001));\n      half factor = lerp(1, 0.2, (1 - metallic) * porosity);\n      albedo *= lerp(1.0, factor, wetFactor);\n      smoothness = lerp(smoothness, 0.92f, wetFactor);\n   }\n\n   void OffsetUV(inout Config c, float2 offset)\n   {\n       c.uv += offset;\n       c.uvT.uv0 += offset;\n       c.uvT.uv1 += offset;\n       c.uvT.uv2 += offset;\n       c.uvX.uv0 += offset;\n       c.uvX.uv1 += offset;\n       c.uvX.uv2 += offset;\n       c.uvY.uv0 += offset;\n       c.uvY.uv1 += offset;\n       c.uvY.uv2 += offset;\n       c.uvZ.uv0 += offset;\n       c.uvZ.uv1 += offset;\n       c.uvZ.uv2 += offset;\n   }\n\n\n    void TriangleGrid(float2 uv, float scale,\n       out float w1, out float w2, out float w3,\n       out int2 vertex1, out int2 vertex2, out int2 vertex3)\n    {\n       // Scaling of the input\n       uv *= 3.464 * scale; // 2 * sqrt(3)\n\n       // Skew input space into simplex triangle grid\n       const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);\n       float2 skewedCoord = mul(gridToSkewedGrid, uv);\n\n       // Compute local triangle vertex IDs and local barycentric coordinates\n       int2 baseId = int2(floor(skewedCoord));\n       float3 temp = float3(frac(skewedCoord), 0);\n       temp.z = 1.0 - temp.x - temp.y;\n       if (temp.z > 0.0)\n       {\n          w1 = temp.z;\n          w2 = temp.y;\n          w3 = temp.x;\n          vertex1 = baseId;\n          vertex2 = baseId + int2(0, 1);\n          vertex3 = baseId + int2(1, 0);\n       }\n       else\n       {\n          w1 = -temp.z;\n          w2 = 1.0 - temp.y;\n          w3 = 1.0 - temp.x;\n          vertex1 = baseId + int2(1, 1);\n          vertex2 = baseId + int2(1, 0);\n          vertex3 = baseId + int2(0, 1);\n       }\n    }\n\n    // Fast random hash function\n    float2 SimpleHash2(float2 p)\n    {\n       return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 43758.5453);\n    }\n\n\n    half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)\n    {\n        // compute weight with height map\n        const half epsilon = 1.0f / 1024.0f;\n        half3 weights = half3(iWeights.x * (tex0 + epsilon), \n                                 iWeights.y * (tex1 + epsilon),\n                                 iWeights.z * (tex2 + epsilon));\n\n        // Contrast weights\n        half maxWeight = max(weights.x, max(weights.y, weights.z));\n        half transition = contrast * maxWeight;\n        half threshold = maxWeight - transition;\n        half scale = 1.0f / transition;\n        weights = saturate((weights - threshold) * scale);\n        // Normalize weights.\n        half weightScale = 1.0f / (weights.x + weights.y + weights.z);\n        weights *= weightScale;\n        return weights;\n    }\n\n\n    half3 PackedUnpackScaleNormal(half4 packedNormal, float scale)\n   {\n       #if _PACKEDFAST\n          half3 normal;\n          normal.xy = (packedNormal.ag * 2 - 1) * scale;\n          normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n          return normal;  \n       #endif\n       return UnpackScaleNormal(packedNormal, scale);\n   }\n\n    void InitStochasticDxDy(inout SampleConfig c, Config cfg)\n    {\n      c.dx0 = ddx(cfg.origUV) * cfg.origScale;\n      c.dy0 = ddy(cfg.origUV) * cfg.origScale;\n      c.dx1 = c.dx0; c.dx1 = c.dx0;\n      c.dx2 = c.dy0; c.dy2 = c.dy0;\n    }\n\n    void PrepareStochasticUVs(float scale, float2 uv, out SampleConfig c)\n    {\n       // Get triangle info\n       ZERO_INITIALIZE(SampleConfig, c);\n       float w1, w2, w3;\n       int2 vertex1, vertex2, vertex3;\n       TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n       // Assign random offset to each triangle vertex\n       c.uv0 = uv;\n       c.uv1 = uv;\n       c.uv2 = uv;\n   \n       c.uv0.xy += SimpleHash2(vertex1);\n       c.uv1.xy += SimpleHash2(vertex2);\n       c.uv2.xy += SimpleHash2(vertex3);\n       c.weights = half3(w1, w2, w3);\n       c.origWeights = half3(w1, w2, w3);\n    }\n\n\n   half3 LitBlendDetailNormal(half3 n1, half3 n2)\n   {\n      #if _SURFACEGRADIENT\n         return n1 + n2;\n      #else\n         return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n      #endif\n   }\n\n   float3 TriplanarBlendUnpackedRNM(float3 n1, float3 n2)\n   {\n       n1.z += 1;\n       n2.xy = -n2.xy;\n       return n1 * dot(n1, n2) / n1.z - n2;\n   }\n\n   void InitConfigDxDy(inout Config c)\n   {\n      c.uvT.dx0 = ddx(c.uvT.uv0);\n      c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1);\n      c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2);\n      c.uvT.dy2 = ddy(c.uvT.uv2);\n   }\n\n   Config CreateConfig(ShaderData d, float4 scale, float space, int uvsource, half triplanarContrast)\n   {\n      Config c;\n      ZERO_INITIALIZE(Config, c);\n\n      float3 pos = d.worldSpacePosition;\n      float3 normal = d.worldSpaceNormal;\n      if (space > 0)\n      {\n         pos = d.localSpacePosition;\n         normal = d.localSpaceNormal;\n      }\n\n      c.uv = d.texcoord0.xy;\n      \n      if (uvsource == 1)\n        c.uv = d.texcoord1.xy;\n      else if (uvsource == 2)\n        c.uv = pos.yz * float2(1, -1);\n      else if (uvsource == 3)\n        c.uv = pos.xz * float2(1, -1);\n      else if (uvsource == 4)\n        c.uv = pos.xy * float2(1, -1);\n\n      c.origUV = c.uv;\n      c.origScale = scale.xy;\n\n      c.uv = c.uv * scale.xy + scale.zw;\n      c.dx = ddx(c.uv);\n      c.dy = ddy(c.uv);\n\n      c.normal = normal;\n      c.uvT.uv0 = pos.zy * scale.xy + scale.zw;\n      c.uvT.uv1 = pos.xz * scale.xy + scale.zw;\n      c.uvT.uv2 = pos.xy * scale.xy + scale.zw;\n        \n      c.uvT.uv1 += 0.33;\n      c.uvT.uv2 += 0.67;\n\n      c.uvT.dx0 = ddx(c.uvT.uv0); c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1); c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2); c.uvT.dy2 = ddy(c.uvT.uv2);\n\n      half3 triblend = saturate(pow(abs(c.normal), triplanarContrast));\n      triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n      c.uvT.weights = triblend;\n      c.uvT.origWeights = triblend;\n      c.axisSign = d.worldSpaceNormal < 0 ? -1 : 1;\n      c.absVertNormal = abs(d.worldSpaceNormal);\n     \n\n      return c;\n   }\n\n\n   half4 TriSample(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0) * c.weights.x;\n      }\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1) * c.weights.y;\n      }  \n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2) * c.weights.z;\n      }\n\n      return res;\n   }\n\n   half4 TriSampleBary(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      c.weights = BaryWeightBlend(c.origWeights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   half4 TriSampleGrad(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvX, contrast, d) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvY, contrast, d) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n           res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvZ, contrast, d) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   \n   half4 SampleTexBaryStochastic(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   half4 SampleTexBaryTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleGrad(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   \n   half4 SampleTexBary(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        COUNTSAMPLE\n        return SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv, c.dx, c.dy);\n   }\n\n   half4 SampleTexStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ) * c.uvT.weights.z;\n\n        return res;     \n   }\n\n   \n   half4 SampleTexStochastic(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n\n   half4 SampleTexTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n   \n   half4 SampleTex(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       COUNTSAMPLE\n       return SAMPLE_TEXTURE2D(tex, ss, c.uv);\n   }\n   \n\n \n   half3 SampleNormalStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n         dataX = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n         dataY = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n         dataZ = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ));\n\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n\n          return WorldToTangentSpace(d, worldNormal);\n       #endif\n   }\n\n\n   half3 SampleNormalTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n      {\n          COUNTSAMPLE\n          dataX = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv0, c.uvT.dx0, c.uvT.dy0));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n      {\n          COUNTSAMPLE\n          dataY = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv1, c.uvT.dx1, c.uvT.dy1));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n      {\n         COUNTSAMPLE\n         dataZ = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv2, c.uvT.dx2, c.uvT.dy2));\n      }\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n          return WorldToTangentSpace(d, worldNormal);\n      #endif\n   }\n\n   half3 SampleNormalStochastic(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n     half4 normal = TriSample(tex, ss, c.uvT);\n     #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half3 SampleNormal(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 normal = SAMPLE_TEXTURE2D(tex, ss, c.uv);\n      #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half HeightBlend(half h1, half h2, half slope, half contrast)\n   {\n      h2 = 1 - h2;\n      half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); \n      half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));\n      return blend;\n   }\n\n\n    #if _POM\n    float2 POM(TEXTURE2D_PARAM(tex, ss), Config c, float contrast, ShaderData d)\n    {\n       float2 curv = float2(0, 0);\n       float refPlane = 0;\n\n       float result = 0;\n       int stepIndex = 0;\n       int maxSamples = _POMMaxSamples;\n       int minSamples = 4;\n       float camDist = distance(_WorldSpaceCameraPos, d.worldSpacePosition);\n       float distanceFade = 1 - saturate((camDist - _POMMin) / max(1, _POMFade));\n       int numSteps = ( int )lerp( maxSamples, minSamples, dot( d.worldSpaceNormal, d.worldSpaceViewDir )) * distanceFade;\n       if (numSteps < 1)\n           numSteps = 1;\n       float layerHeight = 1.0 / numSteps;\n       float2 plane = _ParallaxHeight * ( d.tangentSpaceViewDir.xy / d.tangentSpaceViewDir.z ) * distanceFade;\n       OffsetUV(c, refPlane * plane);\n       float2 deltaTex = -plane * layerHeight;\n       float2 prevTexOffset = 0;\n       float prevRayZ = 1.0f;\n       float prevHeight = 0.0f;\n       float2 currTexOffset = deltaTex;\n       float currRayZ = 1.0f - layerHeight;\n       float currHeight = 0.0f;\n       float intersection = 0;\n       float2 finalTexOffset = 0;\n\n       while ( stepIndex < numSteps + 1 )\n       {\n          result = dot( curv, currTexOffset * currTexOffset );\n          Config cfg = c;\n          OffsetUV(cfg, currTexOffset);\n          currHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( currHeight > currRayZ )\n          {\n             stepIndex = numSteps + 1;\n          }\n          else\n          {\n             stepIndex++;\n             prevTexOffset = currTexOffset;\n             prevRayZ = currRayZ;\n             prevHeight = currHeight;\n             currTexOffset += deltaTex;\n             currRayZ -= layerHeight * ( 1 - result );\n          }\n       }\n       int sectionSteps = 10;\n       int sectionIndex = 0;\n       float newZ = 0;\n       float newHeight = 0;\n       while ( sectionIndex < sectionSteps )\n       {\n          intersection = ( prevHeight - prevRayZ ) / ( prevHeight - currHeight + currRayZ - prevRayZ );\n          finalTexOffset = prevTexOffset + intersection * deltaTex;\n          newZ = prevRayZ - intersection * layerHeight;\n          Config cfg = c;\n          OffsetUV(cfg, finalTexOffset);\n          newHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( newHeight > newZ )\n          {\n             currTexOffset = finalTexOffset;\n             currHeight = newHeight;\n             currRayZ = newZ;\n             deltaTex = intersection * deltaTex;\n             layerHeight = intersection * layerHeight;\n          }\n          else\n          {\n             prevTexOffset = finalTexOffset;\n             prevHeight = newHeight;\n             prevRayZ = newZ;\n             deltaTex = ( 1 - intersection ) * deltaTex;\n             layerHeight = ( 1 - intersection ) * layerHeight;\n          }\n          sectionIndex++;\n       }\n       #if _PASSHADOWS\n       if ( unity_LightShadowBias.z == 0.0 )\n       {\n       #endif\n          if ( result > 1 )\n             clip( -1 );\n       #if _PASSHADOWS\n       }\n       #endif\n       return finalTexOffset;\n    }\n    #endif\n\n   \n\n   // tess versions\n   #if _TESSELLATION_ON\n   half4 TriSampleLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias) * c.weights.x;\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias) * c.weights.y;\n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias) * c.weights.z;\n\n      return res;\n   }\n\n   half4 TriSampleBaryLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias, float contrast)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias);\n      half4 r2 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias);\n      half4 r3 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias);\n      c.weights = BaryWeightBlend(c.weights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryLODStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvX, bias, contrast) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvY, bias, contrast) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvZ, bias, contrast) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   half4 SampleTexBaryLODStochastic(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n       return TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias, contrast);\n   }\n\n   half4 SampleTexBaryLODTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return TriSampleLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias);\n   }\n\n   half4 SampleTexBaryLOD(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv, bias);\n   }\n\n\n    float FBM2DLOD(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           return SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv, _TessellationMipBias).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n        \n        \n    }\n\n    float FBM3DLOD(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           half A = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.zy, _TessellationMipBias).g;\n           half B = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33, _TessellationMipBias).g;\n           half C = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67, _TessellationMipBias).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoiseLOD(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3DLOD(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3DLOD(d.localSpacePosition * frequency + offset, d.localSpaceNormal);\n        #else\n           return FBM2DLOD(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n   #endif //_TESSELLATION_ON\n\n\n    half3 FuzzyShade(ShaderData d, half height, half3 color, half3 normal, half coreMult, half edgeMult, half power)\n    {\n        float3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half dt = saturate(dot(d.worldSpaceViewDir, worldNormal));\n        half dark = 1.0 - (coreMult * dt);\n        half edge = pow(1-dt, abs(power)) * edgeMult;\n        return color * (dark + edge);\n    }\n\n\thalf MicroShadow(ShaderData d, half3 normal, half height, half ao, half strength)\n\t{\n        float3 sun;\n\t\tfloat3 sunColor;\n\t\tGetSun(sun, sunColor);\n\t\tfloat3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half shadow = saturate(abs(dot(worldNormal, sun)) + (ao * ao * 2.0) - 1.0);\n        return 1 - ((1-shadow) * strength);\n\t}\n\n\n#endif\n\n\n\n   #if defined(_SPECULAR)\n      #define _USESPECULAR 1\n      #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n   #endif\n\n   \n   TEXTURE2D(_AlbedoMap);\n   SAMPLER(sampler_AlbedoMap);\n   TEXTURE2D(_NormalMap);\n   SAMPLER(sampler_NormalMap);\n   TEXTURE2D(_MaskMap);\n   TEXTURE2D(_DetailMap);\n   TEXTURE2D(_EmissionMap);\n\n   #if _SPECULAR\n       TEXTURE2D(_SpecularMap);\n   #endif\n\n   \n   \n   void Ext_SurfaceFunction0 (inout Surface o, inout ShaderData d)\n   {\n      // define samplers based on settings\n      #undef SAMPLEBARY\n      #undef SAMPLE\n      #undef SAMPLENORMAL\n      #if _STOCHASTIC && _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n        #define SAMPLE     SampleTexStochasticTriplanar\n        #define SAMPLENORMAL SampleNormalStochasticTriplanar\n      #elif _STOCHASTIC\n        #define SAMPLEBARY SampleTexBaryStochastic\n        #define SAMPLE     SampleTexStochastic\n        #define SAMPLENORMAL SampleNormalStochastic\n      #elif _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryTriplanar\n        #define SAMPLE     SampleTexTriplanar\n        #define SAMPLENORMAL SampleNormalTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBary\n        #define SAMPLE     SampleTex\n        #define SAMPLENORMAL SampleNormal\n      #endif\n\n      Config c = CreateConfig(d, _AlbedoMap_ST, _TriplanarSpace, _UVSource, _TriplanarContrast);\n      InitConfigDxDy(c);\n      #if _STOCHASTIC && !_TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uv, c.uvT);\n         InitStochasticDxDy(c.uvT, c);\n      #elif _STOCHASTIC && _TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv0, c.uvX);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv1, c.uvY);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv2, c.uvZ);\n         InitStochasticDxDy(c.uvX, c);\n         InitStochasticDxDy(c.uvY, c);\n         InitStochasticDxDy(c.uvZ, c);\n      #endif\n\n      #if _POM\n          // would need to handle height remapping if we ever want to ship this\n          float2 pomOffset = POM(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n          OffsetUV(c, pomOffset);\n      #endif\n\n      half4 albedo = SAMPLEBARY(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n      \n      #if _PARALLAX\n         float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n         OffsetUV(c, offset);\n         albedo = SAMPLE(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c);\n         \n      #endif\n      albedo.a = lerp(_HeightRemap.x, _HeightRemap.y, albedo.a);\n      albedo.rgb *= _Tint.rgb;\n\n      albedo.rgb = AdjustContrast(albedo.rgb, _AlbedoContrast);\n      albedo.rgb += _AlbedoBrightness;\n\n\n      if (_AlphaThreshold > 0)\n      {\n         clip(albedo.a - _AlphaThreshold);\n      }\n\n      #if defined(_FLATSHADE)\n\t\t     float3 dx = ddx(d.worldSpacePosition);\n\t\t     float3 dy = ddy(d.worldSpacePosition);\n\t\t     float3 worldNormal = normalize(cross(dy, dx));\n\t\t     worldNormal = lerp(d.worldSpaceNormal, worldNormal, _FlatShadingBlend);\n\t\t     d.worldSpaceNormal = worldNormal;\n\t\t     d.TBNMatrix[2] = worldNormal;\n      #endif\n\n\n\n      o.Albedo = albedo.rgb;\n      o.Alpha = albedo.a;\n\n      float smoothness = _Smoothness;\n      float ao = 1;\n\n      #if defined(_NORMALMAP) && !defined(_AUTONORMAL)\n         o.Normal = SAMPLENORMAL(TEXTURE2D_ARGS(_NormalMap, sampler_NormalMap), c, d, _NormalStrength, smoothness, ao);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, ao);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n      #endif\n\n      half detailMask = 1;\n      o.Smoothness = smoothness;\n      o.Occlusion = ao;\n      o.Metallic = _Metallic;\n      #if defined(_MASKMAP) && !_PACKEDFAST\n         // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = SampleTex(TEXTURE2D_ARGS(_MaskMap, sampler_AlbedoMap), c);\n         o.Metallic = lerp(_MetallicRemap.x, _MetallicRemap.y, mask.r);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, mask.g);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, mask.a);\n         detailMask = mask.b;\n      #endif // separate maps\n\n      #if _SPECULAR\n         o.Specular = SAMPLE(TEXTURE2D_ARGS(_SpecularMap, sampler_AlbedoMap), c).rgb;\n      #endif\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = SAMPLE(TEXTURE2D_ARGS(_EmissionMap, sampler_AlbedoMap), c).rgb * _EmissionColor;\n      #endif\n\n      if (_FuzzyShadingOn > 0)\n      {\n        o.Albedo *= FuzzyShade(d, albedo.a, _FuzzyShadingColor, o.Normal, _FuzzyShadingParams.x, _FuzzyShadingParams.y, _FuzzyShadingParams.z);\n      }\n\n\n      // HDRP style detail texturing\n\n      #if defined(_DETAIL)\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _DETAILSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n         Config dc = CreateConfig(d, _DetailMap_ST, _DetailTriplanarSpace, _DetailUVSource, _DetailTriplanarContrast);\n         InitConfigDxDy(dc);\n         #if _DETAILSTOCHASTIC && !_DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uv, dc.uvT);\n             InitStochasticDxDy(dc.uvT, dc);\n         #elif _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv0, dc.uvX);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv1, dc.uvY);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv2, dc.uvZ);\n             InitStochasticDxDy(dc.uvX, dc);\n             InitStochasticDxDy(dc.uvY, dc);\n             InitStochasticDxDy(dc.uvZ, dc);\n         #endif\n\n         half4 detailSample = SAMPLEBARY(TEXTURE2D_ARGS(_DetailMap, sampler_AlbedoMap), dc, _DetailStochasticContrast, d);\n         smoothness = detailSample.z;\n         #if !_AUTONORMAL\n            half3 dnormal = float3(detailSample.ag * 2 - 1, 1) * detailMask * _DetailNormalStrength;\n            dnormal.z = sqrt(1 - dnormal.x * dnormal.x - dnormal.y * dnormal.y);\n            #if _SURFACEGRADIENT\n               dnormal = ConvertNormalToGradient(d, dnormal);\n            #endif\n            o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n         #endif\n     \n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * smoothness, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n      if (_MicroShadowStrength > 0)\n      {\n        o.Occlusion *= MicroShadow(d, o.Normal, o.Alpha, o.Occlusion, _MicroShadowStrength);\n      }\n  \n      // in case something needs height in the stack..\n      o.Height = o.Alpha;\n\n\n      \n   }\n\n\n\n\t#if _TINTMASK\n\t\tTEXTURE2D(_TintMask);\n\t\tSAMPLER(sampler_TintMask);\n\t#endif\n\n\tvoid Ext_SurfaceFunction1 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _TINTMASK\n\t\t   half4 w = SAMPLE_TEXTURE2D(_TintMask, sampler_TintMask, d.texcoord0.xy * _TintMask_ST.xy + _TintMask_ST.zw);\n\t\t   // allow black to be no tint..\n\t\t   half3 tint = o.Albedo * (_RColor.rgb * 2 * w.r + _GColor.rgb * 2 * w.g + _BColor.rgb * 2 * w.b + _AColor.rgb * 2 * w.a);\n\t\t   o.Albedo = lerp(o.Albedo, tint, saturate(w.r + w.g + w.b + w.a));\n\t\t#endif\n\t}\n\n\n\n\n\t#if _LAYERTEXTUREMASK\n       TEXTURE2D(_LayerTextureMask);\n       SAMPLER(sampler_LayerTextureMask); \n    #endif\n\n   void Ext_ModifyTessellatedVertex2 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON\n          float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n\n          #if _LAYERTEXTUREMASK\n               float2 layerUV = v.texcoord0.xy;\n               if (_LayerTextureMaskUVMode == 1)\n                  layerUV = v.texcoord1.xy;\n               else if (_LayerTextureMaskUVMode == 2)\n                  layerUV = worldSpacePosition.yz;\n               else if (_LayerTextureMaskUVMode == 3)\n                  layerUV = worldSpacePosition.xz;\n               else if (_LayerTextureMaskUVMode == 4)\n                  layerUV = worldSpacePosition.xy;\n\n              e.blackboard.weightTextureMask = SAMPLE_TEXTURE2D_LOD(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw, _TessellationMipBias);\n          #endif\n      #endif\n    }\n\n\n\tvoid Ext_SurfaceFunction2 (inout Surface o, inout ShaderData d)\n\t{\n\t\t#if _LAYERTEXTUREMASK\n           float2 layerUV = d.texcoord0.xy;\n           if (_LayerTextureMaskUVMode == 1)\n              layerUV = d.texcoord1.xy;\n           else if (_LayerTextureMaskUVMode == 2)\n              layerUV = d.worldSpacePosition.yz;\n           else if (_LayerTextureMaskUVMode == 3)\n              layerUV = d.worldSpacePosition.xz;\n           else if (_LayerTextureMaskUVMode == 4)\n              layerUV = d.worldSpacePosition.xy;\n\n          d.blackboard.weightTextureMask = SAMPLE_TEXTURE2D(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw);\n      #endif\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap);\n   SAMPLER(sampler_LayerAlbedoMap);\n   TEXTURE2D(_LayerNormalMap);\n   TEXTURE2D(_LayerMaskMap);\n   TEXTURE2D(_LayerEmissionMap);\n\n   \n\n   void Ext_ModifyTessellatedVertex3 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER) && defined(_LAYERALBEDO) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n         half detailMask = 1;\n         #if _LAYERNOISE\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency,  _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin;\n            dt = saturate(dt * _LayerFalloff);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight) * _LayerFalloff);\n            if (_LayerInvertHeight > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength;\n         detailMask *= _LayerTessStrength;\n\n         #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast).a;\n         albedo = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo);\n\n         if (_LayerBlendMode == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction3 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n            // noise up the mask\n            #if _LAYERNOISE\n               mask = DoNoise(d, _LayerNoiseFrequency, _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend);\n\t    \n                dt -= _LayerAngleMin;\n                dt = saturate(dt * _LayerFalloff);\n\n                float hf = saturate((o.Height - _LayerHeight) * _LayerFalloff);\n                if (_LayerInvertHeight > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 0\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 0\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength;\n\n            #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint, 0.5);\n            #if defined(_LAYERALBEDO)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c, _LayerStochasticContrast, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c);\n                #endif\n                albedo.rgb *= _LayerTint;\n                albedo.a = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL || _LAYERMASK\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap, sampler_LayerAlbedoMap, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast);\n            albedo.rgb += _LayerAlbedoBrightness;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap, sampler_LayerAlbedoMap), c, d, _LayerNormalStrength * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO)\n                if (_LayerFuzzyShadingOn > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor.rgb, dnormal,\n                                            _LayerFuzzyShadingParams.x, _LayerFuzzyShadingParams.y, _LayerFuzzyShadingParams.z);\n                }\n\n                if (_LayerBlendMode == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast);\n                else if (_LayerBlendMode == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE\n                      float maskDif = (_LayerBlendContrast * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength);\n                   #if _LAYERNOISE\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap, sampler_LayerAlbedoMap), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength);\n                }\n\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap, sampler_LayerAlbedoMap), c).rgb * _LayerEmissionColor;\n                #if _LAYERALBEDO\n                    if (_LayerBlendMode > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_1);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_1);\n   TEXTURE2D(_LayerNormalMap_Ext_1);\n   TEXTURE2D(_LayerMaskMap_Ext_1);\n   TEXTURE2D(_LayerEmissionMap_Ext_1);\n\n   \n\n   void Ext_ModifyTessellatedVertex4 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_1) && defined(_LAYERALBEDO_DEF_1) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_1\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_1,  _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_1\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_1;\n            dt = saturate(dt * _LayerFalloff_Ext_1);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n            if (_LayerInvertHeight_Ext_1 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_1;\n         detailMask *= _LayerTessStrength_Ext_1;\n\n         #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_1).a;\n         albedo = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo);\n\n         if (_LayerBlendMode_Ext_1 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_1);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_1 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction4 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_1)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_1\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_1, _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_1\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_1);\n\t    \n                dt -= _LayerAngleMin_Ext_1;\n                dt = saturate(dt * _LayerFalloff_Ext_1);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n                if (_LayerInvertHeight_Ext_1 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 01\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 01\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_1;\n\n            #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_1, 0.5);\n            #if defined(_LAYERALBEDO_DEF_1)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, _LayerStochasticContrast_Ext_1, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_1;\n                albedo.a = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_1 || _LAYERMASK_DEF_1\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_1);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_1;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, d, _LayerNormalStrength_Ext_1 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_1)\n                if (_LayerFuzzyShadingOn_Ext_1 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_1.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_1.x, _LayerFuzzyShadingParams_Ext_1.y, _LayerFuzzyShadingParams_Ext_1.z);\n                }\n\n                if (_LayerBlendMode_Ext_1 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_1);\n                else if (_LayerBlendMode_Ext_1 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_1 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_1);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_1\n                      float maskDif = (_LayerBlendContrast_Ext_1 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_1 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                   #if _LAYERNOISE_DEF_1\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_1));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_1 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_1);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_1) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_1 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_1);\n                }\n\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_1);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_1, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_1, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_1\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c).rgb * _LayerEmissionColor_Ext_1;\n                #if _LAYERALBEDO_DEF_1\n                    if (_LayerBlendMode_Ext_1 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_2);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_2);\n   TEXTURE2D(_LayerNormalMap_Ext_2);\n   TEXTURE2D(_LayerMaskMap_Ext_2);\n   TEXTURE2D(_LayerEmissionMap_Ext_2);\n\n   \n\n   void Ext_ModifyTessellatedVertex5 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_2) && defined(_LAYERALBEDO_DEF_2) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_2\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_2,  _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_2\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_2;\n            dt = saturate(dt * _LayerFalloff_Ext_2);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n            if (_LayerInvertHeight_Ext_2 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_2;\n         detailMask *= _LayerTessStrength_Ext_2;\n\n         #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_2).a;\n         albedo = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo);\n\n         if (_LayerBlendMode_Ext_2 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_2);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_2 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction5 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_2)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_2\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_2, _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_2\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_2);\n\t    \n                dt -= _LayerAngleMin_Ext_2;\n                dt = saturate(dt * _LayerFalloff_Ext_2);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n                if (_LayerInvertHeight_Ext_2 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 02\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 02\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_2;\n\n            #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_2, 0.5);\n            #if defined(_LAYERALBEDO_DEF_2)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, _LayerStochasticContrast_Ext_2, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_2;\n                albedo.a = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_2 || _LAYERMASK_DEF_2\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_2);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_2;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, d, _LayerNormalStrength_Ext_2 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_2)\n                if (_LayerFuzzyShadingOn_Ext_2 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_2.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_2.x, _LayerFuzzyShadingParams_Ext_2.y, _LayerFuzzyShadingParams_Ext_2.z);\n                }\n\n                if (_LayerBlendMode_Ext_2 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_2);\n                else if (_LayerBlendMode_Ext_2 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_2 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_2);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_2\n                      float maskDif = (_LayerBlendContrast_Ext_2 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_2 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                   #if _LAYERNOISE_DEF_2\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_2));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_2 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_2);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_2) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_2 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_2);\n                }\n\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_2);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_2, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_2, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_2\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c).rgb * _LayerEmissionColor_Ext_2;\n                #if _LAYERALBEDO_DEF_2\n                    if (_LayerBlendMode_Ext_2 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   #if _TRAX_ON\n   TEXTURE2D(_TraxAlbedo);\n   SAMPLER(sampler_TraxAlbedo);\n   TEXTURE2D(_TraxPackedNormal);\n   TEXTURE2D(_TraxMask);\n\n   sampler2D_float _GMSTraxBuffer;\n\n   float4 _GMSTraxBuffer_TexelSize;\n   float3 _GMSTraxBufferPosition;\n   float _GMSTraxBufferWorldSize;\n   float _GMSTraxFudgeFactor;\n\n   float SampleTraxBufferLOD(float3 worldPos)\n   {    \n      // generate UVs for the buffer, which is moving\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 8);\n      uv *= 0.5;\n      uv += 0.5;\n            \n      float s =  tex2Dlod(_GMSTraxBuffer, float4(uv, 0, 0)).r;\n\n      return 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n   }\n         \n        \n   float SampleTraxBuffer(float3 worldPos, out float3 norm)\n   {\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 3);\n      uv *= 0.5;\n      uv += 0.5;\n            \n\n      float2 offset = _GMSTraxBuffer_TexelSize.xy;\n\n      float s = tex2D(_GMSTraxBuffer, uv).r;\n               \n      float s1 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, -1)).r;\n      float s2 = tex2D(_GMSTraxBuffer, uv + offset * float2(-1, 0)).r;\n      float s3 = tex2D(_GMSTraxBuffer, uv + offset * float2(1, 0)).r;\n      float s4 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, 1)).r;\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      float r = 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n \n      // generate normals\n      norm.x = (s1 - s4) * 0.25; \n      norm.y = (s2 - s3) * 0.25;\n      norm.z = 2;\n      norm = normalize(norm);\n     \n      norm.xy *= 1 - r;\n            \n      return r;\n   }\n   #endif\n\n   void Ext_ModifyTessellatedVertex6 (inout VertexData v, inout ExtraV2F d)\n   {\n       #if _TESSELLATION_ON && _TRAX_ON && _HAS_LIT_TESSELLATION\n          \n           float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n           float3 worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n           float traxBuffer = SampleTraxBufferLOD(worldSpacePosition);\n           d.blackboard.traxBuffer = traxBuffer;\n           float2 uv = worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n           half albedo = SAMPLE_TEXTURE2D_LOD(_TraxAlbedo, sampler_TraxAlbedo, uv, _TraxMipBias).a;\n\n           float traxOffset = albedo * _TraxDisplacementStrength;\n           traxOffset *= 1 - v.texcoord0.z;\n           traxOffset *= _TessellationDisplacement;\n           float dig = _TraxDisplacementDepth * (1 - v.texcoord0.z);\n           float3 traxVertex = d.blackboard.originalVertexPosition + (v.normal * (traxOffset - dig));\n           v.vertex.xyz = lerp(traxVertex, v.vertex.xyz, traxBuffer);\n\n           d.blackboard.vertexHeightOffset = lerp(traxOffset-dig, d.blackboard.vertexHeightOffset, traxBuffer);\n\n       #endif\n\n   }\n\n   void Ext_SurfaceFunction6 (inout Surface o, inout ShaderData d)\n   {\n      #if _TRAX_ON\n        float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n        float2 fsdx = ddx(uv);\n        float2 fsdy = ddy(uv);\n\n        float3 traxNormal;\n        float traxBuffer = SampleTraxBuffer(d.worldSpacePosition, traxNormal);\n        \n        #if _TESSELLATION_ON\n            traxBuffer -= _TraxDisplacementDepth;\n        #endif\n\n        d.blackboard.traxBuffer = traxBuffer;\n\n        UNITY_BRANCH\n        if (traxBuffer > 0)\n        {\n            half4 albedo = SAMPLE_TEXTURE2D_GRAD(_TraxAlbedo, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            albedo.rgb *= _TraxTint.rgb;\n            half4 normalSample = SAMPLE_TEXTURE2D_GRAD(_TraxPackedNormal, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n\n            half smoothness = normalSample.r;\n            half ao = normalSample.b;\n            half3 normal;\n            normal.xy = (normalSample.ag * 2 - 1) * _TraxNormalStrength;\n            normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n\n            \n            half h = HeightBlend(albedo.a, o.Alpha, traxBuffer, _TraxHeightContrast);\n\n            h = lerp(traxBuffer, h, _TraxInterpContrast);\n\n            o.Albedo = lerp(albedo, o.Albedo, h);\n\n            #if _SURFACEGRADIENT\n                o.Normal = lerp(normal, o.Normal, h);\n            #else\n                o.Normal = lerp(normal + traxNormal, o.Normal, h);\n            #endif\n        \n            o.Smoothness = lerp(smoothness, o.Smoothness, h);\n            o.Occlusion = lerp(ao, o.Occlusion, h);\n        }\n      #endif\n   }\n\n\n\n\n    #if _RAINDROPS\n       TEXTURE2D(_RainDropTexture);\n       SAMPLER(sampler_RainDropTexture);\n       half _Global_RainIntensity;\n    #endif\n\n    #if _WETNESS\n       half2 _Global_WetnessParams; // global, not in cbuffer\n    #endif\n   \n    #if _RAINDROPS\n    half2 ComputeRipple(float2 uv, half time, half weight)\n    {\n        half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_RainDropTexture, uv);\n        COUNTSAMPLE\n        ripple.yz = ripple.yz * 2 - 1;\n\n        half dropFrac = frac(ripple.w + time);\n        half timeFrac = dropFrac - 1.0 + ripple.x;\n        half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);\n        half finalFactor = dropFactor * ripple.x * \n                                sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);\n\n        return half2(ripple.yz * finalFactor);\n    }\n    #endif\n\n    half2 DoRain(half2 waterNorm, float2 uv, out half2 ripple)\n    {\n        #if _RAINDROPS\n            float rainIntensity = _RainIntensityScale.x;\n            if (_RainMode > 1)\n            {\n                rainIntensity = _Global_RainIntensity;\n            }\n\n            half dropStrength = rainIntensity;\n            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); \n            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);\n            half4 times = _Time.yyyy;\n            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);\n\n            float2 ruv1 = uv * _RainIntensityScale.yy;\n            float2 ruv2 = ruv1;\n\n            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);\n            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);\n            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);\n            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);\n            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);\n            weights = saturate(weights * 4);\n\n            half2 rippleNormal = half2( weights.x * ripple1.xy +\n                        weights.y * ripple2.xy + \n                        weights.z * ripple3.xy + \n                        weights.w * ripple4.xy);\n\n            ripple = rippleNormal * dropStrength * rainIntensity;\n            waterNorm = lerp(waterNorm, normalize(half3(rippleNormal.xy + rippleNormal.xy, 1)).xy, rainIntensity * dropStrength); \n            return waterNorm;                        \n        #else\n            return waterNorm;\n        #endif\n    }\n\n   half2 _Global_PuddleParams;   // this is a global, so keep it out of the cbuffer\n   void GetPuddleParams(ShaderData d, inout float puddleMask, inout float pudHeight)\n   {\n      #if _PUDDLES || _GLOBALPUDDLES\n          pudHeight = _PuddleAmount;\n          if (_PuddleMode > 0)\n             pudHeight = _Global_PuddleParams.x;    \n      \n\n          half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t      dt -= _PuddleAngleMin;\n          dt = saturate(dt * _PuddleFalloff);\n          puddleMask *= dt;\n      #endif\n   }\n   \n   void Ext_ModifyTessellatedVertex7 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _PUDDLES && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n         half mask = 1;\n         half pudHeight = 1;\n\n         // save some ops by doing this in 2d\n         #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2DLOD(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2DLOD(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #else\n                mask = (FBM2DLOD(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n         #endif\n\n         GetPuddleParams(d, mask, pudHeight);\n         float height = pudHeight * mask;\n         if (e.blackboard.vertexHeightOffset < height)\n         {\n            e.blackboard.vertexHeightOffset = height;\n            height -= _TessellationOffset; \n            // dampen cracks\n            height *= 1 - v.texcoord0.z;\n            height *= _TessellationDisplacement;\n            v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n            \n        }\n      #endif\n   }\n\n\n#if _WETNESS\n\n   float GetWetnessLevel(Surface o, ShaderData d, float wetnessMask)\n   {\n      float wetLevel = clamp(_WetnessAmount, _WetnessMin, _WetnessMax);\n      \n      if (_WetnessMode > 0)\n         wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);\n\n      wetLevel = saturate(wetLevel + (1 - saturate(d.worldSpacePosition.y - _WetnessShoreline)));\n      float3x3 tbn = float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal);\n      float dt = dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0));\n      dt -= _WetnessAngleMin;\n      dt = saturate(dt * _WetnessFalloff * wetLevel);\n      dt *= wetnessMask;\n      return dt;\n   }\n#endif\n   \n\n   void Ext_SurfaceFunction7 (inout Surface o, ShaderData d)\n   {\n      half wetnessLevel = 0;\n      #if _WETNESS\n          wetnessLevel = GetWetnessLevel(o, d, 1); // mask one day?\n      #endif\n\n      half depthMask = 0;\n      half depth = 0;\n\n      #if _PUDDLES\n          half mask = 1;\n          half pudHeight = 1;\n          #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2D(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2D(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);      \n            #else\n                mask = (FBM2D(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n          #endif\n\n          GetPuddleParams(d, mask, pudHeight);\n          pudHeight *= mask;\n          depth = pudHeight - o.Height;\n          depthMask = saturate(depth * _PuddleFalloff);\n          depthMask *= _PuddleColor.a;\n          depth = o.Height - pudHeight;\n\n          // extend wetness slighting higher than the puddle\n          half wetmask = saturate((pudHeight + 0.05 - o.Height) * _PuddleFalloff);\n          wetnessLevel = max(wetmask, wetnessLevel);\n       #endif\n\n       \n       #if _WETNESS || _PUDDLES\n          half3 waterNorm = half3(0,0,1);\n          half3 wetAlbedo = o.Albedo;\n          half wetSmoothness = o.Smoothness;\n          #if _PUDDLES\n             wetAlbedo *= _PuddleColor.rgb;\n          #endif\n          WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetnessLevel, _Porosity);\n\n          half ri = 0;\n          half2 ripple = 0;\n          #if (_RAINDROPS || _GLOBALRAIN) && (_PUDDLES || _GLOBALPUDDLES)\n             ri = _RainIntensityScale.z;\n             waterNorm.xy = DoRain(waterNorm.xy, d.texcoord0.xy, ripple) * depthMask;\n          #endif\n\n          o.Normal = lerp(o.Normal, waterNorm, depthMask);\n          o.Normal = lerp(o.Normal, LitBlendDetailNormal(o.Normal, half3(ripple.xy, 1)), saturate(ri - depthMask) * wetnessLevel);\n          o.Occlusion = lerp(o.Occlusion, 1, depthMask);\n          o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetnessLevel);\n          o.Albedo = lerp(o.Albedo, wetAlbedo, wetnessLevel);\n          o.Emission *= 1 + depth;\n          o.Metallic *= 1 + depth;\n          o.Specular *= 1 + depth;\n\n       #endif\n\n   }\n\n\n\n\n    #if _SNOW\n       TEXTURE2D(_SnowAlbedo);\n       SAMPLER(sampler_SnowAlbedo);\n       TEXTURE2D(_SnowNormal);\n       TEXTURE2D(_SnowMaskMap);\n       #if _TRAX_ON\n          TEXTURE2D(_SnowTraxAlbedo);\n          TEXTURE2D(_SnowTraxNormal);\n          TEXTURE2D(_SnowTraxMaskMap);\n       #endif\n    #endif\n\n   float _Global_SnowLevel;\n\n\n   void Ext_ModifyVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n    #if (_SNOW)\n        float amount = _SnowAmount;\n        if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n        float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n        float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n        snowAmount -= _SnowAngle;\n        snowAmount *= _SnowContrast * 0.5;\n        snowAmount = saturate(snowAmount) * amount;\n        float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n        if (_SnowWorldFade.z > 0)\n        {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n        }\n        #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n        #endif\n        snowAmount = saturate(snowAmount);\n\n        #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n        #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n        #endif\n\n        float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n        v.vertex.xyz = v.vertex.xyz + displacementVec * snowAmount * snowAmount * _SnowVertexHeight;\n    #endif\n   }\n\n   void Ext_ModifyTessellatedVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _SNOW && _HAS_LIT_TESSELLATION\n         float amount = _SnowAmount;\n         if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n         float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n         float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n         snowAmount -= _SnowAngle;\n         snowAmount *= _SnowContrast * 0.5;\n         float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n         if (_SnowWorldFade.z > 0)\n         {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n         }\n\n         snowAmount = saturate(snowAmount) * amount;\n\n         #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n         #endif\n         snowAmount = saturate(snowAmount);\n\n         #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n         #endif\n\n         float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n         half heightMap = SAMPLE_TEXTURE2D_LOD(_SnowAlbedo, sampler_SnowAlbedo, worldPos.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw, 2);\n\n         float height = max(_SnowVertexHeight * 3 * snowAmount + snowAmount * heightMap, e.blackboard.vertexHeightOffset);\n         #if _TRAX_ON\n            height *= e.blackboard.traxBuffer;\n         #endif\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n\n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n         \n      #endif\n\n   }\n\n   void SampleSnowSurface(TEXTURE2D_PARAM(alb, ss), TEXTURE2D_PARAM(norm, ss2), TEXTURE2D_PARAM(mask, ss3),\n        ShaderData d, float2 uv, float2 dx, float2 dy, out half4 albedo, out half3 normal, out half2 smoothAO)\n   {\n      #if _SNOWSTOCHASTIC\n         float w1, w2, w3;\n         int2 vertex1, vertex2, vertex3;\n         TriangleGrid(uv, _SnowStochasticScale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n         // Assign random offset to each triangle vertex\n         float2 uv0 = uv;\n         float2 uv1 = uv;\n         float2 uv2 = uv;\n   \n         uv0.xy += SimpleHash2(vertex1);\n         uv1.xy += SimpleHash2(vertex2);\n         uv2.xy += SimpleHash2(vertex3);\n         half3 weights = half3(w1, w2, w3);\n\n         half4 albedo0 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv0, dx, dy);\n         half4 albedo1 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv1, dx, dy);\n         half4 albedo2 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv2, dx, dy);\n         COUNTSAMPLE\n         COUNTSAMPLE\n         COUNTSAMPLE\n         weights = BaryWeightBlend(weights, albedo0.a, albedo1.a, albedo2.a, _SnowStochasticContrast);\n         albedo = albedo0 * weights.x + albedo1 * weights.y + albedo2 * weights.z;\n\n         normal = half3(0,0,1);\n         smoothAO = half2(0, 1);\n\n         #if !_AUTONORMAL\n            half4 n0 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv0, dx, dy);\n            half4 n1 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv1, dx, dy);\n            half4 n2 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n            half4 snowNormSamp = n0 * weights.x + n1 * weights.y + n2 * weights.z;\n\n            normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n                \n            #if _PACKEDFAST\n               smoothAO.x = snowNormSamp.r;\n               smoothAO.y = snowNormSamp.b;\n            #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask0 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv0, dx, dy);\n            half4 snowMask1 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv1, dx, dy);\n            half4 snowMask2 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n            half4 snowMask = snowMask0 * weights.x + snowMask1 * weights.y + snowMask2 * weights.z;\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n      #else // not stochastic\n          albedo = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv, dx, dy);\n          COUNTSAMPLE\n\n          normal = half3(0,0,1);\n          smoothAO = half2(0, 1);\n\n          #if !_AUTONORMAL\n             half4 snowNormSamp = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv, dx, dy);\n             COUNTSAMPLE\n             normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n             #if _SURFACEGRADIENT\n                normal = ConvertNormalToGradient(d, normal);\n             #endif\n                 \n             #if _PACKEDFAST\n                smoothAO.x = snowNormSamp.r;\n                smoothAO.y = snowNormSamp.b;\n             #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv, dx, dy);\n            COUNTSAMPLE\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n     #endif // stochastic\n   }\n\n   \n   void Ext_SurfaceFunction8 (inout Surface o, ShaderData d)\n   {\n      #if _SNOW\n          float amount = _SnowAmount;\n          if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n          float snowAmount = lerp(dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), dot(d.worldSpaceNormal, float3(0,1,0)), amount * 0.8) + 1;\n          snowAmount -= _SnowAngle;\n          snowAmount *= _SnowContrast;\n          snowAmount = saturate(snowAmount) - (1-amount) * (1-amount);\n\n          if (_SnowWorldFade.z > 0)\n          {\n             float worldFade = saturate((d.worldSpacePosition.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n             snowAmount *= worldFade;\n          }\n\n          #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(d.worldSpacePosition.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n          #endif\n          snowAmount = saturate(snowAmount);\n\n          float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw;\n          float2 dx = ddx(uv);\n          float2 dy = ddy(uv);\n\n          #if _TRAX_ON\n              float2 tuv = d.worldSpacePosition.xz * float2(1, -1) * _SnowTraxAlbedo_ST.xy + _SnowTraxAlbedo_ST.zw;\n              float2 tdx = ddx(uv);\n              float2 tdy = ddy(uv);\n          #endif\n\n          #if _LAYERVERTEXMASK\n              snowAmount *= d.vertexColor.a;\n          #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n              snowAmount *= d.blackboard.weightTextureMask.a;\n          #endif\n\n          UNITY_BRANCH\n          if (snowAmount > 0)\n          {\n             half4 snowAlbedo;\n             half3 snowNormal;\n             half2 snowSmoothAO;\n             SampleSnowSurface(TEXTURE2D_ARGS(_SnowAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowNormal, sampler_SnowAlbedo),\n                    TEXTURE2D_ARGS(_SnowMaskMap, sampler_SnowAlbedo), d, uv, dx, dy, snowAlbedo, snowNormal, snowSmoothAO);\n\n             snowAlbedo.rgb *= _SnowTint.rgb;\n\n             #if _TRAX_ON\n                half traxBuffer = 1 - d.blackboard.traxBuffer;\n                UNITY_BRANCH\n                if (traxBuffer > 0)\n                {\n                    half4 tsnowAlbedo;\n                    half3 tsnowNormal;\n                    half2 tsnowSmoothAO;\n                    SampleSnowSurface(TEXTURE2D_ARGS(_SnowTraxAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowTraxNormal, sampler_SnowAlbedo),\n                        TEXTURE2D_ARGS(_SnowTraxMaskMap, sampler_SnowAlbedo), d, tuv, tdx, tdy, tsnowAlbedo, tsnowNormal, tsnowSmoothAO);\n\n                    tsnowAlbedo.rgb *= _SnowTraxTint;\n                    half h = HeightBlend(snowAlbedo.a, tsnowAlbedo.a, traxBuffer, 0.5);\n                    snowAlbedo = lerp(snowAlbedo, tsnowAlbedo, h);\n                    snowNormal = lerp(snowNormal, tsnowNormal, h);\n                    snowSmoothAO = lerp(snowSmoothAO, tsnowSmoothAO, h);\n                }\n             #endif\n\n             #if !_AUTONORMAL\n                o.Normal = lerp(o.Normal, snowNormal, snowAmount);\n             #endif\n             o.Albedo = lerp(o.Albedo, snowAlbedo.rgb, snowAmount);\n             o.Alpha = lerp(o.Alpha, snowAlbedo.a, snowAmount);\n             o.Smoothness = lerp(o.Smoothness, snowSmoothAO.x, snowAmount);\n             o.Occlusion = lerp(o.Occlusion, snowSmoothAO.y, snowAmount);\n             o.Height = o.Alpha;\n\n          }\n      #endif\n   }\n\n   \n\n\n\n\n\n   TEXTURE2D(_WindParticulate);\n   SAMPLER(sampler_WindParticulate);\n\n// In case we want to read it more than once..\n\n#ifndef __STACKABLE_WIND_INCLUDES__\n#define __STACKABLE_WIND_INCLUDES__\n\n\n   half FilterRange(float4 range, float y)\n   {\n      half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));\n      w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));\n      return w;\n   }\n\n   \n   float2 RotateUV(float2 uv, float amt)\n   {\n      uv -=0.5;\n      float s = sin ( amt);\n      float c = cos ( amt );\n      float2x2 mtx = float2x2( c, -s, s, c);\n      mtx *= 0.5;\n      mtx += 0.5;\n      mtx = mtx * 2-1;\n      uv = mul ( uv, mtx );\n      uv += 0.5;\n      return uv;\n   }\n\n\n   half FilterWindParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)\n   {\n      float2 windDir = RotateUV(float2(1, 0), windRot);\n      float2 flow = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));\n      float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill\n      return FilterRange(range, cofacing);\n   }\n\n   half ProcessWindParticulateMask(inout half mask, float contrast)\n   {\n      mask = pow(abs(mask), abs(contrast));\n      half invMask = 1.0 - mask;\n      invMask *= invMask; \n      invMask *= invMask;\n      return invMask;\n   }\n#endif // include guard\n\n   void Ext_SurfaceFunction9 (inout Surface o, ShaderData d)\n   {\n      #if _WIND_ON && !_PASSMETA\n   \n         float3 upVector = float3(0,0,1);\n\n         half upDot = max(0.0, dot(d.worldSpaceNormal, float3(0, 1, 0)));\n\n         float2 uv = d.worldSpacePosition.xz;\n         if (_WindParticulateSpace > 0.5)\n            uv = d.texcoord0.xy;\n         float windRotation = _WindParticulateRotation;\n         float windStrength = _WindParticulateStrength;\n\n         float2 wuv = RotateUV(uv, windRotation);\n\n         half windBlend = 1.0;\n\n         float windWorldMask = FilterRange(_WindParticulateWorldHeightMask, d.worldSpacePosition.y);\n         windWorldMask *= FilterRange(_WindParticulateAngleMask, upDot);\n\n         // compute mask\n         wuv *= float2(_WindParticulate_ST.x, 1) * _WindParticulate_ST.y + _WindParticulate_ST.zw;\n         float speed = _Time.x * _WindParticulateSpeed;\n         half w1 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv * 3 + speed * float2(1,0)).g;\n         half w2 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv + speed * float2(1.1,0)).a;\n         half windMask = (w1 * w2);\n\n         windMask *= windStrength * windBlend * windWorldMask;\n         windMask *= saturate((_WindParticulateTextureHeight - o.Height) * 10);\n\n         half windInvMask = ProcessWindParticulateMask(windMask, _WindParticulatePower);\n    \n         o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);\n         o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindParticulateEmissive.rgb;\n         o.Normal.xy *= windInvMask;\n         o.Smoothness *= windInvMask;\n         o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;\n         o.Metallic *= windInvMask;\n      #endif\n\n   }\n\n\n\n\n\tvoid Ext_SurfaceFunction10 (inout Surface o, ShaderData d)\n\t{\n        if (_DoubleSidedNormalMode == 0)\n        {\n           o.Normal *= d.isFrontFace ? 1 : -1;\n        }\n        else if (_DoubleSidedNormalMode == 1)\n        {\n\t\t   o.Normal.z *= d.isFrontFace ? 1 : -1;\n        }\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction11 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _SURFACEGRADIENT\n\t\t\to.Normal = ResolveNormalFromSurfaceGradient(d, o.Normal);\n\t    #elif _AUTONORMAL\n\t        float3 dx = ddx(d.worldSpacePosition);\n\t\t\tfloat3 dy = ddy(d.worldSpacePosition);\n\t\t\tfloat3 crossX = cross(float3(0,1,0), dx);\n\t\t\tfloat3 crossY = cross(float3(0,1,0), dy);\n\t\t\tfloat3 dt = abs(dot(crossY, dx));\n\t\t\tfloat height = _AutoNormalStrength * 0.5 * o.Alpha;\n\t\t\tfloat3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n\t\t\tn.y *= -1.0;\n\t\t\to.Normal = normalize((dt * float3(0,1,0)) - n).xzy;\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#else\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#endif\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction12 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DEBUG_SAMPLECOUNT\n\t\t\tif (_sampleCount > _DebugSampleCountThreshold)\n\t\t\t{\n\t\t\t\to.Albedo.r = 1;\n\t\t\t\to.Albedo.gb *= 0.2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\to.Albedo.b = 1;\n\t\t\t}\n\n        #endif\n\t}\n\n\n\n\n\tSAMPLER(sampler_DissolveTexture);\n\tTEXTURE2D(_DissolveTexture);\n\tTEXTURE2D(_DissolveGradient);\n\n\tvoid Ext_SurfaceFunction13 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DISSOLVE\n\t\tfloat2 uv = d.texcoord0.xy * _DissolveTexture_ST.xy + _DissolveTexture_ST.zw;\n\t\tfloat2 dx = ddx(uv);\n\t\tfloat2 dy = ddy(uv);\n\n\t\tUNITY_BRANCH\n\t\tif (_DissolveAmount > 0)\n\t\t{\n\t\t\thalf dissolve = SAMPLE_TEXTURE2D_GRAD(_DissolveTexture, sampler_DissolveTexture, uv, dx, dy).g;\n\t\t\thalf cp =  saturate(_DissolveAmount - (dissolve - _DissolveAmount) * _DissolveEdgeContrast) + _DissolveAmount;\n\t\t\thalf cp2 = saturate(1.0 - abs((dissolve - _DissolveAmount) * _DissolveEdgeContrast));\n\t\t\tclip(1.0 - cp);\n\t\t\tfloat2 fuv = float2(cp2, 0.5);\n\t\t\thalf3 col = SAMPLE_TEXTURE2D_LOD(_DissolveGradient, sampler_DissolveTexture, fuv, 0).rgb;\n\t\t\t\t\n\t\t\to.Albedo = lerp(o.Albedo, col, _DissolveColoration * cp2);\n\t\t\to.Emission = lerp(o.Emission, col * _DissolveEmissiveStr, _DissolveColoration * cp2);\n\t\t}\n\t\t#endif\n\t}\n\n\n\n\n    float Dither8x8Bayer( int x, int y )\n    {\n        const float dither[ 64 ] = {\n                1, 49, 13, 61,  4, 52, 16, 64,\n            33, 17, 45, 29, 36, 20, 48, 32,\n                9, 57,  5, 53, 12, 60,  8, 56,\n            41, 25, 37, 21, 44, 28, 40, 24,\n                3, 51, 15, 63,  2, 50, 14, 62,\n            35, 19, 47, 31, 34, 18, 46, 30,\n            11, 59,  7, 55, 10, 58,  6, 54,\n            43, 27, 39, 23, 42, 26, 38, 22};\n        int r = y * 8 + x;\n        return dither[r] / 64; \n    }\n\n    void ApplyDitherCrossFadeVSP(float2 vpos, float fadeValue)\n    {\n        float dither = Dither8x8Bayer( fmod(vpos.x, 8), fmod(vpos.y, 8) );\n        float sgn = fadeValue > 0 ? 1.0f : -1.0f;\n        clip(dither - (1-fadeValue) * sgn);\n    }\n    \n\n\tvoid Ext_SurfaceFunction14 (inout Surface o, ShaderData d)\n\t{\n\t\t#if LOD_FADE_CROSSFADE\n            float4 screenPosNorm = d.screenPos / d.screenPos.w;\n            screenPosNorm.z = ( UNITY_NEAR_CLIP_VALUE >= 0 ) ? screenPosNorm.z : screenPosNorm.z * 0.5 + 0.5;\n            float2 clipScreen = screenPosNorm.xy * _ScreenParams.xy;\n            ApplyDitherCrossFadeVSP(clipScreen,unity_LODFade.x);\n        #endif\n\t}\n\n\n\n\n\n\n// declare outside of CBuffer\n\nfloat4x4 _GlobalVolumeMatrix;\nfloat4x4 _VolumeMatrix;\nfloat3 _VolumeMin;\nfloat3 _VolumeInvSize;\nfloat3 _GlobalVolumeMin;\nfloat3 _GlobalVolumeInvSize;\n\n// I inlined a section of your include. You can use includes in better shaders, but doing it via a subshader or this way\n// is much better. The reason is that this allows your shader to be all inclusive, and packed up for asset store distribition,\n// without requiring specific paths to other files, etc.\n//\n\n#ifndef BAKERY_INCLUDED\n#define BAKERY_INCLUDED\n\n#define BAKERYMODE_DEFAULT 0\n#define BAKERYMODE_VERTEXLM 1.0f\n#define BAKERYMODE_RNM 2.0f\n#define BAKERYMODE_SH 3.0f\n\n\n// can't fit vertexLM SH to sm3_0 interpolators\n#ifndef SHADER_API_D3D11\n    #undef _LIGHTMAPMODE_VERTEXSH\n#endif\n\n// can't do stuff on sm2_0 due to standard shader alrady taking up all instructions\n#if SHADER_TARGET < 30\n    #undef BAKERY_BICUBIC\n    #undef BAKERY_LMSPEC\n\n    #undef _LIGHTMAPMODE_RNM\n    #undef _LIGHTMAPMODE_SH\n    #undef _LIGHTMAPMODE_VERTEX\n#endif\n\n#define lumaConv float3(0.2125f, 0.7154f, 0.0721f)\n\n#ifdef BAKERY_VOLUME\n    #ifdef BAKERY_COMPRESSED_VOLUME\n        Texture3D _Volume3;\n    #endif\n#endif\n\n\nhalf3 LinearToGamma (half3 linRGB)\n{\n    linRGB = max(linRGB, half3(0.h, 0.h, 0.h));\n    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n    return max(1.055h * pow(linRGB, 0.416666667h) - 0.055h, 0.h);\n}\n\nfloat shEvaluateDiffuseL1Geomerics(float L0, float3 L1, float3 n)\n{\n    // average energy\n    float R0 = L0;\n\n    // avg direction of incoming light\n    float3 R1 = 0.5f * L1;\n\n    // directional brightness\n    float lenR1 = length(R1);\n\n    // linear angle between normal and direction 0-1\n    //float q = 0.5f * (1.0f + dot(R1 / lenR1, n));\n    //float q = dot(R1 / lenR1, n) * 0.5 + 0.5;\n    float q = dot(normalize(R1), n) * 0.5 + 0.5;\n\n    // power for q\n    // lerps from 1 (linear) to 3 (cubic) based on directionality\n    float p = 1.0f + 2.0f * lenR1 / R0;\n\n    // dynamic range constant\n    // should vary between 4 (highly directional) and 0 (ambient)\n    float a = (1.0f - lenR1 / R0) / (1.0f + lenR1 / R0);\n\n    return R0 * (a + (1.0f - a) * (p + 1.0f) * pow(q, p));\n}\n\n#ifdef BAKERY_VERTEXLMMASK\n    float4 unpack4NFloats(float src)\n\t{\n        //return fmod(float4(src / 262144.0, src / 4096.0, src / 64.0, src), 64.0)/64.0;\n        return frac(float4(src / (262144.0*64), src / (4096.0*64), src / (64.0*64), src));\n    }\n#endif\n\n#if defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n    float3 unpack3NFloats(float src)\n\t{\n        float r = frac(src);\n        float g = frac(src * 256.0);\n        float b = frac(src * 65536.0);\n        return float3(r, g, b);\n    }\n#endif\n\n// Unity defines these under different names in each SRP, so use our own\ninline float3 Bakery_SafeNormalize(float3 inVec)\n{\n    float dp3 = max(0.001f, dot(inVec, inVec));\n    return inVec * rsqrt(dp3);\n}\n\n#if _URP || _HDRP\n\nfloat SmoothnessToPerceptualRoughness(float smoothness)\n{\n    return (1 - smoothness);\n}\n#endif\n\n#if !_STANDARD\nhalf4 unity_Lightmap_HDR;\ninline half3 DecodeLightmap( half4 color )\n{\n    return DecodeLightmap( color, unity_Lightmap_HDR );\n}\n\n#define UNITY_INV_PI        0.31830988618f\ninline float GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return UNITY_INV_PI * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n    void BakeryVertexLMDirection(inout float3 diffuseColor, inout float3 specularColor, float3 lightDirection, float3 vertexNormalWorld, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 dominantDir = Bakery_SafeNormalize(lightDirection);\n        half halfLambert = dot(normalWorld, dominantDir) * 0.5 + 0.5;\n        half flatNormalHalfLambert = dot(vertexNormalWorld, dominantDir) * 0.5 + 0.5;\n\n        #ifdef BAKERY_LMSPEC\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = spec * diffuseColor;\n        #endif\n\n        diffuseColor *= halfLambert / max(1e-4h, flatNormalHalfLambert);\n    }\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXSH\n    void BakeryVertexLMSH(inout float3 diffuseColor, inout float3 specularColor, float3 shL1x, float3 shL1y, float3 shL1z, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 L0 = diffuseColor;\n        float3 nL1x = shL1x;\n        float3 nL1y = shL1y;\n        float3 nL1z = shL1z;\n        float3 L1x = nL1x * L0 * 2;\n        float3 L1y = nL1y * L0 * 2;\n        float3 L1z = nL1z * L0 * 2;\n\n        float3 sh;\n    #if BAKERY_SHNONLINEAR\n        //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n        //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n        //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n        float lumaL0 = dot(L0, 1);\n        float lumaL1x = dot(L1x, 1);\n        float lumaL1y = dot(L1y, 1);\n        float lumaL1z = dot(L1z, 1);\n        float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n        float regularLumaSH = dot(sh, 1);\n        //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n        sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    #else\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    #endif\n\n        diffuseColor = max(sh, 0.0);\n\n        #ifdef BAKERY_LMSPEC\n            float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n            float focus = saturate(length(dominantDir));\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = max(spec * sh, 0.0);\n        #endif\n    }\n#endif\n\n\n\n#ifdef BAKERY_BICUBIC\nfloat BakeryBicubic_w0(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-a + 3.0f) - 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w1(float a)\n{\n    return (1.0f/6.0f)*(a*a*(3.0f*a - 6.0f) + 4.0f);\n}\n\nfloat BakeryBicubic_w2(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-3.0f*a + 3.0f) + 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w3(float a)\n{\n    return (1.0f/6.0f)*(a*a*a);\n}\n\nfloat BakeryBicubic_g0(float a)\n{\n    return BakeryBicubic_w0(a) + BakeryBicubic_w1(a);\n}\n\nfloat BakeryBicubic_g1(float a)\n{\n    return BakeryBicubic_w2(a) + BakeryBicubic_w3(a);\n}\n\nfloat BakeryBicubic_h0(float a)\n{\n    return -1.0f + BakeryBicubic_w1(a) / (BakeryBicubic_w0(a) + BakeryBicubic_w1(a)) + 0.5f;\n}\n\nfloat BakeryBicubic_h1(float a)\n{\n    return 1.0f + BakeryBicubic_w3(a) / (BakeryBicubic_w2(a) + BakeryBicubic_w3(a)) + 0.5f;\n}\n#endif\n\n\n#if defined(_LIGHTMAPMODE_RNM) || defined(_LIGHTMAPMODE_SH)\nTexture2D _RNM0, _RNM1, _RNM2;\n#endif\n\n#ifdef BAKERY_VOLUME\nTexture3D _Volume0, _Volume1, _Volume2, _VolumeMask;\nSamplerState sampler_Volume0;\n#endif\n\n#if defined(BAKERY_BICUBIC) && defined(LIGHTMAP_ON) && defined(SHADER_API_D3D11)\n    // Bicubic\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\tfloat width, height;\n\t\ttex.GetDimensions(width, height);\n\t\tfloat texelSize = 1.0f / width;\n\n        float x = uv.x * width;\n        float y = uv.y * width;\n\n        x -= 0.5f;\n        y -= 0.5f;\n\n        float px = floor(x);\n        float py = floor(y);\n\n        float fx = x - px;\n        float fy = y - py;\n\n        float g0x = BakeryBicubic_g0(fx);\n        float g1x = BakeryBicubic_g1(fx);\n        float h0x = BakeryBicubic_h0(fx);\n        float h1x = BakeryBicubic_h1(fx);\n        float h0y = BakeryBicubic_h0(fy);\n        float h1y = BakeryBicubic_h1(fy);\n\n        return     BakeryBicubic_g0(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h0y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h0y) * texelSize))) +\n\n                   BakeryBicubic_g1(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h1y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h1y) * texelSize)));\n    }\n#else\n    // Bilinear\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\t#ifdef LIGHTMAP_ON\n\t\t\treturn tex.Sample(samplerunity_Lightmap, uv);\n\t\t#else\n\t\t\treturn float4(1,0,0,1);\n\t\t#endif\n    }\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\n#ifdef BAKERY_LMSPEC\nfloat BakeryDirectionalLightmapSpecular(float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 dominantDir = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap, lmUV).xyz * 2 - 1;\n    half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n    half nh = saturate(dot(normalWorld, halfDir));\n    half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n    half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n    half spec = GGXTerm(nh, roughness);\n    return spec;\n}\n#endif\n#endif\n\n\n\n#ifdef _LIGHTMAPMODE_RNM\nvoid BakeryRNM(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalMap, float smoothness, float3 viewDirT)\n{\n    const float3 rnmBasis0 = float3(0.816496580927726f, 0, 0.5773502691896258f);\n    const float3 rnmBasis1 = float3(-0.4082482904638631f, 0.7071067811865475f, 0.5773502691896258f);\n    const float3 rnmBasis2 = float3(-0.4082482904638631f, -0.7071067811865475f, 0.5773502691896258f);\n\n    float3 rnm0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 rnm1 = DecodeLightmap(BakeryTex2D(_RNM1, lmUV));\n    float3 rnm2 = DecodeLightmap(BakeryTex2D(_RNM2, lmUV));\n\n    #ifdef BAKERY_SSBUMP\n        diffuseColor = normalMap.x * rnm0\n                     + normalMap.z * rnm1\n                     + normalMap.y * rnm2;\n         diffuseColor *= 2;\n    #else\n        diffuseColor = saturate(dot(rnmBasis0, normalMap)) * rnm0\n                     + saturate(dot(rnmBasis1, normalMap)) * rnm1\n                     + saturate(dot(rnmBasis2, normalMap)) * rnm2;\n    #endif\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDirT = rnmBasis0 * dot(rnm0, lumaConv) +\n                              rnmBasis1 * dot(rnm1, lumaConv) +\n                              rnmBasis2 * dot(rnm2, lumaConv);\n\n        float3 dominantDirTN = normalize(dominantDirT);\n        float3 specColor = saturate(dot(rnmBasis0, dominantDirTN)) * rnm0 +\n                           saturate(dot(rnmBasis1, dominantDirTN)) * rnm1 +\n                           saturate(dot(rnmBasis2, dominantDirTN)) * rnm2;\n\n        half3 halfDir = Bakery_SafeNormalize(dominantDirTN - viewDirT);\n        half nh = saturate(dot(normalMap, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n        specularColor = spec * specColor;\n    #endif\n}\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\ninline half3 Unity_DecodeDirectionalLightmap(half3 color, half4 dirTex, half3 normalWorld)\n{\n    // In directional (non-specular) mode Enlighten bakes dominant light direction\n    // in a way, that using it for half Lambert and then dividing by a \"rebalancing coefficient\"\n    // gives a result close to plain diffuse response lightmaps, but normalmapped.\n\n    // Note that dir is not unit length on purpose. Its length is \"directionality\", like\n    // for the directional specular lightmaps.\n\n    half halfLambert = dot(normalWorld, dirTex.xyz - 0.5) + 0.5;\n\n    return color * halfLambert / max(1e-4h, dirTex.w);\n}\n#endif\n\n#ifdef _LIGHTMAPMODE_SH\nvoid BakerySH(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 L0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 nL1x = BakeryTex2D(_RNM0, lmUV) * 2 - 1;\n    float3 nL1y = BakeryTex2D(_RNM1, lmUV) * 2 - 1;\n    float3 nL1z = BakeryTex2D(_RNM2, lmUV) * 2 - 1;\n    float3 L1x = nL1x * L0 * 2;\n    float3 L1y = nL1y * L0 * 2;\n    float3 L1z = nL1z * L0 * 2;\n\n    float3 sh;\n#if BAKERY_SHNONLINEAR\n    float lumaL0 = dot(L0, 1);\n    float lumaL1x = dot(L1x, 1);\n    float lumaL1y = dot(L1y, 1);\n    float lumaL1z = dot(L1z, 1);\n    float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    float regularLumaSH = dot(sh, 1);\n    //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n    sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n    //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n    //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n#else\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n#endif\n\n    diffuseColor = max(sh, 0.0);\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n        float focus = saturate(length(dominantDir));\n        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n        half nh = saturate(dot(normalWorld, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n\n        sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n\n        specularColor = max(spec * sh, 0.0);\n    #endif\n}\n#endif\n\n#endif // include guards\n\n\n    void Ext_ModifyVertex15 (inout VertexData v, inout ExtraV2F e)\n    {\n        #if _USEBAKERY\n\t\t    #if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\t\t\t    // Unpack from RGBM\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.a * 8.0f;\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.rgb;\n\n\t\t\t    #ifdef BAKERY_VERTEXLMMASK\n\t\t\t\t    e.extraV2F4.xyzw = unpack4NFloats(v.texcoord1);\n\t\t\t    #endif\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXSH\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n                e.extraV2F6.xyz = unpack3NFloats(v.texcoord3.x) * 2 - 1;\n                e.extraV2F7.xyz = unpack3NFloats(v.texcoord3.y) * 2 - 1;\n            #endif\n       #endif\n    }\n\n#if _HDRP || _URP\n    half3 SHEvalLinearL0L1 (half4 normal)\n    {\n        half3 x;\n\n        // Linear (L1) + constant (L0) polynomial terms\n        x.r = dot(unity_SHAr,normal);\n        x.g = dot(unity_SHAg,normal);\n        x.b = dot(unity_SHAb,normal);\n\n        return x;\n    }\n\n    // normal should be normalized, w=1.0\n    half3 SHEvalLinearL2 (half4 normal)\n    {\n        half3 x1, x2;\n        // 4 of the quadratic (L2) polynomials\n        half4 vB = normal.xyzz * normal.yzzx;\n        x1.r = dot(unity_SHBr,vB);\n        x1.g = dot(unity_SHBg,vB);\n        x1.b = dot(unity_SHBb,vB);\n\n        // Final (5th) quadratic (L2) polynomial\n        half vC = normal.x*normal.x - normal.y*normal.y;\n        x2 = unity_SHC.rgb * vC;\n\n        return x1 + x2;\n    }\n\n    half3 ShadeSH9 (half4 normal)\n    {\n        // Linear + constant polynomial terms\n        half3 res = SHEvalLinearL0L1 (normal);\n\n        // Quadratic polynomials\n        res += SHEvalLinearL2 (normal);\n\n        #ifdef UNITY_COLORSPACE_GAMMA\n            res = LinearToGamma (res);\n        #endif\n\n        return res;\n\n    }\n#endif\n\n\n\n\tvoid DoBakeryStuff(inout float3 indDif, inout float3 indSpec, inout float4 shadowmask, float3 tangentNormal, float smoothness, ShaderData d)\n\t{\n\t\t// Quality!\n\t\tindDif = 1;\n\t\tindSpec = 0;\n\n        #if defined(_PASSFORWARD) || defined(_PASSGBUFFER) // forward pass on URP/Standard/HDRP + built-in deferred\n\n            float3 normalWorld = mul(tangentNormal, d.TBNMatrix);\n\n\t\t\t#ifdef LIGHTMAP_ON\n\n                // Static\n\n\t\t\t\tfloat2 lmUV = d.texcoord1 * unity_LightmapST.xy + unity_LightmapST.zw;\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_STANDARD\n\t\t\t\t\tindDif = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n\n\t\t\t\t\t#ifdef DIRLIGHTMAP_COMBINED\n\t\t\t\t\t\tfloat4 dirMap = BakeryTex2D(unity_LightmapInd, lmUV);\n\t\t\t\t\t\tindDif = Unity_DecodeDirectionalLightmap(indDif, dirMap, normalWorld);\n\n\t\t\t\t\t\t#ifdef BAKERY_LMSPEC\n\t\t\t\t\t\t\tindSpec = BakeryDirectionalLightmapSpecular(lmUV, normalWorld, -d.worldSpaceViewDir, smoothness) * indDif;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\n\t\t\t\t\tindDif = d.vertexColor;\n\n                    #ifdef BAKERY_VERTEXLMMASK\n                        shadowmask = d.extraV2F4;\n                    #endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n\t\t\t\t\t\t// worldSpaceNormal is per-vertex\n\t\t\t\t\t\t// normalWorld is per-pixel\n\t\t\t\t\t\tfloat3 bakedLightDirection = d.extraV2F5;\n\t\t\t\t\t\tBakeryVertexLMDirection(indDif, indSpec, bakedLightDirection, d.worldSpaceNormal, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXSH\n\t\t\t\t\t\tBakeryVertexLMSH(indDif, indSpec, d.extraV2F5, d.extraV2F6, d.extraV2F7, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_RNM\n\t\t\t\t\tBakeryRNM(indDif, indSpec, lmUV, tangentNormal, smoothness, -d.tangentSpaceViewDir);\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_SH\n\t\t\t\t\tBakerySH(indDif, indSpec, lmUV, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t#endif\n\n            #else\n\n                // Dynamic\n\n                #ifdef BAKERY_VOLUME\n\n                    bool isGlobal = dot(abs(_VolumeInvSize),1) == 0;\n                    float3 volViewDir = -d.worldSpaceViewDir;\n                    #ifdef BAKERY_VOLROTATION\n                        float4x4 volMatrix = (isGlobal ? _GlobalVolumeMatrix : _VolumeMatrix);\n                        float3 volInvSize = (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 lpUV = mul(volMatrix, float4(d.worldSpacePosition,1)).xyz * volInvSize + 0.5f;\n                        float3 volNormal = mul((float3x3)volMatrix, normalWorld);\n                        #ifdef BAKERY_LMSPEC\n                            volViewDir = mul((float3x3)volMatrix, volViewDir);\n                        #endif\n                    #else\n                        float3 lpUV = (d.worldSpacePosition - (isGlobal ? _GlobalVolumeMin : _VolumeMin)) * (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 volNormal = normalWorld;\n                    #endif\n\n                    #ifdef BAKERY_COMPRESSED_VOLUME\n                        float4 tex0, tex1, tex2, tex3;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex3 = _Volume3.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz * L0;\n                        L1y = tex2.xyz * L0;\n                        L1z = tex3.xyz * L0;\n                    #else\n                        float4 tex0, tex1, tex2;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV);\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV);\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz;\n                        L1y = tex2.xyz;\n                        L1z = float3(tex0.w, tex1.w, tex2.w);\n                    #endif\n                    indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), volNormal);\n                    indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), volNormal);\n                    indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), volNormal);\n\n                    #ifdef UNITY_COLORSPACE_GAMMA\n                        indDif = pow(indDif, 1.0f / 2.2f);\n                    #endif\n\n                    #ifdef BAKERY_LMSPEC\n                        float3 nL1x = L1x / L0;\n                        float3 nL1y = L1y / L0;\n                        float3 nL1z = L1z / L0;\n                        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n                        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - volViewDir);\n                        half nh = saturate(dot(volNormal, halfDir));\n                        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n                        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n                        half spec = GGXTerm(nh, roughness);\n                        float3 sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n                        indSpec = max(spec * sh, 0.0);\n                    #endif\n\n                    shadowmask = _VolumeMask.Sample(sampler_Volume0, lpUV);\n\n                #else\n\n                    #ifdef BAKERY_SHNONLINEAR\n                        float3 L0 = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);\n                        indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, unity_SHAr.xyz, normalWorld);\n                        indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, unity_SHAg.xyz, normalWorld);\n                        indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, unity_SHAb.xyz, normalWorld);\n                    #else\n                        indDif = ShadeSH9(float4(normalWorld,1));\n                    #endif\n\n                #endif\n\n\t\t\t#endif\n\n        #endif\n\t}\n\n\t// this is the main surface function. Surface is like a surface shader output structure, but\n\t// with our new outputs as well.\n\tvoid Ext_SurfaceFunction15 (inout Surface o, ShaderData d)\n\t{\n        #if _USEBAKERY\n\t\t    float3 indDif;\n\t\t    float3 indSpec;\n            float4 shadowmask = 1;\n\t\t    DoBakeryStuff(indDif, indSpec, shadowmask, o.Normal, o.Smoothness, d);\n\t\t    o.DiffuseGI = indDif;\n\t\t    o.BackDiffuseGI = indDif;\n\t\t    o.SpecularGI = indSpec;\n            o.ShadowMask = shadowmask;\n        #endif\n\t}\n\n\n\n\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                  Ext_SurfaceFunction1(l, d);\n                  Ext_SurfaceFunction2(l, d);\n                  Ext_SurfaceFunction3(l, d);\n                  Ext_SurfaceFunction4(l, d);\n                  Ext_SurfaceFunction5(l, d);\n                  Ext_SurfaceFunction6(l, d);\n                  Ext_SurfaceFunction7(l, d);\n                  Ext_SurfaceFunction8(l, d);\n                  Ext_SurfaceFunction9(l, d);\n\t\t            Ext_SurfaceFunction10(l, d);\n                  Ext_SurfaceFunction11(l, d);\n                  Ext_SurfaceFunction12(l, d);\n                  Ext_SurfaceFunction13(l, d);\n                  Ext_SurfaceFunction14(l, d);\n                  Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraV2F d;\n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                  Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                  Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                  #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                  v2p.extraV2F4 = d.extraV2F4;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                  v2p.extraV2F5 = d.extraV2F5;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F6 = d.extraV2F6;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F7 = d.extraV2F7;\n                  #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                d.extraV2F4 = v2p.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                d.extraV2F5 = v2p.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F6 = v2p.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F7 = v2p.extraV2F7;\n                #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n                Ext_ModifyTessellatedVertex2(v, d);\n                Ext_ModifyTessellatedVertex3(v, d);\n                Ext_ModifyTessellatedVertex4(v, d);\n                Ext_ModifyTessellatedVertex5(v, d);\n                Ext_ModifyTessellatedVertex6(v, d);\n                Ext_ModifyTessellatedVertex7(v, d);\n                Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                v2p.extraV2F4 = d.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                v2p.extraV2F5 = d.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F6 = d.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F7 = d.extraV2F7;\n                #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n            // d.texcoord3 = i.texcoord3;\n             #endif\n\n             d.isFrontFace = facing;\n             #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n             d.vertexColor = i.vertexColor;\n             #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(i.worldPos, 1)).xyz;\n            #endif\n             d.localSpaceNormal = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n             #if LOD_FADE_CROSSFADE\n             d.screenPos = i.screenPos;\n             d.screenUV = (i.screenPos.xy / i.screenPos.w);\n             #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n             #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n             d.extraV2F4 = i.extraV2F4;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n             d.extraV2F5 = i.extraV2F5;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F6 = i.extraV2F6;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F7 = i.extraV2F7;\n             #endif\n\n            return d;\n         }\n         \n\n            \n         #if defined(SHADERPASS_SHADOWCASTER)\n            float3 _LightDirection;\n         #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n            o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n            #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n           // o.texcoord3 = v.texcoord3;\n            #endif\n\n            #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n            o.vertexColor = v.vertexColor;\n            #endif\n           \n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n           o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n\n          #if defined(SHADERPASS_SHADOWCASTER)\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, _LightDirection));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif defined(SHADERPASS_META)\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1, v.texcoord2, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n           #if LOD_FADE_CROSSFADE\n           o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n           #endif\n\n          #if defined(SHADERPASS_FORWARD)\n              OUTPUT_LIGHTMAP_UV(v.texcoord1, unity_LightmapST, o.lightmapUV);\n              OUTPUT_SH(o.worldNormal, o.sh);\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n              half fogFactor = ComputeFogFactor(o.pos.z);\n              o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n          #endif\n\n          #ifdef _MAIN_LIGHT_SHADOWS\n              o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n           return o;\n         }\n\n\n            \n\n            // fragment shader\n            half4 Frag (VertexToPixel IN\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n            ) : SV_Target\n            {\n               UNITY_SETUP_INSTANCE_ID(IN);\n               UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n\n\n               ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                     , facing\n                  #endif\n               );\n\n               Surface l = (Surface)0;\n\n               l.Albedo = half3(0.5, 0.5, 0.5);\n               l.Normal = float3(0,0,1);\n               l.Occlusion = 1;\n               l.Alpha = 1;\n\n               ChainSurfaceFunction(l, d);\n\n               \n               half4 color = half4(l.Albedo, l.Alpha);\n\n               return color;\n\n            }\n\n         ENDHLSL\n\n      }\n\n\n      \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   }\n   \n   \n   CustomEditor \"JBooth.BetterLit.LitBaseMaterialEditor\"\n}\n"},{"srpTarget":2,"UnityVersionMin":20202,"UnityVersionMax":30000,"shader":{"instanceID":0},"shaderSrc":"////////////////////////////////////////\n// Generated with Better Shaders\n//\n// Auto-generated shader code, don't hand edit!\n//\n//   Unity Version: 2020.3.0f1\n//   Render Pipeline: HDRP2020\n//   Platform: OSXEditor\n////////////////////////////////////////\n\n\nShader \"Hidden/Better Lit/Lit Alpha\"\n{\n   Properties\n   {\n      \n   [HideInInspector]_NoiseTex(\"Noise Texture\", 2D) = \"black\" {}\n\n\n    [HideInInspector]_MainTex(\"Unity Standard Shader Hack Property\", 2D) = \"white\" {} // use this to do material conversion.\n    [HideInInspector]_BaseColor(\"Unity HDRP/URP Shader Hack Property\", 2D) = \"white\" {} // use this to do material conversion.\n    [HideInInspector]_BumpMap(\"Unity Standard Shader Hack Property\", 2D) = \"bump\" {} // use this to do material conversion.\n    [HideInInspector]_IsConverted(\"Have we done one time conversion yet?\", Float) = 0\n    \n    _TriplanarSpace (\"Triplanar Space\", Float) = 0\n    _TriplanarContrast (\"Triplanar Contrast\", Range(1, 10)) = 4\n    _UVSource(\"UV Source\", Float) = 0\n    _AlbedoMap(\"Albedo/Height\", 2D) = \"white\" {}\n    _Tint (\"Tint\", Color) = (1, 1, 1, 1)\n    _AlbedoBrightness(\"Brightness\", Range(-1, 1)) = 0\n    _AlbedoContrast(\"Contrast\", Range(0,2)) = 1\n    _AlphaThreshold(\"Alpha Threshold\", Range(0,1)) = 0.0\n    _Cutoff(\"Unity Lightmapper sucks\", Range(0, 1)) = 0.0\n    _NormalMap(\"Normal\", 2D) = \"bump\" {}\n    _NormalStrength(\"Normal Strength\", Range(0,2)) = 1\n    \n    _MaskMap(\"Mask Map\", 2D) = \"black\" {}\n    _Smoothness(\"Smoothness\", Range(0,1)) = 0\n    _Metallic(\"Metallic\", Range(0,1)) = 0\n    _SpecularMap(\"Specular Map\", 2D) = \"black\" {}\n\n    _EmissionMap(\"Emission Map\", 2D) = \"black\" {}\n    _EmissionColor(\"Emission Strength\", Color) = (0,0,0,0)\n\n    _SmoothnessRemap(\"Smoothness Remap\", Vector) = (0, 1, 0, 0)\n    _AORemap(\"AO Remap\", Vector) = (0, 1, 0, 0)\n    _MetallicRemap(\"Metallic Remap\", Vector) = (0, 1, 0, 0)\n    _HeightRemap(\"Height Remap\", Vector) = (0, 1, 0, 0)\n\n    _DetailUVSource(\"Detail UV Source\", Float) = 0\n    _DetailMap(\"Detail Map\", 2D) = \"white\" {}\n    _DetailAlbedoStrength(\"Detail Albedo Strength\", Range(0, 2)) = 1\n    _DetailNormalStrength(\"Detail Normal Strength\", Range(0, 2)) = 1\n    _DetailSmoothnessStrength(\"Detail Smoothness Strength\", Range(0, 2)) = 1\n    _DetailTriplanarSpace (\"Triplanar Space\", Float) = 0\n    _DetailTriplanarContrast (\"Triplanar Contrast\", Range(1, 10)) = 4\n    _DetailStochasticContrast(\"Stochastic Contrast\", Range(0.01,0.999)) = 0.7\n    _DetailStochasticScale(\"Stochastic Contrast\", Range(0.2,1.5)) = 0.5\n    _FlatShadingBlend(\"Flat Shading Blend\", Range(0,4)) = 1\n    _StochasticContrast(\"Stochastic Contrast\", Range(0.01,0.999)) = 0.7\n    _StochasticScale(\"Stochastic Contrast\", Range(0.2,1.5)) = 0.5\n    _ParallaxHeight(\"Parallax Height\", Range(0, 0.25)) = 0\n\n    _MicroShadowStrength(\"Micro Shadow Strength\", Range(0, 2)) = 0\n    _FuzzyShadingOn(\"FuzzyShadingToggle\", Float) = 0\n    _FuzzyShadingColor(\"Fuzzy Shading Color\", Color) = (1,1,1,1)\n    _FuzzyShadingParams(\"Fuzzy Shading Params\", Vector) = (0.3,1,1.5,1) // coreMult, edgeMult, power\n\n    //_POMMaxSamples (\"POM Max Samples\", Range(4, 32)) = 8\n    //_POMMin (\"POM Min Distance\", Float) = 25\n    //_POMFade (\"Pom Fade Range\", Float) = 25\n\n\n\n\t_TintMask(\"Tint Mask\", 2D) = \"white\" {}\n\t_RColor(\"R Color\", Color) = (0.5,0.5,0.5,1)\n\t_GColor(\"G Color\", Color) = (0.5,0.5,0.5,1)\n\t_BColor(\"B Color\", Color) = (0.5,0.5,0.5,1)\n\t_AColor(\"A Color\", Color) = (0.5,0.5,0.5,1)\n\n\n\t_LayerTextureMask(\"Layer Texture Mask\", 2D) = \"white\" {}\n    _LayerTextureMaskUVMode(\"Layer Texture Mask UV Mode\", Float) = 0\n\n\n\t_LayerUVSource(\"Detail UV Source\", Float) = 0\n    [Enum(Multiply2X, 0, AlphaBlend, 1, HeightBlend, 2)]_LayerBlendMode(\"Layer Blend Mode\", Float) = 0\n    _LayerStrength(\"Layer Strength\", Range(0,2)) = 1\n    _LayerAlbedoStrength(\"Detail Albedo Strength\", Range(0, 2)) = 1\n    _LayerNormalStrength(\"Detail Normal Strength\", Range(0, 2)) = 1\n    _LayerSmoothnessRemap(\"Smoothness Remap\", Vector) = (0, 1, 0, 0)\n    _LayerAORemap(\"Occlusion Remap\", Vector) = (0, 1, 0, 0)\n    _LayerMetallicRemap(\"Metallic Remap\", Vector) = (0, 1, 0, 0)\n    _LayerSmoothness(\"Smoothness\", Range(0,1)) = 0\n    _LayerSmoothnessStrength(\"Smoothness Strength\", Range(0,1)) = 1\n    _LayerHeightRemap(\"Height Remap\", Vector) = (0, 1, 0, 0)\n    _LayerHeightContrast(\"Height Contrast\", Range(0.01, 0.99)) = 0.5\n    _LayerMetallic(\"Metallic\", Range(0,1)) = 0\n    _LayerScale(\"Detail UV Scale\", Float) = 3\n    _LayerTriplanarSpace (\"Triplanar Space\", Float) = 0\n    _LayerTriplanarContrast (\"Triplanar Contrast\", Range(1, 10)) = 4\n    _LayerAlbedoMap(\"Albedo/Height\", 2D) = \"white\" {}\n    _LayerNormalMap(\"Normal\", 2D) = \"bump\" {}\n    _LayerMaskMap(\"Mask Map\", 2D) = \"black\" {}\n    _LayerNoiseFrequency(\"Noise Frequency\", Float) = 1\n    _LayerNoiseAmplitude(\"Noise Amplitude\", Range(0,10)) = 0.5\n    _LayerNoiseOffset(\"Noise Offset\", Float) = 0\n    _LayerNoiseCenter(\"Noise Center\", Range(-5, 5)) = 0\n    _LayerStochasticContrast(\"Stochastic Contrast\", Range(0.01,0.999)) = 0.7\n    _LayerStochasticScale(\"Stochastic Scale\", Range(0.2,1.5)) = 0.5\n    _LayerBlendTint(\"Layer Blend Tint\", Color) = (1,1,1,1)\n    _LayerBlendContrast(\"Layer Blend Contrast\", Range(0.5, 8)) = 2\n    _LayerTint(\"Layer Tint\", Color) = (1,1,1,1)\n    _LayerAlbedoBrightness(\"Layer Brightness\", Range(-1, 1)) = 0\n    _LayerAlbedoContrast(\"Layer Contrast\", Range(0, 2)) = 1\n    _LayerEmissionMap(\"Layer Emission Map\", 2D) = \"black\" {}\n    _LayerEmissionColor(\"Layer Emission Multiplier\", Color) = (0,0,0,0)\n    _LayerAngleMin(\"Angle Minimum\", Range(0,1)) = 0.1\n    _LayerVertexNormalBlend(\"Vertex->Normal Filter\", Range(0,1)) = 0.8\n    _LayerHeight(\"Height Filter\", Range(0,1)) = 0\n    [Enum(Top,0,Bottom,1)] _LayerInvertHeight (\"Layer on\", Float) = 0\n    _LayerFalloff(\"Angle Falloff Contrast\", Range(2, 40)) = 8\n    _LayerTessStrength(\"Displacement Strength\", Range(0,1)) = 1\n    _LayerWeightOverDistance(\"Weight Over Distance\", Vector) = (1,1,1,1) // start distance/weight, end fade range/weight\n    _LayerMicroShadowStrength(\"Micro Shadow Strength\", Range(0,2)) = 0\n    _LayerFuzzyShadingOn(\"FuzzyShadingToggle\", Float) = 0\n    _LayerFuzzyShadingColor(\"Fuzzy Shading Color\", Color) = (1,1,1,1)\n    _LayerFuzzyShadingParams(\"Fuzzy Shading Params\", Vector) = (0.3,1,1.5,1) // coreMult, edgeMult, power\n\n\n\n\n\t_LayerUVSource_Ext_1(\"Detail UV Source\", Float) = 0\n    [Enum(Multiply2X, 0, AlphaBlend, 1, HeightBlend, 2)]_LayerBlendMode_Ext_1(\"Layer Blend Mode\", Float) = 0\n    _LayerStrength_Ext_1(\"Layer Strength\", Range(0,2)) = 1\n    _LayerAlbedoStrength_Ext_1(\"Detail Albedo Strength\", Range(0, 2)) = 1\n    _LayerNormalStrength_Ext_1(\"Detail Normal Strength\", Range(0, 2)) = 1\n    _LayerSmoothnessRemap_Ext_1(\"Smoothness Remap\", Vector) = (0, 1, 0, 0)\n    _LayerAORemap_Ext_1(\"Occlusion Remap\", Vector) = (0, 1, 0, 0)\n    _LayerMetallicRemap_Ext_1(\"Metallic Remap\", Vector) = (0, 1, 0, 0)\n    _LayerSmoothness_Ext_1(\"Smoothness\", Range(0,1)) = 0\n    _LayerSmoothnessStrength_Ext_1(\"Smoothness Strength\", Range(0,1)) = 1\n    _LayerHeightRemap_Ext_1(\"Height Remap\", Vector) = (0, 1, 0, 0)\n    _LayerHeightContrast_Ext_1(\"Height Contrast\", Range(0.01, 0.99)) = 0.5\n    _LayerMetallic_Ext_1(\"Metallic\", Range(0,1)) = 0\n    _LayerScale_Ext_1(\"Detail UV Scale\", Float) = 3\n    _LayerTriplanarSpace_Ext_1 (\"Triplanar Space\", Float) = 0\n    _LayerTriplanarContrast_Ext_1 (\"Triplanar Contrast\", Range(1, 10)) = 4\n    _LayerAlbedoMap_Ext_1(\"Albedo/Height\", 2D) = \"white\" {}\n    _LayerNormalMap_Ext_1(\"Normal\", 2D) = \"bump\" {}\n    _LayerMaskMap_Ext_1(\"Mask Map\", 2D) = \"black\" {}\n    _LayerNoiseFrequency_Ext_1(\"Noise Frequency\", Float) = 1\n    _LayerNoiseAmplitude_Ext_1(\"Noise Amplitude\", Range(0,10)) = 0.5\n    _LayerNoiseOffset_Ext_1(\"Noise Offset\", Float) = 0\n    _LayerNoiseCenter_Ext_1(\"Noise Center\", Range(-5, 5)) = 0\n    _LayerStochasticContrast_Ext_1(\"Stochastic Contrast\", Range(0.01,0.999)) = 0.7\n    _LayerStochasticScale_Ext_1(\"Stochastic Scale\", Range(0.2,1.5)) = 0.5\n    _LayerBlendTint_Ext_1(\"Layer Blend Tint\", Color) = (1,1,1,1)\n    _LayerBlendContrast_Ext_1(\"Layer Blend Contrast\", Range(0.5, 8)) = 2\n    _LayerTint_Ext_1(\"Layer Tint\", Color) = (1,1,1,1)\n    _LayerAlbedoBrightness_Ext_1(\"Layer Brightness\", Range(-1, 1)) = 0\n    _LayerAlbedoContrast_Ext_1(\"Layer Contrast\", Range(0, 2)) = 1\n    _LayerEmissionMap_Ext_1(\"Layer Emission Map\", 2D) = \"black\" {}\n    _LayerEmissionColor_Ext_1(\"Layer Emission Multiplier\", Color) = (0,0,0,0)\n    _LayerAngleMin_Ext_1(\"Angle Minimum\", Range(0,1)) = 0.1\n    _LayerVertexNormalBlend_Ext_1(\"Vertex->Normal Filter\", Range(0,1)) = 0.8\n    _LayerHeight_Ext_1(\"Height Filter\", Range(0,1)) = 0\n    [Enum(Top,0,Bottom,1)] _LayerInvertHeight_Ext_1 (\"Layer on\", Float) = 0\n    _LayerFalloff_Ext_1(\"Angle Falloff Contrast\", Range(2, 40)) = 8\n    _LayerTessStrength_Ext_1(\"Displacement Strength\", Range(0,1)) = 1\n    _LayerWeightOverDistance_Ext_1(\"Weight Over Distance\", Vector) = (1,1,1,1) // start distance/weight, end fade range/weight\n    _LayerMicroShadowStrength_Ext_1(\"Micro Shadow Strength\", Range(0,2)) = 0\n    _LayerFuzzyShadingOn_Ext_1(\"FuzzyShadingToggle\", Float) = 0\n    _LayerFuzzyShadingColor_Ext_1(\"Fuzzy Shading Color\", Color) = (1,1,1,1)\n    _LayerFuzzyShadingParams_Ext_1(\"Fuzzy Shading Params\", Vector) = (0.3,1,1.5,1) // coreMult, edgeMult, power\n\n\n\n\n\t_LayerUVSource_Ext_2(\"Detail UV Source\", Float) = 0\n    [Enum(Multiply2X, 0, AlphaBlend, 1, HeightBlend, 2)]_LayerBlendMode_Ext_2(\"Layer Blend Mode\", Float) = 0\n    _LayerStrength_Ext_2(\"Layer Strength\", Range(0,2)) = 1\n    _LayerAlbedoStrength_Ext_2(\"Detail Albedo Strength\", Range(0, 2)) = 1\n    _LayerNormalStrength_Ext_2(\"Detail Normal Strength\", Range(0, 2)) = 1\n    _LayerSmoothnessRemap_Ext_2(\"Smoothness Remap\", Vector) = (0, 1, 0, 0)\n    _LayerAORemap_Ext_2(\"Occlusion Remap\", Vector) = (0, 1, 0, 0)\n    _LayerMetallicRemap_Ext_2(\"Metallic Remap\", Vector) = (0, 1, 0, 0)\n    _LayerSmoothness_Ext_2(\"Smoothness\", Range(0,1)) = 0\n    _LayerSmoothnessStrength_Ext_2(\"Smoothness Strength\", Range(0,1)) = 1\n    _LayerHeightRemap_Ext_2(\"Height Remap\", Vector) = (0, 1, 0, 0)\n    _LayerHeightContrast_Ext_2(\"Height Contrast\", Range(0.01, 0.99)) = 0.5\n    _LayerMetallic_Ext_2(\"Metallic\", Range(0,1)) = 0\n    _LayerScale_Ext_2(\"Detail UV Scale\", Float) = 3\n    _LayerTriplanarSpace_Ext_2 (\"Triplanar Space\", Float) = 0\n    _LayerTriplanarContrast_Ext_2 (\"Triplanar Contrast\", Range(1, 10)) = 4\n    _LayerAlbedoMap_Ext_2(\"Albedo/Height\", 2D) = \"white\" {}\n    _LayerNormalMap_Ext_2(\"Normal\", 2D) = \"bump\" {}\n    _LayerMaskMap_Ext_2(\"Mask Map\", 2D) = \"black\" {}\n    _LayerNoiseFrequency_Ext_2(\"Noise Frequency\", Float) = 1\n    _LayerNoiseAmplitude_Ext_2(\"Noise Amplitude\", Range(0,10)) = 0.5\n    _LayerNoiseOffset_Ext_2(\"Noise Offset\", Float) = 0\n    _LayerNoiseCenter_Ext_2(\"Noise Center\", Range(-5, 5)) = 0\n    _LayerStochasticContrast_Ext_2(\"Stochastic Contrast\", Range(0.01,0.999)) = 0.7\n    _LayerStochasticScale_Ext_2(\"Stochastic Scale\", Range(0.2,1.5)) = 0.5\n    _LayerBlendTint_Ext_2(\"Layer Blend Tint\", Color) = (1,1,1,1)\n    _LayerBlendContrast_Ext_2(\"Layer Blend Contrast\", Range(0.5, 8)) = 2\n    _LayerTint_Ext_2(\"Layer Tint\", Color) = (1,1,1,1)\n    _LayerAlbedoBrightness_Ext_2(\"Layer Brightness\", Range(-1, 1)) = 0\n    _LayerAlbedoContrast_Ext_2(\"Layer Contrast\", Range(0, 2)) = 1\n    _LayerEmissionMap_Ext_2(\"Layer Emission Map\", 2D) = \"black\" {}\n    _LayerEmissionColor_Ext_2(\"Layer Emission Multiplier\", Color) = (0,0,0,0)\n    _LayerAngleMin_Ext_2(\"Angle Minimum\", Range(0,1)) = 0.1\n    _LayerVertexNormalBlend_Ext_2(\"Vertex->Normal Filter\", Range(0,1)) = 0.8\n    _LayerHeight_Ext_2(\"Height Filter\", Range(0,1)) = 0\n    [Enum(Top,0,Bottom,1)] _LayerInvertHeight_Ext_2 (\"Layer on\", Float) = 0\n    _LayerFalloff_Ext_2(\"Angle Falloff Contrast\", Range(2, 40)) = 8\n    _LayerTessStrength_Ext_2(\"Displacement Strength\", Range(0,1)) = 1\n    _LayerWeightOverDistance_Ext_2(\"Weight Over Distance\", Vector) = (1,1,1,1) // start distance/weight, end fade range/weight\n    _LayerMicroShadowStrength_Ext_2(\"Micro Shadow Strength\", Range(0,2)) = 0\n    _LayerFuzzyShadingOn_Ext_2(\"FuzzyShadingToggle\", Float) = 0\n    _LayerFuzzyShadingColor_Ext_2(\"Fuzzy Shading Color\", Color) = (1,1,1,1)\n    _LayerFuzzyShadingParams_Ext_2(\"Fuzzy Shading Params\", Vector) = (0.3,1,1.5,1) // coreMult, edgeMult, power\n\n\n\n\n    [Toggle] _Trax(\"Enable Trax\", Float) = 0\n    _TraxAlbedo(\"Trax Albedo\", 2D) = \"white\" {}\n    _TraxPackedNormal(\"Trax Packed Normal\", 2D) = \"bump\" {}\n    _TraxNormalStrength(\"Normal Strength\", Range(0,2)) = 1\n    _TraxDisplacementDepth(\"Trax Depression Depth\", Float) = 0.1\n    _TraxDisplacementStrength(\"Trax Displacement\", Range(0,3)) = 0.2\n    _TraxMipBias(\"Trax Mip Bias\", Range(0, 5)) = 3\n    _TraxInterpContrast(\"Interpolation Contrast\", Range(0,1)) = 0.9\n    _TraxHeightContrast(\"Height Contrast\", Range(0,1)) = 0.5\n    _TraxTint(\"Tint Color\", Color) = (1,1,1,1)\n\n\n   _WetnessMode(\"Wetness Mode\", Int) = 0\n   _PuddleMode(\"Puddle Mode\", Int) = 0\n   _RainMode(\"Rain Mode\", Int) = 0\n   _WetnessAmount(\"Wetness Amount\", Range(0,1)) = 0\n   _Porosity(\"Porosity\", Range(0,1)) = 0.4\n   _WetnessMin(\"Minimum Wetness\", Range(0,1)) = 0\n   _WetnessMax(\"Maximum Wetness\", Range(0,1)) = 1\n   _WetnessFalloff(\"Angle Falloff\", Range(0,1)) = 1\n   _WetnessAngleMin(\"Wetness Minimum Angle\", Range(-1,1)) = -1\n   _PuddleAmount(\"Puddle Amount\", Range(0,1)) = 0\n   _PuddleFalloff(\"Puddle Contrast\", Range(2, 50)) = 12\n   _PuddleAngleMin(\"Moss Angle Minimum\", Range(0,1)) = 0.1\n   _PuddleColor(\"Puddle Color\", Color) = (0.2, 0.2, 0.2, 0.7)\n   _PuddleNoiseFrequency(\"Noise Frequency\", Float) = 1\n   _PuddleNoiseAmplitude(\"Noise Amplitude\", Range(0,10)) = 0.5\n   _PuddleNoiseCenter(\"Noise Center\", Range(-5, 5)) = 0\n   _PuddleNoiseOffset(\"Noise Offset\", Float) = 0\n   _RainDropTexture(\"RainDrop Texture\", 2D) = \"white\" {}\n   _RainIntensityScale(\"Intensity/Scale/MinWet\", Vector) = (1, 25, 0, 0)\n   _WetnessShoreline(\"Wetness Shore Height\", Float) = -99999\n\n\n    _SnowMode(\"Snow Mode\", Int) = 0\n    _SnowAlbedo(\"Snow Albedo\", 2D) = \"white\" {}\n    _SnowTint(\"Snow Trax Albedo\", Color) = (1,1,1,1)\n    _SnowNormal(\"Snow Normal\", 2D) = \"bump\" {}\n    _SnowMaskMap(\"Snow Mask Map\", 2D) = \"black\" {}\n    _SnowAmount(\"Snow Amount\", Range(0,1)) = 1\n    _SnowAngle(\"Snow Angle Falloff\", Range(0,2)) = 1\n    _SnowContrast(\"Snow Contrast\", Range(0.5, 4)) = 1.5\n    _SnowVertexHeight(\"Snow Vertex Height\", Range(0,1)) = 0.05\n    _SnowWorldFade(\"Snow Height Fade\", Vector) = (100, 50, 0, 0)\n    _SnowTraxAlbedo(\"Snow Trax Albedo\", 2D) = \"white\" {}\n    _SnowTraxTint(\"Snow Trax Albedo\", Color) = (1,1,1,1)\n    _SnowTraxNormal(\"Snow Trax Normal\", 2D) = \"bump\" {}\n    _SnowTraxMaskMap(\"Snow Trax Mask Map\", 2D) = \"black\" {}\n    _SnowNoiseFreq(\"Snow Noise Frequency\", Float) = 1\n    _SnowNoiseAmp(\"Snow Noise Amplitude\", Float) = 1\n    _SnowNoiseOffset(\"Snow Noise Offset\", Float) = 0\n    _SnowStochasticContrast(\"Snow Stochastic Contrast\", Range(0.01, 0.99)) = 0.7\n    _SnowStochasticScale(\"Snow Stochastic Scale\", Range(0,2)) = 1\n\n\n   [BetterHeader(Wind Particulate)]\n   [Toggle] _Wind(\"Enable Wind\", Float) = 0\n   [Enum(World, 0, UV, 1)]_WindParticulateSpace(\"Wind UV Source\", Float) = 0\n   _WindParticulate(\"Wind Texture\", 2D) = \"black\" {}\n   _WindParticulateStrength(\"Strength\", Range(0, 3)) = 2\n   _WindParticulateSpeed(\"Speed\", Float) = 1\n   _WindParticulatePower(\"Contrast\", Range(0.2, 6)) = 1\n   _WindParticulateRotation(\"Rotation\", Float) = 0\n   _WindParticulateColor(\"Color, strength\", Color) = (1, 1, 1, 1)\n   _WindParticulateWorldHeightMask(\"Wind Height Mask\", Vector) = (-99999, -99999, 99999, 99999)\n   _WindParticulateTextureHeight(\"Wind Texture Height\", Range(0,1)) = 1\n   _WindParticulateAngleMask(\"Wind Angle Mask\", Vector) = (-1, -1, 1, 1)\n   _WindParticulateOcclusionStrength(\"Wind Occlusion Strength\", Range(0,1)) = 1\n   _WindParticulateEmissive(\"Wind Emissive\", Color) = (0,0,0,0)\n\n\n   [Enum(Off,0,Front,1,Back,2)]_CullMode(\"Culling Mode\", Float) = 2\n   [Enum(Flip, 0, Mirror, 1, None, 2)] _DoubleSidedNormalMode(\"Double sided normal mode\", Float) = 1\n\n\n   _AutoNormalStrength(\"Auto Normal Strength\", Range(0,2)) = 0.5\n\n\n\t_DebugSampleCountThreshold (\"Debug Sample Threshold\", Int) = 12\n\n\n\t[Toggle(_DISSOLVE)] _DissolveEnabled (\"Enable Dissolve\", Float) = 0\n    _DissolveAmount(\"Dissolve Amount\", Range(0,1)) = 0\n\t_DissolveTexture(\"Dissolve Texture\", 2D) = \"black\" {}\n    _DissolveGradient(\"Dissolve Gradient\", 2D) = \"white\" {}\n\t_DissolveColoration(\"Dissolve Coloration\", Range(0,1)) = 1\n\t_DissolveEdgeContrast(\"Dissolve Edge Contrast\", Range(2, 128)) = 10\n    _DissolveEmissiveStr(\"Dissolve Emissive Strength\", Range(0,4)) = 0\n\n\n\n\n\n\n\t[BetterHeader(Bakery)]\n    [Toggle(USEBAKERY)] _USEBAKERY (\"Enabled Bakery\", Float) = 0\n\t[KeywordEnum(Standard, RNM, SH, Vertex, VertexDirectional, VertexSH)] _LightmapMode (\"Lightmapping mode\", Float) = 0\n    [Toggle(BAKERY_VERTEXLMMASK)] _BAKERY_VERTEXLMMASK (\"Enable vertex shadowmask\", Float) = 0\n    [Toggle(BAKERY_SHNONLINEAR)] _BAKERY_SHNONLINEAR (\"SH non-linear mode\", Float) = 1\n    [Toggle(BAKERY_LMSPEC)] _BAKERY_LMSPEC (\"Enable Lightmap Specular\", Float) = 0\n    [Toggle(BAKERY_BICUBIC)] _BAKERY_BICUBIC (\"Enable Bicubic Filter\", Float) = 0\n    [Toggle(BAKERY_VOLUME)] _BAKERY_VOLUME (\"Use volumes\", Float) = 0\n    [Toggle(BAKERY_VOLROTATION)] _BAKERY_VOLROTATION (\"Allow volume rotation\", Float) = 0\n\n\n\n\n\n   _IsAlpha(\"Not Used or set, just so the editor knows we are an alpha shader\", Float) = 0\n\n\n\n      [HideInInspector]_RenderQueueType(\"Float\", Float) = 1\n      [HideInInspector][ToggleUI]_AddPrecomputedVelocity(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_DepthOffsetEnable(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_TransparentWritingMotionVec(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_AlphaCutoffEnable(\"Boolean\", Float) = 0\n      [HideInInspector]_TransparentSortPriority(\"_TransparentSortPriority\", Float) = 0\n      [HideInInspector][ToggleUI]_UseShadowThreshold(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_TransparentDepthPrepassEnable(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_TransparentDepthPostpassEnable(\"Boolean\", Float) = 0\n      [HideInInspector]_SurfaceType(\"Float\", Float) = 0\n      [HideInInspector]_BlendMode(\"Float\", Float) = 0\n      [HideInInspector]_SrcBlend(\"Float\", Float) = 1\n      [HideInInspector]_DstBlend(\"Float\", Float) = 0\n      [HideInInspector]_AlphaSrcBlend(\"Float\", Float) = 1\n      [HideInInspector]_AlphaDstBlend(\"Float\", Float) = 0\n      [HideInInspector][ToggleUI]_AlphaToMask(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_AlphaToMaskInspectorValue(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_ZWrite(\"Boolean\", Float) = 1\n      [HideInInspector][ToggleUI]_TransparentZWrite(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_EnableFogOnTransparent(\"Boolean\", Float) = 1\n      [HideInInspector]_ZTestDepthEqualForOpaque(\"Float\", Int) = 4\n      [HideInInspector][Enum(UnityEngine.Rendering.CompareFunction)]_ZTestTransparent(\"Float\", Float) = 4\n      [HideInInspector][ToggleUI]_TransparentBackfaceEnable(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_RequireSplitLighting(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_ReceivesSSR(\"Boolean\", Float) = 1\n      [HideInInspector][ToggleUI]_ReceivesSSRTransparent(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_EnableBlendModePreserveSpecularLighting(\"Boolean\", Float) = 1\n      [HideInInspector][ToggleUI]_SupportDecals(\"Boolean\", Float) = 1\n      [HideInInspector]_StencilRef(\"Float\", Int) = 0\n      [HideInInspector]_StencilWriteMask(\"Float\", Int) = 6\n      [HideInInspector]_StencilRefDepth(\"Float\", Int) = 8\n      [HideInInspector]_StencilWriteMaskDepth(\"Float\", Int) = 8\n      [HideInInspector]_StencilRefMV(\"Float\", Int) = 40\n      [HideInInspector]_StencilWriteMaskMV(\"Float\", Int) = 40\n      [HideInInspector]_StencilRefDistortionVec(\"Float\", Int) = 4\n      [HideInInspector]_StencilWriteMaskDistortionVec(\"Float\", Int) = 4\n      [HideInInspector]_StencilWriteMaskGBuffer(\"Float\", Int) = 14\n      [HideInInspector]_StencilRefGBuffer(\"Float\", Int) = 10\n      [HideInInspector]_ZTestGBuffer(\"Float\", Int) = 4\n      [HideInInspector][ToggleUI]_RayTracing(\"Boolean\", Float) = 0\n      [HideInInspector][Enum(None, 0, Box, 1, Sphere, 2, Thin, 3)]_RefractionModel(\"Float\", Float) = 0\n      [HideInInspector][NoScaleOffset]unity_Lightmaps(\"unity_Lightmaps\", 2DArray) = \"\" {}\n      [HideInInspector][NoScaleOffset]unity_LightmapsInd(\"unity_LightmapsInd\", 2DArray) = \"\" {}\n      [HideInInspector][NoScaleOffset]unity_ShadowMasks(\"unity_ShadowMasks\", 2DArray) = \"\" {}\n   }\n   SubShader\n   {\n      Tags { \"RenderPipeline\" = \"HDRenderPipeline\" \"RenderType\" = \"HDLitShader\" \"Queue\" = \"Transparent\" }\n\n      \n              Pass\n        {\n            // based on HDLitPass.template\n            Name \"Forward\"\n            Tags { \"LightMode\" = \"Forward\" }\n\n            Blend SrcAlpha OneMinusSrcAlpha, One OneMinusSrcAlpha\nCull Back\n ZTest LEqual\nZWrite Off\n            \n            Stencil\n            {\n               WriteMask [_StencilWriteMask]\n               Ref [_StencilRef]\n               Comp Always\n               Pass Replace\n            }\n        \n            ColorMask [_ColorMaskTransparentVel] 1\n\n               Cull [_CullMode]\n\n            \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone vulkan metal switch\n            #pragma multi_compile_instancing\n            #pragma instancing_options renderinglayer\n\n\n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            #pragma multi_compile _ DEBUG_DISPLAY\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            #pragma multi_compile _ LIGHTMAP_ON\n            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n            #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n            #pragma multi_compile _ SHADOWS_SHADOWMASK\n            #pragma multi_compile DECALS_OFF DECALS_3RT DECALS_4RT\n            #pragma multi_compile SHADOW_LOW SHADOW_MEDIUM SHADOW_HIGH\n            #pragma multi_compile SCREEN_SPACE_SHADOWS_OFF SCREEN_SPACE_SHADOWS_ON\n            #pragma multi_compile USE_FPTL_LIGHTLIST USE_CLUSTERED_LIGHTLIST\n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n                \n        \n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            // #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            #define SHADERPASS SHADERPASS_FORWARD\n            #define SUPPORT_BLENDMODE_PRESERVE_SPECULAR_LIGHTING\n            #define HAS_LIGHTLOOP\n            #define RAYTRACING_SHADER_GRAPH_DEFAULT\n            #define _PASSFORWARD 1\n            \n            \n\n\n   #pragma shader_feature_local_fragment _ _PACKEDFAST\n   #pragma shader_feature_local _ _TRIPLANAR\n   #pragma shader_feature_local_fragment _ _NORMALMAP \n   #pragma shader_feature_local_fragment _ _MASKMAP\n   #pragma shader_feature_local_fragment _ _DETAIL\n   #pragma shader_feature_local_fragment _ _DETAILTRIPLANAR\n   #pragma shader_feature_local_fragment _ _DETAILSTOCHASTIC\n   #pragma shader_feature_local_fragment _ _EMISSION\n   #pragma shader_feature_local_fragment _ _FLATSHADE\n   #pragma shader_feature_local _ _STOCHASTIC\n   #pragma shader_feature_local_fragment _ _PARALLAX //_POM\n   #pragma shader_feature_local_fragment _ _SPECULAR\n   #pragma shader_feature_local _ _NOISEWORLD _NOISELOCAL\n   #pragma shader_feature_local _ _NOISEHQ _NOISETEXTURE _NOISEWORLEY\n   // only for URP/Standard Forward\n   #pragma shader_feature_local_fragment _ _SIMPLELIT\n\n\n   #pragma shader_feature_local_fragment _ _TINTMASK\n\n\n    #pragma shader_feature_local _ _LAYERVERTEXMASK _LAYERTEXTUREMASK\n\n    #define _HAS_WEIGHTTEXTURE_MASK 1\n\n\n   #pragma shader_feature_local _ _USELAYER\n   #pragma shader_feature_local _ _LAYERTRIPLANAR\n   #pragma shader_feature_local _ _LAYERALBEDO\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL\n   #pragma shader_feature_local _ _LAYERMASK\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION\n   #pragma shader_feature_local _ _LAYERNOISE\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC\n   #pragma shader_feature_local _ _LAYERANGLEFILTER\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_1\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_1\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_1\n   #pragma shader_feature_local _ _LAYERMASK_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_1\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_1\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_1\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_1\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_2\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_2\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_2\n   #pragma shader_feature_local _ _LAYERMASK_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_2\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_2\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_2\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_2\n\n\n   #pragma shader_feature_local _ _TRAX_ON\n\n\n   #pragma shader_feature_local_fragment _ _WETNESS\n   #pragma shader_feature_local_fragment _ _PUDDLES\n   #pragma shader_feature_local_fragment _ _PUDDLENOISE\n   #pragma shader_feature_local_fragment _ _RAINDROPS\n\n\n   #pragma shader_feature_local _ _SNOW\n   #pragma shader_feature_local _ _SNOWMASKMAP\n   #pragma shader_feature_local _ _SNOWNOISE\n   #pragma shader_feature_local_fragment _SNOWSTOCHASTIC\n\n\n   #pragma shader_feature_local_fragment _ _WIND_ON\n\n\n\n\n   #pragma shader_feature_local_fragment _ _SURFACEGRADIENT _AUTONORMAL\n   #define _WORLDSPACENORMAL 1\n\n\n   #pragma shader_feature_local _ _DEBUG_SAMPLECOUNT\n\n\n\t#pragma shader_feature_local_fragment _ _DISSOLVE\n\n\n   #pragma multi_compile_local  LOD_FADE_CROSSFADE\n\n\n\n#pragma instancing_options procedural:setupVSPro forwardadd\n\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\nstruct IndirectShaderData\n{\n\tfloat4x4 PositionMatrix;\n\tfloat4x4 InversePositionMatrix;\n\tfloat4 ControlData;\n};\n\n#if defined(SHADER_API_GLCORE) || defined(SHADER_API_D3D11) || defined(SHADER_API_GLES3) || defined(SHADER_API_METAL) || defined(SHADER_API_VULKAN) || defined(SHADER_API_PSSL) || defined(SHADER_API_XBOXONE)\n\tuniform StructuredBuffer<IndirectShaderData> VisibleShaderDataBuffer;\n#endif\n\n#endif\n\nfloat VSPRenderingLayerMask;\n\nvoid setupVSPro()\n{\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\n    #if _HDRP\n\t    unity_RenderingLayer.x = VSPRenderingLayerMask;\n    #endif\n\n\t#ifdef unity_ObjectToWorld\n\t#undef unity_ObjectToWorld\n\t#endif\n\n\t#ifdef unity_WorldToObject\n\t#undef unity_WorldToObject\n\t#endif\n\n\tunity_ObjectToWorld = VisibleShaderDataBuffer[unity_InstanceID].PositionMatrix;\n\tunity_WorldToObject = VisibleShaderDataBuffer[unity_InstanceID].InversePositionMatrix;\n#endif\n\n}\n\n\n\t#pragma multi_compile _LIGHTMAPMODE_STANDARD _LIGHTMAPMODE_RNM _LIGHTMAPMODE_SH _LIGHTMAPMODE_VERTEX _LIGHTMAPMODE_VERTEXDIRECTIONAL _LIGHTMAPMODE_VERTEXSH\n\n    #pragma shader_feature USEBAKERY\n    #pragma shader_feature BAKERY_VERTEXLMMASK\n    #pragma shader_feature BAKERY_SHNONLINEAR\n    #pragma shader_feature BAKERY_LMSPEC\n    #pragma shader_feature BAKERY_BICUBIC\n    #pragma shader_feature BAKERY_VOLUME\n    #pragma shader_feature BAKERY_VOLROTATION\n    #pragma shader_feature BAKERY_COMPRESSED_VOLUME\n\n    #if _USEBAKERY\n\t    #define _OVERRIDE_BAKEDGI\n        #if BAKERY_VOLUME || (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)) && defined(BAKERY_VERTEXLMMASK)\n            #define _OVERRIDE_SHADOWMASK\n        #endif\n    #endif\n\n\n\n\n\n\n\n\n   #define _HDRP 1\n#define _BLENDMODE_ALPHA 1\n#define _SURFACE_TYPE_TRANSPARENT 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\" // Need to be here for Gradient struct definition\n         \n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n\n\n   half4 _Tint;\n   half _UVSource;\n   half _TriplanarContrast;\n   half _AlbedoContrast;\n   half _AlbedoBrightness;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half3 _EmissionColor;\n   float _DetailUVSource;\n   half _StochasticScale;\n   half _DetailStochasticScale;\n   half _Smoothness;\n   half _Metallic;\n   half2 _SmoothnessRemap;\n   half2 _AORemap;\n   half2 _MetallicRemap;\n   half2 _HeightRemap;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n   half _AlphaThreshold;\n   half _Cutoff; // for Unity's light mapper\n   half _TriplanarSpace;\n   half _DetailTriplanarSpace;\n   half _DetailTriplanarContrast;\n   half _MicroShadowStrength;\n   half3 _FuzzyShadingColor;\n   half _FuzzyShadingOn;\n   half3 _FuzzyShadingParams;\n\n   //int _POMMaxSamples;\n   //float _POMMin;\n   //float _POMFade;\n#if _FLATSHADE\n   half _FlatShadingBlend;\n#endif\n\n   half _StochasticContrast;\n   half _DetailStochasticContrast;\n\n#if _PARALLAX || _POM\n   half _ParallaxHeight;\n#endif\n\n\n\n\tfloat4 _TintMask_ST;\n\thalf3 _RColor;\n\thalf3 _GColor;\n\thalf3 _BColor;\n\thalf3 _AColor;\n\n\n\thalf _LayerTextureMaskUVMode;\n    float4 _LayerTextureMask_ST;\n\n\n   //#if _USELAYER\n       float4 _LayerAlbedoMap_ST;\n       half3 _LayerTint;\n       half _LayerBlendMode;\n       float _LayerUVSource;\n       half _LayerAlbedoBrightness;\n       half _LayerAlbedoContrast;\n       half _LayerHeightContrast;\n       half _LayerStrength;\n       half _LayerAlbedoStrength;\n       half _LayerNormalStrength;\n       half _LayerSmoothnessStrength;\n       half _LayerSmoothness;\n       half _LayerMetallic;\n       half _LayerStochasticScale;\n       half2 _LayerSmoothnessRemap;\n       half2 _LayerAORemap;\n       half2 _LayerMetallicRemap;\n       half2 _LayerHeightRemap;\n       float4 _LayerWeightOverDistance;\n       half _LayerMicroShadowStrength;\n       //#if _LAYERNOISE\n           float _LayerNoiseFrequency;\n           float _LayerNoiseAmplitude;\n           float _LayerNoiseOffset;\n           float _LayerNoiseCenter;\n           half3 _LayerBlendTint;\n       //#endif\n       //#if _LAYERANGLEFILTER\n           half _LayerFalloff;\n           half _LayerAngleMin;\n           half _LayerHeight;\n           half _LayerInvertHeight;\n           half _LayerVertexNormalBlend;\n       //#endif\n       half _LayerTriplanarSpace;\n       half _LayerTriplanarContrast;\n       half _LayerBlendContrast;\n       half3 _LayerEmissionColor;\n       half _LayerStochasticContrast;\n       half _LayerTessStrength;\n       half3 _LayerFuzzyShadingColor;\n       half _LayerFuzzyShadingOn;\n       half3 _LayerFuzzyShadingParams;\n   //#endif\n\n\n   //#if _USELAYER_DEF_1\n       float4 _LayerAlbedoMap_Ext_1_ST;\n       half3 _LayerTint_Ext_1;\n       half _LayerBlendMode_Ext_1;\n       float _LayerUVSource_Ext_1;\n       half _LayerAlbedoBrightness_Ext_1;\n       half _LayerAlbedoContrast_Ext_1;\n       half _LayerHeightContrast_Ext_1;\n       half _LayerStrength_Ext_1;\n       half _LayerAlbedoStrength_Ext_1;\n       half _LayerNormalStrength_Ext_1;\n       half _LayerSmoothnessStrength_Ext_1;\n       half _LayerSmoothness_Ext_1;\n       half _LayerMetallic_Ext_1;\n       half _LayerStochasticScale_Ext_1;\n       half2 _LayerSmoothnessRemap_Ext_1;\n       half2 _LayerAORemap_Ext_1;\n       half2 _LayerMetallicRemap_Ext_1;\n       half2 _LayerHeightRemap_Ext_1;\n       float4 _LayerWeightOverDistance_Ext_1;\n       half _LayerMicroShadowStrength_Ext_1;\n       //#if _LAYERNOISE_DEF_1\n           float _LayerNoiseFrequency_Ext_1;\n           float _LayerNoiseAmplitude_Ext_1;\n           float _LayerNoiseOffset_Ext_1;\n           float _LayerNoiseCenter_Ext_1;\n           half3 _LayerBlendTint_Ext_1;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_1\n           half _LayerFalloff_Ext_1;\n           half _LayerAngleMin_Ext_1;\n           half _LayerHeight_Ext_1;\n           half _LayerInvertHeight_Ext_1;\n           half _LayerVertexNormalBlend_Ext_1;\n       //#endif\n       half _LayerTriplanarSpace_Ext_1;\n       half _LayerTriplanarContrast_Ext_1;\n       half _LayerBlendContrast_Ext_1;\n       half3 _LayerEmissionColor_Ext_1;\n       half _LayerStochasticContrast_Ext_1;\n       half _LayerTessStrength_Ext_1;\n       half3 _LayerFuzzyShadingColor_Ext_1;\n       half _LayerFuzzyShadingOn_Ext_1;\n       half3 _LayerFuzzyShadingParams_Ext_1;\n   //#endif\n\n\n   //#if _USELAYER_DEF_2\n       float4 _LayerAlbedoMap_Ext_2_ST;\n       half3 _LayerTint_Ext_2;\n       half _LayerBlendMode_Ext_2;\n       float _LayerUVSource_Ext_2;\n       half _LayerAlbedoBrightness_Ext_2;\n       half _LayerAlbedoContrast_Ext_2;\n       half _LayerHeightContrast_Ext_2;\n       half _LayerStrength_Ext_2;\n       half _LayerAlbedoStrength_Ext_2;\n       half _LayerNormalStrength_Ext_2;\n       half _LayerSmoothnessStrength_Ext_2;\n       half _LayerSmoothness_Ext_2;\n       half _LayerMetallic_Ext_2;\n       half _LayerStochasticScale_Ext_2;\n       half2 _LayerSmoothnessRemap_Ext_2;\n       half2 _LayerAORemap_Ext_2;\n       half2 _LayerMetallicRemap_Ext_2;\n       half2 _LayerHeightRemap_Ext_2;\n       float4 _LayerWeightOverDistance_Ext_2;\n       half _LayerMicroShadowStrength_Ext_2;\n       //#if _LAYERNOISE_DEF_2\n           float _LayerNoiseFrequency_Ext_2;\n           float _LayerNoiseAmplitude_Ext_2;\n           float _LayerNoiseOffset_Ext_2;\n           float _LayerNoiseCenter_Ext_2;\n           half3 _LayerBlendTint_Ext_2;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_2\n           half _LayerFalloff_Ext_2;\n           half _LayerAngleMin_Ext_2;\n           half _LayerHeight_Ext_2;\n           half _LayerInvertHeight_Ext_2;\n           half _LayerVertexNormalBlend_Ext_2;\n       //#endif\n       half _LayerTriplanarSpace_Ext_2;\n       half _LayerTriplanarContrast_Ext_2;\n       half _LayerBlendContrast_Ext_2;\n       half3 _LayerEmissionColor_Ext_2;\n       half _LayerStochasticContrast_Ext_2;\n       half _LayerTessStrength_Ext_2;\n       half3 _LayerFuzzyShadingColor_Ext_2;\n       half _LayerFuzzyShadingOn_Ext_2;\n       half3 _LayerFuzzyShadingParams_Ext_2;\n   //#endif\n\n\n    half _TraxDisplacementDepth;\n    half _TraxDisplacementStrength;\n    half _TraxMipBias;\n    half _TraxNormalStrength;\n    float4 _TraxAlbedo_ST;\n    half _TraxInterpContrast;\n    half _TraxHeightContrast;\n    half3 _TraxTint;\n\n\n\n    half _Porosity;\n    int _WetnessMode;\n    int _PuddleMode;\n\n    half  _PuddleAmount;\n    half  _PuddleFalloff;\n    half4 _PuddleColor;\n    half _PuddleNoiseFrequency;\n    half _PuddleNoiseAmplitude;\n    half _PuddleNoiseOffset;\n    half _PuddleNoiseCenter;\n    half _PuddleAngleMin;\n\n    half _WetnessAmount;\n\thalf _WetnessMin;\n    half _WetnessMax;\n    half _WetnessFalloff;\n\thalf _WetnessAngleMin;\n    float _WetnessShoreline;\n\n    int _RainMode;\n    half3 _RainIntensityScale;\n\n\n\n\n    float4 _SnowAlbedo_ST;\n    half3 _SnowTint;\n    half _SnowAmount;\n    half _SnowAngle;\n    half _SnowContrast;\n    half _SnowVertexHeight;\n    half _SnowMode;\n    half3 _SnowWorldFade; // z is on/off\n    float4 _SnowTraxAlbedo_ST;\n    half3 _SnowTraxTint;\n\n    half _SnowNoiseFreq; \n    half _SnowNoiseAmp;\n    half _SnowNoiseOffset;\n    half _SnowStochasticContrast;\n    half _SnowStochasticScale;\n\n\n    half     _WindParticulateSpace;\n    half     _WindParticulateRotation;\n    half      _WindParticulateSpeed;\n    float4     _WindParticulate_ST;\n    half      _WindParticulatePower;\n    half4    _WindParticulateColor;\n    half4    _WindParticulateWorldHeightMask;\n    half4    _WindParticulateAngleMask;\n    half      _WindParticulateOcclusionStrength;\n    half      _WindParticulateStrength;\n    half4    _WindParticulateEmissive;\n    half     _WindParticulateTextureHeight;\n\n\n   float _DoubleSidedNormalMode;\n\n\n\thalf _AutoNormalStrength;\n\n\n\tint _DebugSampleCountThreshold;\n\n\n\thalf _DissolveAmount;\n\thalf _DissolveEmissiveStr;\n\thalf _DissolveEdgeContrast;\n\thalf _DissolveColoration;\n\tfloat4 _DissolveTexture_ST;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCCOORD3;\n               float4 texcoord1 : TEXCCOORD4;\n               float4 texcoord2 : TEXCCOORD5;\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n               // float4 texcoord3 : TEXCCOORD6;\n                #endif\n\n                #if LOD_FADE_CROSSFADE\n                float4 screenPos : TEXCOORD7;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR_centroid;\n                #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                float4 extraV2F4 : TEXCOORD12_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                float4 extraV2F5 : TEXCOORD13_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F6 : TEXCOORD14_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F7 : TEXCOORD15_centroid;\n                #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n    \n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n   half4 weightTextureMask;\n   \n\n\n   float traxBuffer;\n\n\n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // would love to strip these, but they are used in certain\n               // combinations of the lighting system, and may be used\n               // by the user as well, so no easy way to strip them.\n\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR_centroid;\n                #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                float4 extraV2F4 : TEXCOORD9_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                float4 extraV2F5 : TEXCOORD10_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F6 : TEXCOORD11_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F7 : TEXCOORD12_centroid;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n               #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n               #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n               #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n               #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()     unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n               #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V   unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n               #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V    mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n               #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n               #endif\n               #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\n#ifndef __STACKABLEFUNCLIBRARY_INCLUDES__\n#define __STACKABLEFUNCLIBRARY_INCLUDES__\n\n   #if _DEBUG_SAMPLECOUNT\n      int _sampleCount;\n      #define COUNTSAMPLE { _sampleCount++; }\n   #else\n      #define COUNTSAMPLE\n   #endif\n\n   TEXTURE2D(_NoiseTex);\n   SAMPLER(sampler_NoiseTex);\n\n\n\n   half3 AdjustContrast(half3 color, half contrast)\n   {\n       half3 comp = 0.5;\n   #if !UNITY_COLORSPACE_GAMMA\n       comp = 0.22;\n   #endif\n       color = saturate(lerp(comp, color, contrast));\n       return color;\n   }\n\n   float2 DoParallaxOffset( half h, half height, half3 viewDir)\n   {\n      h = h * height - height/2.0;\n      float3 v = normalize(viewDir);\n      v.z += 0.42;\n      return h * (v.xy / v.z);\n   }\n\n\n\n   #define SAMPLEBARY SampleTexBary\n\n   struct SampleConfig\n   {\n      float2 uv0;\n      float2 uv1;\n      float2 uv2;\n      float2 dx0;\n      float2 dy0;\n      float2 dx1;\n      float2 dy1;\n      float2 dx2;\n      float2 dy2;\n      float3 weights;\n      float3 origWeights;\n   };\n\n   struct Config\n   {\n      float2 origUV; // unscaled uv\n      float2 origScale;\n      float2 uv;        // no stocastic or triplanar\n      float2 dx;\n      float2 dy;\n      SampleConfig uvT; // just stochastic, or just triplanar\n      SampleConfig uvX; // stochastic and triplanar\n      SampleConfig uvY;\n      SampleConfig uvZ;\n\n      \n      float3 absVertNormal;\n      half3 axisSign;\n      float3 normal;\n   };\n\n\n    float2 Hash2D( float2 x )\n    {\n        float2 k = float2( 0.3183099, 0.3678794 );\n        x = x*k + k.yx;\n        return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );\n    }\n\n    float Noise2D(float2 p )\n    {\n        float2 i = floor( p );\n        float2 f = frac( p );\n         \n        float2 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), \n                        dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),\n                    lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), \n                        dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);\n    }\n      \n\n    float2 WorleyHash2D(float2 p)\n    {\n \t    return frac(cos(mul(p, float2x2(-64.2,71.3,81.4,-29.8)))*8321.3); \n    }\n    float WorleyNoise2D(float2 p)\n    {\n        float dist = 1;\n        float2 i = floor(p);\n        float2 f = frac(p);\n    \n        for(int x = -1;x<=1;x++)\n        {\n            for(int y = -1;y<=1;y++)\n            {\n                float d = distance(WorleyHash2D(i+float2(x,y))+float2(x,y),f);\n                dist = min(dist,d);\n            }\n        }\n        return dist;\n\t\n    }\n\n#ifndef PI\n    #define PI 3.14159265359\n#endif\n\n    float GetIntegerNoise(float2 p)\n    {\n        p  = 53.7 * frac( (p*0.3183099) + float2(0.71,0.113));\n        return frac( p.x*p.y*(p.x+p.y) );\n    }\n\n    float WorleyHash3D(float f)\n    {\n        return frac(sin(f)*43758.5453);\n    }\n\n    float WorleyHash31(float3 v)\n    {\n        return WorleyHash3D(dot(v, float3(253.14, 453.74, 183.3)));\n    }\n\n    float3 WorleyRandom3D( float3 p )\n    {\n        return frac(sin(float3(dot(p,float3(127.1,311.7,217.3)),dot(p,float3(269.5,183.3,431.1)), dot(p,float3(365.6,749.9,323.7))))*437158.5453);\n    }\n\n    float WorleyNoise3D(float3 uvw)\n    {\n        float noise = 0.0;\n    \n        float3 p = floor(uvw);\n        float3 f = frac(uvw);\n    \n        float4 res = 1;\n        for(int x = -1; x <=1; ++x)\n        {\n            for(int y = -1; y <=1; ++y)\n            {\n                for(int z = -1; z <=1; ++z)\n                {\n                    float3 gp = p + float3(x, y, z);\n\n                    float3 v = WorleyRandom3D(gp);\n\n\t\t\t\t    float3 diff = gp + v - uvw;\n                \n                    float d = length(diff);\n                \n                    if(d < res.x)\n                    {\n                        res.xyz = float3(d, res.x, res.y);\n                    }\n                    else if(d < res.y)\n                    {\n                        res.xyz = float3(res.x, d, res.y);\n                    }\n                    else if(d < res.z)\n                    {\n                        res.z = d;\n                    }\n                \n                    res.w = WorleyHash31(gp);\n                }\n            }\n        }\n\n        return res.x;\n    }\n    \n      \n    float3 Hash3D( float3 p )\n    {\n        p = float3( dot(p,float3(127.1,311.7, 74.7)),\n                dot(p,float3(269.5,183.3,246.1)),\n                dot(p,float3(113.5,271.9,124.6)));\n\n        return -1.0 + 2.0*frac(sin(p)*437.5453123);\n    }\n\n    float Noise3D( float3 p )\n    {\n        float3 i = floor( p );\n        float3 f = frac( p );\n         \n        float3 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),\n                    lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n    }\n\n    \n    float FBM2D(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           return SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n\n    }\n      \n    float FBM3D(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           half A = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.zy).g;\n           half B = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33).g;\n           half C = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoise(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3D(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3D(d.localSpacePosition * frequency+ offset, d.localSpaceNormal);\n        #else\n           return FBM2D(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n    \n    #if _SURFACEGRADIENT  \n\n    #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)\n\n      \n      \n    half3 SurfaceGradientFromTBN(ShaderData d, half2 deriv)\n    {\n        return deriv.x * d.TBNMatrix[0] + deriv.y * d.TBNMatrix[1];\n    }\n\n    half2 TspaceNormalToDerivative(half3 vM)\n    {\n        const half scale = 1.0/128.0;\n        const half3 vMa = abs(vM);\n        const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));\n\n        return -half2(vM.x, vM.y)/z_ma;\n    }\n\n    half3 SurfgradFromVolumeGradient(ShaderData d, half3 grad)\n    {\n        return grad - dot(d.worldSpaceNormal, grad) * d.worldSpaceNormal;\n    }\n\n    half3 SurfgradFromTriplanarProjection(ShaderData d, half3 pN, half3 xN, half3 yN, half3 zN)\n    {\n        const half w0 = pN.x;\n        const half w1 = pN.y;\n        const half w2 = pN.z;\n\n        half2 xD = TspaceNormalToDerivative(xN);\n        half2 yD = TspaceNormalToDerivative(yN);\n        half2 zD = TspaceNormalToDerivative(zN);\n\n        half3 volumeGrad = half3(w2 * zD.x + w1 * yD.y, w2 * zD.y + w0 * xD.y, w0 * xD.x + w1 * yD.x);\n\n        return SurfgradFromVolumeGradient(d, volumeGrad);\n    }\n\n    half3 ConvertNormalToGradient(ShaderData d, half3 normal)\n    {\n        half2 deriv = TspaceNormalToDerivative(normal);\n\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n    half3 ConvertNormal2ToGradient(ShaderData d, half2 packedNormal)\n    {\n        half2 tNormal = packedNormal;\n        half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF\n        half2 deriv = tNormal * -rcpZ;\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n\n    half3 ResolveNormalFromSurfaceGradient(ShaderData d, half3 gradient)\n    {\n        return normalize(d.worldSpaceNormal - gradient);\n    }\n\n    #endif // _SURFACEGRADIENT\n\n\n    // normals are in surface gradient or world space depending on settings, and can also be generated by height\n    half3 GetWorldSpaceNormal(ShaderData d, half3 normal, half pheight)\n    {\n       #if _SURFACEGRADIENT\n          return ResolveNormalFromSurfaceGradient(d, normal);\n       #elif _AUTONORMAL\n          float3 dx = ddx(d.worldSpacePosition);\n          float3 dy = ddy(d.worldSpacePosition);\n          float3 crossX = cross(float3(0,1,0), dx);\n          float3 crossY = cross(float3(0,1,0), dy);\n          float3 dt = abs(dot(crossY, dx));\n          float height = _AutoNormalStrength * 0.5 * pheight;\n          float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n          n.y *= -1.0;\n          return TangentToWorldSpace(d, normalize((dt * float3(0,1,0)) - n).xzy);\n       #else\n          return TangentToWorldSpace(d, normal);\n          \n       #endif\n       \n    }\n\n   void WaterBRDF (inout half3 albedo, inout half smoothness, half metallic, half wetFactor, half surfPorosity) \n   {\n      half porosity = saturate((( (1 - smoothness) - 0.5)) / max(surfPorosity, 0.001));\n      half factor = lerp(1, 0.2, (1 - metallic) * porosity);\n      albedo *= lerp(1.0, factor, wetFactor);\n      smoothness = lerp(smoothness, 0.92f, wetFactor);\n   }\n\n   void OffsetUV(inout Config c, float2 offset)\n   {\n       c.uv += offset;\n       c.uvT.uv0 += offset;\n       c.uvT.uv1 += offset;\n       c.uvT.uv2 += offset;\n       c.uvX.uv0 += offset;\n       c.uvX.uv1 += offset;\n       c.uvX.uv2 += offset;\n       c.uvY.uv0 += offset;\n       c.uvY.uv1 += offset;\n       c.uvY.uv2 += offset;\n       c.uvZ.uv0 += offset;\n       c.uvZ.uv1 += offset;\n       c.uvZ.uv2 += offset;\n   }\n\n\n    void TriangleGrid(float2 uv, float scale,\n       out float w1, out float w2, out float w3,\n       out int2 vertex1, out int2 vertex2, out int2 vertex3)\n    {\n       // Scaling of the input\n       uv *= 3.464 * scale; // 2 * sqrt(3)\n\n       // Skew input space into simplex triangle grid\n       const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);\n       float2 skewedCoord = mul(gridToSkewedGrid, uv);\n\n       // Compute local triangle vertex IDs and local barycentric coordinates\n       int2 baseId = int2(floor(skewedCoord));\n       float3 temp = float3(frac(skewedCoord), 0);\n       temp.z = 1.0 - temp.x - temp.y;\n       if (temp.z > 0.0)\n       {\n          w1 = temp.z;\n          w2 = temp.y;\n          w3 = temp.x;\n          vertex1 = baseId;\n          vertex2 = baseId + int2(0, 1);\n          vertex3 = baseId + int2(1, 0);\n       }\n       else\n       {\n          w1 = -temp.z;\n          w2 = 1.0 - temp.y;\n          w3 = 1.0 - temp.x;\n          vertex1 = baseId + int2(1, 1);\n          vertex2 = baseId + int2(1, 0);\n          vertex3 = baseId + int2(0, 1);\n       }\n    }\n\n    // Fast random hash function\n    float2 SimpleHash2(float2 p)\n    {\n       return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 43758.5453);\n    }\n\n\n    half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)\n    {\n        // compute weight with height map\n        const half epsilon = 1.0f / 1024.0f;\n        half3 weights = half3(iWeights.x * (tex0 + epsilon), \n                                 iWeights.y * (tex1 + epsilon),\n                                 iWeights.z * (tex2 + epsilon));\n\n        // Contrast weights\n        half maxWeight = max(weights.x, max(weights.y, weights.z));\n        half transition = contrast * maxWeight;\n        half threshold = maxWeight - transition;\n        half scale = 1.0f / transition;\n        weights = saturate((weights - threshold) * scale);\n        // Normalize weights.\n        half weightScale = 1.0f / (weights.x + weights.y + weights.z);\n        weights *= weightScale;\n        return weights;\n    }\n\n\n    half3 PackedUnpackScaleNormal(half4 packedNormal, float scale)\n   {\n       #if _PACKEDFAST\n          half3 normal;\n          normal.xy = (packedNormal.ag * 2 - 1) * scale;\n          normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n          return normal;  \n       #endif\n       return UnpackScaleNormal(packedNormal, scale);\n   }\n\n    void InitStochasticDxDy(inout SampleConfig c, Config cfg)\n    {\n      c.dx0 = ddx(cfg.origUV) * cfg.origScale;\n      c.dy0 = ddy(cfg.origUV) * cfg.origScale;\n      c.dx1 = c.dx0; c.dx1 = c.dx0;\n      c.dx2 = c.dy0; c.dy2 = c.dy0;\n    }\n\n    void PrepareStochasticUVs(float scale, float2 uv, out SampleConfig c)\n    {\n       // Get triangle info\n       ZERO_INITIALIZE(SampleConfig, c);\n       float w1, w2, w3;\n       int2 vertex1, vertex2, vertex3;\n       TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n       // Assign random offset to each triangle vertex\n       c.uv0 = uv;\n       c.uv1 = uv;\n       c.uv2 = uv;\n   \n       c.uv0.xy += SimpleHash2(vertex1);\n       c.uv1.xy += SimpleHash2(vertex2);\n       c.uv2.xy += SimpleHash2(vertex3);\n       c.weights = half3(w1, w2, w3);\n       c.origWeights = half3(w1, w2, w3);\n    }\n\n\n   half3 LitBlendDetailNormal(half3 n1, half3 n2)\n   {\n      #if _SURFACEGRADIENT\n         return n1 + n2;\n      #else\n         return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n      #endif\n   }\n\n   float3 TriplanarBlendUnpackedRNM(float3 n1, float3 n2)\n   {\n       n1.z += 1;\n       n2.xy = -n2.xy;\n       return n1 * dot(n1, n2) / n1.z - n2;\n   }\n\n   void InitConfigDxDy(inout Config c)\n   {\n      c.uvT.dx0 = ddx(c.uvT.uv0);\n      c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1);\n      c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2);\n      c.uvT.dy2 = ddy(c.uvT.uv2);\n   }\n\n   Config CreateConfig(ShaderData d, float4 scale, float space, int uvsource, half triplanarContrast)\n   {\n      Config c;\n      ZERO_INITIALIZE(Config, c);\n\n      float3 pos = d.worldSpacePosition;\n      float3 normal = d.worldSpaceNormal;\n      if (space > 0)\n      {\n         pos = d.localSpacePosition;\n         normal = d.localSpaceNormal;\n      }\n\n      c.uv = d.texcoord0.xy;\n      \n      if (uvsource == 1)\n        c.uv = d.texcoord1.xy;\n      else if (uvsource == 2)\n        c.uv = pos.yz * float2(1, -1);\n      else if (uvsource == 3)\n        c.uv = pos.xz * float2(1, -1);\n      else if (uvsource == 4)\n        c.uv = pos.xy * float2(1, -1);\n\n      c.origUV = c.uv;\n      c.origScale = scale.xy;\n\n      c.uv = c.uv * scale.xy + scale.zw;\n      c.dx = ddx(c.uv);\n      c.dy = ddy(c.uv);\n\n      c.normal = normal;\n      c.uvT.uv0 = pos.zy * scale.xy + scale.zw;\n      c.uvT.uv1 = pos.xz * scale.xy + scale.zw;\n      c.uvT.uv2 = pos.xy * scale.xy + scale.zw;\n        \n      c.uvT.uv1 += 0.33;\n      c.uvT.uv2 += 0.67;\n\n      c.uvT.dx0 = ddx(c.uvT.uv0); c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1); c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2); c.uvT.dy2 = ddy(c.uvT.uv2);\n\n      half3 triblend = saturate(pow(abs(c.normal), triplanarContrast));\n      triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n      c.uvT.weights = triblend;\n      c.uvT.origWeights = triblend;\n      c.axisSign = d.worldSpaceNormal < 0 ? -1 : 1;\n      c.absVertNormal = abs(d.worldSpaceNormal);\n     \n\n      return c;\n   }\n\n\n   half4 TriSample(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0) * c.weights.x;\n      }\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1) * c.weights.y;\n      }  \n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2) * c.weights.z;\n      }\n\n      return res;\n   }\n\n   half4 TriSampleBary(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      c.weights = BaryWeightBlend(c.origWeights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   half4 TriSampleGrad(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvX, contrast, d) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvY, contrast, d) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n           res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvZ, contrast, d) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   \n   half4 SampleTexBaryStochastic(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   half4 SampleTexBaryTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleGrad(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   \n   half4 SampleTexBary(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        COUNTSAMPLE\n        return SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv, c.dx, c.dy);\n   }\n\n   half4 SampleTexStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ) * c.uvT.weights.z;\n\n        return res;     \n   }\n\n   \n   half4 SampleTexStochastic(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n\n   half4 SampleTexTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n   \n   half4 SampleTex(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       COUNTSAMPLE\n       return SAMPLE_TEXTURE2D(tex, ss, c.uv);\n   }\n   \n\n \n   half3 SampleNormalStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n         dataX = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n         dataY = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n         dataZ = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ));\n\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n\n          return WorldToTangentSpace(d, worldNormal);\n       #endif\n   }\n\n\n   half3 SampleNormalTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n      {\n          COUNTSAMPLE\n          dataX = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv0, c.uvT.dx0, c.uvT.dy0));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n      {\n          COUNTSAMPLE\n          dataY = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv1, c.uvT.dx1, c.uvT.dy1));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n      {\n         COUNTSAMPLE\n         dataZ = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv2, c.uvT.dx2, c.uvT.dy2));\n      }\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n          return WorldToTangentSpace(d, worldNormal);\n      #endif\n   }\n\n   half3 SampleNormalStochastic(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n     half4 normal = TriSample(tex, ss, c.uvT);\n     #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half3 SampleNormal(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 normal = SAMPLE_TEXTURE2D(tex, ss, c.uv);\n      #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half HeightBlend(half h1, half h2, half slope, half contrast)\n   {\n      h2 = 1 - h2;\n      half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); \n      half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));\n      return blend;\n   }\n\n\n    #if _POM\n    float2 POM(TEXTURE2D_PARAM(tex, ss), Config c, float contrast, ShaderData d)\n    {\n       float2 curv = float2(0, 0);\n       float refPlane = 0;\n\n       float result = 0;\n       int stepIndex = 0;\n       int maxSamples = _POMMaxSamples;\n       int minSamples = 4;\n       float camDist = distance(_WorldSpaceCameraPos, d.worldSpacePosition);\n       float distanceFade = 1 - saturate((camDist - _POMMin) / max(1, _POMFade));\n       int numSteps = ( int )lerp( maxSamples, minSamples, dot( d.worldSpaceNormal, d.worldSpaceViewDir )) * distanceFade;\n       if (numSteps < 1)\n           numSteps = 1;\n       float layerHeight = 1.0 / numSteps;\n       float2 plane = _ParallaxHeight * ( d.tangentSpaceViewDir.xy / d.tangentSpaceViewDir.z ) * distanceFade;\n       OffsetUV(c, refPlane * plane);\n       float2 deltaTex = -plane * layerHeight;\n       float2 prevTexOffset = 0;\n       float prevRayZ = 1.0f;\n       float prevHeight = 0.0f;\n       float2 currTexOffset = deltaTex;\n       float currRayZ = 1.0f - layerHeight;\n       float currHeight = 0.0f;\n       float intersection = 0;\n       float2 finalTexOffset = 0;\n\n       while ( stepIndex < numSteps + 1 )\n       {\n          result = dot( curv, currTexOffset * currTexOffset );\n          Config cfg = c;\n          OffsetUV(cfg, currTexOffset);\n          currHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( currHeight > currRayZ )\n          {\n             stepIndex = numSteps + 1;\n          }\n          else\n          {\n             stepIndex++;\n             prevTexOffset = currTexOffset;\n             prevRayZ = currRayZ;\n             prevHeight = currHeight;\n             currTexOffset += deltaTex;\n             currRayZ -= layerHeight * ( 1 - result );\n          }\n       }\n       int sectionSteps = 10;\n       int sectionIndex = 0;\n       float newZ = 0;\n       float newHeight = 0;\n       while ( sectionIndex < sectionSteps )\n       {\n          intersection = ( prevHeight - prevRayZ ) / ( prevHeight - currHeight + currRayZ - prevRayZ );\n          finalTexOffset = prevTexOffset + intersection * deltaTex;\n          newZ = prevRayZ - intersection * layerHeight;\n          Config cfg = c;\n          OffsetUV(cfg, finalTexOffset);\n          newHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( newHeight > newZ )\n          {\n             currTexOffset = finalTexOffset;\n             currHeight = newHeight;\n             currRayZ = newZ;\n             deltaTex = intersection * deltaTex;\n             layerHeight = intersection * layerHeight;\n          }\n          else\n          {\n             prevTexOffset = finalTexOffset;\n             prevHeight = newHeight;\n             prevRayZ = newZ;\n             deltaTex = ( 1 - intersection ) * deltaTex;\n             layerHeight = ( 1 - intersection ) * layerHeight;\n          }\n          sectionIndex++;\n       }\n       #if _PASSHADOWS\n       if ( unity_LightShadowBias.z == 0.0 )\n       {\n       #endif\n          if ( result > 1 )\n             clip( -1 );\n       #if _PASSHADOWS\n       }\n       #endif\n       return finalTexOffset;\n    }\n    #endif\n\n   \n\n   // tess versions\n   #if _TESSELLATION_ON\n   half4 TriSampleLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias) * c.weights.x;\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias) * c.weights.y;\n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias) * c.weights.z;\n\n      return res;\n   }\n\n   half4 TriSampleBaryLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias, float contrast)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias);\n      half4 r2 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias);\n      half4 r3 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias);\n      c.weights = BaryWeightBlend(c.weights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryLODStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvX, bias, contrast) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvY, bias, contrast) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvZ, bias, contrast) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   half4 SampleTexBaryLODStochastic(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n       return TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias, contrast);\n   }\n\n   half4 SampleTexBaryLODTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return TriSampleLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias);\n   }\n\n   half4 SampleTexBaryLOD(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv, bias);\n   }\n\n\n    float FBM2DLOD(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           return SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv, _TessellationMipBias).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n        \n        \n    }\n\n    float FBM3DLOD(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           half A = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.zy, _TessellationMipBias).g;\n           half B = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33, _TessellationMipBias).g;\n           half C = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67, _TessellationMipBias).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoiseLOD(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3DLOD(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3DLOD(d.localSpacePosition * frequency + offset, d.localSpaceNormal);\n        #else\n           return FBM2DLOD(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n   #endif //_TESSELLATION_ON\n\n\n    half3 FuzzyShade(ShaderData d, half height, half3 color, half3 normal, half coreMult, half edgeMult, half power)\n    {\n        float3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half dt = saturate(dot(d.worldSpaceViewDir, worldNormal));\n        half dark = 1.0 - (coreMult * dt);\n        half edge = pow(1-dt, abs(power)) * edgeMult;\n        return color * (dark + edge);\n    }\n\n\thalf MicroShadow(ShaderData d, half3 normal, half height, half ao, half strength)\n\t{\n        float3 sun;\n\t\tfloat3 sunColor;\n\t\tGetSun(sun, sunColor);\n\t\tfloat3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half shadow = saturate(abs(dot(worldNormal, sun)) + (ao * ao * 2.0) - 1.0);\n        return 1 - ((1-shadow) * strength);\n\t}\n\n\n#endif\n\n\n\n   #if defined(_SPECULAR)\n      #define _USESPECULAR 1\n      #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n   #endif\n\n   \n   TEXTURE2D(_AlbedoMap);\n   SAMPLER(sampler_AlbedoMap);\n   TEXTURE2D(_NormalMap);\n   SAMPLER(sampler_NormalMap);\n   TEXTURE2D(_MaskMap);\n   TEXTURE2D(_DetailMap);\n   TEXTURE2D(_EmissionMap);\n\n   #if _SPECULAR\n       TEXTURE2D(_SpecularMap);\n   #endif\n\n   \n   \n   void Ext_SurfaceFunction0 (inout Surface o, inout ShaderData d)\n   {\n      // define samplers based on settings\n      #undef SAMPLEBARY\n      #undef SAMPLE\n      #undef SAMPLENORMAL\n      #if _STOCHASTIC && _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n        #define SAMPLE     SampleTexStochasticTriplanar\n        #define SAMPLENORMAL SampleNormalStochasticTriplanar\n      #elif _STOCHASTIC\n        #define SAMPLEBARY SampleTexBaryStochastic\n        #define SAMPLE     SampleTexStochastic\n        #define SAMPLENORMAL SampleNormalStochastic\n      #elif _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryTriplanar\n        #define SAMPLE     SampleTexTriplanar\n        #define SAMPLENORMAL SampleNormalTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBary\n        #define SAMPLE     SampleTex\n        #define SAMPLENORMAL SampleNormal\n      #endif\n\n      Config c = CreateConfig(d, _AlbedoMap_ST, _TriplanarSpace, _UVSource, _TriplanarContrast);\n      InitConfigDxDy(c);\n      #if _STOCHASTIC && !_TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uv, c.uvT);\n         InitStochasticDxDy(c.uvT, c);\n      #elif _STOCHASTIC && _TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv0, c.uvX);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv1, c.uvY);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv2, c.uvZ);\n         InitStochasticDxDy(c.uvX, c);\n         InitStochasticDxDy(c.uvY, c);\n         InitStochasticDxDy(c.uvZ, c);\n      #endif\n\n      #if _POM\n          // would need to handle height remapping if we ever want to ship this\n          float2 pomOffset = POM(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n          OffsetUV(c, pomOffset);\n      #endif\n\n      half4 albedo = SAMPLEBARY(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n      \n      #if _PARALLAX\n         float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n         OffsetUV(c, offset);\n         albedo = SAMPLE(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c);\n         \n      #endif\n      albedo.a = lerp(_HeightRemap.x, _HeightRemap.y, albedo.a);\n      albedo.rgb *= _Tint.rgb;\n\n      albedo.rgb = AdjustContrast(albedo.rgb, _AlbedoContrast);\n      albedo.rgb += _AlbedoBrightness;\n\n\n      if (_AlphaThreshold > 0)\n      {\n         clip(albedo.a - _AlphaThreshold);\n      }\n\n      #if defined(_FLATSHADE)\n\t\t     float3 dx = ddx(d.worldSpacePosition);\n\t\t     float3 dy = ddy(d.worldSpacePosition);\n\t\t     float3 worldNormal = normalize(cross(dy, dx));\n\t\t     worldNormal = lerp(d.worldSpaceNormal, worldNormal, _FlatShadingBlend);\n\t\t     d.worldSpaceNormal = worldNormal;\n\t\t     d.TBNMatrix[2] = worldNormal;\n      #endif\n\n\n\n      o.Albedo = albedo.rgb;\n      o.Alpha = albedo.a;\n\n      float smoothness = _Smoothness;\n      float ao = 1;\n\n      #if defined(_NORMALMAP) && !defined(_AUTONORMAL)\n         o.Normal = SAMPLENORMAL(TEXTURE2D_ARGS(_NormalMap, sampler_NormalMap), c, d, _NormalStrength, smoothness, ao);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, ao);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n      #endif\n\n      half detailMask = 1;\n      o.Smoothness = smoothness;\n      o.Occlusion = ao;\n      o.Metallic = _Metallic;\n      #if defined(_MASKMAP) && !_PACKEDFAST\n         // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = SampleTex(TEXTURE2D_ARGS(_MaskMap, sampler_AlbedoMap), c);\n         o.Metallic = lerp(_MetallicRemap.x, _MetallicRemap.y, mask.r);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, mask.g);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, mask.a);\n         detailMask = mask.b;\n      #endif // separate maps\n\n      #if _SPECULAR\n         o.Specular = SAMPLE(TEXTURE2D_ARGS(_SpecularMap, sampler_AlbedoMap), c).rgb;\n      #endif\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = SAMPLE(TEXTURE2D_ARGS(_EmissionMap, sampler_AlbedoMap), c).rgb * _EmissionColor;\n      #endif\n\n      if (_FuzzyShadingOn > 0)\n      {\n        o.Albedo *= FuzzyShade(d, albedo.a, _FuzzyShadingColor, o.Normal, _FuzzyShadingParams.x, _FuzzyShadingParams.y, _FuzzyShadingParams.z);\n      }\n\n\n      // HDRP style detail texturing\n\n      #if defined(_DETAIL)\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _DETAILSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n         Config dc = CreateConfig(d, _DetailMap_ST, _DetailTriplanarSpace, _DetailUVSource, _DetailTriplanarContrast);\n         InitConfigDxDy(dc);\n         #if _DETAILSTOCHASTIC && !_DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uv, dc.uvT);\n             InitStochasticDxDy(dc.uvT, dc);\n         #elif _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv0, dc.uvX);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv1, dc.uvY);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv2, dc.uvZ);\n             InitStochasticDxDy(dc.uvX, dc);\n             InitStochasticDxDy(dc.uvY, dc);\n             InitStochasticDxDy(dc.uvZ, dc);\n         #endif\n\n         half4 detailSample = SAMPLEBARY(TEXTURE2D_ARGS(_DetailMap, sampler_AlbedoMap), dc, _DetailStochasticContrast, d);\n         smoothness = detailSample.z;\n         #if !_AUTONORMAL\n            half3 dnormal = float3(detailSample.ag * 2 - 1, 1) * detailMask * _DetailNormalStrength;\n            dnormal.z = sqrt(1 - dnormal.x * dnormal.x - dnormal.y * dnormal.y);\n            #if _SURFACEGRADIENT\n               dnormal = ConvertNormalToGradient(d, dnormal);\n            #endif\n            o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n         #endif\n     \n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * smoothness, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n      if (_MicroShadowStrength > 0)\n      {\n        o.Occlusion *= MicroShadow(d, o.Normal, o.Alpha, o.Occlusion, _MicroShadowStrength);\n      }\n  \n      // in case something needs height in the stack..\n      o.Height = o.Alpha;\n\n\n      \n   }\n\n\n\n\t#if _TINTMASK\n\t\tTEXTURE2D(_TintMask);\n\t\tSAMPLER(sampler_TintMask);\n\t#endif\n\n\tvoid Ext_SurfaceFunction1 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _TINTMASK\n\t\t   half4 w = SAMPLE_TEXTURE2D(_TintMask, sampler_TintMask, d.texcoord0.xy * _TintMask_ST.xy + _TintMask_ST.zw);\n\t\t   // allow black to be no tint..\n\t\t   half3 tint = o.Albedo * (_RColor.rgb * 2 * w.r + _GColor.rgb * 2 * w.g + _BColor.rgb * 2 * w.b + _AColor.rgb * 2 * w.a);\n\t\t   o.Albedo = lerp(o.Albedo, tint, saturate(w.r + w.g + w.b + w.a));\n\t\t#endif\n\t}\n\n\n\n\n\t#if _LAYERTEXTUREMASK\n       TEXTURE2D(_LayerTextureMask);\n       SAMPLER(sampler_LayerTextureMask); \n    #endif\n\n   void Ext_ModifyTessellatedVertex2 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON\n          float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n\n          #if _LAYERTEXTUREMASK\n               float2 layerUV = v.texcoord0.xy;\n               if (_LayerTextureMaskUVMode == 1)\n                  layerUV = v.texcoord1.xy;\n               else if (_LayerTextureMaskUVMode == 2)\n                  layerUV = worldSpacePosition.yz;\n               else if (_LayerTextureMaskUVMode == 3)\n                  layerUV = worldSpacePosition.xz;\n               else if (_LayerTextureMaskUVMode == 4)\n                  layerUV = worldSpacePosition.xy;\n\n              e.blackboard.weightTextureMask = SAMPLE_TEXTURE2D_LOD(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw, _TessellationMipBias);\n          #endif\n      #endif\n    }\n\n\n\tvoid Ext_SurfaceFunction2 (inout Surface o, inout ShaderData d)\n\t{\n\t\t#if _LAYERTEXTUREMASK\n           float2 layerUV = d.texcoord0.xy;\n           if (_LayerTextureMaskUVMode == 1)\n              layerUV = d.texcoord1.xy;\n           else if (_LayerTextureMaskUVMode == 2)\n              layerUV = d.worldSpacePosition.yz;\n           else if (_LayerTextureMaskUVMode == 3)\n              layerUV = d.worldSpacePosition.xz;\n           else if (_LayerTextureMaskUVMode == 4)\n              layerUV = d.worldSpacePosition.xy;\n\n          d.blackboard.weightTextureMask = SAMPLE_TEXTURE2D(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw);\n      #endif\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap);\n   SAMPLER(sampler_LayerAlbedoMap);\n   TEXTURE2D(_LayerNormalMap);\n   TEXTURE2D(_LayerMaskMap);\n   TEXTURE2D(_LayerEmissionMap);\n\n   \n\n   void Ext_ModifyTessellatedVertex3 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER) && defined(_LAYERALBEDO) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n         half detailMask = 1;\n         #if _LAYERNOISE\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency,  _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin;\n            dt = saturate(dt * _LayerFalloff);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight) * _LayerFalloff);\n            if (_LayerInvertHeight > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength;\n         detailMask *= _LayerTessStrength;\n\n         #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast).a;\n         albedo = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo);\n\n         if (_LayerBlendMode == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction3 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n            // noise up the mask\n            #if _LAYERNOISE\n               mask = DoNoise(d, _LayerNoiseFrequency, _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend);\n\t    \n                dt -= _LayerAngleMin;\n                dt = saturate(dt * _LayerFalloff);\n\n                float hf = saturate((o.Height - _LayerHeight) * _LayerFalloff);\n                if (_LayerInvertHeight > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 0\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 0\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength;\n\n            #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint, 0.5);\n            #if defined(_LAYERALBEDO)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c, _LayerStochasticContrast, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c);\n                #endif\n                albedo.rgb *= _LayerTint;\n                albedo.a = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL || _LAYERMASK\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap, sampler_LayerAlbedoMap, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast);\n            albedo.rgb += _LayerAlbedoBrightness;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap, sampler_LayerAlbedoMap), c, d, _LayerNormalStrength * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO)\n                if (_LayerFuzzyShadingOn > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor.rgb, dnormal,\n                                            _LayerFuzzyShadingParams.x, _LayerFuzzyShadingParams.y, _LayerFuzzyShadingParams.z);\n                }\n\n                if (_LayerBlendMode == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast);\n                else if (_LayerBlendMode == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE\n                      float maskDif = (_LayerBlendContrast * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength);\n                   #if _LAYERNOISE\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap, sampler_LayerAlbedoMap), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength);\n                }\n\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap, sampler_LayerAlbedoMap), c).rgb * _LayerEmissionColor;\n                #if _LAYERALBEDO\n                    if (_LayerBlendMode > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_1);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_1);\n   TEXTURE2D(_LayerNormalMap_Ext_1);\n   TEXTURE2D(_LayerMaskMap_Ext_1);\n   TEXTURE2D(_LayerEmissionMap_Ext_1);\n\n   \n\n   void Ext_ModifyTessellatedVertex4 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_1) && defined(_LAYERALBEDO_DEF_1) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_1\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_1,  _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_1\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_1;\n            dt = saturate(dt * _LayerFalloff_Ext_1);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n            if (_LayerInvertHeight_Ext_1 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_1;\n         detailMask *= _LayerTessStrength_Ext_1;\n\n         #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_1).a;\n         albedo = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo);\n\n         if (_LayerBlendMode_Ext_1 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_1);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_1 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction4 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_1)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_1\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_1, _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_1\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_1);\n\t    \n                dt -= _LayerAngleMin_Ext_1;\n                dt = saturate(dt * _LayerFalloff_Ext_1);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n                if (_LayerInvertHeight_Ext_1 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 01\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 01\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_1;\n\n            #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_1, 0.5);\n            #if defined(_LAYERALBEDO_DEF_1)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, _LayerStochasticContrast_Ext_1, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_1;\n                albedo.a = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_1 || _LAYERMASK_DEF_1\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_1);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_1;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, d, _LayerNormalStrength_Ext_1 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_1)\n                if (_LayerFuzzyShadingOn_Ext_1 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_1.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_1.x, _LayerFuzzyShadingParams_Ext_1.y, _LayerFuzzyShadingParams_Ext_1.z);\n                }\n\n                if (_LayerBlendMode_Ext_1 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_1);\n                else if (_LayerBlendMode_Ext_1 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_1 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_1);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_1\n                      float maskDif = (_LayerBlendContrast_Ext_1 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_1 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                   #if _LAYERNOISE_DEF_1\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_1));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_1 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_1);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_1) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_1 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_1);\n                }\n\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_1);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_1, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_1, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_1\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c).rgb * _LayerEmissionColor_Ext_1;\n                #if _LAYERALBEDO_DEF_1\n                    if (_LayerBlendMode_Ext_1 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_2);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_2);\n   TEXTURE2D(_LayerNormalMap_Ext_2);\n   TEXTURE2D(_LayerMaskMap_Ext_2);\n   TEXTURE2D(_LayerEmissionMap_Ext_2);\n\n   \n\n   void Ext_ModifyTessellatedVertex5 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_2) && defined(_LAYERALBEDO_DEF_2) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_2\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_2,  _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_2\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_2;\n            dt = saturate(dt * _LayerFalloff_Ext_2);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n            if (_LayerInvertHeight_Ext_2 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_2;\n         detailMask *= _LayerTessStrength_Ext_2;\n\n         #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_2).a;\n         albedo = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo);\n\n         if (_LayerBlendMode_Ext_2 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_2);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_2 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction5 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_2)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_2\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_2, _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_2\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_2);\n\t    \n                dt -= _LayerAngleMin_Ext_2;\n                dt = saturate(dt * _LayerFalloff_Ext_2);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n                if (_LayerInvertHeight_Ext_2 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 02\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 02\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_2;\n\n            #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_2, 0.5);\n            #if defined(_LAYERALBEDO_DEF_2)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, _LayerStochasticContrast_Ext_2, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_2;\n                albedo.a = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_2 || _LAYERMASK_DEF_2\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_2);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_2;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, d, _LayerNormalStrength_Ext_2 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_2)\n                if (_LayerFuzzyShadingOn_Ext_2 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_2.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_2.x, _LayerFuzzyShadingParams_Ext_2.y, _LayerFuzzyShadingParams_Ext_2.z);\n                }\n\n                if (_LayerBlendMode_Ext_2 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_2);\n                else if (_LayerBlendMode_Ext_2 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_2 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_2);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_2\n                      float maskDif = (_LayerBlendContrast_Ext_2 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_2 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                   #if _LAYERNOISE_DEF_2\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_2));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_2 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_2);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_2) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_2 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_2);\n                }\n\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_2);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_2, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_2, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_2\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c).rgb * _LayerEmissionColor_Ext_2;\n                #if _LAYERALBEDO_DEF_2\n                    if (_LayerBlendMode_Ext_2 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   #if _TRAX_ON\n   TEXTURE2D(_TraxAlbedo);\n   SAMPLER(sampler_TraxAlbedo);\n   TEXTURE2D(_TraxPackedNormal);\n   TEXTURE2D(_TraxMask);\n\n   sampler2D_float _GMSTraxBuffer;\n\n   float4 _GMSTraxBuffer_TexelSize;\n   float3 _GMSTraxBufferPosition;\n   float _GMSTraxBufferWorldSize;\n   float _GMSTraxFudgeFactor;\n\n   float SampleTraxBufferLOD(float3 worldPos)\n   {    \n      // generate UVs for the buffer, which is moving\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 8);\n      uv *= 0.5;\n      uv += 0.5;\n            \n      float s =  tex2Dlod(_GMSTraxBuffer, float4(uv, 0, 0)).r;\n\n      return 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n   }\n         \n        \n   float SampleTraxBuffer(float3 worldPos, out float3 norm)\n   {\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 3);\n      uv *= 0.5;\n      uv += 0.5;\n            \n\n      float2 offset = _GMSTraxBuffer_TexelSize.xy;\n\n      float s = tex2D(_GMSTraxBuffer, uv).r;\n               \n      float s1 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, -1)).r;\n      float s2 = tex2D(_GMSTraxBuffer, uv + offset * float2(-1, 0)).r;\n      float s3 = tex2D(_GMSTraxBuffer, uv + offset * float2(1, 0)).r;\n      float s4 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, 1)).r;\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      float r = 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n \n      // generate normals\n      norm.x = (s1 - s4) * 0.25; \n      norm.y = (s2 - s3) * 0.25;\n      norm.z = 2;\n      norm = normalize(norm);\n     \n      norm.xy *= 1 - r;\n            \n      return r;\n   }\n   #endif\n\n   void Ext_ModifyTessellatedVertex6 (inout VertexData v, inout ExtraV2F d)\n   {\n       #if _TESSELLATION_ON && _TRAX_ON && _HAS_LIT_TESSELLATION\n          \n           float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n           float3 worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n           float traxBuffer = SampleTraxBufferLOD(worldSpacePosition);\n           d.blackboard.traxBuffer = traxBuffer;\n           float2 uv = worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n           half albedo = SAMPLE_TEXTURE2D_LOD(_TraxAlbedo, sampler_TraxAlbedo, uv, _TraxMipBias).a;\n\n           float traxOffset = albedo * _TraxDisplacementStrength;\n           traxOffset *= 1 - v.texcoord0.z;\n           traxOffset *= _TessellationDisplacement;\n           float dig = _TraxDisplacementDepth * (1 - v.texcoord0.z);\n           float3 traxVertex = d.blackboard.originalVertexPosition + (v.normal * (traxOffset - dig));\n           v.vertex.xyz = lerp(traxVertex, v.vertex.xyz, traxBuffer);\n\n           d.blackboard.vertexHeightOffset = lerp(traxOffset-dig, d.blackboard.vertexHeightOffset, traxBuffer);\n\n       #endif\n\n   }\n\n   void Ext_SurfaceFunction6 (inout Surface o, inout ShaderData d)\n   {\n      #if _TRAX_ON\n        float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n        float2 fsdx = ddx(uv);\n        float2 fsdy = ddy(uv);\n\n        float3 traxNormal;\n        float traxBuffer = SampleTraxBuffer(d.worldSpacePosition, traxNormal);\n        \n        #if _TESSELLATION_ON\n            traxBuffer -= _TraxDisplacementDepth;\n        #endif\n\n        d.blackboard.traxBuffer = traxBuffer;\n\n        UNITY_BRANCH\n        if (traxBuffer > 0)\n        {\n            half4 albedo = SAMPLE_TEXTURE2D_GRAD(_TraxAlbedo, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            albedo.rgb *= _TraxTint.rgb;\n            half4 normalSample = SAMPLE_TEXTURE2D_GRAD(_TraxPackedNormal, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n\n            half smoothness = normalSample.r;\n            half ao = normalSample.b;\n            half3 normal;\n            normal.xy = (normalSample.ag * 2 - 1) * _TraxNormalStrength;\n            normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n\n            \n            half h = HeightBlend(albedo.a, o.Alpha, traxBuffer, _TraxHeightContrast);\n\n            h = lerp(traxBuffer, h, _TraxInterpContrast);\n\n            o.Albedo = lerp(albedo, o.Albedo, h);\n\n            #if _SURFACEGRADIENT\n                o.Normal = lerp(normal, o.Normal, h);\n            #else\n                o.Normal = lerp(normal + traxNormal, o.Normal, h);\n            #endif\n        \n            o.Smoothness = lerp(smoothness, o.Smoothness, h);\n            o.Occlusion = lerp(ao, o.Occlusion, h);\n        }\n      #endif\n   }\n\n\n\n\n    #if _RAINDROPS\n       TEXTURE2D(_RainDropTexture);\n       SAMPLER(sampler_RainDropTexture);\n       half _Global_RainIntensity;\n    #endif\n\n    #if _WETNESS\n       half2 _Global_WetnessParams; // global, not in cbuffer\n    #endif\n   \n    #if _RAINDROPS\n    half2 ComputeRipple(float2 uv, half time, half weight)\n    {\n        half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_RainDropTexture, uv);\n        COUNTSAMPLE\n        ripple.yz = ripple.yz * 2 - 1;\n\n        half dropFrac = frac(ripple.w + time);\n        half timeFrac = dropFrac - 1.0 + ripple.x;\n        half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);\n        half finalFactor = dropFactor * ripple.x * \n                                sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);\n\n        return half2(ripple.yz * finalFactor);\n    }\n    #endif\n\n    half2 DoRain(half2 waterNorm, float2 uv, out half2 ripple)\n    {\n        #if _RAINDROPS\n            float rainIntensity = _RainIntensityScale.x;\n            if (_RainMode > 1)\n            {\n                rainIntensity = _Global_RainIntensity;\n            }\n\n            half dropStrength = rainIntensity;\n            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); \n            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);\n            half4 times = _Time.yyyy;\n            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);\n\n            float2 ruv1 = uv * _RainIntensityScale.yy;\n            float2 ruv2 = ruv1;\n\n            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);\n            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);\n            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);\n            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);\n            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);\n            weights = saturate(weights * 4);\n\n            half2 rippleNormal = half2( weights.x * ripple1.xy +\n                        weights.y * ripple2.xy + \n                        weights.z * ripple3.xy + \n                        weights.w * ripple4.xy);\n\n            ripple = rippleNormal * dropStrength * rainIntensity;\n            waterNorm = lerp(waterNorm, normalize(half3(rippleNormal.xy + rippleNormal.xy, 1)).xy, rainIntensity * dropStrength); \n            return waterNorm;                        \n        #else\n            return waterNorm;\n        #endif\n    }\n\n   half2 _Global_PuddleParams;   // this is a global, so keep it out of the cbuffer\n   void GetPuddleParams(ShaderData d, inout float puddleMask, inout float pudHeight)\n   {\n      #if _PUDDLES || _GLOBALPUDDLES\n          pudHeight = _PuddleAmount;\n          if (_PuddleMode > 0)\n             pudHeight = _Global_PuddleParams.x;    \n      \n\n          half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t      dt -= _PuddleAngleMin;\n          dt = saturate(dt * _PuddleFalloff);\n          puddleMask *= dt;\n      #endif\n   }\n   \n   void Ext_ModifyTessellatedVertex7 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _PUDDLES && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n         half mask = 1;\n         half pudHeight = 1;\n\n         // save some ops by doing this in 2d\n         #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2DLOD(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2DLOD(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #else\n                mask = (FBM2DLOD(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n         #endif\n\n         GetPuddleParams(d, mask, pudHeight);\n         float height = pudHeight * mask;\n         if (e.blackboard.vertexHeightOffset < height)\n         {\n            e.blackboard.vertexHeightOffset = height;\n            height -= _TessellationOffset; \n            // dampen cracks\n            height *= 1 - v.texcoord0.z;\n            height *= _TessellationDisplacement;\n            v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n            \n        }\n      #endif\n   }\n\n\n#if _WETNESS\n\n   float GetWetnessLevel(Surface o, ShaderData d, float wetnessMask)\n   {\n      float wetLevel = clamp(_WetnessAmount, _WetnessMin, _WetnessMax);\n      \n      if (_WetnessMode > 0)\n         wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);\n\n      wetLevel = saturate(wetLevel + (1 - saturate(d.worldSpacePosition.y - _WetnessShoreline)));\n      float3x3 tbn = float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal);\n      float dt = dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0));\n      dt -= _WetnessAngleMin;\n      dt = saturate(dt * _WetnessFalloff * wetLevel);\n      dt *= wetnessMask;\n      return dt;\n   }\n#endif\n   \n\n   void Ext_SurfaceFunction7 (inout Surface o, ShaderData d)\n   {\n      half wetnessLevel = 0;\n      #if _WETNESS\n          wetnessLevel = GetWetnessLevel(o, d, 1); // mask one day?\n      #endif\n\n      half depthMask = 0;\n      half depth = 0;\n\n      #if _PUDDLES\n          half mask = 1;\n          half pudHeight = 1;\n          #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2D(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2D(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);      \n            #else\n                mask = (FBM2D(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n          #endif\n\n          GetPuddleParams(d, mask, pudHeight);\n          pudHeight *= mask;\n          depth = pudHeight - o.Height;\n          depthMask = saturate(depth * _PuddleFalloff);\n          depthMask *= _PuddleColor.a;\n          depth = o.Height - pudHeight;\n\n          // extend wetness slighting higher than the puddle\n          half wetmask = saturate((pudHeight + 0.05 - o.Height) * _PuddleFalloff);\n          wetnessLevel = max(wetmask, wetnessLevel);\n       #endif\n\n       \n       #if _WETNESS || _PUDDLES\n          half3 waterNorm = half3(0,0,1);\n          half3 wetAlbedo = o.Albedo;\n          half wetSmoothness = o.Smoothness;\n          #if _PUDDLES\n             wetAlbedo *= _PuddleColor.rgb;\n          #endif\n          WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetnessLevel, _Porosity);\n\n          half ri = 0;\n          half2 ripple = 0;\n          #if (_RAINDROPS || _GLOBALRAIN) && (_PUDDLES || _GLOBALPUDDLES)\n             ri = _RainIntensityScale.z;\n             waterNorm.xy = DoRain(waterNorm.xy, d.texcoord0.xy, ripple) * depthMask;\n          #endif\n\n          o.Normal = lerp(o.Normal, waterNorm, depthMask);\n          o.Normal = lerp(o.Normal, LitBlendDetailNormal(o.Normal, half3(ripple.xy, 1)), saturate(ri - depthMask) * wetnessLevel);\n          o.Occlusion = lerp(o.Occlusion, 1, depthMask);\n          o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetnessLevel);\n          o.Albedo = lerp(o.Albedo, wetAlbedo, wetnessLevel);\n          o.Emission *= 1 + depth;\n          o.Metallic *= 1 + depth;\n          o.Specular *= 1 + depth;\n\n       #endif\n\n   }\n\n\n\n\n    #if _SNOW\n       TEXTURE2D(_SnowAlbedo);\n       SAMPLER(sampler_SnowAlbedo);\n       TEXTURE2D(_SnowNormal);\n       TEXTURE2D(_SnowMaskMap);\n       #if _TRAX_ON\n          TEXTURE2D(_SnowTraxAlbedo);\n          TEXTURE2D(_SnowTraxNormal);\n          TEXTURE2D(_SnowTraxMaskMap);\n       #endif\n    #endif\n\n   float _Global_SnowLevel;\n\n\n   void Ext_ModifyVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n    #if (_SNOW)\n        float amount = _SnowAmount;\n        if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n        float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n        float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n        snowAmount -= _SnowAngle;\n        snowAmount *= _SnowContrast * 0.5;\n        snowAmount = saturate(snowAmount) * amount;\n        float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n        if (_SnowWorldFade.z > 0)\n        {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n        }\n        #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n        #endif\n        snowAmount = saturate(snowAmount);\n\n        #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n        #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n        #endif\n\n        float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n        v.vertex.xyz = v.vertex.xyz + displacementVec * snowAmount * snowAmount * _SnowVertexHeight;\n    #endif\n   }\n\n   void Ext_ModifyTessellatedVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _SNOW && _HAS_LIT_TESSELLATION\n         float amount = _SnowAmount;\n         if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n         float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n         float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n         snowAmount -= _SnowAngle;\n         snowAmount *= _SnowContrast * 0.5;\n         float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n         if (_SnowWorldFade.z > 0)\n         {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n         }\n\n         snowAmount = saturate(snowAmount) * amount;\n\n         #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n         #endif\n         snowAmount = saturate(snowAmount);\n\n         #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n         #endif\n\n         float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n         half heightMap = SAMPLE_TEXTURE2D_LOD(_SnowAlbedo, sampler_SnowAlbedo, worldPos.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw, 2);\n\n         float height = max(_SnowVertexHeight * 3 * snowAmount + snowAmount * heightMap, e.blackboard.vertexHeightOffset);\n         #if _TRAX_ON\n            height *= e.blackboard.traxBuffer;\n         #endif\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n\n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n         \n      #endif\n\n   }\n\n   void SampleSnowSurface(TEXTURE2D_PARAM(alb, ss), TEXTURE2D_PARAM(norm, ss2), TEXTURE2D_PARAM(mask, ss3),\n        ShaderData d, float2 uv, float2 dx, float2 dy, out half4 albedo, out half3 normal, out half2 smoothAO)\n   {\n      #if _SNOWSTOCHASTIC\n         float w1, w2, w3;\n         int2 vertex1, vertex2, vertex3;\n         TriangleGrid(uv, _SnowStochasticScale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n         // Assign random offset to each triangle vertex\n         float2 uv0 = uv;\n         float2 uv1 = uv;\n         float2 uv2 = uv;\n   \n         uv0.xy += SimpleHash2(vertex1);\n         uv1.xy += SimpleHash2(vertex2);\n         uv2.xy += SimpleHash2(vertex3);\n         half3 weights = half3(w1, w2, w3);\n\n         half4 albedo0 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv0, dx, dy);\n         half4 albedo1 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv1, dx, dy);\n         half4 albedo2 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv2, dx, dy);\n         COUNTSAMPLE\n         COUNTSAMPLE\n         COUNTSAMPLE\n         weights = BaryWeightBlend(weights, albedo0.a, albedo1.a, albedo2.a, _SnowStochasticContrast);\n         albedo = albedo0 * weights.x + albedo1 * weights.y + albedo2 * weights.z;\n\n         normal = half3(0,0,1);\n         smoothAO = half2(0, 1);\n\n         #if !_AUTONORMAL\n            half4 n0 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv0, dx, dy);\n            half4 n1 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv1, dx, dy);\n            half4 n2 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n            half4 snowNormSamp = n0 * weights.x + n1 * weights.y + n2 * weights.z;\n\n            normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n                \n            #if _PACKEDFAST\n               smoothAO.x = snowNormSamp.r;\n               smoothAO.y = snowNormSamp.b;\n            #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask0 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv0, dx, dy);\n            half4 snowMask1 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv1, dx, dy);\n            half4 snowMask2 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n            half4 snowMask = snowMask0 * weights.x + snowMask1 * weights.y + snowMask2 * weights.z;\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n      #else // not stochastic\n          albedo = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv, dx, dy);\n          COUNTSAMPLE\n\n          normal = half3(0,0,1);\n          smoothAO = half2(0, 1);\n\n          #if !_AUTONORMAL\n             half4 snowNormSamp = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv, dx, dy);\n             COUNTSAMPLE\n             normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n             #if _SURFACEGRADIENT\n                normal = ConvertNormalToGradient(d, normal);\n             #endif\n                 \n             #if _PACKEDFAST\n                smoothAO.x = snowNormSamp.r;\n                smoothAO.y = snowNormSamp.b;\n             #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv, dx, dy);\n            COUNTSAMPLE\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n     #endif // stochastic\n   }\n\n   \n   void Ext_SurfaceFunction8 (inout Surface o, ShaderData d)\n   {\n      #if _SNOW\n          float amount = _SnowAmount;\n          if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n          float snowAmount = lerp(dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), dot(d.worldSpaceNormal, float3(0,1,0)), amount * 0.8) + 1;\n          snowAmount -= _SnowAngle;\n          snowAmount *= _SnowContrast;\n          snowAmount = saturate(snowAmount) - (1-amount) * (1-amount);\n\n          if (_SnowWorldFade.z > 0)\n          {\n             float worldFade = saturate((d.worldSpacePosition.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n             snowAmount *= worldFade;\n          }\n\n          #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(d.worldSpacePosition.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n          #endif\n          snowAmount = saturate(snowAmount);\n\n          float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw;\n          float2 dx = ddx(uv);\n          float2 dy = ddy(uv);\n\n          #if _TRAX_ON\n              float2 tuv = d.worldSpacePosition.xz * float2(1, -1) * _SnowTraxAlbedo_ST.xy + _SnowTraxAlbedo_ST.zw;\n              float2 tdx = ddx(uv);\n              float2 tdy = ddy(uv);\n          #endif\n\n          #if _LAYERVERTEXMASK\n              snowAmount *= d.vertexColor.a;\n          #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n              snowAmount *= d.blackboard.weightTextureMask.a;\n          #endif\n\n          UNITY_BRANCH\n          if (snowAmount > 0)\n          {\n             half4 snowAlbedo;\n             half3 snowNormal;\n             half2 snowSmoothAO;\n             SampleSnowSurface(TEXTURE2D_ARGS(_SnowAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowNormal, sampler_SnowAlbedo),\n                    TEXTURE2D_ARGS(_SnowMaskMap, sampler_SnowAlbedo), d, uv, dx, dy, snowAlbedo, snowNormal, snowSmoothAO);\n\n             snowAlbedo.rgb *= _SnowTint.rgb;\n\n             #if _TRAX_ON\n                half traxBuffer = 1 - d.blackboard.traxBuffer;\n                UNITY_BRANCH\n                if (traxBuffer > 0)\n                {\n                    half4 tsnowAlbedo;\n                    half3 tsnowNormal;\n                    half2 tsnowSmoothAO;\n                    SampleSnowSurface(TEXTURE2D_ARGS(_SnowTraxAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowTraxNormal, sampler_SnowAlbedo),\n                        TEXTURE2D_ARGS(_SnowTraxMaskMap, sampler_SnowAlbedo), d, tuv, tdx, tdy, tsnowAlbedo, tsnowNormal, tsnowSmoothAO);\n\n                    tsnowAlbedo.rgb *= _SnowTraxTint;\n                    half h = HeightBlend(snowAlbedo.a, tsnowAlbedo.a, traxBuffer, 0.5);\n                    snowAlbedo = lerp(snowAlbedo, tsnowAlbedo, h);\n                    snowNormal = lerp(snowNormal, tsnowNormal, h);\n                    snowSmoothAO = lerp(snowSmoothAO, tsnowSmoothAO, h);\n                }\n             #endif\n\n             #if !_AUTONORMAL\n                o.Normal = lerp(o.Normal, snowNormal, snowAmount);\n             #endif\n             o.Albedo = lerp(o.Albedo, snowAlbedo.rgb, snowAmount);\n             o.Alpha = lerp(o.Alpha, snowAlbedo.a, snowAmount);\n             o.Smoothness = lerp(o.Smoothness, snowSmoothAO.x, snowAmount);\n             o.Occlusion = lerp(o.Occlusion, snowSmoothAO.y, snowAmount);\n             o.Height = o.Alpha;\n\n          }\n      #endif\n   }\n\n   \n\n\n\n\n\n   TEXTURE2D(_WindParticulate);\n   SAMPLER(sampler_WindParticulate);\n\n// In case we want to read it more than once..\n\n#ifndef __STACKABLE_WIND_INCLUDES__\n#define __STACKABLE_WIND_INCLUDES__\n\n\n   half FilterRange(float4 range, float y)\n   {\n      half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));\n      w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));\n      return w;\n   }\n\n   \n   float2 RotateUV(float2 uv, float amt)\n   {\n      uv -=0.5;\n      float s = sin ( amt);\n      float c = cos ( amt );\n      float2x2 mtx = float2x2( c, -s, s, c);\n      mtx *= 0.5;\n      mtx += 0.5;\n      mtx = mtx * 2-1;\n      uv = mul ( uv, mtx );\n      uv += 0.5;\n      return uv;\n   }\n\n\n   half FilterWindParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)\n   {\n      float2 windDir = RotateUV(float2(1, 0), windRot);\n      float2 flow = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));\n      float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill\n      return FilterRange(range, cofacing);\n   }\n\n   half ProcessWindParticulateMask(inout half mask, float contrast)\n   {\n      mask = pow(abs(mask), abs(contrast));\n      half invMask = 1.0 - mask;\n      invMask *= invMask; \n      invMask *= invMask;\n      return invMask;\n   }\n#endif // include guard\n\n   void Ext_SurfaceFunction9 (inout Surface o, ShaderData d)\n   {\n      #if _WIND_ON && !_PASSMETA\n   \n         float3 upVector = float3(0,0,1);\n\n         half upDot = max(0.0, dot(d.worldSpaceNormal, float3(0, 1, 0)));\n\n         float2 uv = d.worldSpacePosition.xz;\n         if (_WindParticulateSpace > 0.5)\n            uv = d.texcoord0.xy;\n         float windRotation = _WindParticulateRotation;\n         float windStrength = _WindParticulateStrength;\n\n         float2 wuv = RotateUV(uv, windRotation);\n\n         half windBlend = 1.0;\n\n         float windWorldMask = FilterRange(_WindParticulateWorldHeightMask, d.worldSpacePosition.y);\n         windWorldMask *= FilterRange(_WindParticulateAngleMask, upDot);\n\n         // compute mask\n         wuv *= float2(_WindParticulate_ST.x, 1) * _WindParticulate_ST.y + _WindParticulate_ST.zw;\n         float speed = _Time.x * _WindParticulateSpeed;\n         half w1 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv * 3 + speed * float2(1,0)).g;\n         half w2 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv + speed * float2(1.1,0)).a;\n         half windMask = (w1 * w2);\n\n         windMask *= windStrength * windBlend * windWorldMask;\n         windMask *= saturate((_WindParticulateTextureHeight - o.Height) * 10);\n\n         half windInvMask = ProcessWindParticulateMask(windMask, _WindParticulatePower);\n    \n         o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);\n         o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindParticulateEmissive.rgb;\n         o.Normal.xy *= windInvMask;\n         o.Smoothness *= windInvMask;\n         o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;\n         o.Metallic *= windInvMask;\n      #endif\n\n   }\n\n\n\n\n\tvoid Ext_SurfaceFunction10 (inout Surface o, ShaderData d)\n\t{\n        if (_DoubleSidedNormalMode == 0)\n        {\n           o.Normal *= d.isFrontFace ? 1 : -1;\n        }\n        else if (_DoubleSidedNormalMode == 1)\n        {\n\t\t   o.Normal.z *= d.isFrontFace ? 1 : -1;\n        }\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction11 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _SURFACEGRADIENT\n\t\t\to.Normal = ResolveNormalFromSurfaceGradient(d, o.Normal);\n\t    #elif _AUTONORMAL\n\t        float3 dx = ddx(d.worldSpacePosition);\n\t\t\tfloat3 dy = ddy(d.worldSpacePosition);\n\t\t\tfloat3 crossX = cross(float3(0,1,0), dx);\n\t\t\tfloat3 crossY = cross(float3(0,1,0), dy);\n\t\t\tfloat3 dt = abs(dot(crossY, dx));\n\t\t\tfloat height = _AutoNormalStrength * 0.5 * o.Alpha;\n\t\t\tfloat3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n\t\t\tn.y *= -1.0;\n\t\t\to.Normal = normalize((dt * float3(0,1,0)) - n).xzy;\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#else\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#endif\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction12 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DEBUG_SAMPLECOUNT\n\t\t\tif (_sampleCount > _DebugSampleCountThreshold)\n\t\t\t{\n\t\t\t\to.Albedo.r = 1;\n\t\t\t\to.Albedo.gb *= 0.2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\to.Albedo.b = 1;\n\t\t\t}\n\n        #endif\n\t}\n\n\n\n\n\tSAMPLER(sampler_DissolveTexture);\n\tTEXTURE2D(_DissolveTexture);\n\tTEXTURE2D(_DissolveGradient);\n\n\tvoid Ext_SurfaceFunction13 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DISSOLVE\n\t\tfloat2 uv = d.texcoord0.xy * _DissolveTexture_ST.xy + _DissolveTexture_ST.zw;\n\t\tfloat2 dx = ddx(uv);\n\t\tfloat2 dy = ddy(uv);\n\n\t\tUNITY_BRANCH\n\t\tif (_DissolveAmount > 0)\n\t\t{\n\t\t\thalf dissolve = SAMPLE_TEXTURE2D_GRAD(_DissolveTexture, sampler_DissolveTexture, uv, dx, dy).g;\n\t\t\thalf cp =  saturate(_DissolveAmount - (dissolve - _DissolveAmount) * _DissolveEdgeContrast) + _DissolveAmount;\n\t\t\thalf cp2 = saturate(1.0 - abs((dissolve - _DissolveAmount) * _DissolveEdgeContrast));\n\t\t\tclip(1.0 - cp);\n\t\t\tfloat2 fuv = float2(cp2, 0.5);\n\t\t\thalf3 col = SAMPLE_TEXTURE2D_LOD(_DissolveGradient, sampler_DissolveTexture, fuv, 0).rgb;\n\t\t\t\t\n\t\t\to.Albedo = lerp(o.Albedo, col, _DissolveColoration * cp2);\n\t\t\to.Emission = lerp(o.Emission, col * _DissolveEmissiveStr, _DissolveColoration * cp2);\n\t\t}\n\t\t#endif\n\t}\n\n\n\n\n    float Dither8x8Bayer( int x, int y )\n    {\n        const float dither[ 64 ] = {\n                1, 49, 13, 61,  4, 52, 16, 64,\n            33, 17, 45, 29, 36, 20, 48, 32,\n                9, 57,  5, 53, 12, 60,  8, 56,\n            41, 25, 37, 21, 44, 28, 40, 24,\n                3, 51, 15, 63,  2, 50, 14, 62,\n            35, 19, 47, 31, 34, 18, 46, 30,\n            11, 59,  7, 55, 10, 58,  6, 54,\n            43, 27, 39, 23, 42, 26, 38, 22};\n        int r = y * 8 + x;\n        return dither[r] / 64; \n    }\n\n    void ApplyDitherCrossFadeVSP(float2 vpos, float fadeValue)\n    {\n        float dither = Dither8x8Bayer( fmod(vpos.x, 8), fmod(vpos.y, 8) );\n        float sgn = fadeValue > 0 ? 1.0f : -1.0f;\n        clip(dither - (1-fadeValue) * sgn);\n    }\n    \n\n\tvoid Ext_SurfaceFunction14 (inout Surface o, ShaderData d)\n\t{\n\t\t#if LOD_FADE_CROSSFADE\n            float4 screenPosNorm = d.screenPos / d.screenPos.w;\n            screenPosNorm.z = ( UNITY_NEAR_CLIP_VALUE >= 0 ) ? screenPosNorm.z : screenPosNorm.z * 0.5 + 0.5;\n            float2 clipScreen = screenPosNorm.xy * _ScreenParams.xy;\n            ApplyDitherCrossFadeVSP(clipScreen,unity_LODFade.x);\n        #endif\n\t}\n\n\n\n\n\n\n// declare outside of CBuffer\n\nfloat4x4 _GlobalVolumeMatrix;\nfloat4x4 _VolumeMatrix;\nfloat3 _VolumeMin;\nfloat3 _VolumeInvSize;\nfloat3 _GlobalVolumeMin;\nfloat3 _GlobalVolumeInvSize;\n\n// I inlined a section of your include. You can use includes in better shaders, but doing it via a subshader or this way\n// is much better. The reason is that this allows your shader to be all inclusive, and packed up for asset store distribition,\n// without requiring specific paths to other files, etc.\n//\n\n#ifndef BAKERY_INCLUDED\n#define BAKERY_INCLUDED\n\n#define BAKERYMODE_DEFAULT 0\n#define BAKERYMODE_VERTEXLM 1.0f\n#define BAKERYMODE_RNM 2.0f\n#define BAKERYMODE_SH 3.0f\n\n\n// can't fit vertexLM SH to sm3_0 interpolators\n#ifndef SHADER_API_D3D11\n    #undef _LIGHTMAPMODE_VERTEXSH\n#endif\n\n// can't do stuff on sm2_0 due to standard shader alrady taking up all instructions\n#if SHADER_TARGET < 30\n    #undef BAKERY_BICUBIC\n    #undef BAKERY_LMSPEC\n\n    #undef _LIGHTMAPMODE_RNM\n    #undef _LIGHTMAPMODE_SH\n    #undef _LIGHTMAPMODE_VERTEX\n#endif\n\n#define lumaConv float3(0.2125f, 0.7154f, 0.0721f)\n\n#ifdef BAKERY_VOLUME\n    #ifdef BAKERY_COMPRESSED_VOLUME\n        Texture3D _Volume3;\n    #endif\n#endif\n\n\nhalf3 LinearToGamma (half3 linRGB)\n{\n    linRGB = max(linRGB, half3(0.h, 0.h, 0.h));\n    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n    return max(1.055h * pow(linRGB, 0.416666667h) - 0.055h, 0.h);\n}\n\nfloat shEvaluateDiffuseL1Geomerics(float L0, float3 L1, float3 n)\n{\n    // average energy\n    float R0 = L0;\n\n    // avg direction of incoming light\n    float3 R1 = 0.5f * L1;\n\n    // directional brightness\n    float lenR1 = length(R1);\n\n    // linear angle between normal and direction 0-1\n    //float q = 0.5f * (1.0f + dot(R1 / lenR1, n));\n    //float q = dot(R1 / lenR1, n) * 0.5 + 0.5;\n    float q = dot(normalize(R1), n) * 0.5 + 0.5;\n\n    // power for q\n    // lerps from 1 (linear) to 3 (cubic) based on directionality\n    float p = 1.0f + 2.0f * lenR1 / R0;\n\n    // dynamic range constant\n    // should vary between 4 (highly directional) and 0 (ambient)\n    float a = (1.0f - lenR1 / R0) / (1.0f + lenR1 / R0);\n\n    return R0 * (a + (1.0f - a) * (p + 1.0f) * pow(q, p));\n}\n\n#ifdef BAKERY_VERTEXLMMASK\n    float4 unpack4NFloats(float src)\n\t{\n        //return fmod(float4(src / 262144.0, src / 4096.0, src / 64.0, src), 64.0)/64.0;\n        return frac(float4(src / (262144.0*64), src / (4096.0*64), src / (64.0*64), src));\n    }\n#endif\n\n#if defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n    float3 unpack3NFloats(float src)\n\t{\n        float r = frac(src);\n        float g = frac(src * 256.0);\n        float b = frac(src * 65536.0);\n        return float3(r, g, b);\n    }\n#endif\n\n// Unity defines these under different names in each SRP, so use our own\ninline float3 Bakery_SafeNormalize(float3 inVec)\n{\n    float dp3 = max(0.001f, dot(inVec, inVec));\n    return inVec * rsqrt(dp3);\n}\n\n#if _URP || _HDRP\n\nfloat SmoothnessToPerceptualRoughness(float smoothness)\n{\n    return (1 - smoothness);\n}\n#endif\n\n#if !_STANDARD\nhalf4 unity_Lightmap_HDR;\ninline half3 DecodeLightmap( half4 color )\n{\n    return DecodeLightmap( color, unity_Lightmap_HDR );\n}\n\n#define UNITY_INV_PI        0.31830988618f\ninline float GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return UNITY_INV_PI * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n    void BakeryVertexLMDirection(inout float3 diffuseColor, inout float3 specularColor, float3 lightDirection, float3 vertexNormalWorld, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 dominantDir = Bakery_SafeNormalize(lightDirection);\n        half halfLambert = dot(normalWorld, dominantDir) * 0.5 + 0.5;\n        half flatNormalHalfLambert = dot(vertexNormalWorld, dominantDir) * 0.5 + 0.5;\n\n        #ifdef BAKERY_LMSPEC\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = spec * diffuseColor;\n        #endif\n\n        diffuseColor *= halfLambert / max(1e-4h, flatNormalHalfLambert);\n    }\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXSH\n    void BakeryVertexLMSH(inout float3 diffuseColor, inout float3 specularColor, float3 shL1x, float3 shL1y, float3 shL1z, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 L0 = diffuseColor;\n        float3 nL1x = shL1x;\n        float3 nL1y = shL1y;\n        float3 nL1z = shL1z;\n        float3 L1x = nL1x * L0 * 2;\n        float3 L1y = nL1y * L0 * 2;\n        float3 L1z = nL1z * L0 * 2;\n\n        float3 sh;\n    #if BAKERY_SHNONLINEAR\n        //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n        //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n        //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n        float lumaL0 = dot(L0, 1);\n        float lumaL1x = dot(L1x, 1);\n        float lumaL1y = dot(L1y, 1);\n        float lumaL1z = dot(L1z, 1);\n        float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n        float regularLumaSH = dot(sh, 1);\n        //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n        sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    #else\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    #endif\n\n        diffuseColor = max(sh, 0.0);\n\n        #ifdef BAKERY_LMSPEC\n            float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n            float focus = saturate(length(dominantDir));\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = max(spec * sh, 0.0);\n        #endif\n    }\n#endif\n\n\n\n#ifdef BAKERY_BICUBIC\nfloat BakeryBicubic_w0(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-a + 3.0f) - 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w1(float a)\n{\n    return (1.0f/6.0f)*(a*a*(3.0f*a - 6.0f) + 4.0f);\n}\n\nfloat BakeryBicubic_w2(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-3.0f*a + 3.0f) + 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w3(float a)\n{\n    return (1.0f/6.0f)*(a*a*a);\n}\n\nfloat BakeryBicubic_g0(float a)\n{\n    return BakeryBicubic_w0(a) + BakeryBicubic_w1(a);\n}\n\nfloat BakeryBicubic_g1(float a)\n{\n    return BakeryBicubic_w2(a) + BakeryBicubic_w3(a);\n}\n\nfloat BakeryBicubic_h0(float a)\n{\n    return -1.0f + BakeryBicubic_w1(a) / (BakeryBicubic_w0(a) + BakeryBicubic_w1(a)) + 0.5f;\n}\n\nfloat BakeryBicubic_h1(float a)\n{\n    return 1.0f + BakeryBicubic_w3(a) / (BakeryBicubic_w2(a) + BakeryBicubic_w3(a)) + 0.5f;\n}\n#endif\n\n\n#if defined(_LIGHTMAPMODE_RNM) || defined(_LIGHTMAPMODE_SH)\nTexture2D _RNM0, _RNM1, _RNM2;\n#endif\n\n#ifdef BAKERY_VOLUME\nTexture3D _Volume0, _Volume1, _Volume2, _VolumeMask;\nSamplerState sampler_Volume0;\n#endif\n\n#if defined(BAKERY_BICUBIC) && defined(LIGHTMAP_ON) && defined(SHADER_API_D3D11)\n    // Bicubic\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\tfloat width, height;\n\t\ttex.GetDimensions(width, height);\n\t\tfloat texelSize = 1.0f / width;\n\n        float x = uv.x * width;\n        float y = uv.y * width;\n\n        x -= 0.5f;\n        y -= 0.5f;\n\n        float px = floor(x);\n        float py = floor(y);\n\n        float fx = x - px;\n        float fy = y - py;\n\n        float g0x = BakeryBicubic_g0(fx);\n        float g1x = BakeryBicubic_g1(fx);\n        float h0x = BakeryBicubic_h0(fx);\n        float h1x = BakeryBicubic_h1(fx);\n        float h0y = BakeryBicubic_h0(fy);\n        float h1y = BakeryBicubic_h1(fy);\n\n        return     BakeryBicubic_g0(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h0y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h0y) * texelSize))) +\n\n                   BakeryBicubic_g1(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h1y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h1y) * texelSize)));\n    }\n#else\n    // Bilinear\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\t#ifdef LIGHTMAP_ON\n\t\t\treturn tex.Sample(samplerunity_Lightmap, uv);\n\t\t#else\n\t\t\treturn float4(1,0,0,1);\n\t\t#endif\n    }\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\n#ifdef BAKERY_LMSPEC\nfloat BakeryDirectionalLightmapSpecular(float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 dominantDir = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap, lmUV).xyz * 2 - 1;\n    half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n    half nh = saturate(dot(normalWorld, halfDir));\n    half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n    half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n    half spec = GGXTerm(nh, roughness);\n    return spec;\n}\n#endif\n#endif\n\n\n\n#ifdef _LIGHTMAPMODE_RNM\nvoid BakeryRNM(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalMap, float smoothness, float3 viewDirT)\n{\n    const float3 rnmBasis0 = float3(0.816496580927726f, 0, 0.5773502691896258f);\n    const float3 rnmBasis1 = float3(-0.4082482904638631f, 0.7071067811865475f, 0.5773502691896258f);\n    const float3 rnmBasis2 = float3(-0.4082482904638631f, -0.7071067811865475f, 0.5773502691896258f);\n\n    float3 rnm0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 rnm1 = DecodeLightmap(BakeryTex2D(_RNM1, lmUV));\n    float3 rnm2 = DecodeLightmap(BakeryTex2D(_RNM2, lmUV));\n\n    #ifdef BAKERY_SSBUMP\n        diffuseColor = normalMap.x * rnm0\n                     + normalMap.z * rnm1\n                     + normalMap.y * rnm2;\n         diffuseColor *= 2;\n    #else\n        diffuseColor = saturate(dot(rnmBasis0, normalMap)) * rnm0\n                     + saturate(dot(rnmBasis1, normalMap)) * rnm1\n                     + saturate(dot(rnmBasis2, normalMap)) * rnm2;\n    #endif\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDirT = rnmBasis0 * dot(rnm0, lumaConv) +\n                              rnmBasis1 * dot(rnm1, lumaConv) +\n                              rnmBasis2 * dot(rnm2, lumaConv);\n\n        float3 dominantDirTN = normalize(dominantDirT);\n        float3 specColor = saturate(dot(rnmBasis0, dominantDirTN)) * rnm0 +\n                           saturate(dot(rnmBasis1, dominantDirTN)) * rnm1 +\n                           saturate(dot(rnmBasis2, dominantDirTN)) * rnm2;\n\n        half3 halfDir = Bakery_SafeNormalize(dominantDirTN - viewDirT);\n        half nh = saturate(dot(normalMap, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n        specularColor = spec * specColor;\n    #endif\n}\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\ninline half3 Unity_DecodeDirectionalLightmap(half3 color, half4 dirTex, half3 normalWorld)\n{\n    // In directional (non-specular) mode Enlighten bakes dominant light direction\n    // in a way, that using it for half Lambert and then dividing by a \"rebalancing coefficient\"\n    // gives a result close to plain diffuse response lightmaps, but normalmapped.\n\n    // Note that dir is not unit length on purpose. Its length is \"directionality\", like\n    // for the directional specular lightmaps.\n\n    half halfLambert = dot(normalWorld, dirTex.xyz - 0.5) + 0.5;\n\n    return color * halfLambert / max(1e-4h, dirTex.w);\n}\n#endif\n\n#ifdef _LIGHTMAPMODE_SH\nvoid BakerySH(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 L0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 nL1x = BakeryTex2D(_RNM0, lmUV) * 2 - 1;\n    float3 nL1y = BakeryTex2D(_RNM1, lmUV) * 2 - 1;\n    float3 nL1z = BakeryTex2D(_RNM2, lmUV) * 2 - 1;\n    float3 L1x = nL1x * L0 * 2;\n    float3 L1y = nL1y * L0 * 2;\n    float3 L1z = nL1z * L0 * 2;\n\n    float3 sh;\n#if BAKERY_SHNONLINEAR\n    float lumaL0 = dot(L0, 1);\n    float lumaL1x = dot(L1x, 1);\n    float lumaL1y = dot(L1y, 1);\n    float lumaL1z = dot(L1z, 1);\n    float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    float regularLumaSH = dot(sh, 1);\n    //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n    sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n    //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n    //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n#else\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n#endif\n\n    diffuseColor = max(sh, 0.0);\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n        float focus = saturate(length(dominantDir));\n        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n        half nh = saturate(dot(normalWorld, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n\n        sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n\n        specularColor = max(spec * sh, 0.0);\n    #endif\n}\n#endif\n\n#endif // include guards\n\n\n    void Ext_ModifyVertex15 (inout VertexData v, inout ExtraV2F e)\n    {\n        #if _USEBAKERY\n\t\t    #if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\t\t\t    // Unpack from RGBM\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.a * 8.0f;\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.rgb;\n\n\t\t\t    #ifdef BAKERY_VERTEXLMMASK\n\t\t\t\t    e.extraV2F4.xyzw = unpack4NFloats(v.texcoord1);\n\t\t\t    #endif\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXSH\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n                e.extraV2F6.xyz = unpack3NFloats(v.texcoord3.x) * 2 - 1;\n                e.extraV2F7.xyz = unpack3NFloats(v.texcoord3.y) * 2 - 1;\n            #endif\n       #endif\n    }\n\n#if _HDRP || _URP\n    half3 SHEvalLinearL0L1 (half4 normal)\n    {\n        half3 x;\n\n        // Linear (L1) + constant (L0) polynomial terms\n        x.r = dot(unity_SHAr,normal);\n        x.g = dot(unity_SHAg,normal);\n        x.b = dot(unity_SHAb,normal);\n\n        return x;\n    }\n\n    // normal should be normalized, w=1.0\n    half3 SHEvalLinearL2 (half4 normal)\n    {\n        half3 x1, x2;\n        // 4 of the quadratic (L2) polynomials\n        half4 vB = normal.xyzz * normal.yzzx;\n        x1.r = dot(unity_SHBr,vB);\n        x1.g = dot(unity_SHBg,vB);\n        x1.b = dot(unity_SHBb,vB);\n\n        // Final (5th) quadratic (L2) polynomial\n        half vC = normal.x*normal.x - normal.y*normal.y;\n        x2 = unity_SHC.rgb * vC;\n\n        return x1 + x2;\n    }\n\n    half3 ShadeSH9 (half4 normal)\n    {\n        // Linear + constant polynomial terms\n        half3 res = SHEvalLinearL0L1 (normal);\n\n        // Quadratic polynomials\n        res += SHEvalLinearL2 (normal);\n\n        #ifdef UNITY_COLORSPACE_GAMMA\n            res = LinearToGamma (res);\n        #endif\n\n        return res;\n\n    }\n#endif\n\n\n\n\tvoid DoBakeryStuff(inout float3 indDif, inout float3 indSpec, inout float4 shadowmask, float3 tangentNormal, float smoothness, ShaderData d)\n\t{\n\t\t// Quality!\n\t\tindDif = 1;\n\t\tindSpec = 0;\n\n        #if defined(_PASSFORWARD) || defined(_PASSGBUFFER) // forward pass on URP/Standard/HDRP + built-in deferred\n\n            float3 normalWorld = mul(tangentNormal, d.TBNMatrix);\n\n\t\t\t#ifdef LIGHTMAP_ON\n\n                // Static\n\n\t\t\t\tfloat2 lmUV = d.texcoord1 * unity_LightmapST.xy + unity_LightmapST.zw;\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_STANDARD\n\t\t\t\t\tindDif = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n\n\t\t\t\t\t#ifdef DIRLIGHTMAP_COMBINED\n\t\t\t\t\t\tfloat4 dirMap = BakeryTex2D(unity_LightmapInd, lmUV);\n\t\t\t\t\t\tindDif = Unity_DecodeDirectionalLightmap(indDif, dirMap, normalWorld);\n\n\t\t\t\t\t\t#ifdef BAKERY_LMSPEC\n\t\t\t\t\t\t\tindSpec = BakeryDirectionalLightmapSpecular(lmUV, normalWorld, -d.worldSpaceViewDir, smoothness) * indDif;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\n\t\t\t\t\tindDif = d.vertexColor;\n\n                    #ifdef BAKERY_VERTEXLMMASK\n                        shadowmask = d.extraV2F4;\n                    #endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n\t\t\t\t\t\t// worldSpaceNormal is per-vertex\n\t\t\t\t\t\t// normalWorld is per-pixel\n\t\t\t\t\t\tfloat3 bakedLightDirection = d.extraV2F5;\n\t\t\t\t\t\tBakeryVertexLMDirection(indDif, indSpec, bakedLightDirection, d.worldSpaceNormal, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXSH\n\t\t\t\t\t\tBakeryVertexLMSH(indDif, indSpec, d.extraV2F5, d.extraV2F6, d.extraV2F7, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_RNM\n\t\t\t\t\tBakeryRNM(indDif, indSpec, lmUV, tangentNormal, smoothness, -d.tangentSpaceViewDir);\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_SH\n\t\t\t\t\tBakerySH(indDif, indSpec, lmUV, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t#endif\n\n            #else\n\n                // Dynamic\n\n                #ifdef BAKERY_VOLUME\n\n                    bool isGlobal = dot(abs(_VolumeInvSize),1) == 0;\n                    float3 volViewDir = -d.worldSpaceViewDir;\n                    #ifdef BAKERY_VOLROTATION\n                        float4x4 volMatrix = (isGlobal ? _GlobalVolumeMatrix : _VolumeMatrix);\n                        float3 volInvSize = (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 lpUV = mul(volMatrix, float4(d.worldSpacePosition,1)).xyz * volInvSize + 0.5f;\n                        float3 volNormal = mul((float3x3)volMatrix, normalWorld);\n                        #ifdef BAKERY_LMSPEC\n                            volViewDir = mul((float3x3)volMatrix, volViewDir);\n                        #endif\n                    #else\n                        float3 lpUV = (d.worldSpacePosition - (isGlobal ? _GlobalVolumeMin : _VolumeMin)) * (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 volNormal = normalWorld;\n                    #endif\n\n                    #ifdef BAKERY_COMPRESSED_VOLUME\n                        float4 tex0, tex1, tex2, tex3;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex3 = _Volume3.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz * L0;\n                        L1y = tex2.xyz * L0;\n                        L1z = tex3.xyz * L0;\n                    #else\n                        float4 tex0, tex1, tex2;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV);\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV);\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz;\n                        L1y = tex2.xyz;\n                        L1z = float3(tex0.w, tex1.w, tex2.w);\n                    #endif\n                    indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), volNormal);\n                    indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), volNormal);\n                    indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), volNormal);\n\n                    #ifdef UNITY_COLORSPACE_GAMMA\n                        indDif = pow(indDif, 1.0f / 2.2f);\n                    #endif\n\n                    #ifdef BAKERY_LMSPEC\n                        float3 nL1x = L1x / L0;\n                        float3 nL1y = L1y / L0;\n                        float3 nL1z = L1z / L0;\n                        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n                        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - volViewDir);\n                        half nh = saturate(dot(volNormal, halfDir));\n                        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n                        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n                        half spec = GGXTerm(nh, roughness);\n                        float3 sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n                        indSpec = max(spec * sh, 0.0);\n                    #endif\n\n                    shadowmask = _VolumeMask.Sample(sampler_Volume0, lpUV);\n\n                #else\n\n                    #ifdef BAKERY_SHNONLINEAR\n                        float3 L0 = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);\n                        indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, unity_SHAr.xyz, normalWorld);\n                        indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, unity_SHAg.xyz, normalWorld);\n                        indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, unity_SHAb.xyz, normalWorld);\n                    #else\n                        indDif = ShadeSH9(float4(normalWorld,1));\n                    #endif\n\n                #endif\n\n\t\t\t#endif\n\n        #endif\n\t}\n\n\t// this is the main surface function. Surface is like a surface shader output structure, but\n\t// with our new outputs as well.\n\tvoid Ext_SurfaceFunction15 (inout Surface o, ShaderData d)\n\t{\n        #if _USEBAKERY\n\t\t    float3 indDif;\n\t\t    float3 indSpec;\n            float4 shadowmask = 1;\n\t\t    DoBakeryStuff(indDif, indSpec, shadowmask, o.Normal, o.Smoothness, d);\n\t\t    o.DiffuseGI = indDif;\n\t\t    o.BackDiffuseGI = indDif;\n\t\t    o.SpecularGI = indSpec;\n            o.ShadowMask = shadowmask;\n        #endif\n\t}\n\n\n\n\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                  Ext_SurfaceFunction1(l, d);\n                  Ext_SurfaceFunction2(l, d);\n                  Ext_SurfaceFunction3(l, d);\n                  Ext_SurfaceFunction4(l, d);\n                  Ext_SurfaceFunction5(l, d);\n                  Ext_SurfaceFunction6(l, d);\n                  Ext_SurfaceFunction7(l, d);\n                  Ext_SurfaceFunction8(l, d);\n                  Ext_SurfaceFunction9(l, d);\n\t\t            Ext_SurfaceFunction10(l, d);\n                  Ext_SurfaceFunction11(l, d);\n                  Ext_SurfaceFunction12(l, d);\n                  Ext_SurfaceFunction13(l, d);\n                  Ext_SurfaceFunction14(l, d);\n                  Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraV2F d;\n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                  Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                  Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                  #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                  v2p.extraV2F4 = d.extraV2F4;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                  v2p.extraV2F5 = d.extraV2F5;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F6 = d.extraV2F6;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F7 = d.extraV2F7;\n                  #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                d.extraV2F4 = v2p.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                d.extraV2F5 = v2p.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F6 = v2p.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F7 = v2p.extraV2F7;\n                #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n                Ext_ModifyTessellatedVertex2(v, d);\n                Ext_ModifyTessellatedVertex3(v, d);\n                Ext_ModifyTessellatedVertex4(v, d);\n                Ext_ModifyTessellatedVertex5(v, d);\n                Ext_ModifyTessellatedVertex6(v, d);\n                Ext_ModifyTessellatedVertex7(v, d);\n                Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                v2p.extraV2F4 = d.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                v2p.extraV2F5 = d.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F6 = d.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F7 = d.extraV2F7;\n                #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n            // d.texcoord3 = i.texcoord3;\n             #endif\n\n             d.isFrontFace = facing;\n             #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n             d.vertexColor = i.vertexColor;\n             #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(i.worldPos, 1)).xyz;\n            #endif\n             d.localSpaceNormal = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n             #if LOD_FADE_CROSSFADE\n             d.screenPos = i.screenPos;\n             d.screenUV = (i.screenPos.xy / i.screenPos.w);\n             #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n             #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n             d.extraV2F4 = i.extraV2F4;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n             d.extraV2F5 = i.extraV2F5;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F6 = i.extraV2F6;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F7 = i.extraV2F7;\n             #endif\n\n            return d;\n         }\n         \n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n   #ifdef VARYINGS_NEED_POSITION_WS\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex);\n   #endif\n\n   #ifdef VARYINGS_NEED_TANGENT_TO_WORLD\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n   #endif\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n        #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n       // output.texcoord3 = inputMesh.texcoord3;\n        #endif\n        #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n        output.vertexColor = inputMesh.vertexColor;\n        #endif\n\n       return output;\n   }\n#else\n\n   #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n    \n       ChainModifyVertex(input, output);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n        #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n       // output.texcoord3 = input.texcoord3;\n        #endif\n\n        #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n        output.vertexColor = input.vertexColor;\n        #endif\n\n        #if LOD_FADE_CROSSFADE\n        output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n        #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(output.worldPos.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? input.previousPositionOS : input.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n\n            VertexData previousMesh = input;\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            // Remap time to old time\n            float4 oldTime = _Time;\n            _Time.y = _LastTimeParameters.x;\n            _Time.x = _LastTimeParameters.x / 20;\n            _Time.z = _LastTimeParameters.x * 2;\n            _Time.w = _LastTimeParameters.x * 3;\n            ChainModifyVertex(previousMesh, dummy);\n            _Time = oldTime;\n\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = output.worldPos.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n            \n                    output.positionRWS = input.worldPos;\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n            \n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n                    #if defined(_ENABLE_SHADOW_MATTE) && SHADERPASS == SHADERPASS_FORWARD_UNLIT\n                        HDShadowContext shadowContext = InitShadowContext();\n                        float shadow;\n                        float3 shadow3;\n                        // We need to recompute some coordinate not computed by default for shadow matte\n                        posInput = GetPositionInput(fragInputs.positionSS.xy, _ScreenSize.zw, fragInputs.positionSS.z, UNITY_MATRIX_I_VP, GetWorldToViewMatrix());\n                        float3 upWS = normalize(fragInputs.tangentToWorld[1]);\n                        uint renderingLayers = GetMeshRenderingLightLayer();\n                        ShadowLoopMin(shadowContext, posInput, upWS, asuint(_ShadowMatteFilter), renderingLayers, shadow3);\n                        shadow = dot(shadow3, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));\n                \n                        float4 shadowColor = (1.0 - shadow) * surfaceDescription.ShadowTint.rgba;\n                        float  localAlpha  = saturate(shadowColor.a + surfaceDescription.Alpha);\n                \n                        // Keep the nested lerp\n                        // With no Color (bsdfData.color.rgb, bsdfData.color.a == 0.0f), just use ShadowColor*Color to avoid a ring of \"white\" around the shadow\n                        // And mix color to consider the Color & ShadowColor alpha (from texture or/and color picker)\n                        #ifdef _SURFACE_TYPE_TRANSPARENT\n                            surfaceData.baseColor = lerp(shadowColor.rgb * surfaceData.baseColor, lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow), surfaceDescription.Alpha);\n                        #else\n                            surfaceData.baseColor = lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow);\n                        #endif\n                        localAlpha = ApplyBlendMode(surfaceData.baseColor, localAlpha).a;\n                \n                        surfaceDescription.Alpha = localAlpha;\n                    #endif\n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n                \n\n                   // tangent-space normal\n                   float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                   normalTS = surfaceDescription.Normal;\n        \n                   // compute world space normal\n                   #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(normalTS, fragInputs.tangentToWorld);\n                   #else\n                      surfaceData.normalWS = normalTS;\n                   #endif\n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                    #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                \n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2], alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                    #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 //builtinData.vtPackedFeedback = surfaceDescription.VTPackedFeedback;\n        \n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     //builtinData.distortion = surfaceData.Distortion;\n                     //builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n\n\n\n            #ifdef UNITY_VIRTUAL_TEXTURING\n            #define VT_BUFFER_TARGET SV_Target1\n            #define EXTRA_BUFFER_TARGET SV_Target2\n            #else\n            #define EXTRA_BUFFER_TARGET SV_Target1\n            #endif\n\n\n\n          void Frag(VertexToPixel v2p,\n              #ifdef OUTPUT_SPLIT_LIGHTING\n                  out float4 outColor : SV_Target0,  // outSpecularLighting\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                      out float4 outVTFeedback : VT_BUFFER_TARGET,\n                  #endif\n                  out float4 outDiffuseLighting : EXTRA_BUFFER_TARGET,\n                  OUTPUT_SSSBUFFER(outSSSBuffer)\n              #else\n                  out float4 outColor : SV_Target0\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                      ,out float4 outVTFeedback : VT_BUFFER_TARGET\n                  #endif\n                  #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n                     , out float4 outMotionVec : EXTRA_BUFFER_TARGET\n                  #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n              #endif // OUTPUT_SPLIT_LIGHTING\n              #ifdef _DEPTHOFFSET_ON\n                  , out float outputDepth : SV_Depth\n              #endif\n              #if NEED_FACING\n                 , bool facing : SV_IsFrontFace\n              #endif\n          )\n          {\n              #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n                 // Init outMotionVector here to solve compiler warning (potentially unitialized variable)\n                 // It is init to the value of forceNoMotion (with 2.0)\n                 outMotionVec = float4(2.0, 0.0, 0.0, 0.0);\n              #endif\n\n              UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2p);\n              FragInputs input = BuildFragInputs(v2p);\n\n              // We need to readapt the SS position as our screen space positions are for a low res buffer, but we try to access a full res buffer.\n              input.positionSS.xy = _OffScreenRendering > 0 ? (input.positionSS.xy * _OffScreenDownsampleFactor) : input.positionSS.xy;\n\n              uint2 tileIndex = uint2(input.positionSS.xy) / GetTileSize();\n\n              // input.positionSS is SV_Position\n              PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS.xyz, tileIndex);\n\n\n              float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n              SurfaceData surfaceData;\n              BuiltinData builtinData;\n              Surface l;\n              ShaderData d;\n              GetSurfaceAndBuiltinData(v2p, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n\n\n              BSDFData bsdfData = ConvertSurfaceDataToBSDFData(input.positionSS.xy, surfaceData);\n\n              PreLightData preLightData = GetPreLightData(V, posInput, bsdfData);\n\n              outColor = float4(0.0, 0.0, 0.0, 0.0);\n\n              // We need to skip lighting when doing debug pass because the debug pass is done before lighting so some buffers may not be properly initialized potentially causing crashes on PS4.\n\n             #ifdef DEBUG_DISPLAY\n                 // Init in debug display mode to quiet warning\n                #ifdef OUTPUT_SPLIT_LIGHTING\n                    outDiffuseLighting = 0;\n                    ENCODE_INTO_SSSBUFFER(surfaceData, posInput.positionSS, outSSSBuffer);\n                #endif\n\n              \n\n              // Same code in ShaderPassForwardUnlit.shader\n              // Reminder: _DebugViewMaterialArray[i]\n              //   i==0 -> the size used in the buffer\n              //   i>0  -> the index used (0 value means nothing)\n              // The index stored in this buffer could either be\n              //   - a gBufferIndex (always stored in _DebugViewMaterialArray[1] as only one supported)\n              //   - a property index which is different for each kind of material even if reflecting the same thing (see MaterialSharedProperty)\n              bool viewMaterial = false;\n              int bufferSize = _DebugViewMaterialArray[0].x;\n              if (bufferSize != 0)\n              {\n                  bool needLinearToSRGB = false;\n                  float3 result = float3(1.0, 0.0, 1.0);\n\n                  // Loop through the whole buffer\n                  // Works because GetSurfaceDataDebug will do nothing if the index is not a known one\n                  for (int index = 1; index <= bufferSize; index++)\n                  {\n                      int indexMaterialProperty = _DebugViewMaterialArray[index].x;\n\n                      // skip if not really in use\n                      if (indexMaterialProperty != 0)\n                      {\n                          viewMaterial = true;\n\n                          GetPropertiesDataDebug(indexMaterialProperty, result, needLinearToSRGB);\n                          GetVaryingsDataDebug(indexMaterialProperty, input, result, needLinearToSRGB);\n                          GetBuiltinDataDebug(indexMaterialProperty, builtinData, posInput, result, needLinearToSRGB);\n                          GetSurfaceDataDebug(indexMaterialProperty, surfaceData, result, needLinearToSRGB);\n                          GetBSDFDataDebug(indexMaterialProperty, bsdfData, result, needLinearToSRGB);\n                      }\n                  }\n\n                  // TEMP!\n                  // For now, the final blit in the backbuffer performs an sRGB write\n                  // So in the meantime we apply the inverse transform to linear data to compensate.\n                  if (!needLinearToSRGB)\n                      result = SRGBToLinear(max(0, result));\n\n                  outColor = float4(result, 1.0);\n              }\n\n              if (!viewMaterial)\n              {\n                  if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_VALIDATE_DIFFUSE_COLOR || _DebugFullScreenMode == FULLSCREENDEBUGMODE_VALIDATE_SPECULAR_COLOR)\n                  {\n                      float3 result = float3(0.0, 0.0, 0.0);\n\n                      GetPBRValidatorDebug(surfaceData, result);\n\n                      outColor = float4(result, 1.0f);\n                  }\n                  else if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_TRANSPARENCY_OVERDRAW)\n                  {\n                      float4 result = _DebugTransparencyOverdrawWeight * float4(TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_A);\n                      outColor = result;\n                  }\n                  else\n          #endif\n                  {\n          #ifdef _SURFACE_TYPE_TRANSPARENT\n                      uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_TRANSPARENT;\n          #else\n                      uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_OPAQUE;\n          #endif\n\n                      LightLoopOutput lightLoopOutput;\n                      LightLoop(V, posInput, preLightData, bsdfData, builtinData, featureFlags, lightLoopOutput);\n\n                      float3 diffuseLighting = lightLoopOutput.diffuseLighting;\n                      float3 specularLighting = lightLoopOutput.specularLighting;\n\n                      diffuseLighting *= GetCurrentExposureMultiplier();\n                      specularLighting *= GetCurrentExposureMultiplier();\n\n          #ifdef OUTPUT_SPLIT_LIGHTING\n                      if (_EnableSubsurfaceScattering != 0 && ShouldOutputSplitLighting(bsdfData))\n                      {\n                          outColor = float4(specularLighting, 1.0);\n                          outDiffuseLighting = float4(TagLightingForSSS(diffuseLighting), 1.0);\n                      }\n                      else\n                      {\n                          outColor = float4(diffuseLighting + specularLighting, 1.0);\n                          outDiffuseLighting = 0;\n                      }\n                      ENCODE_INTO_SSSBUFFER(surfaceData, posInput.positionSS, outSSSBuffer);\n          #else\n                      outColor = ApplyBlendMode(diffuseLighting, specularLighting, builtinData.opacity);\n                      outColor = EvaluateAtmosphericScattering(posInput, V, outColor);\n          #endif\n\n          ChainFinalColorForward(l, d, outColor);\n\n          #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n                      bool forceNoMotion = any(unity_MotionVectorsParams.yw == 0.0);\n                      // outMotionVec is already initialize at the value of forceNoMotion (see above)\n                      if (!forceNoMotion)\n                      {\n                          float2 motionVec = CalculateMotionVector(v2p.motionVectorCS, v2p.previousPositionCS);\n                          EncodeMotionVector(motionVec * 0.5, outMotionVec);\n                          outMotionVec.zw = 1.0;\n                      }\n          #endif\n                  }\n\n          #ifdef DEBUG_DISPLAY\n              }\n          #endif\n\n          #ifdef _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n          #endif\n\n          #ifdef UNITY_VIRTUAL_TEXTURING\n             outVTFeedback = builtinData.vtPackedFeedback;\n          #endif\n          }\n\n            ENDHLSL\n        }\n      \n      \n      \n      \n              Pass\n        {\n            // based on HDLitPass.template\n            Name \"META\"\n            Tags { \"LightMode\" = \"META\" }\n            \n            Cull Off\n        \n               Cull [_CullMode]\n\n        \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 ps4 xboxone vulkan metal switch\n            //#pragma enable_d3d11_debug_symbols\n        \n            #pragma multi_compile_instancing\n\n            //#pragma multi_compile_local _ _ALPHATEST_ON\n\n\n \n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            // #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            #define SHADERPASS SHADERPASS_LIGHT_TRANSPORT\n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #define REQUIRE_DEPTH_TEXTURE\n            #define _PASSMETA 1\n\n        \n            \n\n\n   #pragma shader_feature_local_fragment _ _PACKEDFAST\n   #pragma shader_feature_local _ _TRIPLANAR\n   #pragma shader_feature_local_fragment _ _NORMALMAP \n   #pragma shader_feature_local_fragment _ _MASKMAP\n   #pragma shader_feature_local_fragment _ _DETAIL\n   #pragma shader_feature_local_fragment _ _DETAILTRIPLANAR\n   #pragma shader_feature_local_fragment _ _DETAILSTOCHASTIC\n   #pragma shader_feature_local_fragment _ _EMISSION\n   #pragma shader_feature_local_fragment _ _FLATSHADE\n   #pragma shader_feature_local _ _STOCHASTIC\n   #pragma shader_feature_local_fragment _ _PARALLAX //_POM\n   #pragma shader_feature_local_fragment _ _SPECULAR\n   #pragma shader_feature_local _ _NOISEWORLD _NOISELOCAL\n   #pragma shader_feature_local _ _NOISEHQ _NOISETEXTURE _NOISEWORLEY\n   // only for URP/Standard Forward\n   #pragma shader_feature_local_fragment _ _SIMPLELIT\n\n\n   #pragma shader_feature_local_fragment _ _TINTMASK\n\n\n    #pragma shader_feature_local _ _LAYERVERTEXMASK _LAYERTEXTUREMASK\n\n    #define _HAS_WEIGHTTEXTURE_MASK 1\n\n\n   #pragma shader_feature_local _ _USELAYER\n   #pragma shader_feature_local _ _LAYERTRIPLANAR\n   #pragma shader_feature_local _ _LAYERALBEDO\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL\n   #pragma shader_feature_local _ _LAYERMASK\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION\n   #pragma shader_feature_local _ _LAYERNOISE\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC\n   #pragma shader_feature_local _ _LAYERANGLEFILTER\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_1\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_1\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_1\n   #pragma shader_feature_local _ _LAYERMASK_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_1\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_1\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_1\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_1\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_2\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_2\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_2\n   #pragma shader_feature_local _ _LAYERMASK_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_2\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_2\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_2\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_2\n\n\n   #pragma shader_feature_local _ _TRAX_ON\n\n\n   #pragma shader_feature_local_fragment _ _WETNESS\n   #pragma shader_feature_local_fragment _ _PUDDLES\n   #pragma shader_feature_local_fragment _ _PUDDLENOISE\n   #pragma shader_feature_local_fragment _ _RAINDROPS\n\n\n   #pragma shader_feature_local _ _SNOW\n   #pragma shader_feature_local _ _SNOWMASKMAP\n   #pragma shader_feature_local _ _SNOWNOISE\n   #pragma shader_feature_local_fragment _SNOWSTOCHASTIC\n\n\n   #pragma shader_feature_local_fragment _ _WIND_ON\n\n\n\n\n   #pragma shader_feature_local_fragment _ _SURFACEGRADIENT _AUTONORMAL\n   #define _WORLDSPACENORMAL 1\n\n\n   #pragma shader_feature_local _ _DEBUG_SAMPLECOUNT\n\n\n\t#pragma shader_feature_local_fragment _ _DISSOLVE\n\n\n   #pragma multi_compile_local  LOD_FADE_CROSSFADE\n\n\n\n#pragma instancing_options procedural:setupVSPro forwardadd\n\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\nstruct IndirectShaderData\n{\n\tfloat4x4 PositionMatrix;\n\tfloat4x4 InversePositionMatrix;\n\tfloat4 ControlData;\n};\n\n#if defined(SHADER_API_GLCORE) || defined(SHADER_API_D3D11) || defined(SHADER_API_GLES3) || defined(SHADER_API_METAL) || defined(SHADER_API_VULKAN) || defined(SHADER_API_PSSL) || defined(SHADER_API_XBOXONE)\n\tuniform StructuredBuffer<IndirectShaderData> VisibleShaderDataBuffer;\n#endif\n\n#endif\n\nfloat VSPRenderingLayerMask;\n\nvoid setupVSPro()\n{\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\n    #if _HDRP\n\t    unity_RenderingLayer.x = VSPRenderingLayerMask;\n    #endif\n\n\t#ifdef unity_ObjectToWorld\n\t#undef unity_ObjectToWorld\n\t#endif\n\n\t#ifdef unity_WorldToObject\n\t#undef unity_WorldToObject\n\t#endif\n\n\tunity_ObjectToWorld = VisibleShaderDataBuffer[unity_InstanceID].PositionMatrix;\n\tunity_WorldToObject = VisibleShaderDataBuffer[unity_InstanceID].InversePositionMatrix;\n#endif\n\n}\n\n\n\t#pragma multi_compile _LIGHTMAPMODE_STANDARD _LIGHTMAPMODE_RNM _LIGHTMAPMODE_SH _LIGHTMAPMODE_VERTEX _LIGHTMAPMODE_VERTEXDIRECTIONAL _LIGHTMAPMODE_VERTEXSH\n\n    #pragma shader_feature USEBAKERY\n    #pragma shader_feature BAKERY_VERTEXLMMASK\n    #pragma shader_feature BAKERY_SHNONLINEAR\n    #pragma shader_feature BAKERY_LMSPEC\n    #pragma shader_feature BAKERY_BICUBIC\n    #pragma shader_feature BAKERY_VOLUME\n    #pragma shader_feature BAKERY_VOLROTATION\n    #pragma shader_feature BAKERY_COMPRESSED_VOLUME\n\n    #if _USEBAKERY\n\t    #define _OVERRIDE_BAKEDGI\n        #if BAKERY_VOLUME || (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)) && defined(BAKERY_VERTEXLMMASK)\n            #define _OVERRIDE_SHADOWMASK\n        #endif\n    #endif\n\n\n\n\n\n\n\n\n   #define _HDRP 1\n#define _BLENDMODE_ALPHA 1\n#define _SURFACE_TYPE_TRANSPARENT 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n        \n\n            \n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\" // Need to be here for Gradient struct definition\n         \n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n\n\n   half4 _Tint;\n   half _UVSource;\n   half _TriplanarContrast;\n   half _AlbedoContrast;\n   half _AlbedoBrightness;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half3 _EmissionColor;\n   float _DetailUVSource;\n   half _StochasticScale;\n   half _DetailStochasticScale;\n   half _Smoothness;\n   half _Metallic;\n   half2 _SmoothnessRemap;\n   half2 _AORemap;\n   half2 _MetallicRemap;\n   half2 _HeightRemap;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n   half _AlphaThreshold;\n   half _Cutoff; // for Unity's light mapper\n   half _TriplanarSpace;\n   half _DetailTriplanarSpace;\n   half _DetailTriplanarContrast;\n   half _MicroShadowStrength;\n   half3 _FuzzyShadingColor;\n   half _FuzzyShadingOn;\n   half3 _FuzzyShadingParams;\n\n   //int _POMMaxSamples;\n   //float _POMMin;\n   //float _POMFade;\n#if _FLATSHADE\n   half _FlatShadingBlend;\n#endif\n\n   half _StochasticContrast;\n   half _DetailStochasticContrast;\n\n#if _PARALLAX || _POM\n   half _ParallaxHeight;\n#endif\n\n\n\n\tfloat4 _TintMask_ST;\n\thalf3 _RColor;\n\thalf3 _GColor;\n\thalf3 _BColor;\n\thalf3 _AColor;\n\n\n\thalf _LayerTextureMaskUVMode;\n    float4 _LayerTextureMask_ST;\n\n\n   //#if _USELAYER\n       float4 _LayerAlbedoMap_ST;\n       half3 _LayerTint;\n       half _LayerBlendMode;\n       float _LayerUVSource;\n       half _LayerAlbedoBrightness;\n       half _LayerAlbedoContrast;\n       half _LayerHeightContrast;\n       half _LayerStrength;\n       half _LayerAlbedoStrength;\n       half _LayerNormalStrength;\n       half _LayerSmoothnessStrength;\n       half _LayerSmoothness;\n       half _LayerMetallic;\n       half _LayerStochasticScale;\n       half2 _LayerSmoothnessRemap;\n       half2 _LayerAORemap;\n       half2 _LayerMetallicRemap;\n       half2 _LayerHeightRemap;\n       float4 _LayerWeightOverDistance;\n       half _LayerMicroShadowStrength;\n       //#if _LAYERNOISE\n           float _LayerNoiseFrequency;\n           float _LayerNoiseAmplitude;\n           float _LayerNoiseOffset;\n           float _LayerNoiseCenter;\n           half3 _LayerBlendTint;\n       //#endif\n       //#if _LAYERANGLEFILTER\n           half _LayerFalloff;\n           half _LayerAngleMin;\n           half _LayerHeight;\n           half _LayerInvertHeight;\n           half _LayerVertexNormalBlend;\n       //#endif\n       half _LayerTriplanarSpace;\n       half _LayerTriplanarContrast;\n       half _LayerBlendContrast;\n       half3 _LayerEmissionColor;\n       half _LayerStochasticContrast;\n       half _LayerTessStrength;\n       half3 _LayerFuzzyShadingColor;\n       half _LayerFuzzyShadingOn;\n       half3 _LayerFuzzyShadingParams;\n   //#endif\n\n\n   //#if _USELAYER_DEF_1\n       float4 _LayerAlbedoMap_Ext_1_ST;\n       half3 _LayerTint_Ext_1;\n       half _LayerBlendMode_Ext_1;\n       float _LayerUVSource_Ext_1;\n       half _LayerAlbedoBrightness_Ext_1;\n       half _LayerAlbedoContrast_Ext_1;\n       half _LayerHeightContrast_Ext_1;\n       half _LayerStrength_Ext_1;\n       half _LayerAlbedoStrength_Ext_1;\n       half _LayerNormalStrength_Ext_1;\n       half _LayerSmoothnessStrength_Ext_1;\n       half _LayerSmoothness_Ext_1;\n       half _LayerMetallic_Ext_1;\n       half _LayerStochasticScale_Ext_1;\n       half2 _LayerSmoothnessRemap_Ext_1;\n       half2 _LayerAORemap_Ext_1;\n       half2 _LayerMetallicRemap_Ext_1;\n       half2 _LayerHeightRemap_Ext_1;\n       float4 _LayerWeightOverDistance_Ext_1;\n       half _LayerMicroShadowStrength_Ext_1;\n       //#if _LAYERNOISE_DEF_1\n           float _LayerNoiseFrequency_Ext_1;\n           float _LayerNoiseAmplitude_Ext_1;\n           float _LayerNoiseOffset_Ext_1;\n           float _LayerNoiseCenter_Ext_1;\n           half3 _LayerBlendTint_Ext_1;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_1\n           half _LayerFalloff_Ext_1;\n           half _LayerAngleMin_Ext_1;\n           half _LayerHeight_Ext_1;\n           half _LayerInvertHeight_Ext_1;\n           half _LayerVertexNormalBlend_Ext_1;\n       //#endif\n       half _LayerTriplanarSpace_Ext_1;\n       half _LayerTriplanarContrast_Ext_1;\n       half _LayerBlendContrast_Ext_1;\n       half3 _LayerEmissionColor_Ext_1;\n       half _LayerStochasticContrast_Ext_1;\n       half _LayerTessStrength_Ext_1;\n       half3 _LayerFuzzyShadingColor_Ext_1;\n       half _LayerFuzzyShadingOn_Ext_1;\n       half3 _LayerFuzzyShadingParams_Ext_1;\n   //#endif\n\n\n   //#if _USELAYER_DEF_2\n       float4 _LayerAlbedoMap_Ext_2_ST;\n       half3 _LayerTint_Ext_2;\n       half _LayerBlendMode_Ext_2;\n       float _LayerUVSource_Ext_2;\n       half _LayerAlbedoBrightness_Ext_2;\n       half _LayerAlbedoContrast_Ext_2;\n       half _LayerHeightContrast_Ext_2;\n       half _LayerStrength_Ext_2;\n       half _LayerAlbedoStrength_Ext_2;\n       half _LayerNormalStrength_Ext_2;\n       half _LayerSmoothnessStrength_Ext_2;\n       half _LayerSmoothness_Ext_2;\n       half _LayerMetallic_Ext_2;\n       half _LayerStochasticScale_Ext_2;\n       half2 _LayerSmoothnessRemap_Ext_2;\n       half2 _LayerAORemap_Ext_2;\n       half2 _LayerMetallicRemap_Ext_2;\n       half2 _LayerHeightRemap_Ext_2;\n       float4 _LayerWeightOverDistance_Ext_2;\n       half _LayerMicroShadowStrength_Ext_2;\n       //#if _LAYERNOISE_DEF_2\n           float _LayerNoiseFrequency_Ext_2;\n           float _LayerNoiseAmplitude_Ext_2;\n           float _LayerNoiseOffset_Ext_2;\n           float _LayerNoiseCenter_Ext_2;\n           half3 _LayerBlendTint_Ext_2;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_2\n           half _LayerFalloff_Ext_2;\n           half _LayerAngleMin_Ext_2;\n           half _LayerHeight_Ext_2;\n           half _LayerInvertHeight_Ext_2;\n           half _LayerVertexNormalBlend_Ext_2;\n       //#endif\n       half _LayerTriplanarSpace_Ext_2;\n       half _LayerTriplanarContrast_Ext_2;\n       half _LayerBlendContrast_Ext_2;\n       half3 _LayerEmissionColor_Ext_2;\n       half _LayerStochasticContrast_Ext_2;\n       half _LayerTessStrength_Ext_2;\n       half3 _LayerFuzzyShadingColor_Ext_2;\n       half _LayerFuzzyShadingOn_Ext_2;\n       half3 _LayerFuzzyShadingParams_Ext_2;\n   //#endif\n\n\n    half _TraxDisplacementDepth;\n    half _TraxDisplacementStrength;\n    half _TraxMipBias;\n    half _TraxNormalStrength;\n    float4 _TraxAlbedo_ST;\n    half _TraxInterpContrast;\n    half _TraxHeightContrast;\n    half3 _TraxTint;\n\n\n\n    half _Porosity;\n    int _WetnessMode;\n    int _PuddleMode;\n\n    half  _PuddleAmount;\n    half  _PuddleFalloff;\n    half4 _PuddleColor;\n    half _PuddleNoiseFrequency;\n    half _PuddleNoiseAmplitude;\n    half _PuddleNoiseOffset;\n    half _PuddleNoiseCenter;\n    half _PuddleAngleMin;\n\n    half _WetnessAmount;\n\thalf _WetnessMin;\n    half _WetnessMax;\n    half _WetnessFalloff;\n\thalf _WetnessAngleMin;\n    float _WetnessShoreline;\n\n    int _RainMode;\n    half3 _RainIntensityScale;\n\n\n\n\n    float4 _SnowAlbedo_ST;\n    half3 _SnowTint;\n    half _SnowAmount;\n    half _SnowAngle;\n    half _SnowContrast;\n    half _SnowVertexHeight;\n    half _SnowMode;\n    half3 _SnowWorldFade; // z is on/off\n    float4 _SnowTraxAlbedo_ST;\n    half3 _SnowTraxTint;\n\n    half _SnowNoiseFreq; \n    half _SnowNoiseAmp;\n    half _SnowNoiseOffset;\n    half _SnowStochasticContrast;\n    half _SnowStochasticScale;\n\n\n    half     _WindParticulateSpace;\n    half     _WindParticulateRotation;\n    half      _WindParticulateSpeed;\n    float4     _WindParticulate_ST;\n    half      _WindParticulatePower;\n    half4    _WindParticulateColor;\n    half4    _WindParticulateWorldHeightMask;\n    half4    _WindParticulateAngleMask;\n    half      _WindParticulateOcclusionStrength;\n    half      _WindParticulateStrength;\n    half4    _WindParticulateEmissive;\n    half     _WindParticulateTextureHeight;\n\n\n   float _DoubleSidedNormalMode;\n\n\n\thalf _AutoNormalStrength;\n\n\n\tint _DebugSampleCountThreshold;\n\n\n\thalf _DissolveAmount;\n\thalf _DissolveEmissiveStr;\n\thalf _DissolveEdgeContrast;\n\thalf _DissolveColoration;\n\tfloat4 _DissolveTexture_ST;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCCOORD3;\n               float4 texcoord1 : TEXCCOORD4;\n               float4 texcoord2 : TEXCCOORD5;\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n               // float4 texcoord3 : TEXCCOORD6;\n                #endif\n\n                #if LOD_FADE_CROSSFADE\n                float4 screenPos : TEXCOORD7;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR_centroid;\n                #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                float4 extraV2F4 : TEXCOORD12_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                float4 extraV2F5 : TEXCOORD13_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F6 : TEXCOORD14_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F7 : TEXCOORD15_centroid;\n                #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n    \n\n  \n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n   half4 weightTextureMask;\n   \n\n\n   float traxBuffer;\n\n\n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // would love to strip these, but they are used in certain\n               // combinations of the lighting system, and may be used\n               // by the user as well, so no easy way to strip them.\n\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR_centroid;\n                #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                float4 extraV2F4 : TEXCOORD9_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                float4 extraV2F5 : TEXCOORD10_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F6 : TEXCOORD11_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F7 : TEXCOORD12_centroid;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n               #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n               #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n               #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n               #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()     unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n               #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V   unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n               #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V    mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n               #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n               #endif\n               #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\n#ifndef __STACKABLEFUNCLIBRARY_INCLUDES__\n#define __STACKABLEFUNCLIBRARY_INCLUDES__\n\n   #if _DEBUG_SAMPLECOUNT\n      int _sampleCount;\n      #define COUNTSAMPLE { _sampleCount++; }\n   #else\n      #define COUNTSAMPLE\n   #endif\n\n   TEXTURE2D(_NoiseTex);\n   SAMPLER(sampler_NoiseTex);\n\n\n\n   half3 AdjustContrast(half3 color, half contrast)\n   {\n       half3 comp = 0.5;\n   #if !UNITY_COLORSPACE_GAMMA\n       comp = 0.22;\n   #endif\n       color = saturate(lerp(comp, color, contrast));\n       return color;\n   }\n\n   float2 DoParallaxOffset( half h, half height, half3 viewDir)\n   {\n      h = h * height - height/2.0;\n      float3 v = normalize(viewDir);\n      v.z += 0.42;\n      return h * (v.xy / v.z);\n   }\n\n\n\n   #define SAMPLEBARY SampleTexBary\n\n   struct SampleConfig\n   {\n      float2 uv0;\n      float2 uv1;\n      float2 uv2;\n      float2 dx0;\n      float2 dy0;\n      float2 dx1;\n      float2 dy1;\n      float2 dx2;\n      float2 dy2;\n      float3 weights;\n      float3 origWeights;\n   };\n\n   struct Config\n   {\n      float2 origUV; // unscaled uv\n      float2 origScale;\n      float2 uv;        // no stocastic or triplanar\n      float2 dx;\n      float2 dy;\n      SampleConfig uvT; // just stochastic, or just triplanar\n      SampleConfig uvX; // stochastic and triplanar\n      SampleConfig uvY;\n      SampleConfig uvZ;\n\n      \n      float3 absVertNormal;\n      half3 axisSign;\n      float3 normal;\n   };\n\n\n    float2 Hash2D( float2 x )\n    {\n        float2 k = float2( 0.3183099, 0.3678794 );\n        x = x*k + k.yx;\n        return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );\n    }\n\n    float Noise2D(float2 p )\n    {\n        float2 i = floor( p );\n        float2 f = frac( p );\n         \n        float2 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), \n                        dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),\n                    lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), \n                        dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);\n    }\n      \n\n    float2 WorleyHash2D(float2 p)\n    {\n \t    return frac(cos(mul(p, float2x2(-64.2,71.3,81.4,-29.8)))*8321.3); \n    }\n    float WorleyNoise2D(float2 p)\n    {\n        float dist = 1;\n        float2 i = floor(p);\n        float2 f = frac(p);\n    \n        for(int x = -1;x<=1;x++)\n        {\n            for(int y = -1;y<=1;y++)\n            {\n                float d = distance(WorleyHash2D(i+float2(x,y))+float2(x,y),f);\n                dist = min(dist,d);\n            }\n        }\n        return dist;\n\t\n    }\n\n#ifndef PI\n    #define PI 3.14159265359\n#endif\n\n    float GetIntegerNoise(float2 p)\n    {\n        p  = 53.7 * frac( (p*0.3183099) + float2(0.71,0.113));\n        return frac( p.x*p.y*(p.x+p.y) );\n    }\n\n    float WorleyHash3D(float f)\n    {\n        return frac(sin(f)*43758.5453);\n    }\n\n    float WorleyHash31(float3 v)\n    {\n        return WorleyHash3D(dot(v, float3(253.14, 453.74, 183.3)));\n    }\n\n    float3 WorleyRandom3D( float3 p )\n    {\n        return frac(sin(float3(dot(p,float3(127.1,311.7,217.3)),dot(p,float3(269.5,183.3,431.1)), dot(p,float3(365.6,749.9,323.7))))*437158.5453);\n    }\n\n    float WorleyNoise3D(float3 uvw)\n    {\n        float noise = 0.0;\n    \n        float3 p = floor(uvw);\n        float3 f = frac(uvw);\n    \n        float4 res = 1;\n        for(int x = -1; x <=1; ++x)\n        {\n            for(int y = -1; y <=1; ++y)\n            {\n                for(int z = -1; z <=1; ++z)\n                {\n                    float3 gp = p + float3(x, y, z);\n\n                    float3 v = WorleyRandom3D(gp);\n\n\t\t\t\t    float3 diff = gp + v - uvw;\n                \n                    float d = length(diff);\n                \n                    if(d < res.x)\n                    {\n                        res.xyz = float3(d, res.x, res.y);\n                    }\n                    else if(d < res.y)\n                    {\n                        res.xyz = float3(res.x, d, res.y);\n                    }\n                    else if(d < res.z)\n                    {\n                        res.z = d;\n                    }\n                \n                    res.w = WorleyHash31(gp);\n                }\n            }\n        }\n\n        return res.x;\n    }\n    \n      \n    float3 Hash3D( float3 p )\n    {\n        p = float3( dot(p,float3(127.1,311.7, 74.7)),\n                dot(p,float3(269.5,183.3,246.1)),\n                dot(p,float3(113.5,271.9,124.6)));\n\n        return -1.0 + 2.0*frac(sin(p)*437.5453123);\n    }\n\n    float Noise3D( float3 p )\n    {\n        float3 i = floor( p );\n        float3 f = frac( p );\n         \n        float3 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),\n                    lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n    }\n\n    \n    float FBM2D(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           return SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n\n    }\n      \n    float FBM3D(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           half A = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.zy).g;\n           half B = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33).g;\n           half C = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoise(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3D(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3D(d.localSpacePosition * frequency+ offset, d.localSpaceNormal);\n        #else\n           return FBM2D(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n    \n    #if _SURFACEGRADIENT  \n\n    #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)\n\n      \n      \n    half3 SurfaceGradientFromTBN(ShaderData d, half2 deriv)\n    {\n        return deriv.x * d.TBNMatrix[0] + deriv.y * d.TBNMatrix[1];\n    }\n\n    half2 TspaceNormalToDerivative(half3 vM)\n    {\n        const half scale = 1.0/128.0;\n        const half3 vMa = abs(vM);\n        const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));\n\n        return -half2(vM.x, vM.y)/z_ma;\n    }\n\n    half3 SurfgradFromVolumeGradient(ShaderData d, half3 grad)\n    {\n        return grad - dot(d.worldSpaceNormal, grad) * d.worldSpaceNormal;\n    }\n\n    half3 SurfgradFromTriplanarProjection(ShaderData d, half3 pN, half3 xN, half3 yN, half3 zN)\n    {\n        const half w0 = pN.x;\n        const half w1 = pN.y;\n        const half w2 = pN.z;\n\n        half2 xD = TspaceNormalToDerivative(xN);\n        half2 yD = TspaceNormalToDerivative(yN);\n        half2 zD = TspaceNormalToDerivative(zN);\n\n        half3 volumeGrad = half3(w2 * zD.x + w1 * yD.y, w2 * zD.y + w0 * xD.y, w0 * xD.x + w1 * yD.x);\n\n        return SurfgradFromVolumeGradient(d, volumeGrad);\n    }\n\n    half3 ConvertNormalToGradient(ShaderData d, half3 normal)\n    {\n        half2 deriv = TspaceNormalToDerivative(normal);\n\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n    half3 ConvertNormal2ToGradient(ShaderData d, half2 packedNormal)\n    {\n        half2 tNormal = packedNormal;\n        half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF\n        half2 deriv = tNormal * -rcpZ;\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n\n    half3 ResolveNormalFromSurfaceGradient(ShaderData d, half3 gradient)\n    {\n        return normalize(d.worldSpaceNormal - gradient);\n    }\n\n    #endif // _SURFACEGRADIENT\n\n\n    // normals are in surface gradient or world space depending on settings, and can also be generated by height\n    half3 GetWorldSpaceNormal(ShaderData d, half3 normal, half pheight)\n    {\n       #if _SURFACEGRADIENT\n          return ResolveNormalFromSurfaceGradient(d, normal);\n       #elif _AUTONORMAL\n          float3 dx = ddx(d.worldSpacePosition);\n          float3 dy = ddy(d.worldSpacePosition);\n          float3 crossX = cross(float3(0,1,0), dx);\n          float3 crossY = cross(float3(0,1,0), dy);\n          float3 dt = abs(dot(crossY, dx));\n          float height = _AutoNormalStrength * 0.5 * pheight;\n          float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n          n.y *= -1.0;\n          return TangentToWorldSpace(d, normalize((dt * float3(0,1,0)) - n).xzy);\n       #else\n          return TangentToWorldSpace(d, normal);\n          \n       #endif\n       \n    }\n\n   void WaterBRDF (inout half3 albedo, inout half smoothness, half metallic, half wetFactor, half surfPorosity) \n   {\n      half porosity = saturate((( (1 - smoothness) - 0.5)) / max(surfPorosity, 0.001));\n      half factor = lerp(1, 0.2, (1 - metallic) * porosity);\n      albedo *= lerp(1.0, factor, wetFactor);\n      smoothness = lerp(smoothness, 0.92f, wetFactor);\n   }\n\n   void OffsetUV(inout Config c, float2 offset)\n   {\n       c.uv += offset;\n       c.uvT.uv0 += offset;\n       c.uvT.uv1 += offset;\n       c.uvT.uv2 += offset;\n       c.uvX.uv0 += offset;\n       c.uvX.uv1 += offset;\n       c.uvX.uv2 += offset;\n       c.uvY.uv0 += offset;\n       c.uvY.uv1 += offset;\n       c.uvY.uv2 += offset;\n       c.uvZ.uv0 += offset;\n       c.uvZ.uv1 += offset;\n       c.uvZ.uv2 += offset;\n   }\n\n\n    void TriangleGrid(float2 uv, float scale,\n       out float w1, out float w2, out float w3,\n       out int2 vertex1, out int2 vertex2, out int2 vertex3)\n    {\n       // Scaling of the input\n       uv *= 3.464 * scale; // 2 * sqrt(3)\n\n       // Skew input space into simplex triangle grid\n       const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);\n       float2 skewedCoord = mul(gridToSkewedGrid, uv);\n\n       // Compute local triangle vertex IDs and local barycentric coordinates\n       int2 baseId = int2(floor(skewedCoord));\n       float3 temp = float3(frac(skewedCoord), 0);\n       temp.z = 1.0 - temp.x - temp.y;\n       if (temp.z > 0.0)\n       {\n          w1 = temp.z;\n          w2 = temp.y;\n          w3 = temp.x;\n          vertex1 = baseId;\n          vertex2 = baseId + int2(0, 1);\n          vertex3 = baseId + int2(1, 0);\n       }\n       else\n       {\n          w1 = -temp.z;\n          w2 = 1.0 - temp.y;\n          w3 = 1.0 - temp.x;\n          vertex1 = baseId + int2(1, 1);\n          vertex2 = baseId + int2(1, 0);\n          vertex3 = baseId + int2(0, 1);\n       }\n    }\n\n    // Fast random hash function\n    float2 SimpleHash2(float2 p)\n    {\n       return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 43758.5453);\n    }\n\n\n    half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)\n    {\n        // compute weight with height map\n        const half epsilon = 1.0f / 1024.0f;\n        half3 weights = half3(iWeights.x * (tex0 + epsilon), \n                                 iWeights.y * (tex1 + epsilon),\n                                 iWeights.z * (tex2 + epsilon));\n\n        // Contrast weights\n        half maxWeight = max(weights.x, max(weights.y, weights.z));\n        half transition = contrast * maxWeight;\n        half threshold = maxWeight - transition;\n        half scale = 1.0f / transition;\n        weights = saturate((weights - threshold) * scale);\n        // Normalize weights.\n        half weightScale = 1.0f / (weights.x + weights.y + weights.z);\n        weights *= weightScale;\n        return weights;\n    }\n\n\n    half3 PackedUnpackScaleNormal(half4 packedNormal, float scale)\n   {\n       #if _PACKEDFAST\n          half3 normal;\n          normal.xy = (packedNormal.ag * 2 - 1) * scale;\n          normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n          return normal;  \n       #endif\n       return UnpackScaleNormal(packedNormal, scale);\n   }\n\n    void InitStochasticDxDy(inout SampleConfig c, Config cfg)\n    {\n      c.dx0 = ddx(cfg.origUV) * cfg.origScale;\n      c.dy0 = ddy(cfg.origUV) * cfg.origScale;\n      c.dx1 = c.dx0; c.dx1 = c.dx0;\n      c.dx2 = c.dy0; c.dy2 = c.dy0;\n    }\n\n    void PrepareStochasticUVs(float scale, float2 uv, out SampleConfig c)\n    {\n       // Get triangle info\n       ZERO_INITIALIZE(SampleConfig, c);\n       float w1, w2, w3;\n       int2 vertex1, vertex2, vertex3;\n       TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n       // Assign random offset to each triangle vertex\n       c.uv0 = uv;\n       c.uv1 = uv;\n       c.uv2 = uv;\n   \n       c.uv0.xy += SimpleHash2(vertex1);\n       c.uv1.xy += SimpleHash2(vertex2);\n       c.uv2.xy += SimpleHash2(vertex3);\n       c.weights = half3(w1, w2, w3);\n       c.origWeights = half3(w1, w2, w3);\n    }\n\n\n   half3 LitBlendDetailNormal(half3 n1, half3 n2)\n   {\n      #if _SURFACEGRADIENT\n         return n1 + n2;\n      #else\n         return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n      #endif\n   }\n\n   float3 TriplanarBlendUnpackedRNM(float3 n1, float3 n2)\n   {\n       n1.z += 1;\n       n2.xy = -n2.xy;\n       return n1 * dot(n1, n2) / n1.z - n2;\n   }\n\n   void InitConfigDxDy(inout Config c)\n   {\n      c.uvT.dx0 = ddx(c.uvT.uv0);\n      c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1);\n      c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2);\n      c.uvT.dy2 = ddy(c.uvT.uv2);\n   }\n\n   Config CreateConfig(ShaderData d, float4 scale, float space, int uvsource, half triplanarContrast)\n   {\n      Config c;\n      ZERO_INITIALIZE(Config, c);\n\n      float3 pos = d.worldSpacePosition;\n      float3 normal = d.worldSpaceNormal;\n      if (space > 0)\n      {\n         pos = d.localSpacePosition;\n         normal = d.localSpaceNormal;\n      }\n\n      c.uv = d.texcoord0.xy;\n      \n      if (uvsource == 1)\n        c.uv = d.texcoord1.xy;\n      else if (uvsource == 2)\n        c.uv = pos.yz * float2(1, -1);\n      else if (uvsource == 3)\n        c.uv = pos.xz * float2(1, -1);\n      else if (uvsource == 4)\n        c.uv = pos.xy * float2(1, -1);\n\n      c.origUV = c.uv;\n      c.origScale = scale.xy;\n\n      c.uv = c.uv * scale.xy + scale.zw;\n      c.dx = ddx(c.uv);\n      c.dy = ddy(c.uv);\n\n      c.normal = normal;\n      c.uvT.uv0 = pos.zy * scale.xy + scale.zw;\n      c.uvT.uv1 = pos.xz * scale.xy + scale.zw;\n      c.uvT.uv2 = pos.xy * scale.xy + scale.zw;\n        \n      c.uvT.uv1 += 0.33;\n      c.uvT.uv2 += 0.67;\n\n      c.uvT.dx0 = ddx(c.uvT.uv0); c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1); c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2); c.uvT.dy2 = ddy(c.uvT.uv2);\n\n      half3 triblend = saturate(pow(abs(c.normal), triplanarContrast));\n      triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n      c.uvT.weights = triblend;\n      c.uvT.origWeights = triblend;\n      c.axisSign = d.worldSpaceNormal < 0 ? -1 : 1;\n      c.absVertNormal = abs(d.worldSpaceNormal);\n     \n\n      return c;\n   }\n\n\n   half4 TriSample(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0) * c.weights.x;\n      }\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1) * c.weights.y;\n      }  \n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2) * c.weights.z;\n      }\n\n      return res;\n   }\n\n   half4 TriSampleBary(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      c.weights = BaryWeightBlend(c.origWeights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   half4 TriSampleGrad(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvX, contrast, d) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvY, contrast, d) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n           res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvZ, contrast, d) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   \n   half4 SampleTexBaryStochastic(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   half4 SampleTexBaryTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleGrad(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   \n   half4 SampleTexBary(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        COUNTSAMPLE\n        return SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv, c.dx, c.dy);\n   }\n\n   half4 SampleTexStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ) * c.uvT.weights.z;\n\n        return res;     \n   }\n\n   \n   half4 SampleTexStochastic(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n\n   half4 SampleTexTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n   \n   half4 SampleTex(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       COUNTSAMPLE\n       return SAMPLE_TEXTURE2D(tex, ss, c.uv);\n   }\n   \n\n \n   half3 SampleNormalStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n         dataX = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n         dataY = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n         dataZ = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ));\n\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n\n          return WorldToTangentSpace(d, worldNormal);\n       #endif\n   }\n\n\n   half3 SampleNormalTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n      {\n          COUNTSAMPLE\n          dataX = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv0, c.uvT.dx0, c.uvT.dy0));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n      {\n          COUNTSAMPLE\n          dataY = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv1, c.uvT.dx1, c.uvT.dy1));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n      {\n         COUNTSAMPLE\n         dataZ = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv2, c.uvT.dx2, c.uvT.dy2));\n      }\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n          return WorldToTangentSpace(d, worldNormal);\n      #endif\n   }\n\n   half3 SampleNormalStochastic(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n     half4 normal = TriSample(tex, ss, c.uvT);\n     #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half3 SampleNormal(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 normal = SAMPLE_TEXTURE2D(tex, ss, c.uv);\n      #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half HeightBlend(half h1, half h2, half slope, half contrast)\n   {\n      h2 = 1 - h2;\n      half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); \n      half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));\n      return blend;\n   }\n\n\n    #if _POM\n    float2 POM(TEXTURE2D_PARAM(tex, ss), Config c, float contrast, ShaderData d)\n    {\n       float2 curv = float2(0, 0);\n       float refPlane = 0;\n\n       float result = 0;\n       int stepIndex = 0;\n       int maxSamples = _POMMaxSamples;\n       int minSamples = 4;\n       float camDist = distance(_WorldSpaceCameraPos, d.worldSpacePosition);\n       float distanceFade = 1 - saturate((camDist - _POMMin) / max(1, _POMFade));\n       int numSteps = ( int )lerp( maxSamples, minSamples, dot( d.worldSpaceNormal, d.worldSpaceViewDir )) * distanceFade;\n       if (numSteps < 1)\n           numSteps = 1;\n       float layerHeight = 1.0 / numSteps;\n       float2 plane = _ParallaxHeight * ( d.tangentSpaceViewDir.xy / d.tangentSpaceViewDir.z ) * distanceFade;\n       OffsetUV(c, refPlane * plane);\n       float2 deltaTex = -plane * layerHeight;\n       float2 prevTexOffset = 0;\n       float prevRayZ = 1.0f;\n       float prevHeight = 0.0f;\n       float2 currTexOffset = deltaTex;\n       float currRayZ = 1.0f - layerHeight;\n       float currHeight = 0.0f;\n       float intersection = 0;\n       float2 finalTexOffset = 0;\n\n       while ( stepIndex < numSteps + 1 )\n       {\n          result = dot( curv, currTexOffset * currTexOffset );\n          Config cfg = c;\n          OffsetUV(cfg, currTexOffset);\n          currHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( currHeight > currRayZ )\n          {\n             stepIndex = numSteps + 1;\n          }\n          else\n          {\n             stepIndex++;\n             prevTexOffset = currTexOffset;\n             prevRayZ = currRayZ;\n             prevHeight = currHeight;\n             currTexOffset += deltaTex;\n             currRayZ -= layerHeight * ( 1 - result );\n          }\n       }\n       int sectionSteps = 10;\n       int sectionIndex = 0;\n       float newZ = 0;\n       float newHeight = 0;\n       while ( sectionIndex < sectionSteps )\n       {\n          intersection = ( prevHeight - prevRayZ ) / ( prevHeight - currHeight + currRayZ - prevRayZ );\n          finalTexOffset = prevTexOffset + intersection * deltaTex;\n          newZ = prevRayZ - intersection * layerHeight;\n          Config cfg = c;\n          OffsetUV(cfg, finalTexOffset);\n          newHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( newHeight > newZ )\n          {\n             currTexOffset = finalTexOffset;\n             currHeight = newHeight;\n             currRayZ = newZ;\n             deltaTex = intersection * deltaTex;\n             layerHeight = intersection * layerHeight;\n          }\n          else\n          {\n             prevTexOffset = finalTexOffset;\n             prevHeight = newHeight;\n             prevRayZ = newZ;\n             deltaTex = ( 1 - intersection ) * deltaTex;\n             layerHeight = ( 1 - intersection ) * layerHeight;\n          }\n          sectionIndex++;\n       }\n       #if _PASSHADOWS\n       if ( unity_LightShadowBias.z == 0.0 )\n       {\n       #endif\n          if ( result > 1 )\n             clip( -1 );\n       #if _PASSHADOWS\n       }\n       #endif\n       return finalTexOffset;\n    }\n    #endif\n\n   \n\n   // tess versions\n   #if _TESSELLATION_ON\n   half4 TriSampleLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias) * c.weights.x;\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias) * c.weights.y;\n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias) * c.weights.z;\n\n      return res;\n   }\n\n   half4 TriSampleBaryLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias, float contrast)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias);\n      half4 r2 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias);\n      half4 r3 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias);\n      c.weights = BaryWeightBlend(c.weights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryLODStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvX, bias, contrast) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvY, bias, contrast) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvZ, bias, contrast) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   half4 SampleTexBaryLODStochastic(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n       return TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias, contrast);\n   }\n\n   half4 SampleTexBaryLODTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return TriSampleLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias);\n   }\n\n   half4 SampleTexBaryLOD(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv, bias);\n   }\n\n\n    float FBM2DLOD(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           return SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv, _TessellationMipBias).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n        \n        \n    }\n\n    float FBM3DLOD(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           half A = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.zy, _TessellationMipBias).g;\n           half B = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33, _TessellationMipBias).g;\n           half C = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67, _TessellationMipBias).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoiseLOD(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3DLOD(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3DLOD(d.localSpacePosition * frequency + offset, d.localSpaceNormal);\n        #else\n           return FBM2DLOD(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n   #endif //_TESSELLATION_ON\n\n\n    half3 FuzzyShade(ShaderData d, half height, half3 color, half3 normal, half coreMult, half edgeMult, half power)\n    {\n        float3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half dt = saturate(dot(d.worldSpaceViewDir, worldNormal));\n        half dark = 1.0 - (coreMult * dt);\n        half edge = pow(1-dt, abs(power)) * edgeMult;\n        return color * (dark + edge);\n    }\n\n\thalf MicroShadow(ShaderData d, half3 normal, half height, half ao, half strength)\n\t{\n        float3 sun;\n\t\tfloat3 sunColor;\n\t\tGetSun(sun, sunColor);\n\t\tfloat3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half shadow = saturate(abs(dot(worldNormal, sun)) + (ao * ao * 2.0) - 1.0);\n        return 1 - ((1-shadow) * strength);\n\t}\n\n\n#endif\n\n\n\n   #if defined(_SPECULAR)\n      #define _USESPECULAR 1\n      #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n   #endif\n\n   \n   TEXTURE2D(_AlbedoMap);\n   SAMPLER(sampler_AlbedoMap);\n   TEXTURE2D(_NormalMap);\n   SAMPLER(sampler_NormalMap);\n   TEXTURE2D(_MaskMap);\n   TEXTURE2D(_DetailMap);\n   TEXTURE2D(_EmissionMap);\n\n   #if _SPECULAR\n       TEXTURE2D(_SpecularMap);\n   #endif\n\n   \n   \n   void Ext_SurfaceFunction0 (inout Surface o, inout ShaderData d)\n   {\n      // define samplers based on settings\n      #undef SAMPLEBARY\n      #undef SAMPLE\n      #undef SAMPLENORMAL\n      #if _STOCHASTIC && _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n        #define SAMPLE     SampleTexStochasticTriplanar\n        #define SAMPLENORMAL SampleNormalStochasticTriplanar\n      #elif _STOCHASTIC\n        #define SAMPLEBARY SampleTexBaryStochastic\n        #define SAMPLE     SampleTexStochastic\n        #define SAMPLENORMAL SampleNormalStochastic\n      #elif _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryTriplanar\n        #define SAMPLE     SampleTexTriplanar\n        #define SAMPLENORMAL SampleNormalTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBary\n        #define SAMPLE     SampleTex\n        #define SAMPLENORMAL SampleNormal\n      #endif\n\n      Config c = CreateConfig(d, _AlbedoMap_ST, _TriplanarSpace, _UVSource, _TriplanarContrast);\n      InitConfigDxDy(c);\n      #if _STOCHASTIC && !_TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uv, c.uvT);\n         InitStochasticDxDy(c.uvT, c);\n      #elif _STOCHASTIC && _TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv0, c.uvX);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv1, c.uvY);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv2, c.uvZ);\n         InitStochasticDxDy(c.uvX, c);\n         InitStochasticDxDy(c.uvY, c);\n         InitStochasticDxDy(c.uvZ, c);\n      #endif\n\n      #if _POM\n          // would need to handle height remapping if we ever want to ship this\n          float2 pomOffset = POM(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n          OffsetUV(c, pomOffset);\n      #endif\n\n      half4 albedo = SAMPLEBARY(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n      \n      #if _PARALLAX\n         float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n         OffsetUV(c, offset);\n         albedo = SAMPLE(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c);\n         \n      #endif\n      albedo.a = lerp(_HeightRemap.x, _HeightRemap.y, albedo.a);\n      albedo.rgb *= _Tint.rgb;\n\n      albedo.rgb = AdjustContrast(albedo.rgb, _AlbedoContrast);\n      albedo.rgb += _AlbedoBrightness;\n\n\n      if (_AlphaThreshold > 0)\n      {\n         clip(albedo.a - _AlphaThreshold);\n      }\n\n      #if defined(_FLATSHADE)\n\t\t     float3 dx = ddx(d.worldSpacePosition);\n\t\t     float3 dy = ddy(d.worldSpacePosition);\n\t\t     float3 worldNormal = normalize(cross(dy, dx));\n\t\t     worldNormal = lerp(d.worldSpaceNormal, worldNormal, _FlatShadingBlend);\n\t\t     d.worldSpaceNormal = worldNormal;\n\t\t     d.TBNMatrix[2] = worldNormal;\n      #endif\n\n\n\n      o.Albedo = albedo.rgb;\n      o.Alpha = albedo.a;\n\n      float smoothness = _Smoothness;\n      float ao = 1;\n\n      #if defined(_NORMALMAP) && !defined(_AUTONORMAL)\n         o.Normal = SAMPLENORMAL(TEXTURE2D_ARGS(_NormalMap, sampler_NormalMap), c, d, _NormalStrength, smoothness, ao);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, ao);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n      #endif\n\n      half detailMask = 1;\n      o.Smoothness = smoothness;\n      o.Occlusion = ao;\n      o.Metallic = _Metallic;\n      #if defined(_MASKMAP) && !_PACKEDFAST\n         // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = SampleTex(TEXTURE2D_ARGS(_MaskMap, sampler_AlbedoMap), c);\n         o.Metallic = lerp(_MetallicRemap.x, _MetallicRemap.y, mask.r);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, mask.g);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, mask.a);\n         detailMask = mask.b;\n      #endif // separate maps\n\n      #if _SPECULAR\n         o.Specular = SAMPLE(TEXTURE2D_ARGS(_SpecularMap, sampler_AlbedoMap), c).rgb;\n      #endif\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = SAMPLE(TEXTURE2D_ARGS(_EmissionMap, sampler_AlbedoMap), c).rgb * _EmissionColor;\n      #endif\n\n      if (_FuzzyShadingOn > 0)\n      {\n        o.Albedo *= FuzzyShade(d, albedo.a, _FuzzyShadingColor, o.Normal, _FuzzyShadingParams.x, _FuzzyShadingParams.y, _FuzzyShadingParams.z);\n      }\n\n\n      // HDRP style detail texturing\n\n      #if defined(_DETAIL)\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _DETAILSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n         Config dc = CreateConfig(d, _DetailMap_ST, _DetailTriplanarSpace, _DetailUVSource, _DetailTriplanarContrast);\n         InitConfigDxDy(dc);\n         #if _DETAILSTOCHASTIC && !_DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uv, dc.uvT);\n             InitStochasticDxDy(dc.uvT, dc);\n         #elif _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv0, dc.uvX);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv1, dc.uvY);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv2, dc.uvZ);\n             InitStochasticDxDy(dc.uvX, dc);\n             InitStochasticDxDy(dc.uvY, dc);\n             InitStochasticDxDy(dc.uvZ, dc);\n         #endif\n\n         half4 detailSample = SAMPLEBARY(TEXTURE2D_ARGS(_DetailMap, sampler_AlbedoMap), dc, _DetailStochasticContrast, d);\n         smoothness = detailSample.z;\n         #if !_AUTONORMAL\n            half3 dnormal = float3(detailSample.ag * 2 - 1, 1) * detailMask * _DetailNormalStrength;\n            dnormal.z = sqrt(1 - dnormal.x * dnormal.x - dnormal.y * dnormal.y);\n            #if _SURFACEGRADIENT\n               dnormal = ConvertNormalToGradient(d, dnormal);\n            #endif\n            o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n         #endif\n     \n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * smoothness, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n      if (_MicroShadowStrength > 0)\n      {\n        o.Occlusion *= MicroShadow(d, o.Normal, o.Alpha, o.Occlusion, _MicroShadowStrength);\n      }\n  \n      // in case something needs height in the stack..\n      o.Height = o.Alpha;\n\n\n      \n   }\n\n\n\n\t#if _TINTMASK\n\t\tTEXTURE2D(_TintMask);\n\t\tSAMPLER(sampler_TintMask);\n\t#endif\n\n\tvoid Ext_SurfaceFunction1 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _TINTMASK\n\t\t   half4 w = SAMPLE_TEXTURE2D(_TintMask, sampler_TintMask, d.texcoord0.xy * _TintMask_ST.xy + _TintMask_ST.zw);\n\t\t   // allow black to be no tint..\n\t\t   half3 tint = o.Albedo * (_RColor.rgb * 2 * w.r + _GColor.rgb * 2 * w.g + _BColor.rgb * 2 * w.b + _AColor.rgb * 2 * w.a);\n\t\t   o.Albedo = lerp(o.Albedo, tint, saturate(w.r + w.g + w.b + w.a));\n\t\t#endif\n\t}\n\n\n\n\n\t#if _LAYERTEXTUREMASK\n       TEXTURE2D(_LayerTextureMask);\n       SAMPLER(sampler_LayerTextureMask); \n    #endif\n\n   void Ext_ModifyTessellatedVertex2 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON\n          float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n\n          #if _LAYERTEXTUREMASK\n               float2 layerUV = v.texcoord0.xy;\n               if (_LayerTextureMaskUVMode == 1)\n                  layerUV = v.texcoord1.xy;\n               else if (_LayerTextureMaskUVMode == 2)\n                  layerUV = worldSpacePosition.yz;\n               else if (_LayerTextureMaskUVMode == 3)\n                  layerUV = worldSpacePosition.xz;\n               else if (_LayerTextureMaskUVMode == 4)\n                  layerUV = worldSpacePosition.xy;\n\n              e.blackboard.weightTextureMask = SAMPLE_TEXTURE2D_LOD(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw, _TessellationMipBias);\n          #endif\n      #endif\n    }\n\n\n\tvoid Ext_SurfaceFunction2 (inout Surface o, inout ShaderData d)\n\t{\n\t\t#if _LAYERTEXTUREMASK\n           float2 layerUV = d.texcoord0.xy;\n           if (_LayerTextureMaskUVMode == 1)\n              layerUV = d.texcoord1.xy;\n           else if (_LayerTextureMaskUVMode == 2)\n              layerUV = d.worldSpacePosition.yz;\n           else if (_LayerTextureMaskUVMode == 3)\n              layerUV = d.worldSpacePosition.xz;\n           else if (_LayerTextureMaskUVMode == 4)\n              layerUV = d.worldSpacePosition.xy;\n\n          d.blackboard.weightTextureMask = SAMPLE_TEXTURE2D(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw);\n      #endif\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap);\n   SAMPLER(sampler_LayerAlbedoMap);\n   TEXTURE2D(_LayerNormalMap);\n   TEXTURE2D(_LayerMaskMap);\n   TEXTURE2D(_LayerEmissionMap);\n\n   \n\n   void Ext_ModifyTessellatedVertex3 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER) && defined(_LAYERALBEDO) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n         half detailMask = 1;\n         #if _LAYERNOISE\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency,  _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin;\n            dt = saturate(dt * _LayerFalloff);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight) * _LayerFalloff);\n            if (_LayerInvertHeight > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength;\n         detailMask *= _LayerTessStrength;\n\n         #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast).a;\n         albedo = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo);\n\n         if (_LayerBlendMode == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction3 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n            // noise up the mask\n            #if _LAYERNOISE\n               mask = DoNoise(d, _LayerNoiseFrequency, _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend);\n\t    \n                dt -= _LayerAngleMin;\n                dt = saturate(dt * _LayerFalloff);\n\n                float hf = saturate((o.Height - _LayerHeight) * _LayerFalloff);\n                if (_LayerInvertHeight > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 0\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 0\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength;\n\n            #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint, 0.5);\n            #if defined(_LAYERALBEDO)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c, _LayerStochasticContrast, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c);\n                #endif\n                albedo.rgb *= _LayerTint;\n                albedo.a = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL || _LAYERMASK\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap, sampler_LayerAlbedoMap, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast);\n            albedo.rgb += _LayerAlbedoBrightness;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap, sampler_LayerAlbedoMap), c, d, _LayerNormalStrength * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO)\n                if (_LayerFuzzyShadingOn > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor.rgb, dnormal,\n                                            _LayerFuzzyShadingParams.x, _LayerFuzzyShadingParams.y, _LayerFuzzyShadingParams.z);\n                }\n\n                if (_LayerBlendMode == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast);\n                else if (_LayerBlendMode == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE\n                      float maskDif = (_LayerBlendContrast * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength);\n                   #if _LAYERNOISE\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap, sampler_LayerAlbedoMap), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength);\n                }\n\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap, sampler_LayerAlbedoMap), c).rgb * _LayerEmissionColor;\n                #if _LAYERALBEDO\n                    if (_LayerBlendMode > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_1);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_1);\n   TEXTURE2D(_LayerNormalMap_Ext_1);\n   TEXTURE2D(_LayerMaskMap_Ext_1);\n   TEXTURE2D(_LayerEmissionMap_Ext_1);\n\n   \n\n   void Ext_ModifyTessellatedVertex4 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_1) && defined(_LAYERALBEDO_DEF_1) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_1\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_1,  _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_1\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_1;\n            dt = saturate(dt * _LayerFalloff_Ext_1);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n            if (_LayerInvertHeight_Ext_1 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_1;\n         detailMask *= _LayerTessStrength_Ext_1;\n\n         #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_1).a;\n         albedo = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo);\n\n         if (_LayerBlendMode_Ext_1 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_1);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_1 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction4 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_1)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_1\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_1, _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_1\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_1);\n\t    \n                dt -= _LayerAngleMin_Ext_1;\n                dt = saturate(dt * _LayerFalloff_Ext_1);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n                if (_LayerInvertHeight_Ext_1 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 01\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 01\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_1;\n\n            #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_1, 0.5);\n            #if defined(_LAYERALBEDO_DEF_1)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, _LayerStochasticContrast_Ext_1, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_1;\n                albedo.a = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_1 || _LAYERMASK_DEF_1\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_1);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_1;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, d, _LayerNormalStrength_Ext_1 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_1)\n                if (_LayerFuzzyShadingOn_Ext_1 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_1.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_1.x, _LayerFuzzyShadingParams_Ext_1.y, _LayerFuzzyShadingParams_Ext_1.z);\n                }\n\n                if (_LayerBlendMode_Ext_1 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_1);\n                else if (_LayerBlendMode_Ext_1 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_1 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_1);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_1\n                      float maskDif = (_LayerBlendContrast_Ext_1 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_1 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                   #if _LAYERNOISE_DEF_1\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_1));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_1 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_1);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_1) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_1 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_1);\n                }\n\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_1);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_1, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_1, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_1\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c).rgb * _LayerEmissionColor_Ext_1;\n                #if _LAYERALBEDO_DEF_1\n                    if (_LayerBlendMode_Ext_1 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_2);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_2);\n   TEXTURE2D(_LayerNormalMap_Ext_2);\n   TEXTURE2D(_LayerMaskMap_Ext_2);\n   TEXTURE2D(_LayerEmissionMap_Ext_2);\n\n   \n\n   void Ext_ModifyTessellatedVertex5 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_2) && defined(_LAYERALBEDO_DEF_2) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_2\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_2,  _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_2\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_2;\n            dt = saturate(dt * _LayerFalloff_Ext_2);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n            if (_LayerInvertHeight_Ext_2 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_2;\n         detailMask *= _LayerTessStrength_Ext_2;\n\n         #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_2).a;\n         albedo = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo);\n\n         if (_LayerBlendMode_Ext_2 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_2);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_2 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction5 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_2)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_2\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_2, _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_2\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_2);\n\t    \n                dt -= _LayerAngleMin_Ext_2;\n                dt = saturate(dt * _LayerFalloff_Ext_2);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n                if (_LayerInvertHeight_Ext_2 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 02\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 02\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_2;\n\n            #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_2, 0.5);\n            #if defined(_LAYERALBEDO_DEF_2)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, _LayerStochasticContrast_Ext_2, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_2;\n                albedo.a = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_2 || _LAYERMASK_DEF_2\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_2);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_2;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, d, _LayerNormalStrength_Ext_2 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_2)\n                if (_LayerFuzzyShadingOn_Ext_2 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_2.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_2.x, _LayerFuzzyShadingParams_Ext_2.y, _LayerFuzzyShadingParams_Ext_2.z);\n                }\n\n                if (_LayerBlendMode_Ext_2 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_2);\n                else if (_LayerBlendMode_Ext_2 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_2 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_2);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_2\n                      float maskDif = (_LayerBlendContrast_Ext_2 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_2 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                   #if _LAYERNOISE_DEF_2\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_2));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_2 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_2);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_2) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_2 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_2);\n                }\n\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_2);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_2, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_2, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_2\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c).rgb * _LayerEmissionColor_Ext_2;\n                #if _LAYERALBEDO_DEF_2\n                    if (_LayerBlendMode_Ext_2 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   #if _TRAX_ON\n   TEXTURE2D(_TraxAlbedo);\n   SAMPLER(sampler_TraxAlbedo);\n   TEXTURE2D(_TraxPackedNormal);\n   TEXTURE2D(_TraxMask);\n\n   sampler2D_float _GMSTraxBuffer;\n\n   float4 _GMSTraxBuffer_TexelSize;\n   float3 _GMSTraxBufferPosition;\n   float _GMSTraxBufferWorldSize;\n   float _GMSTraxFudgeFactor;\n\n   float SampleTraxBufferLOD(float3 worldPos)\n   {    \n      // generate UVs for the buffer, which is moving\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 8);\n      uv *= 0.5;\n      uv += 0.5;\n            \n      float s =  tex2Dlod(_GMSTraxBuffer, float4(uv, 0, 0)).r;\n\n      return 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n   }\n         \n        \n   float SampleTraxBuffer(float3 worldPos, out float3 norm)\n   {\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 3);\n      uv *= 0.5;\n      uv += 0.5;\n            \n\n      float2 offset = _GMSTraxBuffer_TexelSize.xy;\n\n      float s = tex2D(_GMSTraxBuffer, uv).r;\n               \n      float s1 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, -1)).r;\n      float s2 = tex2D(_GMSTraxBuffer, uv + offset * float2(-1, 0)).r;\n      float s3 = tex2D(_GMSTraxBuffer, uv + offset * float2(1, 0)).r;\n      float s4 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, 1)).r;\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      float r = 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n \n      // generate normals\n      norm.x = (s1 - s4) * 0.25; \n      norm.y = (s2 - s3) * 0.25;\n      norm.z = 2;\n      norm = normalize(norm);\n     \n      norm.xy *= 1 - r;\n            \n      return r;\n   }\n   #endif\n\n   void Ext_ModifyTessellatedVertex6 (inout VertexData v, inout ExtraV2F d)\n   {\n       #if _TESSELLATION_ON && _TRAX_ON && _HAS_LIT_TESSELLATION\n          \n           float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n           float3 worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n           float traxBuffer = SampleTraxBufferLOD(worldSpacePosition);\n           d.blackboard.traxBuffer = traxBuffer;\n           float2 uv = worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n           half albedo = SAMPLE_TEXTURE2D_LOD(_TraxAlbedo, sampler_TraxAlbedo, uv, _TraxMipBias).a;\n\n           float traxOffset = albedo * _TraxDisplacementStrength;\n           traxOffset *= 1 - v.texcoord0.z;\n           traxOffset *= _TessellationDisplacement;\n           float dig = _TraxDisplacementDepth * (1 - v.texcoord0.z);\n           float3 traxVertex = d.blackboard.originalVertexPosition + (v.normal * (traxOffset - dig));\n           v.vertex.xyz = lerp(traxVertex, v.vertex.xyz, traxBuffer);\n\n           d.blackboard.vertexHeightOffset = lerp(traxOffset-dig, d.blackboard.vertexHeightOffset, traxBuffer);\n\n       #endif\n\n   }\n\n   void Ext_SurfaceFunction6 (inout Surface o, inout ShaderData d)\n   {\n      #if _TRAX_ON\n        float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n        float2 fsdx = ddx(uv);\n        float2 fsdy = ddy(uv);\n\n        float3 traxNormal;\n        float traxBuffer = SampleTraxBuffer(d.worldSpacePosition, traxNormal);\n        \n        #if _TESSELLATION_ON\n            traxBuffer -= _TraxDisplacementDepth;\n        #endif\n\n        d.blackboard.traxBuffer = traxBuffer;\n\n        UNITY_BRANCH\n        if (traxBuffer > 0)\n        {\n            half4 albedo = SAMPLE_TEXTURE2D_GRAD(_TraxAlbedo, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            albedo.rgb *= _TraxTint.rgb;\n            half4 normalSample = SAMPLE_TEXTURE2D_GRAD(_TraxPackedNormal, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n\n            half smoothness = normalSample.r;\n            half ao = normalSample.b;\n            half3 normal;\n            normal.xy = (normalSample.ag * 2 - 1) * _TraxNormalStrength;\n            normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n\n            \n            half h = HeightBlend(albedo.a, o.Alpha, traxBuffer, _TraxHeightContrast);\n\n            h = lerp(traxBuffer, h, _TraxInterpContrast);\n\n            o.Albedo = lerp(albedo, o.Albedo, h);\n\n            #if _SURFACEGRADIENT\n                o.Normal = lerp(normal, o.Normal, h);\n            #else\n                o.Normal = lerp(normal + traxNormal, o.Normal, h);\n            #endif\n        \n            o.Smoothness = lerp(smoothness, o.Smoothness, h);\n            o.Occlusion = lerp(ao, o.Occlusion, h);\n        }\n      #endif\n   }\n\n\n\n\n    #if _RAINDROPS\n       TEXTURE2D(_RainDropTexture);\n       SAMPLER(sampler_RainDropTexture);\n       half _Global_RainIntensity;\n    #endif\n\n    #if _WETNESS\n       half2 _Global_WetnessParams; // global, not in cbuffer\n    #endif\n   \n    #if _RAINDROPS\n    half2 ComputeRipple(float2 uv, half time, half weight)\n    {\n        half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_RainDropTexture, uv);\n        COUNTSAMPLE\n        ripple.yz = ripple.yz * 2 - 1;\n\n        half dropFrac = frac(ripple.w + time);\n        half timeFrac = dropFrac - 1.0 + ripple.x;\n        half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);\n        half finalFactor = dropFactor * ripple.x * \n                                sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);\n\n        return half2(ripple.yz * finalFactor);\n    }\n    #endif\n\n    half2 DoRain(half2 waterNorm, float2 uv, out half2 ripple)\n    {\n        #if _RAINDROPS\n            float rainIntensity = _RainIntensityScale.x;\n            if (_RainMode > 1)\n            {\n                rainIntensity = _Global_RainIntensity;\n            }\n\n            half dropStrength = rainIntensity;\n            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); \n            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);\n            half4 times = _Time.yyyy;\n            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);\n\n            float2 ruv1 = uv * _RainIntensityScale.yy;\n            float2 ruv2 = ruv1;\n\n            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);\n            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);\n            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);\n            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);\n            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);\n            weights = saturate(weights * 4);\n\n            half2 rippleNormal = half2( weights.x * ripple1.xy +\n                        weights.y * ripple2.xy + \n                        weights.z * ripple3.xy + \n                        weights.w * ripple4.xy);\n\n            ripple = rippleNormal * dropStrength * rainIntensity;\n            waterNorm = lerp(waterNorm, normalize(half3(rippleNormal.xy + rippleNormal.xy, 1)).xy, rainIntensity * dropStrength); \n            return waterNorm;                        \n        #else\n            return waterNorm;\n        #endif\n    }\n\n   half2 _Global_PuddleParams;   // this is a global, so keep it out of the cbuffer\n   void GetPuddleParams(ShaderData d, inout float puddleMask, inout float pudHeight)\n   {\n      #if _PUDDLES || _GLOBALPUDDLES\n          pudHeight = _PuddleAmount;\n          if (_PuddleMode > 0)\n             pudHeight = _Global_PuddleParams.x;    \n      \n\n          half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t      dt -= _PuddleAngleMin;\n          dt = saturate(dt * _PuddleFalloff);\n          puddleMask *= dt;\n      #endif\n   }\n   \n   void Ext_ModifyTessellatedVertex7 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _PUDDLES && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n         half mask = 1;\n         half pudHeight = 1;\n\n         // save some ops by doing this in 2d\n         #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2DLOD(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2DLOD(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #else\n                mask = (FBM2DLOD(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n         #endif\n\n         GetPuddleParams(d, mask, pudHeight);\n         float height = pudHeight * mask;\n         if (e.blackboard.vertexHeightOffset < height)\n         {\n            e.blackboard.vertexHeightOffset = height;\n            height -= _TessellationOffset; \n            // dampen cracks\n            height *= 1 - v.texcoord0.z;\n            height *= _TessellationDisplacement;\n            v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n            \n        }\n      #endif\n   }\n\n\n#if _WETNESS\n\n   float GetWetnessLevel(Surface o, ShaderData d, float wetnessMask)\n   {\n      float wetLevel = clamp(_WetnessAmount, _WetnessMin, _WetnessMax);\n      \n      if (_WetnessMode > 0)\n         wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);\n\n      wetLevel = saturate(wetLevel + (1 - saturate(d.worldSpacePosition.y - _WetnessShoreline)));\n      float3x3 tbn = float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal);\n      float dt = dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0));\n      dt -= _WetnessAngleMin;\n      dt = saturate(dt * _WetnessFalloff * wetLevel);\n      dt *= wetnessMask;\n      return dt;\n   }\n#endif\n   \n\n   void Ext_SurfaceFunction7 (inout Surface o, ShaderData d)\n   {\n      half wetnessLevel = 0;\n      #if _WETNESS\n          wetnessLevel = GetWetnessLevel(o, d, 1); // mask one day?\n      #endif\n\n      half depthMask = 0;\n      half depth = 0;\n\n      #if _PUDDLES\n          half mask = 1;\n          half pudHeight = 1;\n          #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2D(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2D(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);      \n            #else\n                mask = (FBM2D(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n          #endif\n\n          GetPuddleParams(d, mask, pudHeight);\n          pudHeight *= mask;\n          depth = pudHeight - o.Height;\n          depthMask = saturate(depth * _PuddleFalloff);\n          depthMask *= _PuddleColor.a;\n          depth = o.Height - pudHeight;\n\n          // extend wetness slighting higher than the puddle\n          half wetmask = saturate((pudHeight + 0.05 - o.Height) * _PuddleFalloff);\n          wetnessLevel = max(wetmask, wetnessLevel);\n       #endif\n\n       \n       #if _WETNESS || _PUDDLES\n          half3 waterNorm = half3(0,0,1);\n          half3 wetAlbedo = o.Albedo;\n          half wetSmoothness = o.Smoothness;\n          #if _PUDDLES\n             wetAlbedo *= _PuddleColor.rgb;\n          #endif\n          WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetnessLevel, _Porosity);\n\n          half ri = 0;\n          half2 ripple = 0;\n          #if (_RAINDROPS || _GLOBALRAIN) && (_PUDDLES || _GLOBALPUDDLES)\n             ri = _RainIntensityScale.z;\n             waterNorm.xy = DoRain(waterNorm.xy, d.texcoord0.xy, ripple) * depthMask;\n          #endif\n\n          o.Normal = lerp(o.Normal, waterNorm, depthMask);\n          o.Normal = lerp(o.Normal, LitBlendDetailNormal(o.Normal, half3(ripple.xy, 1)), saturate(ri - depthMask) * wetnessLevel);\n          o.Occlusion = lerp(o.Occlusion, 1, depthMask);\n          o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetnessLevel);\n          o.Albedo = lerp(o.Albedo, wetAlbedo, wetnessLevel);\n          o.Emission *= 1 + depth;\n          o.Metallic *= 1 + depth;\n          o.Specular *= 1 + depth;\n\n       #endif\n\n   }\n\n\n\n\n    #if _SNOW\n       TEXTURE2D(_SnowAlbedo);\n       SAMPLER(sampler_SnowAlbedo);\n       TEXTURE2D(_SnowNormal);\n       TEXTURE2D(_SnowMaskMap);\n       #if _TRAX_ON\n          TEXTURE2D(_SnowTraxAlbedo);\n          TEXTURE2D(_SnowTraxNormal);\n          TEXTURE2D(_SnowTraxMaskMap);\n       #endif\n    #endif\n\n   float _Global_SnowLevel;\n\n\n   void Ext_ModifyVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n    #if (_SNOW)\n        float amount = _SnowAmount;\n        if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n        float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n        float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n        snowAmount -= _SnowAngle;\n        snowAmount *= _SnowContrast * 0.5;\n        snowAmount = saturate(snowAmount) * amount;\n        float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n        if (_SnowWorldFade.z > 0)\n        {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n        }\n        #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n        #endif\n        snowAmount = saturate(snowAmount);\n\n        #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n        #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n        #endif\n\n        float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n        v.vertex.xyz = v.vertex.xyz + displacementVec * snowAmount * snowAmount * _SnowVertexHeight;\n    #endif\n   }\n\n   void Ext_ModifyTessellatedVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _SNOW && _HAS_LIT_TESSELLATION\n         float amount = _SnowAmount;\n         if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n         float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n         float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n         snowAmount -= _SnowAngle;\n         snowAmount *= _SnowContrast * 0.5;\n         float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n         if (_SnowWorldFade.z > 0)\n         {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n         }\n\n         snowAmount = saturate(snowAmount) * amount;\n\n         #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n         #endif\n         snowAmount = saturate(snowAmount);\n\n         #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n         #endif\n\n         float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n         half heightMap = SAMPLE_TEXTURE2D_LOD(_SnowAlbedo, sampler_SnowAlbedo, worldPos.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw, 2);\n\n         float height = max(_SnowVertexHeight * 3 * snowAmount + snowAmount * heightMap, e.blackboard.vertexHeightOffset);\n         #if _TRAX_ON\n            height *= e.blackboard.traxBuffer;\n         #endif\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n\n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n         \n      #endif\n\n   }\n\n   void SampleSnowSurface(TEXTURE2D_PARAM(alb, ss), TEXTURE2D_PARAM(norm, ss2), TEXTURE2D_PARAM(mask, ss3),\n        ShaderData d, float2 uv, float2 dx, float2 dy, out half4 albedo, out half3 normal, out half2 smoothAO)\n   {\n      #if _SNOWSTOCHASTIC\n         float w1, w2, w3;\n         int2 vertex1, vertex2, vertex3;\n         TriangleGrid(uv, _SnowStochasticScale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n         // Assign random offset to each triangle vertex\n         float2 uv0 = uv;\n         float2 uv1 = uv;\n         float2 uv2 = uv;\n   \n         uv0.xy += SimpleHash2(vertex1);\n         uv1.xy += SimpleHash2(vertex2);\n         uv2.xy += SimpleHash2(vertex3);\n         half3 weights = half3(w1, w2, w3);\n\n         half4 albedo0 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv0, dx, dy);\n         half4 albedo1 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv1, dx, dy);\n         half4 albedo2 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv2, dx, dy);\n         COUNTSAMPLE\n         COUNTSAMPLE\n         COUNTSAMPLE\n         weights = BaryWeightBlend(weights, albedo0.a, albedo1.a, albedo2.a, _SnowStochasticContrast);\n         albedo = albedo0 * weights.x + albedo1 * weights.y + albedo2 * weights.z;\n\n         normal = half3(0,0,1);\n         smoothAO = half2(0, 1);\n\n         #if !_AUTONORMAL\n            half4 n0 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv0, dx, dy);\n            half4 n1 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv1, dx, dy);\n            half4 n2 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n            half4 snowNormSamp = n0 * weights.x + n1 * weights.y + n2 * weights.z;\n\n            normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n                \n            #if _PACKEDFAST\n               smoothAO.x = snowNormSamp.r;\n               smoothAO.y = snowNormSamp.b;\n            #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask0 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv0, dx, dy);\n            half4 snowMask1 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv1, dx, dy);\n            half4 snowMask2 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n            half4 snowMask = snowMask0 * weights.x + snowMask1 * weights.y + snowMask2 * weights.z;\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n      #else // not stochastic\n          albedo = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv, dx, dy);\n          COUNTSAMPLE\n\n          normal = half3(0,0,1);\n          smoothAO = half2(0, 1);\n\n          #if !_AUTONORMAL\n             half4 snowNormSamp = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv, dx, dy);\n             COUNTSAMPLE\n             normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n             #if _SURFACEGRADIENT\n                normal = ConvertNormalToGradient(d, normal);\n             #endif\n                 \n             #if _PACKEDFAST\n                smoothAO.x = snowNormSamp.r;\n                smoothAO.y = snowNormSamp.b;\n             #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv, dx, dy);\n            COUNTSAMPLE\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n     #endif // stochastic\n   }\n\n   \n   void Ext_SurfaceFunction8 (inout Surface o, ShaderData d)\n   {\n      #if _SNOW\n          float amount = _SnowAmount;\n          if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n          float snowAmount = lerp(dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), dot(d.worldSpaceNormal, float3(0,1,0)), amount * 0.8) + 1;\n          snowAmount -= _SnowAngle;\n          snowAmount *= _SnowContrast;\n          snowAmount = saturate(snowAmount) - (1-amount) * (1-amount);\n\n          if (_SnowWorldFade.z > 0)\n          {\n             float worldFade = saturate((d.worldSpacePosition.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n             snowAmount *= worldFade;\n          }\n\n          #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(d.worldSpacePosition.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n          #endif\n          snowAmount = saturate(snowAmount);\n\n          float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw;\n          float2 dx = ddx(uv);\n          float2 dy = ddy(uv);\n\n          #if _TRAX_ON\n              float2 tuv = d.worldSpacePosition.xz * float2(1, -1) * _SnowTraxAlbedo_ST.xy + _SnowTraxAlbedo_ST.zw;\n              float2 tdx = ddx(uv);\n              float2 tdy = ddy(uv);\n          #endif\n\n          #if _LAYERVERTEXMASK\n              snowAmount *= d.vertexColor.a;\n          #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n              snowAmount *= d.blackboard.weightTextureMask.a;\n          #endif\n\n          UNITY_BRANCH\n          if (snowAmount > 0)\n          {\n             half4 snowAlbedo;\n             half3 snowNormal;\n             half2 snowSmoothAO;\n             SampleSnowSurface(TEXTURE2D_ARGS(_SnowAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowNormal, sampler_SnowAlbedo),\n                    TEXTURE2D_ARGS(_SnowMaskMap, sampler_SnowAlbedo), d, uv, dx, dy, snowAlbedo, snowNormal, snowSmoothAO);\n\n             snowAlbedo.rgb *= _SnowTint.rgb;\n\n             #if _TRAX_ON\n                half traxBuffer = 1 - d.blackboard.traxBuffer;\n                UNITY_BRANCH\n                if (traxBuffer > 0)\n                {\n                    half4 tsnowAlbedo;\n                    half3 tsnowNormal;\n                    half2 tsnowSmoothAO;\n                    SampleSnowSurface(TEXTURE2D_ARGS(_SnowTraxAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowTraxNormal, sampler_SnowAlbedo),\n                        TEXTURE2D_ARGS(_SnowTraxMaskMap, sampler_SnowAlbedo), d, tuv, tdx, tdy, tsnowAlbedo, tsnowNormal, tsnowSmoothAO);\n\n                    tsnowAlbedo.rgb *= _SnowTraxTint;\n                    half h = HeightBlend(snowAlbedo.a, tsnowAlbedo.a, traxBuffer, 0.5);\n                    snowAlbedo = lerp(snowAlbedo, tsnowAlbedo, h);\n                    snowNormal = lerp(snowNormal, tsnowNormal, h);\n                    snowSmoothAO = lerp(snowSmoothAO, tsnowSmoothAO, h);\n                }\n             #endif\n\n             #if !_AUTONORMAL\n                o.Normal = lerp(o.Normal, snowNormal, snowAmount);\n             #endif\n             o.Albedo = lerp(o.Albedo, snowAlbedo.rgb, snowAmount);\n             o.Alpha = lerp(o.Alpha, snowAlbedo.a, snowAmount);\n             o.Smoothness = lerp(o.Smoothness, snowSmoothAO.x, snowAmount);\n             o.Occlusion = lerp(o.Occlusion, snowSmoothAO.y, snowAmount);\n             o.Height = o.Alpha;\n\n          }\n      #endif\n   }\n\n   \n\n\n\n\n\n   TEXTURE2D(_WindParticulate);\n   SAMPLER(sampler_WindParticulate);\n\n// In case we want to read it more than once..\n\n#ifndef __STACKABLE_WIND_INCLUDES__\n#define __STACKABLE_WIND_INCLUDES__\n\n\n   half FilterRange(float4 range, float y)\n   {\n      half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));\n      w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));\n      return w;\n   }\n\n   \n   float2 RotateUV(float2 uv, float amt)\n   {\n      uv -=0.5;\n      float s = sin ( amt);\n      float c = cos ( amt );\n      float2x2 mtx = float2x2( c, -s, s, c);\n      mtx *= 0.5;\n      mtx += 0.5;\n      mtx = mtx * 2-1;\n      uv = mul ( uv, mtx );\n      uv += 0.5;\n      return uv;\n   }\n\n\n   half FilterWindParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)\n   {\n      float2 windDir = RotateUV(float2(1, 0), windRot);\n      float2 flow = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));\n      float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill\n      return FilterRange(range, cofacing);\n   }\n\n   half ProcessWindParticulateMask(inout half mask, float contrast)\n   {\n      mask = pow(abs(mask), abs(contrast));\n      half invMask = 1.0 - mask;\n      invMask *= invMask; \n      invMask *= invMask;\n      return invMask;\n   }\n#endif // include guard\n\n   void Ext_SurfaceFunction9 (inout Surface o, ShaderData d)\n   {\n      #if _WIND_ON && !_PASSMETA\n   \n         float3 upVector = float3(0,0,1);\n\n         half upDot = max(0.0, dot(d.worldSpaceNormal, float3(0, 1, 0)));\n\n         float2 uv = d.worldSpacePosition.xz;\n         if (_WindParticulateSpace > 0.5)\n            uv = d.texcoord0.xy;\n         float windRotation = _WindParticulateRotation;\n         float windStrength = _WindParticulateStrength;\n\n         float2 wuv = RotateUV(uv, windRotation);\n\n         half windBlend = 1.0;\n\n         float windWorldMask = FilterRange(_WindParticulateWorldHeightMask, d.worldSpacePosition.y);\n         windWorldMask *= FilterRange(_WindParticulateAngleMask, upDot);\n\n         // compute mask\n         wuv *= float2(_WindParticulate_ST.x, 1) * _WindParticulate_ST.y + _WindParticulate_ST.zw;\n         float speed = _Time.x * _WindParticulateSpeed;\n         half w1 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv * 3 + speed * float2(1,0)).g;\n         half w2 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv + speed * float2(1.1,0)).a;\n         half windMask = (w1 * w2);\n\n         windMask *= windStrength * windBlend * windWorldMask;\n         windMask *= saturate((_WindParticulateTextureHeight - o.Height) * 10);\n\n         half windInvMask = ProcessWindParticulateMask(windMask, _WindParticulatePower);\n    \n         o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);\n         o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindParticulateEmissive.rgb;\n         o.Normal.xy *= windInvMask;\n         o.Smoothness *= windInvMask;\n         o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;\n         o.Metallic *= windInvMask;\n      #endif\n\n   }\n\n\n\n\n\tvoid Ext_SurfaceFunction10 (inout Surface o, ShaderData d)\n\t{\n        if (_DoubleSidedNormalMode == 0)\n        {\n           o.Normal *= d.isFrontFace ? 1 : -1;\n        }\n        else if (_DoubleSidedNormalMode == 1)\n        {\n\t\t   o.Normal.z *= d.isFrontFace ? 1 : -1;\n        }\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction11 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _SURFACEGRADIENT\n\t\t\to.Normal = ResolveNormalFromSurfaceGradient(d, o.Normal);\n\t    #elif _AUTONORMAL\n\t        float3 dx = ddx(d.worldSpacePosition);\n\t\t\tfloat3 dy = ddy(d.worldSpacePosition);\n\t\t\tfloat3 crossX = cross(float3(0,1,0), dx);\n\t\t\tfloat3 crossY = cross(float3(0,1,0), dy);\n\t\t\tfloat3 dt = abs(dot(crossY, dx));\n\t\t\tfloat height = _AutoNormalStrength * 0.5 * o.Alpha;\n\t\t\tfloat3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n\t\t\tn.y *= -1.0;\n\t\t\to.Normal = normalize((dt * float3(0,1,0)) - n).xzy;\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#else\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#endif\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction12 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DEBUG_SAMPLECOUNT\n\t\t\tif (_sampleCount > _DebugSampleCountThreshold)\n\t\t\t{\n\t\t\t\to.Albedo.r = 1;\n\t\t\t\to.Albedo.gb *= 0.2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\to.Albedo.b = 1;\n\t\t\t}\n\n        #endif\n\t}\n\n\n\n\n\tSAMPLER(sampler_DissolveTexture);\n\tTEXTURE2D(_DissolveTexture);\n\tTEXTURE2D(_DissolveGradient);\n\n\tvoid Ext_SurfaceFunction13 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DISSOLVE\n\t\tfloat2 uv = d.texcoord0.xy * _DissolveTexture_ST.xy + _DissolveTexture_ST.zw;\n\t\tfloat2 dx = ddx(uv);\n\t\tfloat2 dy = ddy(uv);\n\n\t\tUNITY_BRANCH\n\t\tif (_DissolveAmount > 0)\n\t\t{\n\t\t\thalf dissolve = SAMPLE_TEXTURE2D_GRAD(_DissolveTexture, sampler_DissolveTexture, uv, dx, dy).g;\n\t\t\thalf cp =  saturate(_DissolveAmount - (dissolve - _DissolveAmount) * _DissolveEdgeContrast) + _DissolveAmount;\n\t\t\thalf cp2 = saturate(1.0 - abs((dissolve - _DissolveAmount) * _DissolveEdgeContrast));\n\t\t\tclip(1.0 - cp);\n\t\t\tfloat2 fuv = float2(cp2, 0.5);\n\t\t\thalf3 col = SAMPLE_TEXTURE2D_LOD(_DissolveGradient, sampler_DissolveTexture, fuv, 0).rgb;\n\t\t\t\t\n\t\t\to.Albedo = lerp(o.Albedo, col, _DissolveColoration * cp2);\n\t\t\to.Emission = lerp(o.Emission, col * _DissolveEmissiveStr, _DissolveColoration * cp2);\n\t\t}\n\t\t#endif\n\t}\n\n\n\n\n    float Dither8x8Bayer( int x, int y )\n    {\n        const float dither[ 64 ] = {\n                1, 49, 13, 61,  4, 52, 16, 64,\n            33, 17, 45, 29, 36, 20, 48, 32,\n                9, 57,  5, 53, 12, 60,  8, 56,\n            41, 25, 37, 21, 44, 28, 40, 24,\n                3, 51, 15, 63,  2, 50, 14, 62,\n            35, 19, 47, 31, 34, 18, 46, 30,\n            11, 59,  7, 55, 10, 58,  6, 54,\n            43, 27, 39, 23, 42, 26, 38, 22};\n        int r = y * 8 + x;\n        return dither[r] / 64; \n    }\n\n    void ApplyDitherCrossFadeVSP(float2 vpos, float fadeValue)\n    {\n        float dither = Dither8x8Bayer( fmod(vpos.x, 8), fmod(vpos.y, 8) );\n        float sgn = fadeValue > 0 ? 1.0f : -1.0f;\n        clip(dither - (1-fadeValue) * sgn);\n    }\n    \n\n\tvoid Ext_SurfaceFunction14 (inout Surface o, ShaderData d)\n\t{\n\t\t#if LOD_FADE_CROSSFADE\n            float4 screenPosNorm = d.screenPos / d.screenPos.w;\n            screenPosNorm.z = ( UNITY_NEAR_CLIP_VALUE >= 0 ) ? screenPosNorm.z : screenPosNorm.z * 0.5 + 0.5;\n            float2 clipScreen = screenPosNorm.xy * _ScreenParams.xy;\n            ApplyDitherCrossFadeVSP(clipScreen,unity_LODFade.x);\n        #endif\n\t}\n\n\n\n\n\n\n// declare outside of CBuffer\n\nfloat4x4 _GlobalVolumeMatrix;\nfloat4x4 _VolumeMatrix;\nfloat3 _VolumeMin;\nfloat3 _VolumeInvSize;\nfloat3 _GlobalVolumeMin;\nfloat3 _GlobalVolumeInvSize;\n\n// I inlined a section of your include. You can use includes in better shaders, but doing it via a subshader or this way\n// is much better. The reason is that this allows your shader to be all inclusive, and packed up for asset store distribition,\n// without requiring specific paths to other files, etc.\n//\n\n#ifndef BAKERY_INCLUDED\n#define BAKERY_INCLUDED\n\n#define BAKERYMODE_DEFAULT 0\n#define BAKERYMODE_VERTEXLM 1.0f\n#define BAKERYMODE_RNM 2.0f\n#define BAKERYMODE_SH 3.0f\n\n\n// can't fit vertexLM SH to sm3_0 interpolators\n#ifndef SHADER_API_D3D11\n    #undef _LIGHTMAPMODE_VERTEXSH\n#endif\n\n// can't do stuff on sm2_0 due to standard shader alrady taking up all instructions\n#if SHADER_TARGET < 30\n    #undef BAKERY_BICUBIC\n    #undef BAKERY_LMSPEC\n\n    #undef _LIGHTMAPMODE_RNM\n    #undef _LIGHTMAPMODE_SH\n    #undef _LIGHTMAPMODE_VERTEX\n#endif\n\n#define lumaConv float3(0.2125f, 0.7154f, 0.0721f)\n\n#ifdef BAKERY_VOLUME\n    #ifdef BAKERY_COMPRESSED_VOLUME\n        Texture3D _Volume3;\n    #endif\n#endif\n\n\nhalf3 LinearToGamma (half3 linRGB)\n{\n    linRGB = max(linRGB, half3(0.h, 0.h, 0.h));\n    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n    return max(1.055h * pow(linRGB, 0.416666667h) - 0.055h, 0.h);\n}\n\nfloat shEvaluateDiffuseL1Geomerics(float L0, float3 L1, float3 n)\n{\n    // average energy\n    float R0 = L0;\n\n    // avg direction of incoming light\n    float3 R1 = 0.5f * L1;\n\n    // directional brightness\n    float lenR1 = length(R1);\n\n    // linear angle between normal and direction 0-1\n    //float q = 0.5f * (1.0f + dot(R1 / lenR1, n));\n    //float q = dot(R1 / lenR1, n) * 0.5 + 0.5;\n    float q = dot(normalize(R1), n) * 0.5 + 0.5;\n\n    // power for q\n    // lerps from 1 (linear) to 3 (cubic) based on directionality\n    float p = 1.0f + 2.0f * lenR1 / R0;\n\n    // dynamic range constant\n    // should vary between 4 (highly directional) and 0 (ambient)\n    float a = (1.0f - lenR1 / R0) / (1.0f + lenR1 / R0);\n\n    return R0 * (a + (1.0f - a) * (p + 1.0f) * pow(q, p));\n}\n\n#ifdef BAKERY_VERTEXLMMASK\n    float4 unpack4NFloats(float src)\n\t{\n        //return fmod(float4(src / 262144.0, src / 4096.0, src / 64.0, src), 64.0)/64.0;\n        return frac(float4(src / (262144.0*64), src / (4096.0*64), src / (64.0*64), src));\n    }\n#endif\n\n#if defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n    float3 unpack3NFloats(float src)\n\t{\n        float r = frac(src);\n        float g = frac(src * 256.0);\n        float b = frac(src * 65536.0);\n        return float3(r, g, b);\n    }\n#endif\n\n// Unity defines these under different names in each SRP, so use our own\ninline float3 Bakery_SafeNormalize(float3 inVec)\n{\n    float dp3 = max(0.001f, dot(inVec, inVec));\n    return inVec * rsqrt(dp3);\n}\n\n#if _URP || _HDRP\n\nfloat SmoothnessToPerceptualRoughness(float smoothness)\n{\n    return (1 - smoothness);\n}\n#endif\n\n#if !_STANDARD\nhalf4 unity_Lightmap_HDR;\ninline half3 DecodeLightmap( half4 color )\n{\n    return DecodeLightmap( color, unity_Lightmap_HDR );\n}\n\n#define UNITY_INV_PI        0.31830988618f\ninline float GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return UNITY_INV_PI * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n    void BakeryVertexLMDirection(inout float3 diffuseColor, inout float3 specularColor, float3 lightDirection, float3 vertexNormalWorld, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 dominantDir = Bakery_SafeNormalize(lightDirection);\n        half halfLambert = dot(normalWorld, dominantDir) * 0.5 + 0.5;\n        half flatNormalHalfLambert = dot(vertexNormalWorld, dominantDir) * 0.5 + 0.5;\n\n        #ifdef BAKERY_LMSPEC\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = spec * diffuseColor;\n        #endif\n\n        diffuseColor *= halfLambert / max(1e-4h, flatNormalHalfLambert);\n    }\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXSH\n    void BakeryVertexLMSH(inout float3 diffuseColor, inout float3 specularColor, float3 shL1x, float3 shL1y, float3 shL1z, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 L0 = diffuseColor;\n        float3 nL1x = shL1x;\n        float3 nL1y = shL1y;\n        float3 nL1z = shL1z;\n        float3 L1x = nL1x * L0 * 2;\n        float3 L1y = nL1y * L0 * 2;\n        float3 L1z = nL1z * L0 * 2;\n\n        float3 sh;\n    #if BAKERY_SHNONLINEAR\n        //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n        //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n        //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n        float lumaL0 = dot(L0, 1);\n        float lumaL1x = dot(L1x, 1);\n        float lumaL1y = dot(L1y, 1);\n        float lumaL1z = dot(L1z, 1);\n        float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n        float regularLumaSH = dot(sh, 1);\n        //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n        sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    #else\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    #endif\n\n        diffuseColor = max(sh, 0.0);\n\n        #ifdef BAKERY_LMSPEC\n            float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n            float focus = saturate(length(dominantDir));\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = max(spec * sh, 0.0);\n        #endif\n    }\n#endif\n\n\n\n#ifdef BAKERY_BICUBIC\nfloat BakeryBicubic_w0(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-a + 3.0f) - 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w1(float a)\n{\n    return (1.0f/6.0f)*(a*a*(3.0f*a - 6.0f) + 4.0f);\n}\n\nfloat BakeryBicubic_w2(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-3.0f*a + 3.0f) + 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w3(float a)\n{\n    return (1.0f/6.0f)*(a*a*a);\n}\n\nfloat BakeryBicubic_g0(float a)\n{\n    return BakeryBicubic_w0(a) + BakeryBicubic_w1(a);\n}\n\nfloat BakeryBicubic_g1(float a)\n{\n    return BakeryBicubic_w2(a) + BakeryBicubic_w3(a);\n}\n\nfloat BakeryBicubic_h0(float a)\n{\n    return -1.0f + BakeryBicubic_w1(a) / (BakeryBicubic_w0(a) + BakeryBicubic_w1(a)) + 0.5f;\n}\n\nfloat BakeryBicubic_h1(float a)\n{\n    return 1.0f + BakeryBicubic_w3(a) / (BakeryBicubic_w2(a) + BakeryBicubic_w3(a)) + 0.5f;\n}\n#endif\n\n\n#if defined(_LIGHTMAPMODE_RNM) || defined(_LIGHTMAPMODE_SH)\nTexture2D _RNM0, _RNM1, _RNM2;\n#endif\n\n#ifdef BAKERY_VOLUME\nTexture3D _Volume0, _Volume1, _Volume2, _VolumeMask;\nSamplerState sampler_Volume0;\n#endif\n\n#if defined(BAKERY_BICUBIC) && defined(LIGHTMAP_ON) && defined(SHADER_API_D3D11)\n    // Bicubic\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\tfloat width, height;\n\t\ttex.GetDimensions(width, height);\n\t\tfloat texelSize = 1.0f / width;\n\n        float x = uv.x * width;\n        float y = uv.y * width;\n\n        x -= 0.5f;\n        y -= 0.5f;\n\n        float px = floor(x);\n        float py = floor(y);\n\n        float fx = x - px;\n        float fy = y - py;\n\n        float g0x = BakeryBicubic_g0(fx);\n        float g1x = BakeryBicubic_g1(fx);\n        float h0x = BakeryBicubic_h0(fx);\n        float h1x = BakeryBicubic_h1(fx);\n        float h0y = BakeryBicubic_h0(fy);\n        float h1y = BakeryBicubic_h1(fy);\n\n        return     BakeryBicubic_g0(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h0y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h0y) * texelSize))) +\n\n                   BakeryBicubic_g1(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h1y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h1y) * texelSize)));\n    }\n#else\n    // Bilinear\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\t#ifdef LIGHTMAP_ON\n\t\t\treturn tex.Sample(samplerunity_Lightmap, uv);\n\t\t#else\n\t\t\treturn float4(1,0,0,1);\n\t\t#endif\n    }\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\n#ifdef BAKERY_LMSPEC\nfloat BakeryDirectionalLightmapSpecular(float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 dominantDir = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap, lmUV).xyz * 2 - 1;\n    half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n    half nh = saturate(dot(normalWorld, halfDir));\n    half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n    half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n    half spec = GGXTerm(nh, roughness);\n    return spec;\n}\n#endif\n#endif\n\n\n\n#ifdef _LIGHTMAPMODE_RNM\nvoid BakeryRNM(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalMap, float smoothness, float3 viewDirT)\n{\n    const float3 rnmBasis0 = float3(0.816496580927726f, 0, 0.5773502691896258f);\n    const float3 rnmBasis1 = float3(-0.4082482904638631f, 0.7071067811865475f, 0.5773502691896258f);\n    const float3 rnmBasis2 = float3(-0.4082482904638631f, -0.7071067811865475f, 0.5773502691896258f);\n\n    float3 rnm0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 rnm1 = DecodeLightmap(BakeryTex2D(_RNM1, lmUV));\n    float3 rnm2 = DecodeLightmap(BakeryTex2D(_RNM2, lmUV));\n\n    #ifdef BAKERY_SSBUMP\n        diffuseColor = normalMap.x * rnm0\n                     + normalMap.z * rnm1\n                     + normalMap.y * rnm2;\n         diffuseColor *= 2;\n    #else\n        diffuseColor = saturate(dot(rnmBasis0, normalMap)) * rnm0\n                     + saturate(dot(rnmBasis1, normalMap)) * rnm1\n                     + saturate(dot(rnmBasis2, normalMap)) * rnm2;\n    #endif\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDirT = rnmBasis0 * dot(rnm0, lumaConv) +\n                              rnmBasis1 * dot(rnm1, lumaConv) +\n                              rnmBasis2 * dot(rnm2, lumaConv);\n\n        float3 dominantDirTN = normalize(dominantDirT);\n        float3 specColor = saturate(dot(rnmBasis0, dominantDirTN)) * rnm0 +\n                           saturate(dot(rnmBasis1, dominantDirTN)) * rnm1 +\n                           saturate(dot(rnmBasis2, dominantDirTN)) * rnm2;\n\n        half3 halfDir = Bakery_SafeNormalize(dominantDirTN - viewDirT);\n        half nh = saturate(dot(normalMap, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n        specularColor = spec * specColor;\n    #endif\n}\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\ninline half3 Unity_DecodeDirectionalLightmap(half3 color, half4 dirTex, half3 normalWorld)\n{\n    // In directional (non-specular) mode Enlighten bakes dominant light direction\n    // in a way, that using it for half Lambert and then dividing by a \"rebalancing coefficient\"\n    // gives a result close to plain diffuse response lightmaps, but normalmapped.\n\n    // Note that dir is not unit length on purpose. Its length is \"directionality\", like\n    // for the directional specular lightmaps.\n\n    half halfLambert = dot(normalWorld, dirTex.xyz - 0.5) + 0.5;\n\n    return color * halfLambert / max(1e-4h, dirTex.w);\n}\n#endif\n\n#ifdef _LIGHTMAPMODE_SH\nvoid BakerySH(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 L0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 nL1x = BakeryTex2D(_RNM0, lmUV) * 2 - 1;\n    float3 nL1y = BakeryTex2D(_RNM1, lmUV) * 2 - 1;\n    float3 nL1z = BakeryTex2D(_RNM2, lmUV) * 2 - 1;\n    float3 L1x = nL1x * L0 * 2;\n    float3 L1y = nL1y * L0 * 2;\n    float3 L1z = nL1z * L0 * 2;\n\n    float3 sh;\n#if BAKERY_SHNONLINEAR\n    float lumaL0 = dot(L0, 1);\n    float lumaL1x = dot(L1x, 1);\n    float lumaL1y = dot(L1y, 1);\n    float lumaL1z = dot(L1z, 1);\n    float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    float regularLumaSH = dot(sh, 1);\n    //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n    sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n    //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n    //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n#else\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n#endif\n\n    diffuseColor = max(sh, 0.0);\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n        float focus = saturate(length(dominantDir));\n        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n        half nh = saturate(dot(normalWorld, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n\n        sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n\n        specularColor = max(spec * sh, 0.0);\n    #endif\n}\n#endif\n\n#endif // include guards\n\n\n    void Ext_ModifyVertex15 (inout VertexData v, inout ExtraV2F e)\n    {\n        #if _USEBAKERY\n\t\t    #if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\t\t\t    // Unpack from RGBM\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.a * 8.0f;\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.rgb;\n\n\t\t\t    #ifdef BAKERY_VERTEXLMMASK\n\t\t\t\t    e.extraV2F4.xyzw = unpack4NFloats(v.texcoord1);\n\t\t\t    #endif\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXSH\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n                e.extraV2F6.xyz = unpack3NFloats(v.texcoord3.x) * 2 - 1;\n                e.extraV2F7.xyz = unpack3NFloats(v.texcoord3.y) * 2 - 1;\n            #endif\n       #endif\n    }\n\n#if _HDRP || _URP\n    half3 SHEvalLinearL0L1 (half4 normal)\n    {\n        half3 x;\n\n        // Linear (L1) + constant (L0) polynomial terms\n        x.r = dot(unity_SHAr,normal);\n        x.g = dot(unity_SHAg,normal);\n        x.b = dot(unity_SHAb,normal);\n\n        return x;\n    }\n\n    // normal should be normalized, w=1.0\n    half3 SHEvalLinearL2 (half4 normal)\n    {\n        half3 x1, x2;\n        // 4 of the quadratic (L2) polynomials\n        half4 vB = normal.xyzz * normal.yzzx;\n        x1.r = dot(unity_SHBr,vB);\n        x1.g = dot(unity_SHBg,vB);\n        x1.b = dot(unity_SHBb,vB);\n\n        // Final (5th) quadratic (L2) polynomial\n        half vC = normal.x*normal.x - normal.y*normal.y;\n        x2 = unity_SHC.rgb * vC;\n\n        return x1 + x2;\n    }\n\n    half3 ShadeSH9 (half4 normal)\n    {\n        // Linear + constant polynomial terms\n        half3 res = SHEvalLinearL0L1 (normal);\n\n        // Quadratic polynomials\n        res += SHEvalLinearL2 (normal);\n\n        #ifdef UNITY_COLORSPACE_GAMMA\n            res = LinearToGamma (res);\n        #endif\n\n        return res;\n\n    }\n#endif\n\n\n\n\tvoid DoBakeryStuff(inout float3 indDif, inout float3 indSpec, inout float4 shadowmask, float3 tangentNormal, float smoothness, ShaderData d)\n\t{\n\t\t// Quality!\n\t\tindDif = 1;\n\t\tindSpec = 0;\n\n        #if defined(_PASSFORWARD) || defined(_PASSGBUFFER) // forward pass on URP/Standard/HDRP + built-in deferred\n\n            float3 normalWorld = mul(tangentNormal, d.TBNMatrix);\n\n\t\t\t#ifdef LIGHTMAP_ON\n\n                // Static\n\n\t\t\t\tfloat2 lmUV = d.texcoord1 * unity_LightmapST.xy + unity_LightmapST.zw;\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_STANDARD\n\t\t\t\t\tindDif = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n\n\t\t\t\t\t#ifdef DIRLIGHTMAP_COMBINED\n\t\t\t\t\t\tfloat4 dirMap = BakeryTex2D(unity_LightmapInd, lmUV);\n\t\t\t\t\t\tindDif = Unity_DecodeDirectionalLightmap(indDif, dirMap, normalWorld);\n\n\t\t\t\t\t\t#ifdef BAKERY_LMSPEC\n\t\t\t\t\t\t\tindSpec = BakeryDirectionalLightmapSpecular(lmUV, normalWorld, -d.worldSpaceViewDir, smoothness) * indDif;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\n\t\t\t\t\tindDif = d.vertexColor;\n\n                    #ifdef BAKERY_VERTEXLMMASK\n                        shadowmask = d.extraV2F4;\n                    #endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n\t\t\t\t\t\t// worldSpaceNormal is per-vertex\n\t\t\t\t\t\t// normalWorld is per-pixel\n\t\t\t\t\t\tfloat3 bakedLightDirection = d.extraV2F5;\n\t\t\t\t\t\tBakeryVertexLMDirection(indDif, indSpec, bakedLightDirection, d.worldSpaceNormal, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXSH\n\t\t\t\t\t\tBakeryVertexLMSH(indDif, indSpec, d.extraV2F5, d.extraV2F6, d.extraV2F7, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_RNM\n\t\t\t\t\tBakeryRNM(indDif, indSpec, lmUV, tangentNormal, smoothness, -d.tangentSpaceViewDir);\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_SH\n\t\t\t\t\tBakerySH(indDif, indSpec, lmUV, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t#endif\n\n            #else\n\n                // Dynamic\n\n                #ifdef BAKERY_VOLUME\n\n                    bool isGlobal = dot(abs(_VolumeInvSize),1) == 0;\n                    float3 volViewDir = -d.worldSpaceViewDir;\n                    #ifdef BAKERY_VOLROTATION\n                        float4x4 volMatrix = (isGlobal ? _GlobalVolumeMatrix : _VolumeMatrix);\n                        float3 volInvSize = (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 lpUV = mul(volMatrix, float4(d.worldSpacePosition,1)).xyz * volInvSize + 0.5f;\n                        float3 volNormal = mul((float3x3)volMatrix, normalWorld);\n                        #ifdef BAKERY_LMSPEC\n                            volViewDir = mul((float3x3)volMatrix, volViewDir);\n                        #endif\n                    #else\n                        float3 lpUV = (d.worldSpacePosition - (isGlobal ? _GlobalVolumeMin : _VolumeMin)) * (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 volNormal = normalWorld;\n                    #endif\n\n                    #ifdef BAKERY_COMPRESSED_VOLUME\n                        float4 tex0, tex1, tex2, tex3;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex3 = _Volume3.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz * L0;\n                        L1y = tex2.xyz * L0;\n                        L1z = tex3.xyz * L0;\n                    #else\n                        float4 tex0, tex1, tex2;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV);\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV);\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz;\n                        L1y = tex2.xyz;\n                        L1z = float3(tex0.w, tex1.w, tex2.w);\n                    #endif\n                    indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), volNormal);\n                    indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), volNormal);\n                    indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), volNormal);\n\n                    #ifdef UNITY_COLORSPACE_GAMMA\n                        indDif = pow(indDif, 1.0f / 2.2f);\n                    #endif\n\n                    #ifdef BAKERY_LMSPEC\n                        float3 nL1x = L1x / L0;\n                        float3 nL1y = L1y / L0;\n                        float3 nL1z = L1z / L0;\n                        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n                        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - volViewDir);\n                        half nh = saturate(dot(volNormal, halfDir));\n                        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n                        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n                        half spec = GGXTerm(nh, roughness);\n                        float3 sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n                        indSpec = max(spec * sh, 0.0);\n                    #endif\n\n                    shadowmask = _VolumeMask.Sample(sampler_Volume0, lpUV);\n\n                #else\n\n                    #ifdef BAKERY_SHNONLINEAR\n                        float3 L0 = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);\n                        indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, unity_SHAr.xyz, normalWorld);\n                        indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, unity_SHAg.xyz, normalWorld);\n                        indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, unity_SHAb.xyz, normalWorld);\n                    #else\n                        indDif = ShadeSH9(float4(normalWorld,1));\n                    #endif\n\n                #endif\n\n\t\t\t#endif\n\n        #endif\n\t}\n\n\t// this is the main surface function. Surface is like a surface shader output structure, but\n\t// with our new outputs as well.\n\tvoid Ext_SurfaceFunction15 (inout Surface o, ShaderData d)\n\t{\n        #if _USEBAKERY\n\t\t    float3 indDif;\n\t\t    float3 indSpec;\n            float4 shadowmask = 1;\n\t\t    DoBakeryStuff(indDif, indSpec, shadowmask, o.Normal, o.Smoothness, d);\n\t\t    o.DiffuseGI = indDif;\n\t\t    o.BackDiffuseGI = indDif;\n\t\t    o.SpecularGI = indSpec;\n            o.ShadowMask = shadowmask;\n        #endif\n\t}\n\n\n\n\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                  Ext_SurfaceFunction1(l, d);\n                  Ext_SurfaceFunction2(l, d);\n                  Ext_SurfaceFunction3(l, d);\n                  Ext_SurfaceFunction4(l, d);\n                  Ext_SurfaceFunction5(l, d);\n                  Ext_SurfaceFunction6(l, d);\n                  Ext_SurfaceFunction7(l, d);\n                  Ext_SurfaceFunction8(l, d);\n                  Ext_SurfaceFunction9(l, d);\n\t\t            Ext_SurfaceFunction10(l, d);\n                  Ext_SurfaceFunction11(l, d);\n                  Ext_SurfaceFunction12(l, d);\n                  Ext_SurfaceFunction13(l, d);\n                  Ext_SurfaceFunction14(l, d);\n                  Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraV2F d;\n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                  Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                  Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                  #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                  v2p.extraV2F4 = d.extraV2F4;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                  v2p.extraV2F5 = d.extraV2F5;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F6 = d.extraV2F6;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F7 = d.extraV2F7;\n                  #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                d.extraV2F4 = v2p.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                d.extraV2F5 = v2p.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F6 = v2p.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F7 = v2p.extraV2F7;\n                #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n                Ext_ModifyTessellatedVertex2(v, d);\n                Ext_ModifyTessellatedVertex3(v, d);\n                Ext_ModifyTessellatedVertex4(v, d);\n                Ext_ModifyTessellatedVertex5(v, d);\n                Ext_ModifyTessellatedVertex6(v, d);\n                Ext_ModifyTessellatedVertex7(v, d);\n                Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                v2p.extraV2F4 = d.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                v2p.extraV2F5 = d.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F6 = d.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F7 = d.extraV2F7;\n                #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n            // d.texcoord3 = i.texcoord3;\n             #endif\n\n             d.isFrontFace = facing;\n             #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n             d.vertexColor = i.vertexColor;\n             #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(i.worldPos, 1)).xyz;\n            #endif\n             d.localSpaceNormal = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n             #if LOD_FADE_CROSSFADE\n             d.screenPos = i.screenPos;\n             d.screenUV = (i.screenPos.xy / i.screenPos.w);\n             #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n             #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n             d.extraV2F4 = i.extraV2F4;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n             d.extraV2F5 = i.extraV2F5;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F6 = i.extraV2F6;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F7 = i.extraV2F7;\n             #endif\n\n            return d;\n         }\n         \n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n   #ifdef VARYINGS_NEED_POSITION_WS\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex);\n   #endif\n\n   #ifdef VARYINGS_NEED_TANGENT_TO_WORLD\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n   #endif\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n        #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n       // output.texcoord3 = inputMesh.texcoord3;\n        #endif\n        #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n        output.vertexColor = inputMesh.vertexColor;\n        #endif\n\n       return output;\n   }\n#else\n\n   #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n    \n       ChainModifyVertex(input, output);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n        #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n       // output.texcoord3 = input.texcoord3;\n        #endif\n\n        #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n        output.vertexColor = input.vertexColor;\n        #endif\n\n        #if LOD_FADE_CROSSFADE\n        output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n        #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(output.worldPos.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? input.previousPositionOS : input.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n\n            VertexData previousMesh = input;\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            // Remap time to old time\n            float4 oldTime = _Time;\n            _Time.y = _LastTimeParameters.x;\n            _Time.x = _LastTimeParameters.x / 20;\n            _Time.z = _LastTimeParameters.x * 2;\n            _Time.w = _LastTimeParameters.x * 3;\n            ChainModifyVertex(previousMesh, dummy);\n            _Time = oldTime;\n\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = output.worldPos.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n            \n                    output.positionRWS = input.worldPos;\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n            \n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n                    #if defined(_ENABLE_SHADOW_MATTE) && SHADERPASS == SHADERPASS_FORWARD_UNLIT\n                        HDShadowContext shadowContext = InitShadowContext();\n                        float shadow;\n                        float3 shadow3;\n                        // We need to recompute some coordinate not computed by default for shadow matte\n                        posInput = GetPositionInput(fragInputs.positionSS.xy, _ScreenSize.zw, fragInputs.positionSS.z, UNITY_MATRIX_I_VP, GetWorldToViewMatrix());\n                        float3 upWS = normalize(fragInputs.tangentToWorld[1]);\n                        uint renderingLayers = GetMeshRenderingLightLayer();\n                        ShadowLoopMin(shadowContext, posInput, upWS, asuint(_ShadowMatteFilter), renderingLayers, shadow3);\n                        shadow = dot(shadow3, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));\n                \n                        float4 shadowColor = (1.0 - shadow) * surfaceDescription.ShadowTint.rgba;\n                        float  localAlpha  = saturate(shadowColor.a + surfaceDescription.Alpha);\n                \n                        // Keep the nested lerp\n                        // With no Color (bsdfData.color.rgb, bsdfData.color.a == 0.0f), just use ShadowColor*Color to avoid a ring of \"white\" around the shadow\n                        // And mix color to consider the Color & ShadowColor alpha (from texture or/and color picker)\n                        #ifdef _SURFACE_TYPE_TRANSPARENT\n                            surfaceData.baseColor = lerp(shadowColor.rgb * surfaceData.baseColor, lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow), surfaceDescription.Alpha);\n                        #else\n                            surfaceData.baseColor = lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow);\n                        #endif\n                        localAlpha = ApplyBlendMode(surfaceData.baseColor, localAlpha).a;\n                \n                        surfaceDescription.Alpha = localAlpha;\n                    #endif\n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n                \n\n                   // tangent-space normal\n                   float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                   normalTS = surfaceDescription.Normal;\n        \n                   // compute world space normal\n                   #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(normalTS, fragInputs.tangentToWorld);\n                   #else\n                      surfaceData.normalWS = normalTS;\n                   #endif\n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                    #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                \n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2], alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                    #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 //builtinData.vtPackedFeedback = surfaceDescription.VTPackedFeedback;\n        \n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     //builtinData.distortion = surfaceData.Distortion;\n                     //builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n\n\n            float4 Frag(VertexToPixel v2f\n               #if NEED_FACING\n                  , bool facing : SV_IsFrontFace\n               #endif\n            ) : SV_Target\n            {\n                FragInputs input = BuildFragInputs(v2f);\n\n                // input.positionSS is SV_Position\n                PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n            #ifdef VARYINGS_NEED_POSITION_WS\n                float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n            #else\n                // Unused\n                float3 V = float3(1.0, 1.0, 1.0); // Avoid the division by 0\n            #endif\n\n                SurfaceData surfaceData;\n                BuiltinData builtinData;\n                Surface l;\n                ShaderData d;\n                GetSurfaceAndBuiltinData(v2f, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n\n                // no debug apply during light transport pass\n\n                BSDFData bsdfData = ConvertSurfaceDataToBSDFData(input.positionSS.xy, surfaceData);\n                LightTransportData lightTransportData = GetLightTransportData(surfaceData, builtinData, bsdfData);\n\n                // This shader is call two times. Once for getting emissiveColor, the other time to get diffuseColor\n                // We use unity_MetaFragmentControl to make the distinction.\n                float4 res = float4(0.0, 0.0, 0.0, 1.0);\n\n                if (unity_MetaFragmentControl.x)\n                {\n                    // Apply diffuseColor Boost from LightmapSettings.\n                    // put abs here to silent a warning, no cost, no impact as color is assume to be positive.\n                    res.rgb = clamp(pow(abs(lightTransportData.diffuseColor), saturate(unity_OneOverOutputBoost)), 0, unity_MaxOutputValue);\n                }\n\n                if (unity_MetaFragmentControl.y)\n                {\n                    // emissive use HDR format\n                    res.rgb = lightTransportData.emissiveColor;\n                }\n\n                return res;\n            }\n\n\n\n            ENDHLSL\n        }\n        \n              Pass\n        {\n            // based on HDLitPass.template\n            Name \"SceneSelectionPass\"\n            Tags { \"LightMode\" = \"SceneSelectionPass\" }\n        \n            Cull Off\n            ColorMask 0\n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone vulkan metal switch\n            #pragma multi_compile_instancing\n            #pragma editor_sync_compilation\n            #pragma instancing_options renderinglayer\n        \n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n                \n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            // #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            #define SHADERPASS SHADERPASS_DEPTH_ONLY\n            #define RAYTRACING_SHADER_GRAPH_DEFAULT\n            #define SCENESELECTIONPASS\n            #define _PASSSCENESELECT 1\n\n            \n\n\n   #pragma shader_feature_local_fragment _ _PACKEDFAST\n   #pragma shader_feature_local _ _TRIPLANAR\n   #pragma shader_feature_local_fragment _ _NORMALMAP \n   #pragma shader_feature_local_fragment _ _MASKMAP\n   #pragma shader_feature_local_fragment _ _DETAIL\n   #pragma shader_feature_local_fragment _ _DETAILTRIPLANAR\n   #pragma shader_feature_local_fragment _ _DETAILSTOCHASTIC\n   #pragma shader_feature_local_fragment _ _EMISSION\n   #pragma shader_feature_local_fragment _ _FLATSHADE\n   #pragma shader_feature_local _ _STOCHASTIC\n   #pragma shader_feature_local_fragment _ _PARALLAX //_POM\n   #pragma shader_feature_local_fragment _ _SPECULAR\n   #pragma shader_feature_local _ _NOISEWORLD _NOISELOCAL\n   #pragma shader_feature_local _ _NOISEHQ _NOISETEXTURE _NOISEWORLEY\n   // only for URP/Standard Forward\n   #pragma shader_feature_local_fragment _ _SIMPLELIT\n\n\n   #pragma shader_feature_local_fragment _ _TINTMASK\n\n\n    #pragma shader_feature_local _ _LAYERVERTEXMASK _LAYERTEXTUREMASK\n\n    #define _HAS_WEIGHTTEXTURE_MASK 1\n\n\n   #pragma shader_feature_local _ _USELAYER\n   #pragma shader_feature_local _ _LAYERTRIPLANAR\n   #pragma shader_feature_local _ _LAYERALBEDO\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL\n   #pragma shader_feature_local _ _LAYERMASK\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION\n   #pragma shader_feature_local _ _LAYERNOISE\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC\n   #pragma shader_feature_local _ _LAYERANGLEFILTER\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_1\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_1\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_1\n   #pragma shader_feature_local _ _LAYERMASK_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_1\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_1\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_1\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_1\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_2\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_2\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_2\n   #pragma shader_feature_local _ _LAYERMASK_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_2\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_2\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_2\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_2\n\n\n   #pragma shader_feature_local _ _TRAX_ON\n\n\n   #pragma shader_feature_local_fragment _ _WETNESS\n   #pragma shader_feature_local_fragment _ _PUDDLES\n   #pragma shader_feature_local_fragment _ _PUDDLENOISE\n   #pragma shader_feature_local_fragment _ _RAINDROPS\n\n\n   #pragma shader_feature_local _ _SNOW\n   #pragma shader_feature_local _ _SNOWMASKMAP\n   #pragma shader_feature_local _ _SNOWNOISE\n   #pragma shader_feature_local_fragment _SNOWSTOCHASTIC\n\n\n   #pragma shader_feature_local_fragment _ _WIND_ON\n\n\n\n\n   #pragma shader_feature_local_fragment _ _SURFACEGRADIENT _AUTONORMAL\n   #define _WORLDSPACENORMAL 1\n\n\n   #pragma shader_feature_local _ _DEBUG_SAMPLECOUNT\n\n\n\t#pragma shader_feature_local_fragment _ _DISSOLVE\n\n\n   #pragma multi_compile_local  LOD_FADE_CROSSFADE\n\n\n\n#pragma instancing_options procedural:setupVSPro forwardadd\n\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\nstruct IndirectShaderData\n{\n\tfloat4x4 PositionMatrix;\n\tfloat4x4 InversePositionMatrix;\n\tfloat4 ControlData;\n};\n\n#if defined(SHADER_API_GLCORE) || defined(SHADER_API_D3D11) || defined(SHADER_API_GLES3) || defined(SHADER_API_METAL) || defined(SHADER_API_VULKAN) || defined(SHADER_API_PSSL) || defined(SHADER_API_XBOXONE)\n\tuniform StructuredBuffer<IndirectShaderData> VisibleShaderDataBuffer;\n#endif\n\n#endif\n\nfloat VSPRenderingLayerMask;\n\nvoid setupVSPro()\n{\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\n    #if _HDRP\n\t    unity_RenderingLayer.x = VSPRenderingLayerMask;\n    #endif\n\n\t#ifdef unity_ObjectToWorld\n\t#undef unity_ObjectToWorld\n\t#endif\n\n\t#ifdef unity_WorldToObject\n\t#undef unity_WorldToObject\n\t#endif\n\n\tunity_ObjectToWorld = VisibleShaderDataBuffer[unity_InstanceID].PositionMatrix;\n\tunity_WorldToObject = VisibleShaderDataBuffer[unity_InstanceID].InversePositionMatrix;\n#endif\n\n}\n\n\n\t#pragma multi_compile _LIGHTMAPMODE_STANDARD _LIGHTMAPMODE_RNM _LIGHTMAPMODE_SH _LIGHTMAPMODE_VERTEX _LIGHTMAPMODE_VERTEXDIRECTIONAL _LIGHTMAPMODE_VERTEXSH\n\n    #pragma shader_feature USEBAKERY\n    #pragma shader_feature BAKERY_VERTEXLMMASK\n    #pragma shader_feature BAKERY_SHNONLINEAR\n    #pragma shader_feature BAKERY_LMSPEC\n    #pragma shader_feature BAKERY_BICUBIC\n    #pragma shader_feature BAKERY_VOLUME\n    #pragma shader_feature BAKERY_VOLROTATION\n    #pragma shader_feature BAKERY_COMPRESSED_VOLUME\n\n    #if _USEBAKERY\n\t    #define _OVERRIDE_BAKEDGI\n        #if BAKERY_VOLUME || (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)) && defined(BAKERY_VERTEXLMMASK)\n            #define _OVERRIDE_SHADOWMASK\n        #endif\n    #endif\n\n\n\n\n\n\n\n\n   #define _HDRP 1\n#define _BLENDMODE_ALPHA 1\n#define _SURFACE_TYPE_TRANSPARENT 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n        \n            \n\n        \n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\" // Need to be here for Gradient struct definition\n         \n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n\n\n   half4 _Tint;\n   half _UVSource;\n   half _TriplanarContrast;\n   half _AlbedoContrast;\n   half _AlbedoBrightness;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half3 _EmissionColor;\n   float _DetailUVSource;\n   half _StochasticScale;\n   half _DetailStochasticScale;\n   half _Smoothness;\n   half _Metallic;\n   half2 _SmoothnessRemap;\n   half2 _AORemap;\n   half2 _MetallicRemap;\n   half2 _HeightRemap;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n   half _AlphaThreshold;\n   half _Cutoff; // for Unity's light mapper\n   half _TriplanarSpace;\n   half _DetailTriplanarSpace;\n   half _DetailTriplanarContrast;\n   half _MicroShadowStrength;\n   half3 _FuzzyShadingColor;\n   half _FuzzyShadingOn;\n   half3 _FuzzyShadingParams;\n\n   //int _POMMaxSamples;\n   //float _POMMin;\n   //float _POMFade;\n#if _FLATSHADE\n   half _FlatShadingBlend;\n#endif\n\n   half _StochasticContrast;\n   half _DetailStochasticContrast;\n\n#if _PARALLAX || _POM\n   half _ParallaxHeight;\n#endif\n\n\n\n\tfloat4 _TintMask_ST;\n\thalf3 _RColor;\n\thalf3 _GColor;\n\thalf3 _BColor;\n\thalf3 _AColor;\n\n\n\thalf _LayerTextureMaskUVMode;\n    float4 _LayerTextureMask_ST;\n\n\n   //#if _USELAYER\n       float4 _LayerAlbedoMap_ST;\n       half3 _LayerTint;\n       half _LayerBlendMode;\n       float _LayerUVSource;\n       half _LayerAlbedoBrightness;\n       half _LayerAlbedoContrast;\n       half _LayerHeightContrast;\n       half _LayerStrength;\n       half _LayerAlbedoStrength;\n       half _LayerNormalStrength;\n       half _LayerSmoothnessStrength;\n       half _LayerSmoothness;\n       half _LayerMetallic;\n       half _LayerStochasticScale;\n       half2 _LayerSmoothnessRemap;\n       half2 _LayerAORemap;\n       half2 _LayerMetallicRemap;\n       half2 _LayerHeightRemap;\n       float4 _LayerWeightOverDistance;\n       half _LayerMicroShadowStrength;\n       //#if _LAYERNOISE\n           float _LayerNoiseFrequency;\n           float _LayerNoiseAmplitude;\n           float _LayerNoiseOffset;\n           float _LayerNoiseCenter;\n           half3 _LayerBlendTint;\n       //#endif\n       //#if _LAYERANGLEFILTER\n           half _LayerFalloff;\n           half _LayerAngleMin;\n           half _LayerHeight;\n           half _LayerInvertHeight;\n           half _LayerVertexNormalBlend;\n       //#endif\n       half _LayerTriplanarSpace;\n       half _LayerTriplanarContrast;\n       half _LayerBlendContrast;\n       half3 _LayerEmissionColor;\n       half _LayerStochasticContrast;\n       half _LayerTessStrength;\n       half3 _LayerFuzzyShadingColor;\n       half _LayerFuzzyShadingOn;\n       half3 _LayerFuzzyShadingParams;\n   //#endif\n\n\n   //#if _USELAYER_DEF_1\n       float4 _LayerAlbedoMap_Ext_1_ST;\n       half3 _LayerTint_Ext_1;\n       half _LayerBlendMode_Ext_1;\n       float _LayerUVSource_Ext_1;\n       half _LayerAlbedoBrightness_Ext_1;\n       half _LayerAlbedoContrast_Ext_1;\n       half _LayerHeightContrast_Ext_1;\n       half _LayerStrength_Ext_1;\n       half _LayerAlbedoStrength_Ext_1;\n       half _LayerNormalStrength_Ext_1;\n       half _LayerSmoothnessStrength_Ext_1;\n       half _LayerSmoothness_Ext_1;\n       half _LayerMetallic_Ext_1;\n       half _LayerStochasticScale_Ext_1;\n       half2 _LayerSmoothnessRemap_Ext_1;\n       half2 _LayerAORemap_Ext_1;\n       half2 _LayerMetallicRemap_Ext_1;\n       half2 _LayerHeightRemap_Ext_1;\n       float4 _LayerWeightOverDistance_Ext_1;\n       half _LayerMicroShadowStrength_Ext_1;\n       //#if _LAYERNOISE_DEF_1\n           float _LayerNoiseFrequency_Ext_1;\n           float _LayerNoiseAmplitude_Ext_1;\n           float _LayerNoiseOffset_Ext_1;\n           float _LayerNoiseCenter_Ext_1;\n           half3 _LayerBlendTint_Ext_1;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_1\n           half _LayerFalloff_Ext_1;\n           half _LayerAngleMin_Ext_1;\n           half _LayerHeight_Ext_1;\n           half _LayerInvertHeight_Ext_1;\n           half _LayerVertexNormalBlend_Ext_1;\n       //#endif\n       half _LayerTriplanarSpace_Ext_1;\n       half _LayerTriplanarContrast_Ext_1;\n       half _LayerBlendContrast_Ext_1;\n       half3 _LayerEmissionColor_Ext_1;\n       half _LayerStochasticContrast_Ext_1;\n       half _LayerTessStrength_Ext_1;\n       half3 _LayerFuzzyShadingColor_Ext_1;\n       half _LayerFuzzyShadingOn_Ext_1;\n       half3 _LayerFuzzyShadingParams_Ext_1;\n   //#endif\n\n\n   //#if _USELAYER_DEF_2\n       float4 _LayerAlbedoMap_Ext_2_ST;\n       half3 _LayerTint_Ext_2;\n       half _LayerBlendMode_Ext_2;\n       float _LayerUVSource_Ext_2;\n       half _LayerAlbedoBrightness_Ext_2;\n       half _LayerAlbedoContrast_Ext_2;\n       half _LayerHeightContrast_Ext_2;\n       half _LayerStrength_Ext_2;\n       half _LayerAlbedoStrength_Ext_2;\n       half _LayerNormalStrength_Ext_2;\n       half _LayerSmoothnessStrength_Ext_2;\n       half _LayerSmoothness_Ext_2;\n       half _LayerMetallic_Ext_2;\n       half _LayerStochasticScale_Ext_2;\n       half2 _LayerSmoothnessRemap_Ext_2;\n       half2 _LayerAORemap_Ext_2;\n       half2 _LayerMetallicRemap_Ext_2;\n       half2 _LayerHeightRemap_Ext_2;\n       float4 _LayerWeightOverDistance_Ext_2;\n       half _LayerMicroShadowStrength_Ext_2;\n       //#if _LAYERNOISE_DEF_2\n           float _LayerNoiseFrequency_Ext_2;\n           float _LayerNoiseAmplitude_Ext_2;\n           float _LayerNoiseOffset_Ext_2;\n           float _LayerNoiseCenter_Ext_2;\n           half3 _LayerBlendTint_Ext_2;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_2\n           half _LayerFalloff_Ext_2;\n           half _LayerAngleMin_Ext_2;\n           half _LayerHeight_Ext_2;\n           half _LayerInvertHeight_Ext_2;\n           half _LayerVertexNormalBlend_Ext_2;\n       //#endif\n       half _LayerTriplanarSpace_Ext_2;\n       half _LayerTriplanarContrast_Ext_2;\n       half _LayerBlendContrast_Ext_2;\n       half3 _LayerEmissionColor_Ext_2;\n       half _LayerStochasticContrast_Ext_2;\n       half _LayerTessStrength_Ext_2;\n       half3 _LayerFuzzyShadingColor_Ext_2;\n       half _LayerFuzzyShadingOn_Ext_2;\n       half3 _LayerFuzzyShadingParams_Ext_2;\n   //#endif\n\n\n    half _TraxDisplacementDepth;\n    half _TraxDisplacementStrength;\n    half _TraxMipBias;\n    half _TraxNormalStrength;\n    float4 _TraxAlbedo_ST;\n    half _TraxInterpContrast;\n    half _TraxHeightContrast;\n    half3 _TraxTint;\n\n\n\n    half _Porosity;\n    int _WetnessMode;\n    int _PuddleMode;\n\n    half  _PuddleAmount;\n    half  _PuddleFalloff;\n    half4 _PuddleColor;\n    half _PuddleNoiseFrequency;\n    half _PuddleNoiseAmplitude;\n    half _PuddleNoiseOffset;\n    half _PuddleNoiseCenter;\n    half _PuddleAngleMin;\n\n    half _WetnessAmount;\n\thalf _WetnessMin;\n    half _WetnessMax;\n    half _WetnessFalloff;\n\thalf _WetnessAngleMin;\n    float _WetnessShoreline;\n\n    int _RainMode;\n    half3 _RainIntensityScale;\n\n\n\n\n    float4 _SnowAlbedo_ST;\n    half3 _SnowTint;\n    half _SnowAmount;\n    half _SnowAngle;\n    half _SnowContrast;\n    half _SnowVertexHeight;\n    half _SnowMode;\n    half3 _SnowWorldFade; // z is on/off\n    float4 _SnowTraxAlbedo_ST;\n    half3 _SnowTraxTint;\n\n    half _SnowNoiseFreq; \n    half _SnowNoiseAmp;\n    half _SnowNoiseOffset;\n    half _SnowStochasticContrast;\n    half _SnowStochasticScale;\n\n\n    half     _WindParticulateSpace;\n    half     _WindParticulateRotation;\n    half      _WindParticulateSpeed;\n    float4     _WindParticulate_ST;\n    half      _WindParticulatePower;\n    half4    _WindParticulateColor;\n    half4    _WindParticulateWorldHeightMask;\n    half4    _WindParticulateAngleMask;\n    half      _WindParticulateOcclusionStrength;\n    half      _WindParticulateStrength;\n    half4    _WindParticulateEmissive;\n    half     _WindParticulateTextureHeight;\n\n\n   float _DoubleSidedNormalMode;\n\n\n\thalf _AutoNormalStrength;\n\n\n\tint _DebugSampleCountThreshold;\n\n\n\thalf _DissolveAmount;\n\thalf _DissolveEmissiveStr;\n\thalf _DissolveEdgeContrast;\n\thalf _DissolveColoration;\n\tfloat4 _DissolveTexture_ST;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCCOORD3;\n               float4 texcoord1 : TEXCCOORD4;\n               float4 texcoord2 : TEXCCOORD5;\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n               // float4 texcoord3 : TEXCCOORD6;\n                #endif\n\n                #if LOD_FADE_CROSSFADE\n                float4 screenPos : TEXCOORD7;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR_centroid;\n                #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                float4 extraV2F4 : TEXCOORD12_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                float4 extraV2F5 : TEXCOORD13_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F6 : TEXCOORD14_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F7 : TEXCOORD15_centroid;\n                #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n    \n  \n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n   half4 weightTextureMask;\n   \n\n\n   float traxBuffer;\n\n\n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // would love to strip these, but they are used in certain\n               // combinations of the lighting system, and may be used\n               // by the user as well, so no easy way to strip them.\n\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR_centroid;\n                #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                float4 extraV2F4 : TEXCOORD9_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                float4 extraV2F5 : TEXCOORD10_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F6 : TEXCOORD11_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F7 : TEXCOORD12_centroid;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n               #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n               #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n               #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n               #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()     unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n               #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V   unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n               #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V    mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n               #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n               #endif\n               #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\n#ifndef __STACKABLEFUNCLIBRARY_INCLUDES__\n#define __STACKABLEFUNCLIBRARY_INCLUDES__\n\n   #if _DEBUG_SAMPLECOUNT\n      int _sampleCount;\n      #define COUNTSAMPLE { _sampleCount++; }\n   #else\n      #define COUNTSAMPLE\n   #endif\n\n   TEXTURE2D(_NoiseTex);\n   SAMPLER(sampler_NoiseTex);\n\n\n\n   half3 AdjustContrast(half3 color, half contrast)\n   {\n       half3 comp = 0.5;\n   #if !UNITY_COLORSPACE_GAMMA\n       comp = 0.22;\n   #endif\n       color = saturate(lerp(comp, color, contrast));\n       return color;\n   }\n\n   float2 DoParallaxOffset( half h, half height, half3 viewDir)\n   {\n      h = h * height - height/2.0;\n      float3 v = normalize(viewDir);\n      v.z += 0.42;\n      return h * (v.xy / v.z);\n   }\n\n\n\n   #define SAMPLEBARY SampleTexBary\n\n   struct SampleConfig\n   {\n      float2 uv0;\n      float2 uv1;\n      float2 uv2;\n      float2 dx0;\n      float2 dy0;\n      float2 dx1;\n      float2 dy1;\n      float2 dx2;\n      float2 dy2;\n      float3 weights;\n      float3 origWeights;\n   };\n\n   struct Config\n   {\n      float2 origUV; // unscaled uv\n      float2 origScale;\n      float2 uv;        // no stocastic or triplanar\n      float2 dx;\n      float2 dy;\n      SampleConfig uvT; // just stochastic, or just triplanar\n      SampleConfig uvX; // stochastic and triplanar\n      SampleConfig uvY;\n      SampleConfig uvZ;\n\n      \n      float3 absVertNormal;\n      half3 axisSign;\n      float3 normal;\n   };\n\n\n    float2 Hash2D( float2 x )\n    {\n        float2 k = float2( 0.3183099, 0.3678794 );\n        x = x*k + k.yx;\n        return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );\n    }\n\n    float Noise2D(float2 p )\n    {\n        float2 i = floor( p );\n        float2 f = frac( p );\n         \n        float2 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), \n                        dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),\n                    lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), \n                        dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);\n    }\n      \n\n    float2 WorleyHash2D(float2 p)\n    {\n \t    return frac(cos(mul(p, float2x2(-64.2,71.3,81.4,-29.8)))*8321.3); \n    }\n    float WorleyNoise2D(float2 p)\n    {\n        float dist = 1;\n        float2 i = floor(p);\n        float2 f = frac(p);\n    \n        for(int x = -1;x<=1;x++)\n        {\n            for(int y = -1;y<=1;y++)\n            {\n                float d = distance(WorleyHash2D(i+float2(x,y))+float2(x,y),f);\n                dist = min(dist,d);\n            }\n        }\n        return dist;\n\t\n    }\n\n#ifndef PI\n    #define PI 3.14159265359\n#endif\n\n    float GetIntegerNoise(float2 p)\n    {\n        p  = 53.7 * frac( (p*0.3183099) + float2(0.71,0.113));\n        return frac( p.x*p.y*(p.x+p.y) );\n    }\n\n    float WorleyHash3D(float f)\n    {\n        return frac(sin(f)*43758.5453);\n    }\n\n    float WorleyHash31(float3 v)\n    {\n        return WorleyHash3D(dot(v, float3(253.14, 453.74, 183.3)));\n    }\n\n    float3 WorleyRandom3D( float3 p )\n    {\n        return frac(sin(float3(dot(p,float3(127.1,311.7,217.3)),dot(p,float3(269.5,183.3,431.1)), dot(p,float3(365.6,749.9,323.7))))*437158.5453);\n    }\n\n    float WorleyNoise3D(float3 uvw)\n    {\n        float noise = 0.0;\n    \n        float3 p = floor(uvw);\n        float3 f = frac(uvw);\n    \n        float4 res = 1;\n        for(int x = -1; x <=1; ++x)\n        {\n            for(int y = -1; y <=1; ++y)\n            {\n                for(int z = -1; z <=1; ++z)\n                {\n                    float3 gp = p + float3(x, y, z);\n\n                    float3 v = WorleyRandom3D(gp);\n\n\t\t\t\t    float3 diff = gp + v - uvw;\n                \n                    float d = length(diff);\n                \n                    if(d < res.x)\n                    {\n                        res.xyz = float3(d, res.x, res.y);\n                    }\n                    else if(d < res.y)\n                    {\n                        res.xyz = float3(res.x, d, res.y);\n                    }\n                    else if(d < res.z)\n                    {\n                        res.z = d;\n                    }\n                \n                    res.w = WorleyHash31(gp);\n                }\n            }\n        }\n\n        return res.x;\n    }\n    \n      \n    float3 Hash3D( float3 p )\n    {\n        p = float3( dot(p,float3(127.1,311.7, 74.7)),\n                dot(p,float3(269.5,183.3,246.1)),\n                dot(p,float3(113.5,271.9,124.6)));\n\n        return -1.0 + 2.0*frac(sin(p)*437.5453123);\n    }\n\n    float Noise3D( float3 p )\n    {\n        float3 i = floor( p );\n        float3 f = frac( p );\n         \n        float3 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),\n                    lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n    }\n\n    \n    float FBM2D(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           return SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n\n    }\n      \n    float FBM3D(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           half A = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.zy).g;\n           half B = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33).g;\n           half C = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoise(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3D(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3D(d.localSpacePosition * frequency+ offset, d.localSpaceNormal);\n        #else\n           return FBM2D(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n    \n    #if _SURFACEGRADIENT  \n\n    #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)\n\n      \n      \n    half3 SurfaceGradientFromTBN(ShaderData d, half2 deriv)\n    {\n        return deriv.x * d.TBNMatrix[0] + deriv.y * d.TBNMatrix[1];\n    }\n\n    half2 TspaceNormalToDerivative(half3 vM)\n    {\n        const half scale = 1.0/128.0;\n        const half3 vMa = abs(vM);\n        const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));\n\n        return -half2(vM.x, vM.y)/z_ma;\n    }\n\n    half3 SurfgradFromVolumeGradient(ShaderData d, half3 grad)\n    {\n        return grad - dot(d.worldSpaceNormal, grad) * d.worldSpaceNormal;\n    }\n\n    half3 SurfgradFromTriplanarProjection(ShaderData d, half3 pN, half3 xN, half3 yN, half3 zN)\n    {\n        const half w0 = pN.x;\n        const half w1 = pN.y;\n        const half w2 = pN.z;\n\n        half2 xD = TspaceNormalToDerivative(xN);\n        half2 yD = TspaceNormalToDerivative(yN);\n        half2 zD = TspaceNormalToDerivative(zN);\n\n        half3 volumeGrad = half3(w2 * zD.x + w1 * yD.y, w2 * zD.y + w0 * xD.y, w0 * xD.x + w1 * yD.x);\n\n        return SurfgradFromVolumeGradient(d, volumeGrad);\n    }\n\n    half3 ConvertNormalToGradient(ShaderData d, half3 normal)\n    {\n        half2 deriv = TspaceNormalToDerivative(normal);\n\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n    half3 ConvertNormal2ToGradient(ShaderData d, half2 packedNormal)\n    {\n        half2 tNormal = packedNormal;\n        half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF\n        half2 deriv = tNormal * -rcpZ;\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n\n    half3 ResolveNormalFromSurfaceGradient(ShaderData d, half3 gradient)\n    {\n        return normalize(d.worldSpaceNormal - gradient);\n    }\n\n    #endif // _SURFACEGRADIENT\n\n\n    // normals are in surface gradient or world space depending on settings, and can also be generated by height\n    half3 GetWorldSpaceNormal(ShaderData d, half3 normal, half pheight)\n    {\n       #if _SURFACEGRADIENT\n          return ResolveNormalFromSurfaceGradient(d, normal);\n       #elif _AUTONORMAL\n          float3 dx = ddx(d.worldSpacePosition);\n          float3 dy = ddy(d.worldSpacePosition);\n          float3 crossX = cross(float3(0,1,0), dx);\n          float3 crossY = cross(float3(0,1,0), dy);\n          float3 dt = abs(dot(crossY, dx));\n          float height = _AutoNormalStrength * 0.5 * pheight;\n          float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n          n.y *= -1.0;\n          return TangentToWorldSpace(d, normalize((dt * float3(0,1,0)) - n).xzy);\n       #else\n          return TangentToWorldSpace(d, normal);\n          \n       #endif\n       \n    }\n\n   void WaterBRDF (inout half3 albedo, inout half smoothness, half metallic, half wetFactor, half surfPorosity) \n   {\n      half porosity = saturate((( (1 - smoothness) - 0.5)) / max(surfPorosity, 0.001));\n      half factor = lerp(1, 0.2, (1 - metallic) * porosity);\n      albedo *= lerp(1.0, factor, wetFactor);\n      smoothness = lerp(smoothness, 0.92f, wetFactor);\n   }\n\n   void OffsetUV(inout Config c, float2 offset)\n   {\n       c.uv += offset;\n       c.uvT.uv0 += offset;\n       c.uvT.uv1 += offset;\n       c.uvT.uv2 += offset;\n       c.uvX.uv0 += offset;\n       c.uvX.uv1 += offset;\n       c.uvX.uv2 += offset;\n       c.uvY.uv0 += offset;\n       c.uvY.uv1 += offset;\n       c.uvY.uv2 += offset;\n       c.uvZ.uv0 += offset;\n       c.uvZ.uv1 += offset;\n       c.uvZ.uv2 += offset;\n   }\n\n\n    void TriangleGrid(float2 uv, float scale,\n       out float w1, out float w2, out float w3,\n       out int2 vertex1, out int2 vertex2, out int2 vertex3)\n    {\n       // Scaling of the input\n       uv *= 3.464 * scale; // 2 * sqrt(3)\n\n       // Skew input space into simplex triangle grid\n       const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);\n       float2 skewedCoord = mul(gridToSkewedGrid, uv);\n\n       // Compute local triangle vertex IDs and local barycentric coordinates\n       int2 baseId = int2(floor(skewedCoord));\n       float3 temp = float3(frac(skewedCoord), 0);\n       temp.z = 1.0 - temp.x - temp.y;\n       if (temp.z > 0.0)\n       {\n          w1 = temp.z;\n          w2 = temp.y;\n          w3 = temp.x;\n          vertex1 = baseId;\n          vertex2 = baseId + int2(0, 1);\n          vertex3 = baseId + int2(1, 0);\n       }\n       else\n       {\n          w1 = -temp.z;\n          w2 = 1.0 - temp.y;\n          w3 = 1.0 - temp.x;\n          vertex1 = baseId + int2(1, 1);\n          vertex2 = baseId + int2(1, 0);\n          vertex3 = baseId + int2(0, 1);\n       }\n    }\n\n    // Fast random hash function\n    float2 SimpleHash2(float2 p)\n    {\n       return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 43758.5453);\n    }\n\n\n    half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)\n    {\n        // compute weight with height map\n        const half epsilon = 1.0f / 1024.0f;\n        half3 weights = half3(iWeights.x * (tex0 + epsilon), \n                                 iWeights.y * (tex1 + epsilon),\n                                 iWeights.z * (tex2 + epsilon));\n\n        // Contrast weights\n        half maxWeight = max(weights.x, max(weights.y, weights.z));\n        half transition = contrast * maxWeight;\n        half threshold = maxWeight - transition;\n        half scale = 1.0f / transition;\n        weights = saturate((weights - threshold) * scale);\n        // Normalize weights.\n        half weightScale = 1.0f / (weights.x + weights.y + weights.z);\n        weights *= weightScale;\n        return weights;\n    }\n\n\n    half3 PackedUnpackScaleNormal(half4 packedNormal, float scale)\n   {\n       #if _PACKEDFAST\n          half3 normal;\n          normal.xy = (packedNormal.ag * 2 - 1) * scale;\n          normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n          return normal;  \n       #endif\n       return UnpackScaleNormal(packedNormal, scale);\n   }\n\n    void InitStochasticDxDy(inout SampleConfig c, Config cfg)\n    {\n      c.dx0 = ddx(cfg.origUV) * cfg.origScale;\n      c.dy0 = ddy(cfg.origUV) * cfg.origScale;\n      c.dx1 = c.dx0; c.dx1 = c.dx0;\n      c.dx2 = c.dy0; c.dy2 = c.dy0;\n    }\n\n    void PrepareStochasticUVs(float scale, float2 uv, out SampleConfig c)\n    {\n       // Get triangle info\n       ZERO_INITIALIZE(SampleConfig, c);\n       float w1, w2, w3;\n       int2 vertex1, vertex2, vertex3;\n       TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n       // Assign random offset to each triangle vertex\n       c.uv0 = uv;\n       c.uv1 = uv;\n       c.uv2 = uv;\n   \n       c.uv0.xy += SimpleHash2(vertex1);\n       c.uv1.xy += SimpleHash2(vertex2);\n       c.uv2.xy += SimpleHash2(vertex3);\n       c.weights = half3(w1, w2, w3);\n       c.origWeights = half3(w1, w2, w3);\n    }\n\n\n   half3 LitBlendDetailNormal(half3 n1, half3 n2)\n   {\n      #if _SURFACEGRADIENT\n         return n1 + n2;\n      #else\n         return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n      #endif\n   }\n\n   float3 TriplanarBlendUnpackedRNM(float3 n1, float3 n2)\n   {\n       n1.z += 1;\n       n2.xy = -n2.xy;\n       return n1 * dot(n1, n2) / n1.z - n2;\n   }\n\n   void InitConfigDxDy(inout Config c)\n   {\n      c.uvT.dx0 = ddx(c.uvT.uv0);\n      c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1);\n      c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2);\n      c.uvT.dy2 = ddy(c.uvT.uv2);\n   }\n\n   Config CreateConfig(ShaderData d, float4 scale, float space, int uvsource, half triplanarContrast)\n   {\n      Config c;\n      ZERO_INITIALIZE(Config, c);\n\n      float3 pos = d.worldSpacePosition;\n      float3 normal = d.worldSpaceNormal;\n      if (space > 0)\n      {\n         pos = d.localSpacePosition;\n         normal = d.localSpaceNormal;\n      }\n\n      c.uv = d.texcoord0.xy;\n      \n      if (uvsource == 1)\n        c.uv = d.texcoord1.xy;\n      else if (uvsource == 2)\n        c.uv = pos.yz * float2(1, -1);\n      else if (uvsource == 3)\n        c.uv = pos.xz * float2(1, -1);\n      else if (uvsource == 4)\n        c.uv = pos.xy * float2(1, -1);\n\n      c.origUV = c.uv;\n      c.origScale = scale.xy;\n\n      c.uv = c.uv * scale.xy + scale.zw;\n      c.dx = ddx(c.uv);\n      c.dy = ddy(c.uv);\n\n      c.normal = normal;\n      c.uvT.uv0 = pos.zy * scale.xy + scale.zw;\n      c.uvT.uv1 = pos.xz * scale.xy + scale.zw;\n      c.uvT.uv2 = pos.xy * scale.xy + scale.zw;\n        \n      c.uvT.uv1 += 0.33;\n      c.uvT.uv2 += 0.67;\n\n      c.uvT.dx0 = ddx(c.uvT.uv0); c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1); c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2); c.uvT.dy2 = ddy(c.uvT.uv2);\n\n      half3 triblend = saturate(pow(abs(c.normal), triplanarContrast));\n      triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n      c.uvT.weights = triblend;\n      c.uvT.origWeights = triblend;\n      c.axisSign = d.worldSpaceNormal < 0 ? -1 : 1;\n      c.absVertNormal = abs(d.worldSpaceNormal);\n     \n\n      return c;\n   }\n\n\n   half4 TriSample(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0) * c.weights.x;\n      }\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1) * c.weights.y;\n      }  \n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2) * c.weights.z;\n      }\n\n      return res;\n   }\n\n   half4 TriSampleBary(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      c.weights = BaryWeightBlend(c.origWeights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   half4 TriSampleGrad(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvX, contrast, d) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvY, contrast, d) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n           res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvZ, contrast, d) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   \n   half4 SampleTexBaryStochastic(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   half4 SampleTexBaryTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleGrad(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   \n   half4 SampleTexBary(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        COUNTSAMPLE\n        return SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv, c.dx, c.dy);\n   }\n\n   half4 SampleTexStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ) * c.uvT.weights.z;\n\n        return res;     \n   }\n\n   \n   half4 SampleTexStochastic(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n\n   half4 SampleTexTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n   \n   half4 SampleTex(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       COUNTSAMPLE\n       return SAMPLE_TEXTURE2D(tex, ss, c.uv);\n   }\n   \n\n \n   half3 SampleNormalStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n         dataX = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n         dataY = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n         dataZ = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ));\n\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n\n          return WorldToTangentSpace(d, worldNormal);\n       #endif\n   }\n\n\n   half3 SampleNormalTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n      {\n          COUNTSAMPLE\n          dataX = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv0, c.uvT.dx0, c.uvT.dy0));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n      {\n          COUNTSAMPLE\n          dataY = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv1, c.uvT.dx1, c.uvT.dy1));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n      {\n         COUNTSAMPLE\n         dataZ = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv2, c.uvT.dx2, c.uvT.dy2));\n      }\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n          return WorldToTangentSpace(d, worldNormal);\n      #endif\n   }\n\n   half3 SampleNormalStochastic(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n     half4 normal = TriSample(tex, ss, c.uvT);\n     #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half3 SampleNormal(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 normal = SAMPLE_TEXTURE2D(tex, ss, c.uv);\n      #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half HeightBlend(half h1, half h2, half slope, half contrast)\n   {\n      h2 = 1 - h2;\n      half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); \n      half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));\n      return blend;\n   }\n\n\n    #if _POM\n    float2 POM(TEXTURE2D_PARAM(tex, ss), Config c, float contrast, ShaderData d)\n    {\n       float2 curv = float2(0, 0);\n       float refPlane = 0;\n\n       float result = 0;\n       int stepIndex = 0;\n       int maxSamples = _POMMaxSamples;\n       int minSamples = 4;\n       float camDist = distance(_WorldSpaceCameraPos, d.worldSpacePosition);\n       float distanceFade = 1 - saturate((camDist - _POMMin) / max(1, _POMFade));\n       int numSteps = ( int )lerp( maxSamples, minSamples, dot( d.worldSpaceNormal, d.worldSpaceViewDir )) * distanceFade;\n       if (numSteps < 1)\n           numSteps = 1;\n       float layerHeight = 1.0 / numSteps;\n       float2 plane = _ParallaxHeight * ( d.tangentSpaceViewDir.xy / d.tangentSpaceViewDir.z ) * distanceFade;\n       OffsetUV(c, refPlane * plane);\n       float2 deltaTex = -plane * layerHeight;\n       float2 prevTexOffset = 0;\n       float prevRayZ = 1.0f;\n       float prevHeight = 0.0f;\n       float2 currTexOffset = deltaTex;\n       float currRayZ = 1.0f - layerHeight;\n       float currHeight = 0.0f;\n       float intersection = 0;\n       float2 finalTexOffset = 0;\n\n       while ( stepIndex < numSteps + 1 )\n       {\n          result = dot( curv, currTexOffset * currTexOffset );\n          Config cfg = c;\n          OffsetUV(cfg, currTexOffset);\n          currHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( currHeight > currRayZ )\n          {\n             stepIndex = numSteps + 1;\n          }\n          else\n          {\n             stepIndex++;\n             prevTexOffset = currTexOffset;\n             prevRayZ = currRayZ;\n             prevHeight = currHeight;\n             currTexOffset += deltaTex;\n             currRayZ -= layerHeight * ( 1 - result );\n          }\n       }\n       int sectionSteps = 10;\n       int sectionIndex = 0;\n       float newZ = 0;\n       float newHeight = 0;\n       while ( sectionIndex < sectionSteps )\n       {\n          intersection = ( prevHeight - prevRayZ ) / ( prevHeight - currHeight + currRayZ - prevRayZ );\n          finalTexOffset = prevTexOffset + intersection * deltaTex;\n          newZ = prevRayZ - intersection * layerHeight;\n          Config cfg = c;\n          OffsetUV(cfg, finalTexOffset);\n          newHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( newHeight > newZ )\n          {\n             currTexOffset = finalTexOffset;\n             currHeight = newHeight;\n             currRayZ = newZ;\n             deltaTex = intersection * deltaTex;\n             layerHeight = intersection * layerHeight;\n          }\n          else\n          {\n             prevTexOffset = finalTexOffset;\n             prevHeight = newHeight;\n             prevRayZ = newZ;\n             deltaTex = ( 1 - intersection ) * deltaTex;\n             layerHeight = ( 1 - intersection ) * layerHeight;\n          }\n          sectionIndex++;\n       }\n       #if _PASSHADOWS\n       if ( unity_LightShadowBias.z == 0.0 )\n       {\n       #endif\n          if ( result > 1 )\n             clip( -1 );\n       #if _PASSHADOWS\n       }\n       #endif\n       return finalTexOffset;\n    }\n    #endif\n\n   \n\n   // tess versions\n   #if _TESSELLATION_ON\n   half4 TriSampleLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias) * c.weights.x;\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias) * c.weights.y;\n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias) * c.weights.z;\n\n      return res;\n   }\n\n   half4 TriSampleBaryLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias, float contrast)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias);\n      half4 r2 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias);\n      half4 r3 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias);\n      c.weights = BaryWeightBlend(c.weights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryLODStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvX, bias, contrast) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvY, bias, contrast) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvZ, bias, contrast) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   half4 SampleTexBaryLODStochastic(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n       return TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias, contrast);\n   }\n\n   half4 SampleTexBaryLODTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return TriSampleLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias);\n   }\n\n   half4 SampleTexBaryLOD(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv, bias);\n   }\n\n\n    float FBM2DLOD(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           return SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv, _TessellationMipBias).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n        \n        \n    }\n\n    float FBM3DLOD(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           half A = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.zy, _TessellationMipBias).g;\n           half B = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33, _TessellationMipBias).g;\n           half C = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67, _TessellationMipBias).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoiseLOD(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3DLOD(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3DLOD(d.localSpacePosition * frequency + offset, d.localSpaceNormal);\n        #else\n           return FBM2DLOD(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n   #endif //_TESSELLATION_ON\n\n\n    half3 FuzzyShade(ShaderData d, half height, half3 color, half3 normal, half coreMult, half edgeMult, half power)\n    {\n        float3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half dt = saturate(dot(d.worldSpaceViewDir, worldNormal));\n        half dark = 1.0 - (coreMult * dt);\n        half edge = pow(1-dt, abs(power)) * edgeMult;\n        return color * (dark + edge);\n    }\n\n\thalf MicroShadow(ShaderData d, half3 normal, half height, half ao, half strength)\n\t{\n        float3 sun;\n\t\tfloat3 sunColor;\n\t\tGetSun(sun, sunColor);\n\t\tfloat3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half shadow = saturate(abs(dot(worldNormal, sun)) + (ao * ao * 2.0) - 1.0);\n        return 1 - ((1-shadow) * strength);\n\t}\n\n\n#endif\n\n\n\n   #if defined(_SPECULAR)\n      #define _USESPECULAR 1\n      #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n   #endif\n\n   \n   TEXTURE2D(_AlbedoMap);\n   SAMPLER(sampler_AlbedoMap);\n   TEXTURE2D(_NormalMap);\n   SAMPLER(sampler_NormalMap);\n   TEXTURE2D(_MaskMap);\n   TEXTURE2D(_DetailMap);\n   TEXTURE2D(_EmissionMap);\n\n   #if _SPECULAR\n       TEXTURE2D(_SpecularMap);\n   #endif\n\n   \n   \n   void Ext_SurfaceFunction0 (inout Surface o, inout ShaderData d)\n   {\n      // define samplers based on settings\n      #undef SAMPLEBARY\n      #undef SAMPLE\n      #undef SAMPLENORMAL\n      #if _STOCHASTIC && _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n        #define SAMPLE     SampleTexStochasticTriplanar\n        #define SAMPLENORMAL SampleNormalStochasticTriplanar\n      #elif _STOCHASTIC\n        #define SAMPLEBARY SampleTexBaryStochastic\n        #define SAMPLE     SampleTexStochastic\n        #define SAMPLENORMAL SampleNormalStochastic\n      #elif _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryTriplanar\n        #define SAMPLE     SampleTexTriplanar\n        #define SAMPLENORMAL SampleNormalTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBary\n        #define SAMPLE     SampleTex\n        #define SAMPLENORMAL SampleNormal\n      #endif\n\n      Config c = CreateConfig(d, _AlbedoMap_ST, _TriplanarSpace, _UVSource, _TriplanarContrast);\n      InitConfigDxDy(c);\n      #if _STOCHASTIC && !_TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uv, c.uvT);\n         InitStochasticDxDy(c.uvT, c);\n      #elif _STOCHASTIC && _TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv0, c.uvX);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv1, c.uvY);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv2, c.uvZ);\n         InitStochasticDxDy(c.uvX, c);\n         InitStochasticDxDy(c.uvY, c);\n         InitStochasticDxDy(c.uvZ, c);\n      #endif\n\n      #if _POM\n          // would need to handle height remapping if we ever want to ship this\n          float2 pomOffset = POM(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n          OffsetUV(c, pomOffset);\n      #endif\n\n      half4 albedo = SAMPLEBARY(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n      \n      #if _PARALLAX\n         float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n         OffsetUV(c, offset);\n         albedo = SAMPLE(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c);\n         \n      #endif\n      albedo.a = lerp(_HeightRemap.x, _HeightRemap.y, albedo.a);\n      albedo.rgb *= _Tint.rgb;\n\n      albedo.rgb = AdjustContrast(albedo.rgb, _AlbedoContrast);\n      albedo.rgb += _AlbedoBrightness;\n\n\n      if (_AlphaThreshold > 0)\n      {\n         clip(albedo.a - _AlphaThreshold);\n      }\n\n      #if defined(_FLATSHADE)\n\t\t     float3 dx = ddx(d.worldSpacePosition);\n\t\t     float3 dy = ddy(d.worldSpacePosition);\n\t\t     float3 worldNormal = normalize(cross(dy, dx));\n\t\t     worldNormal = lerp(d.worldSpaceNormal, worldNormal, _FlatShadingBlend);\n\t\t     d.worldSpaceNormal = worldNormal;\n\t\t     d.TBNMatrix[2] = worldNormal;\n      #endif\n\n\n\n      o.Albedo = albedo.rgb;\n      o.Alpha = albedo.a;\n\n      float smoothness = _Smoothness;\n      float ao = 1;\n\n      #if defined(_NORMALMAP) && !defined(_AUTONORMAL)\n         o.Normal = SAMPLENORMAL(TEXTURE2D_ARGS(_NormalMap, sampler_NormalMap), c, d, _NormalStrength, smoothness, ao);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, ao);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n      #endif\n\n      half detailMask = 1;\n      o.Smoothness = smoothness;\n      o.Occlusion = ao;\n      o.Metallic = _Metallic;\n      #if defined(_MASKMAP) && !_PACKEDFAST\n         // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = SampleTex(TEXTURE2D_ARGS(_MaskMap, sampler_AlbedoMap), c);\n         o.Metallic = lerp(_MetallicRemap.x, _MetallicRemap.y, mask.r);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, mask.g);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, mask.a);\n         detailMask = mask.b;\n      #endif // separate maps\n\n      #if _SPECULAR\n         o.Specular = SAMPLE(TEXTURE2D_ARGS(_SpecularMap, sampler_AlbedoMap), c).rgb;\n      #endif\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = SAMPLE(TEXTURE2D_ARGS(_EmissionMap, sampler_AlbedoMap), c).rgb * _EmissionColor;\n      #endif\n\n      if (_FuzzyShadingOn > 0)\n      {\n        o.Albedo *= FuzzyShade(d, albedo.a, _FuzzyShadingColor, o.Normal, _FuzzyShadingParams.x, _FuzzyShadingParams.y, _FuzzyShadingParams.z);\n      }\n\n\n      // HDRP style detail texturing\n\n      #if defined(_DETAIL)\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _DETAILSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n         Config dc = CreateConfig(d, _DetailMap_ST, _DetailTriplanarSpace, _DetailUVSource, _DetailTriplanarContrast);\n         InitConfigDxDy(dc);\n         #if _DETAILSTOCHASTIC && !_DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uv, dc.uvT);\n             InitStochasticDxDy(dc.uvT, dc);\n         #elif _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv0, dc.uvX);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv1, dc.uvY);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv2, dc.uvZ);\n             InitStochasticDxDy(dc.uvX, dc);\n             InitStochasticDxDy(dc.uvY, dc);\n             InitStochasticDxDy(dc.uvZ, dc);\n         #endif\n\n         half4 detailSample = SAMPLEBARY(TEXTURE2D_ARGS(_DetailMap, sampler_AlbedoMap), dc, _DetailStochasticContrast, d);\n         smoothness = detailSample.z;\n         #if !_AUTONORMAL\n            half3 dnormal = float3(detailSample.ag * 2 - 1, 1) * detailMask * _DetailNormalStrength;\n            dnormal.z = sqrt(1 - dnormal.x * dnormal.x - dnormal.y * dnormal.y);\n            #if _SURFACEGRADIENT\n               dnormal = ConvertNormalToGradient(d, dnormal);\n            #endif\n            o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n         #endif\n     \n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * smoothness, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n      if (_MicroShadowStrength > 0)\n      {\n        o.Occlusion *= MicroShadow(d, o.Normal, o.Alpha, o.Occlusion, _MicroShadowStrength);\n      }\n  \n      // in case something needs height in the stack..\n      o.Height = o.Alpha;\n\n\n      \n   }\n\n\n\n\t#if _TINTMASK\n\t\tTEXTURE2D(_TintMask);\n\t\tSAMPLER(sampler_TintMask);\n\t#endif\n\n\tvoid Ext_SurfaceFunction1 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _TINTMASK\n\t\t   half4 w = SAMPLE_TEXTURE2D(_TintMask, sampler_TintMask, d.texcoord0.xy * _TintMask_ST.xy + _TintMask_ST.zw);\n\t\t   // allow black to be no tint..\n\t\t   half3 tint = o.Albedo * (_RColor.rgb * 2 * w.r + _GColor.rgb * 2 * w.g + _BColor.rgb * 2 * w.b + _AColor.rgb * 2 * w.a);\n\t\t   o.Albedo = lerp(o.Albedo, tint, saturate(w.r + w.g + w.b + w.a));\n\t\t#endif\n\t}\n\n\n\n\n\t#if _LAYERTEXTUREMASK\n       TEXTURE2D(_LayerTextureMask);\n       SAMPLER(sampler_LayerTextureMask); \n    #endif\n\n   void Ext_ModifyTessellatedVertex2 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON\n          float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n\n          #if _LAYERTEXTUREMASK\n               float2 layerUV = v.texcoord0.xy;\n               if (_LayerTextureMaskUVMode == 1)\n                  layerUV = v.texcoord1.xy;\n               else if (_LayerTextureMaskUVMode == 2)\n                  layerUV = worldSpacePosition.yz;\n               else if (_LayerTextureMaskUVMode == 3)\n                  layerUV = worldSpacePosition.xz;\n               else if (_LayerTextureMaskUVMode == 4)\n                  layerUV = worldSpacePosition.xy;\n\n              e.blackboard.weightTextureMask = SAMPLE_TEXTURE2D_LOD(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw, _TessellationMipBias);\n          #endif\n      #endif\n    }\n\n\n\tvoid Ext_SurfaceFunction2 (inout Surface o, inout ShaderData d)\n\t{\n\t\t#if _LAYERTEXTUREMASK\n           float2 layerUV = d.texcoord0.xy;\n           if (_LayerTextureMaskUVMode == 1)\n              layerUV = d.texcoord1.xy;\n           else if (_LayerTextureMaskUVMode == 2)\n              layerUV = d.worldSpacePosition.yz;\n           else if (_LayerTextureMaskUVMode == 3)\n              layerUV = d.worldSpacePosition.xz;\n           else if (_LayerTextureMaskUVMode == 4)\n              layerUV = d.worldSpacePosition.xy;\n\n          d.blackboard.weightTextureMask = SAMPLE_TEXTURE2D(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw);\n      #endif\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap);\n   SAMPLER(sampler_LayerAlbedoMap);\n   TEXTURE2D(_LayerNormalMap);\n   TEXTURE2D(_LayerMaskMap);\n   TEXTURE2D(_LayerEmissionMap);\n\n   \n\n   void Ext_ModifyTessellatedVertex3 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER) && defined(_LAYERALBEDO) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n         half detailMask = 1;\n         #if _LAYERNOISE\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency,  _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin;\n            dt = saturate(dt * _LayerFalloff);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight) * _LayerFalloff);\n            if (_LayerInvertHeight > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength;\n         detailMask *= _LayerTessStrength;\n\n         #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast).a;\n         albedo = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo);\n\n         if (_LayerBlendMode == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction3 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n            // noise up the mask\n            #if _LAYERNOISE\n               mask = DoNoise(d, _LayerNoiseFrequency, _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend);\n\t    \n                dt -= _LayerAngleMin;\n                dt = saturate(dt * _LayerFalloff);\n\n                float hf = saturate((o.Height - _LayerHeight) * _LayerFalloff);\n                if (_LayerInvertHeight > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 0\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 0\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength;\n\n            #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint, 0.5);\n            #if defined(_LAYERALBEDO)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c, _LayerStochasticContrast, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c);\n                #endif\n                albedo.rgb *= _LayerTint;\n                albedo.a = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL || _LAYERMASK\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap, sampler_LayerAlbedoMap, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast);\n            albedo.rgb += _LayerAlbedoBrightness;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap, sampler_LayerAlbedoMap), c, d, _LayerNormalStrength * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO)\n                if (_LayerFuzzyShadingOn > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor.rgb, dnormal,\n                                            _LayerFuzzyShadingParams.x, _LayerFuzzyShadingParams.y, _LayerFuzzyShadingParams.z);\n                }\n\n                if (_LayerBlendMode == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast);\n                else if (_LayerBlendMode == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE\n                      float maskDif = (_LayerBlendContrast * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength);\n                   #if _LAYERNOISE\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap, sampler_LayerAlbedoMap), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength);\n                }\n\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap, sampler_LayerAlbedoMap), c).rgb * _LayerEmissionColor;\n                #if _LAYERALBEDO\n                    if (_LayerBlendMode > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_1);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_1);\n   TEXTURE2D(_LayerNormalMap_Ext_1);\n   TEXTURE2D(_LayerMaskMap_Ext_1);\n   TEXTURE2D(_LayerEmissionMap_Ext_1);\n\n   \n\n   void Ext_ModifyTessellatedVertex4 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_1) && defined(_LAYERALBEDO_DEF_1) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_1\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_1,  _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_1\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_1;\n            dt = saturate(dt * _LayerFalloff_Ext_1);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n            if (_LayerInvertHeight_Ext_1 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_1;\n         detailMask *= _LayerTessStrength_Ext_1;\n\n         #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_1).a;\n         albedo = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo);\n\n         if (_LayerBlendMode_Ext_1 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_1);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_1 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction4 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_1)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_1\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_1, _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_1\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_1);\n\t    \n                dt -= _LayerAngleMin_Ext_1;\n                dt = saturate(dt * _LayerFalloff_Ext_1);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n                if (_LayerInvertHeight_Ext_1 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 01\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 01\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_1;\n\n            #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_1, 0.5);\n            #if defined(_LAYERALBEDO_DEF_1)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, _LayerStochasticContrast_Ext_1, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_1;\n                albedo.a = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_1 || _LAYERMASK_DEF_1\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_1);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_1;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, d, _LayerNormalStrength_Ext_1 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_1)\n                if (_LayerFuzzyShadingOn_Ext_1 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_1.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_1.x, _LayerFuzzyShadingParams_Ext_1.y, _LayerFuzzyShadingParams_Ext_1.z);\n                }\n\n                if (_LayerBlendMode_Ext_1 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_1);\n                else if (_LayerBlendMode_Ext_1 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_1 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_1);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_1\n                      float maskDif = (_LayerBlendContrast_Ext_1 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_1 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                   #if _LAYERNOISE_DEF_1\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_1));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_1 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_1);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_1) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_1 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_1);\n                }\n\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_1);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_1, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_1, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_1\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c).rgb * _LayerEmissionColor_Ext_1;\n                #if _LAYERALBEDO_DEF_1\n                    if (_LayerBlendMode_Ext_1 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_2);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_2);\n   TEXTURE2D(_LayerNormalMap_Ext_2);\n   TEXTURE2D(_LayerMaskMap_Ext_2);\n   TEXTURE2D(_LayerEmissionMap_Ext_2);\n\n   \n\n   void Ext_ModifyTessellatedVertex5 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_2) && defined(_LAYERALBEDO_DEF_2) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_2\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_2,  _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_2\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_2;\n            dt = saturate(dt * _LayerFalloff_Ext_2);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n            if (_LayerInvertHeight_Ext_2 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_2;\n         detailMask *= _LayerTessStrength_Ext_2;\n\n         #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_2).a;\n         albedo = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo);\n\n         if (_LayerBlendMode_Ext_2 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_2);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_2 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction5 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_2)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_2\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_2, _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_2\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_2);\n\t    \n                dt -= _LayerAngleMin_Ext_2;\n                dt = saturate(dt * _LayerFalloff_Ext_2);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n                if (_LayerInvertHeight_Ext_2 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 02\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 02\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_2;\n\n            #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_2, 0.5);\n            #if defined(_LAYERALBEDO_DEF_2)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, _LayerStochasticContrast_Ext_2, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_2;\n                albedo.a = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_2 || _LAYERMASK_DEF_2\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_2);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_2;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, d, _LayerNormalStrength_Ext_2 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_2)\n                if (_LayerFuzzyShadingOn_Ext_2 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_2.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_2.x, _LayerFuzzyShadingParams_Ext_2.y, _LayerFuzzyShadingParams_Ext_2.z);\n                }\n\n                if (_LayerBlendMode_Ext_2 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_2);\n                else if (_LayerBlendMode_Ext_2 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_2 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_2);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_2\n                      float maskDif = (_LayerBlendContrast_Ext_2 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_2 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                   #if _LAYERNOISE_DEF_2\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_2));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_2 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_2);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_2) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_2 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_2);\n                }\n\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_2);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_2, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_2, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_2\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c).rgb * _LayerEmissionColor_Ext_2;\n                #if _LAYERALBEDO_DEF_2\n                    if (_LayerBlendMode_Ext_2 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   #if _TRAX_ON\n   TEXTURE2D(_TraxAlbedo);\n   SAMPLER(sampler_TraxAlbedo);\n   TEXTURE2D(_TraxPackedNormal);\n   TEXTURE2D(_TraxMask);\n\n   sampler2D_float _GMSTraxBuffer;\n\n   float4 _GMSTraxBuffer_TexelSize;\n   float3 _GMSTraxBufferPosition;\n   float _GMSTraxBufferWorldSize;\n   float _GMSTraxFudgeFactor;\n\n   float SampleTraxBufferLOD(float3 worldPos)\n   {    \n      // generate UVs for the buffer, which is moving\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 8);\n      uv *= 0.5;\n      uv += 0.5;\n            \n      float s =  tex2Dlod(_GMSTraxBuffer, float4(uv, 0, 0)).r;\n\n      return 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n   }\n         \n        \n   float SampleTraxBuffer(float3 worldPos, out float3 norm)\n   {\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 3);\n      uv *= 0.5;\n      uv += 0.5;\n            \n\n      float2 offset = _GMSTraxBuffer_TexelSize.xy;\n\n      float s = tex2D(_GMSTraxBuffer, uv).r;\n               \n      float s1 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, -1)).r;\n      float s2 = tex2D(_GMSTraxBuffer, uv + offset * float2(-1, 0)).r;\n      float s3 = tex2D(_GMSTraxBuffer, uv + offset * float2(1, 0)).r;\n      float s4 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, 1)).r;\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      float r = 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n \n      // generate normals\n      norm.x = (s1 - s4) * 0.25; \n      norm.y = (s2 - s3) * 0.25;\n      norm.z = 2;\n      norm = normalize(norm);\n     \n      norm.xy *= 1 - r;\n            \n      return r;\n   }\n   #endif\n\n   void Ext_ModifyTessellatedVertex6 (inout VertexData v, inout ExtraV2F d)\n   {\n       #if _TESSELLATION_ON && _TRAX_ON && _HAS_LIT_TESSELLATION\n          \n           float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n           float3 worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n           float traxBuffer = SampleTraxBufferLOD(worldSpacePosition);\n           d.blackboard.traxBuffer = traxBuffer;\n           float2 uv = worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n           half albedo = SAMPLE_TEXTURE2D_LOD(_TraxAlbedo, sampler_TraxAlbedo, uv, _TraxMipBias).a;\n\n           float traxOffset = albedo * _TraxDisplacementStrength;\n           traxOffset *= 1 - v.texcoord0.z;\n           traxOffset *= _TessellationDisplacement;\n           float dig = _TraxDisplacementDepth * (1 - v.texcoord0.z);\n           float3 traxVertex = d.blackboard.originalVertexPosition + (v.normal * (traxOffset - dig));\n           v.vertex.xyz = lerp(traxVertex, v.vertex.xyz, traxBuffer);\n\n           d.blackboard.vertexHeightOffset = lerp(traxOffset-dig, d.blackboard.vertexHeightOffset, traxBuffer);\n\n       #endif\n\n   }\n\n   void Ext_SurfaceFunction6 (inout Surface o, inout ShaderData d)\n   {\n      #if _TRAX_ON\n        float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n        float2 fsdx = ddx(uv);\n        float2 fsdy = ddy(uv);\n\n        float3 traxNormal;\n        float traxBuffer = SampleTraxBuffer(d.worldSpacePosition, traxNormal);\n        \n        #if _TESSELLATION_ON\n            traxBuffer -= _TraxDisplacementDepth;\n        #endif\n\n        d.blackboard.traxBuffer = traxBuffer;\n\n        UNITY_BRANCH\n        if (traxBuffer > 0)\n        {\n            half4 albedo = SAMPLE_TEXTURE2D_GRAD(_TraxAlbedo, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            albedo.rgb *= _TraxTint.rgb;\n            half4 normalSample = SAMPLE_TEXTURE2D_GRAD(_TraxPackedNormal, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n\n            half smoothness = normalSample.r;\n            half ao = normalSample.b;\n            half3 normal;\n            normal.xy = (normalSample.ag * 2 - 1) * _TraxNormalStrength;\n            normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n\n            \n            half h = HeightBlend(albedo.a, o.Alpha, traxBuffer, _TraxHeightContrast);\n\n            h = lerp(traxBuffer, h, _TraxInterpContrast);\n\n            o.Albedo = lerp(albedo, o.Albedo, h);\n\n            #if _SURFACEGRADIENT\n                o.Normal = lerp(normal, o.Normal, h);\n            #else\n                o.Normal = lerp(normal + traxNormal, o.Normal, h);\n            #endif\n        \n            o.Smoothness = lerp(smoothness, o.Smoothness, h);\n            o.Occlusion = lerp(ao, o.Occlusion, h);\n        }\n      #endif\n   }\n\n\n\n\n    #if _RAINDROPS\n       TEXTURE2D(_RainDropTexture);\n       SAMPLER(sampler_RainDropTexture);\n       half _Global_RainIntensity;\n    #endif\n\n    #if _WETNESS\n       half2 _Global_WetnessParams; // global, not in cbuffer\n    #endif\n   \n    #if _RAINDROPS\n    half2 ComputeRipple(float2 uv, half time, half weight)\n    {\n        half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_RainDropTexture, uv);\n        COUNTSAMPLE\n        ripple.yz = ripple.yz * 2 - 1;\n\n        half dropFrac = frac(ripple.w + time);\n        half timeFrac = dropFrac - 1.0 + ripple.x;\n        half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);\n        half finalFactor = dropFactor * ripple.x * \n                                sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);\n\n        return half2(ripple.yz * finalFactor);\n    }\n    #endif\n\n    half2 DoRain(half2 waterNorm, float2 uv, out half2 ripple)\n    {\n        #if _RAINDROPS\n            float rainIntensity = _RainIntensityScale.x;\n            if (_RainMode > 1)\n            {\n                rainIntensity = _Global_RainIntensity;\n            }\n\n            half dropStrength = rainIntensity;\n            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); \n            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);\n            half4 times = _Time.yyyy;\n            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);\n\n            float2 ruv1 = uv * _RainIntensityScale.yy;\n            float2 ruv2 = ruv1;\n\n            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);\n            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);\n            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);\n            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);\n            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);\n            weights = saturate(weights * 4);\n\n            half2 rippleNormal = half2( weights.x * ripple1.xy +\n                        weights.y * ripple2.xy + \n                        weights.z * ripple3.xy + \n                        weights.w * ripple4.xy);\n\n            ripple = rippleNormal * dropStrength * rainIntensity;\n            waterNorm = lerp(waterNorm, normalize(half3(rippleNormal.xy + rippleNormal.xy, 1)).xy, rainIntensity * dropStrength); \n            return waterNorm;                        \n        #else\n            return waterNorm;\n        #endif\n    }\n\n   half2 _Global_PuddleParams;   // this is a global, so keep it out of the cbuffer\n   void GetPuddleParams(ShaderData d, inout float puddleMask, inout float pudHeight)\n   {\n      #if _PUDDLES || _GLOBALPUDDLES\n          pudHeight = _PuddleAmount;\n          if (_PuddleMode > 0)\n             pudHeight = _Global_PuddleParams.x;    \n      \n\n          half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t      dt -= _PuddleAngleMin;\n          dt = saturate(dt * _PuddleFalloff);\n          puddleMask *= dt;\n      #endif\n   }\n   \n   void Ext_ModifyTessellatedVertex7 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _PUDDLES && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n         half mask = 1;\n         half pudHeight = 1;\n\n         // save some ops by doing this in 2d\n         #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2DLOD(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2DLOD(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #else\n                mask = (FBM2DLOD(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n         #endif\n\n         GetPuddleParams(d, mask, pudHeight);\n         float height = pudHeight * mask;\n         if (e.blackboard.vertexHeightOffset < height)\n         {\n            e.blackboard.vertexHeightOffset = height;\n            height -= _TessellationOffset; \n            // dampen cracks\n            height *= 1 - v.texcoord0.z;\n            height *= _TessellationDisplacement;\n            v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n            \n        }\n      #endif\n   }\n\n\n#if _WETNESS\n\n   float GetWetnessLevel(Surface o, ShaderData d, float wetnessMask)\n   {\n      float wetLevel = clamp(_WetnessAmount, _WetnessMin, _WetnessMax);\n      \n      if (_WetnessMode > 0)\n         wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);\n\n      wetLevel = saturate(wetLevel + (1 - saturate(d.worldSpacePosition.y - _WetnessShoreline)));\n      float3x3 tbn = float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal);\n      float dt = dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0));\n      dt -= _WetnessAngleMin;\n      dt = saturate(dt * _WetnessFalloff * wetLevel);\n      dt *= wetnessMask;\n      return dt;\n   }\n#endif\n   \n\n   void Ext_SurfaceFunction7 (inout Surface o, ShaderData d)\n   {\n      half wetnessLevel = 0;\n      #if _WETNESS\n          wetnessLevel = GetWetnessLevel(o, d, 1); // mask one day?\n      #endif\n\n      half depthMask = 0;\n      half depth = 0;\n\n      #if _PUDDLES\n          half mask = 1;\n          half pudHeight = 1;\n          #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2D(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2D(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);      \n            #else\n                mask = (FBM2D(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n          #endif\n\n          GetPuddleParams(d, mask, pudHeight);\n          pudHeight *= mask;\n          depth = pudHeight - o.Height;\n          depthMask = saturate(depth * _PuddleFalloff);\n          depthMask *= _PuddleColor.a;\n          depth = o.Height - pudHeight;\n\n          // extend wetness slighting higher than the puddle\n          half wetmask = saturate((pudHeight + 0.05 - o.Height) * _PuddleFalloff);\n          wetnessLevel = max(wetmask, wetnessLevel);\n       #endif\n\n       \n       #if _WETNESS || _PUDDLES\n          half3 waterNorm = half3(0,0,1);\n          half3 wetAlbedo = o.Albedo;\n          half wetSmoothness = o.Smoothness;\n          #if _PUDDLES\n             wetAlbedo *= _PuddleColor.rgb;\n          #endif\n          WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetnessLevel, _Porosity);\n\n          half ri = 0;\n          half2 ripple = 0;\n          #if (_RAINDROPS || _GLOBALRAIN) && (_PUDDLES || _GLOBALPUDDLES)\n             ri = _RainIntensityScale.z;\n             waterNorm.xy = DoRain(waterNorm.xy, d.texcoord0.xy, ripple) * depthMask;\n          #endif\n\n          o.Normal = lerp(o.Normal, waterNorm, depthMask);\n          o.Normal = lerp(o.Normal, LitBlendDetailNormal(o.Normal, half3(ripple.xy, 1)), saturate(ri - depthMask) * wetnessLevel);\n          o.Occlusion = lerp(o.Occlusion, 1, depthMask);\n          o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetnessLevel);\n          o.Albedo = lerp(o.Albedo, wetAlbedo, wetnessLevel);\n          o.Emission *= 1 + depth;\n          o.Metallic *= 1 + depth;\n          o.Specular *= 1 + depth;\n\n       #endif\n\n   }\n\n\n\n\n    #if _SNOW\n       TEXTURE2D(_SnowAlbedo);\n       SAMPLER(sampler_SnowAlbedo);\n       TEXTURE2D(_SnowNormal);\n       TEXTURE2D(_SnowMaskMap);\n       #if _TRAX_ON\n          TEXTURE2D(_SnowTraxAlbedo);\n          TEXTURE2D(_SnowTraxNormal);\n          TEXTURE2D(_SnowTraxMaskMap);\n       #endif\n    #endif\n\n   float _Global_SnowLevel;\n\n\n   void Ext_ModifyVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n    #if (_SNOW)\n        float amount = _SnowAmount;\n        if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n        float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n        float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n        snowAmount -= _SnowAngle;\n        snowAmount *= _SnowContrast * 0.5;\n        snowAmount = saturate(snowAmount) * amount;\n        float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n        if (_SnowWorldFade.z > 0)\n        {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n        }\n        #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n        #endif\n        snowAmount = saturate(snowAmount);\n\n        #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n        #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n        #endif\n\n        float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n        v.vertex.xyz = v.vertex.xyz + displacementVec * snowAmount * snowAmount * _SnowVertexHeight;\n    #endif\n   }\n\n   void Ext_ModifyTessellatedVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _SNOW && _HAS_LIT_TESSELLATION\n         float amount = _SnowAmount;\n         if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n         float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n         float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n         snowAmount -= _SnowAngle;\n         snowAmount *= _SnowContrast * 0.5;\n         float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n         if (_SnowWorldFade.z > 0)\n         {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n         }\n\n         snowAmount = saturate(snowAmount) * amount;\n\n         #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n         #endif\n         snowAmount = saturate(snowAmount);\n\n         #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n         #endif\n\n         float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n         half heightMap = SAMPLE_TEXTURE2D_LOD(_SnowAlbedo, sampler_SnowAlbedo, worldPos.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw, 2);\n\n         float height = max(_SnowVertexHeight * 3 * snowAmount + snowAmount * heightMap, e.blackboard.vertexHeightOffset);\n         #if _TRAX_ON\n            height *= e.blackboard.traxBuffer;\n         #endif\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n\n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n         \n      #endif\n\n   }\n\n   void SampleSnowSurface(TEXTURE2D_PARAM(alb, ss), TEXTURE2D_PARAM(norm, ss2), TEXTURE2D_PARAM(mask, ss3),\n        ShaderData d, float2 uv, float2 dx, float2 dy, out half4 albedo, out half3 normal, out half2 smoothAO)\n   {\n      #if _SNOWSTOCHASTIC\n         float w1, w2, w3;\n         int2 vertex1, vertex2, vertex3;\n         TriangleGrid(uv, _SnowStochasticScale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n         // Assign random offset to each triangle vertex\n         float2 uv0 = uv;\n         float2 uv1 = uv;\n         float2 uv2 = uv;\n   \n         uv0.xy += SimpleHash2(vertex1);\n         uv1.xy += SimpleHash2(vertex2);\n         uv2.xy += SimpleHash2(vertex3);\n         half3 weights = half3(w1, w2, w3);\n\n         half4 albedo0 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv0, dx, dy);\n         half4 albedo1 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv1, dx, dy);\n         half4 albedo2 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv2, dx, dy);\n         COUNTSAMPLE\n         COUNTSAMPLE\n         COUNTSAMPLE\n         weights = BaryWeightBlend(weights, albedo0.a, albedo1.a, albedo2.a, _SnowStochasticContrast);\n         albedo = albedo0 * weights.x + albedo1 * weights.y + albedo2 * weights.z;\n\n         normal = half3(0,0,1);\n         smoothAO = half2(0, 1);\n\n         #if !_AUTONORMAL\n            half4 n0 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv0, dx, dy);\n            half4 n1 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv1, dx, dy);\n            half4 n2 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n            half4 snowNormSamp = n0 * weights.x + n1 * weights.y + n2 * weights.z;\n\n            normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n                \n            #if _PACKEDFAST\n               smoothAO.x = snowNormSamp.r;\n               smoothAO.y = snowNormSamp.b;\n            #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask0 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv0, dx, dy);\n            half4 snowMask1 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv1, dx, dy);\n            half4 snowMask2 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n            half4 snowMask = snowMask0 * weights.x + snowMask1 * weights.y + snowMask2 * weights.z;\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n      #else // not stochastic\n          albedo = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv, dx, dy);\n          COUNTSAMPLE\n\n          normal = half3(0,0,1);\n          smoothAO = half2(0, 1);\n\n          #if !_AUTONORMAL\n             half4 snowNormSamp = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv, dx, dy);\n             COUNTSAMPLE\n             normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n             #if _SURFACEGRADIENT\n                normal = ConvertNormalToGradient(d, normal);\n             #endif\n                 \n             #if _PACKEDFAST\n                smoothAO.x = snowNormSamp.r;\n                smoothAO.y = snowNormSamp.b;\n             #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv, dx, dy);\n            COUNTSAMPLE\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n     #endif // stochastic\n   }\n\n   \n   void Ext_SurfaceFunction8 (inout Surface o, ShaderData d)\n   {\n      #if _SNOW\n          float amount = _SnowAmount;\n          if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n          float snowAmount = lerp(dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), dot(d.worldSpaceNormal, float3(0,1,0)), amount * 0.8) + 1;\n          snowAmount -= _SnowAngle;\n          snowAmount *= _SnowContrast;\n          snowAmount = saturate(snowAmount) - (1-amount) * (1-amount);\n\n          if (_SnowWorldFade.z > 0)\n          {\n             float worldFade = saturate((d.worldSpacePosition.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n             snowAmount *= worldFade;\n          }\n\n          #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(d.worldSpacePosition.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n          #endif\n          snowAmount = saturate(snowAmount);\n\n          float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw;\n          float2 dx = ddx(uv);\n          float2 dy = ddy(uv);\n\n          #if _TRAX_ON\n              float2 tuv = d.worldSpacePosition.xz * float2(1, -1) * _SnowTraxAlbedo_ST.xy + _SnowTraxAlbedo_ST.zw;\n              float2 tdx = ddx(uv);\n              float2 tdy = ddy(uv);\n          #endif\n\n          #if _LAYERVERTEXMASK\n              snowAmount *= d.vertexColor.a;\n          #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n              snowAmount *= d.blackboard.weightTextureMask.a;\n          #endif\n\n          UNITY_BRANCH\n          if (snowAmount > 0)\n          {\n             half4 snowAlbedo;\n             half3 snowNormal;\n             half2 snowSmoothAO;\n             SampleSnowSurface(TEXTURE2D_ARGS(_SnowAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowNormal, sampler_SnowAlbedo),\n                    TEXTURE2D_ARGS(_SnowMaskMap, sampler_SnowAlbedo), d, uv, dx, dy, snowAlbedo, snowNormal, snowSmoothAO);\n\n             snowAlbedo.rgb *= _SnowTint.rgb;\n\n             #if _TRAX_ON\n                half traxBuffer = 1 - d.blackboard.traxBuffer;\n                UNITY_BRANCH\n                if (traxBuffer > 0)\n                {\n                    half4 tsnowAlbedo;\n                    half3 tsnowNormal;\n                    half2 tsnowSmoothAO;\n                    SampleSnowSurface(TEXTURE2D_ARGS(_SnowTraxAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowTraxNormal, sampler_SnowAlbedo),\n                        TEXTURE2D_ARGS(_SnowTraxMaskMap, sampler_SnowAlbedo), d, tuv, tdx, tdy, tsnowAlbedo, tsnowNormal, tsnowSmoothAO);\n\n                    tsnowAlbedo.rgb *= _SnowTraxTint;\n                    half h = HeightBlend(snowAlbedo.a, tsnowAlbedo.a, traxBuffer, 0.5);\n                    snowAlbedo = lerp(snowAlbedo, tsnowAlbedo, h);\n                    snowNormal = lerp(snowNormal, tsnowNormal, h);\n                    snowSmoothAO = lerp(snowSmoothAO, tsnowSmoothAO, h);\n                }\n             #endif\n\n             #if !_AUTONORMAL\n                o.Normal = lerp(o.Normal, snowNormal, snowAmount);\n             #endif\n             o.Albedo = lerp(o.Albedo, snowAlbedo.rgb, snowAmount);\n             o.Alpha = lerp(o.Alpha, snowAlbedo.a, snowAmount);\n             o.Smoothness = lerp(o.Smoothness, snowSmoothAO.x, snowAmount);\n             o.Occlusion = lerp(o.Occlusion, snowSmoothAO.y, snowAmount);\n             o.Height = o.Alpha;\n\n          }\n      #endif\n   }\n\n   \n\n\n\n\n\n   TEXTURE2D(_WindParticulate);\n   SAMPLER(sampler_WindParticulate);\n\n// In case we want to read it more than once..\n\n#ifndef __STACKABLE_WIND_INCLUDES__\n#define __STACKABLE_WIND_INCLUDES__\n\n\n   half FilterRange(float4 range, float y)\n   {\n      half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));\n      w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));\n      return w;\n   }\n\n   \n   float2 RotateUV(float2 uv, float amt)\n   {\n      uv -=0.5;\n      float s = sin ( amt);\n      float c = cos ( amt );\n      float2x2 mtx = float2x2( c, -s, s, c);\n      mtx *= 0.5;\n      mtx += 0.5;\n      mtx = mtx * 2-1;\n      uv = mul ( uv, mtx );\n      uv += 0.5;\n      return uv;\n   }\n\n\n   half FilterWindParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)\n   {\n      float2 windDir = RotateUV(float2(1, 0), windRot);\n      float2 flow = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));\n      float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill\n      return FilterRange(range, cofacing);\n   }\n\n   half ProcessWindParticulateMask(inout half mask, float contrast)\n   {\n      mask = pow(abs(mask), abs(contrast));\n      half invMask = 1.0 - mask;\n      invMask *= invMask; \n      invMask *= invMask;\n      return invMask;\n   }\n#endif // include guard\n\n   void Ext_SurfaceFunction9 (inout Surface o, ShaderData d)\n   {\n      #if _WIND_ON && !_PASSMETA\n   \n         float3 upVector = float3(0,0,1);\n\n         half upDot = max(0.0, dot(d.worldSpaceNormal, float3(0, 1, 0)));\n\n         float2 uv = d.worldSpacePosition.xz;\n         if (_WindParticulateSpace > 0.5)\n            uv = d.texcoord0.xy;\n         float windRotation = _WindParticulateRotation;\n         float windStrength = _WindParticulateStrength;\n\n         float2 wuv = RotateUV(uv, windRotation);\n\n         half windBlend = 1.0;\n\n         float windWorldMask = FilterRange(_WindParticulateWorldHeightMask, d.worldSpacePosition.y);\n         windWorldMask *= FilterRange(_WindParticulateAngleMask, upDot);\n\n         // compute mask\n         wuv *= float2(_WindParticulate_ST.x, 1) * _WindParticulate_ST.y + _WindParticulate_ST.zw;\n         float speed = _Time.x * _WindParticulateSpeed;\n         half w1 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv * 3 + speed * float2(1,0)).g;\n         half w2 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv + speed * float2(1.1,0)).a;\n         half windMask = (w1 * w2);\n\n         windMask *= windStrength * windBlend * windWorldMask;\n         windMask *= saturate((_WindParticulateTextureHeight - o.Height) * 10);\n\n         half windInvMask = ProcessWindParticulateMask(windMask, _WindParticulatePower);\n    \n         o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);\n         o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindParticulateEmissive.rgb;\n         o.Normal.xy *= windInvMask;\n         o.Smoothness *= windInvMask;\n         o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;\n         o.Metallic *= windInvMask;\n      #endif\n\n   }\n\n\n\n\n\tvoid Ext_SurfaceFunction10 (inout Surface o, ShaderData d)\n\t{\n        if (_DoubleSidedNormalMode == 0)\n        {\n           o.Normal *= d.isFrontFace ? 1 : -1;\n        }\n        else if (_DoubleSidedNormalMode == 1)\n        {\n\t\t   o.Normal.z *= d.isFrontFace ? 1 : -1;\n        }\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction11 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _SURFACEGRADIENT\n\t\t\to.Normal = ResolveNormalFromSurfaceGradient(d, o.Normal);\n\t    #elif _AUTONORMAL\n\t        float3 dx = ddx(d.worldSpacePosition);\n\t\t\tfloat3 dy = ddy(d.worldSpacePosition);\n\t\t\tfloat3 crossX = cross(float3(0,1,0), dx);\n\t\t\tfloat3 crossY = cross(float3(0,1,0), dy);\n\t\t\tfloat3 dt = abs(dot(crossY, dx));\n\t\t\tfloat height = _AutoNormalStrength * 0.5 * o.Alpha;\n\t\t\tfloat3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n\t\t\tn.y *= -1.0;\n\t\t\to.Normal = normalize((dt * float3(0,1,0)) - n).xzy;\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#else\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#endif\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction12 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DEBUG_SAMPLECOUNT\n\t\t\tif (_sampleCount > _DebugSampleCountThreshold)\n\t\t\t{\n\t\t\t\to.Albedo.r = 1;\n\t\t\t\to.Albedo.gb *= 0.2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\to.Albedo.b = 1;\n\t\t\t}\n\n        #endif\n\t}\n\n\n\n\n\tSAMPLER(sampler_DissolveTexture);\n\tTEXTURE2D(_DissolveTexture);\n\tTEXTURE2D(_DissolveGradient);\n\n\tvoid Ext_SurfaceFunction13 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DISSOLVE\n\t\tfloat2 uv = d.texcoord0.xy * _DissolveTexture_ST.xy + _DissolveTexture_ST.zw;\n\t\tfloat2 dx = ddx(uv);\n\t\tfloat2 dy = ddy(uv);\n\n\t\tUNITY_BRANCH\n\t\tif (_DissolveAmount > 0)\n\t\t{\n\t\t\thalf dissolve = SAMPLE_TEXTURE2D_GRAD(_DissolveTexture, sampler_DissolveTexture, uv, dx, dy).g;\n\t\t\thalf cp =  saturate(_DissolveAmount - (dissolve - _DissolveAmount) * _DissolveEdgeContrast) + _DissolveAmount;\n\t\t\thalf cp2 = saturate(1.0 - abs((dissolve - _DissolveAmount) * _DissolveEdgeContrast));\n\t\t\tclip(1.0 - cp);\n\t\t\tfloat2 fuv = float2(cp2, 0.5);\n\t\t\thalf3 col = SAMPLE_TEXTURE2D_LOD(_DissolveGradient, sampler_DissolveTexture, fuv, 0).rgb;\n\t\t\t\t\n\t\t\to.Albedo = lerp(o.Albedo, col, _DissolveColoration * cp2);\n\t\t\to.Emission = lerp(o.Emission, col * _DissolveEmissiveStr, _DissolveColoration * cp2);\n\t\t}\n\t\t#endif\n\t}\n\n\n\n\n    float Dither8x8Bayer( int x, int y )\n    {\n        const float dither[ 64 ] = {\n                1, 49, 13, 61,  4, 52, 16, 64,\n            33, 17, 45, 29, 36, 20, 48, 32,\n                9, 57,  5, 53, 12, 60,  8, 56,\n            41, 25, 37, 21, 44, 28, 40, 24,\n                3, 51, 15, 63,  2, 50, 14, 62,\n            35, 19, 47, 31, 34, 18, 46, 30,\n            11, 59,  7, 55, 10, 58,  6, 54,\n            43, 27, 39, 23, 42, 26, 38, 22};\n        int r = y * 8 + x;\n        return dither[r] / 64; \n    }\n\n    void ApplyDitherCrossFadeVSP(float2 vpos, float fadeValue)\n    {\n        float dither = Dither8x8Bayer( fmod(vpos.x, 8), fmod(vpos.y, 8) );\n        float sgn = fadeValue > 0 ? 1.0f : -1.0f;\n        clip(dither - (1-fadeValue) * sgn);\n    }\n    \n\n\tvoid Ext_SurfaceFunction14 (inout Surface o, ShaderData d)\n\t{\n\t\t#if LOD_FADE_CROSSFADE\n            float4 screenPosNorm = d.screenPos / d.screenPos.w;\n            screenPosNorm.z = ( UNITY_NEAR_CLIP_VALUE >= 0 ) ? screenPosNorm.z : screenPosNorm.z * 0.5 + 0.5;\n            float2 clipScreen = screenPosNorm.xy * _ScreenParams.xy;\n            ApplyDitherCrossFadeVSP(clipScreen,unity_LODFade.x);\n        #endif\n\t}\n\n\n\n\n\n\n// declare outside of CBuffer\n\nfloat4x4 _GlobalVolumeMatrix;\nfloat4x4 _VolumeMatrix;\nfloat3 _VolumeMin;\nfloat3 _VolumeInvSize;\nfloat3 _GlobalVolumeMin;\nfloat3 _GlobalVolumeInvSize;\n\n// I inlined a section of your include. You can use includes in better shaders, but doing it via a subshader or this way\n// is much better. The reason is that this allows your shader to be all inclusive, and packed up for asset store distribition,\n// without requiring specific paths to other files, etc.\n//\n\n#ifndef BAKERY_INCLUDED\n#define BAKERY_INCLUDED\n\n#define BAKERYMODE_DEFAULT 0\n#define BAKERYMODE_VERTEXLM 1.0f\n#define BAKERYMODE_RNM 2.0f\n#define BAKERYMODE_SH 3.0f\n\n\n// can't fit vertexLM SH to sm3_0 interpolators\n#ifndef SHADER_API_D3D11\n    #undef _LIGHTMAPMODE_VERTEXSH\n#endif\n\n// can't do stuff on sm2_0 due to standard shader alrady taking up all instructions\n#if SHADER_TARGET < 30\n    #undef BAKERY_BICUBIC\n    #undef BAKERY_LMSPEC\n\n    #undef _LIGHTMAPMODE_RNM\n    #undef _LIGHTMAPMODE_SH\n    #undef _LIGHTMAPMODE_VERTEX\n#endif\n\n#define lumaConv float3(0.2125f, 0.7154f, 0.0721f)\n\n#ifdef BAKERY_VOLUME\n    #ifdef BAKERY_COMPRESSED_VOLUME\n        Texture3D _Volume3;\n    #endif\n#endif\n\n\nhalf3 LinearToGamma (half3 linRGB)\n{\n    linRGB = max(linRGB, half3(0.h, 0.h, 0.h));\n    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n    return max(1.055h * pow(linRGB, 0.416666667h) - 0.055h, 0.h);\n}\n\nfloat shEvaluateDiffuseL1Geomerics(float L0, float3 L1, float3 n)\n{\n    // average energy\n    float R0 = L0;\n\n    // avg direction of incoming light\n    float3 R1 = 0.5f * L1;\n\n    // directional brightness\n    float lenR1 = length(R1);\n\n    // linear angle between normal and direction 0-1\n    //float q = 0.5f * (1.0f + dot(R1 / lenR1, n));\n    //float q = dot(R1 / lenR1, n) * 0.5 + 0.5;\n    float q = dot(normalize(R1), n) * 0.5 + 0.5;\n\n    // power for q\n    // lerps from 1 (linear) to 3 (cubic) based on directionality\n    float p = 1.0f + 2.0f * lenR1 / R0;\n\n    // dynamic range constant\n    // should vary between 4 (highly directional) and 0 (ambient)\n    float a = (1.0f - lenR1 / R0) / (1.0f + lenR1 / R0);\n\n    return R0 * (a + (1.0f - a) * (p + 1.0f) * pow(q, p));\n}\n\n#ifdef BAKERY_VERTEXLMMASK\n    float4 unpack4NFloats(float src)\n\t{\n        //return fmod(float4(src / 262144.0, src / 4096.0, src / 64.0, src), 64.0)/64.0;\n        return frac(float4(src / (262144.0*64), src / (4096.0*64), src / (64.0*64), src));\n    }\n#endif\n\n#if defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n    float3 unpack3NFloats(float src)\n\t{\n        float r = frac(src);\n        float g = frac(src * 256.0);\n        float b = frac(src * 65536.0);\n        return float3(r, g, b);\n    }\n#endif\n\n// Unity defines these under different names in each SRP, so use our own\ninline float3 Bakery_SafeNormalize(float3 inVec)\n{\n    float dp3 = max(0.001f, dot(inVec, inVec));\n    return inVec * rsqrt(dp3);\n}\n\n#if _URP || _HDRP\n\nfloat SmoothnessToPerceptualRoughness(float smoothness)\n{\n    return (1 - smoothness);\n}\n#endif\n\n#if !_STANDARD\nhalf4 unity_Lightmap_HDR;\ninline half3 DecodeLightmap( half4 color )\n{\n    return DecodeLightmap( color, unity_Lightmap_HDR );\n}\n\n#define UNITY_INV_PI        0.31830988618f\ninline float GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return UNITY_INV_PI * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n    void BakeryVertexLMDirection(inout float3 diffuseColor, inout float3 specularColor, float3 lightDirection, float3 vertexNormalWorld, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 dominantDir = Bakery_SafeNormalize(lightDirection);\n        half halfLambert = dot(normalWorld, dominantDir) * 0.5 + 0.5;\n        half flatNormalHalfLambert = dot(vertexNormalWorld, dominantDir) * 0.5 + 0.5;\n\n        #ifdef BAKERY_LMSPEC\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = spec * diffuseColor;\n        #endif\n\n        diffuseColor *= halfLambert / max(1e-4h, flatNormalHalfLambert);\n    }\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXSH\n    void BakeryVertexLMSH(inout float3 diffuseColor, inout float3 specularColor, float3 shL1x, float3 shL1y, float3 shL1z, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 L0 = diffuseColor;\n        float3 nL1x = shL1x;\n        float3 nL1y = shL1y;\n        float3 nL1z = shL1z;\n        float3 L1x = nL1x * L0 * 2;\n        float3 L1y = nL1y * L0 * 2;\n        float3 L1z = nL1z * L0 * 2;\n\n        float3 sh;\n    #if BAKERY_SHNONLINEAR\n        //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n        //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n        //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n        float lumaL0 = dot(L0, 1);\n        float lumaL1x = dot(L1x, 1);\n        float lumaL1y = dot(L1y, 1);\n        float lumaL1z = dot(L1z, 1);\n        float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n        float regularLumaSH = dot(sh, 1);\n        //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n        sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    #else\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    #endif\n\n        diffuseColor = max(sh, 0.0);\n\n        #ifdef BAKERY_LMSPEC\n            float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n            float focus = saturate(length(dominantDir));\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = max(spec * sh, 0.0);\n        #endif\n    }\n#endif\n\n\n\n#ifdef BAKERY_BICUBIC\nfloat BakeryBicubic_w0(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-a + 3.0f) - 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w1(float a)\n{\n    return (1.0f/6.0f)*(a*a*(3.0f*a - 6.0f) + 4.0f);\n}\n\nfloat BakeryBicubic_w2(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-3.0f*a + 3.0f) + 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w3(float a)\n{\n    return (1.0f/6.0f)*(a*a*a);\n}\n\nfloat BakeryBicubic_g0(float a)\n{\n    return BakeryBicubic_w0(a) + BakeryBicubic_w1(a);\n}\n\nfloat BakeryBicubic_g1(float a)\n{\n    return BakeryBicubic_w2(a) + BakeryBicubic_w3(a);\n}\n\nfloat BakeryBicubic_h0(float a)\n{\n    return -1.0f + BakeryBicubic_w1(a) / (BakeryBicubic_w0(a) + BakeryBicubic_w1(a)) + 0.5f;\n}\n\nfloat BakeryBicubic_h1(float a)\n{\n    return 1.0f + BakeryBicubic_w3(a) / (BakeryBicubic_w2(a) + BakeryBicubic_w3(a)) + 0.5f;\n}\n#endif\n\n\n#if defined(_LIGHTMAPMODE_RNM) || defined(_LIGHTMAPMODE_SH)\nTexture2D _RNM0, _RNM1, _RNM2;\n#endif\n\n#ifdef BAKERY_VOLUME\nTexture3D _Volume0, _Volume1, _Volume2, _VolumeMask;\nSamplerState sampler_Volume0;\n#endif\n\n#if defined(BAKERY_BICUBIC) && defined(LIGHTMAP_ON) && defined(SHADER_API_D3D11)\n    // Bicubic\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\tfloat width, height;\n\t\ttex.GetDimensions(width, height);\n\t\tfloat texelSize = 1.0f / width;\n\n        float x = uv.x * width;\n        float y = uv.y * width;\n\n        x -= 0.5f;\n        y -= 0.5f;\n\n        float px = floor(x);\n        float py = floor(y);\n\n        float fx = x - px;\n        float fy = y - py;\n\n        float g0x = BakeryBicubic_g0(fx);\n        float g1x = BakeryBicubic_g1(fx);\n        float h0x = BakeryBicubic_h0(fx);\n        float h1x = BakeryBicubic_h1(fx);\n        float h0y = BakeryBicubic_h0(fy);\n        float h1y = BakeryBicubic_h1(fy);\n\n        return     BakeryBicubic_g0(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h0y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h0y) * texelSize))) +\n\n                   BakeryBicubic_g1(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h1y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h1y) * texelSize)));\n    }\n#else\n    // Bilinear\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\t#ifdef LIGHTMAP_ON\n\t\t\treturn tex.Sample(samplerunity_Lightmap, uv);\n\t\t#else\n\t\t\treturn float4(1,0,0,1);\n\t\t#endif\n    }\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\n#ifdef BAKERY_LMSPEC\nfloat BakeryDirectionalLightmapSpecular(float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 dominantDir = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap, lmUV).xyz * 2 - 1;\n    half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n    half nh = saturate(dot(normalWorld, halfDir));\n    half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n    half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n    half spec = GGXTerm(nh, roughness);\n    return spec;\n}\n#endif\n#endif\n\n\n\n#ifdef _LIGHTMAPMODE_RNM\nvoid BakeryRNM(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalMap, float smoothness, float3 viewDirT)\n{\n    const float3 rnmBasis0 = float3(0.816496580927726f, 0, 0.5773502691896258f);\n    const float3 rnmBasis1 = float3(-0.4082482904638631f, 0.7071067811865475f, 0.5773502691896258f);\n    const float3 rnmBasis2 = float3(-0.4082482904638631f, -0.7071067811865475f, 0.5773502691896258f);\n\n    float3 rnm0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 rnm1 = DecodeLightmap(BakeryTex2D(_RNM1, lmUV));\n    float3 rnm2 = DecodeLightmap(BakeryTex2D(_RNM2, lmUV));\n\n    #ifdef BAKERY_SSBUMP\n        diffuseColor = normalMap.x * rnm0\n                     + normalMap.z * rnm1\n                     + normalMap.y * rnm2;\n         diffuseColor *= 2;\n    #else\n        diffuseColor = saturate(dot(rnmBasis0, normalMap)) * rnm0\n                     + saturate(dot(rnmBasis1, normalMap)) * rnm1\n                     + saturate(dot(rnmBasis2, normalMap)) * rnm2;\n    #endif\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDirT = rnmBasis0 * dot(rnm0, lumaConv) +\n                              rnmBasis1 * dot(rnm1, lumaConv) +\n                              rnmBasis2 * dot(rnm2, lumaConv);\n\n        float3 dominantDirTN = normalize(dominantDirT);\n        float3 specColor = saturate(dot(rnmBasis0, dominantDirTN)) * rnm0 +\n                           saturate(dot(rnmBasis1, dominantDirTN)) * rnm1 +\n                           saturate(dot(rnmBasis2, dominantDirTN)) * rnm2;\n\n        half3 halfDir = Bakery_SafeNormalize(dominantDirTN - viewDirT);\n        half nh = saturate(dot(normalMap, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n        specularColor = spec * specColor;\n    #endif\n}\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\ninline half3 Unity_DecodeDirectionalLightmap(half3 color, half4 dirTex, half3 normalWorld)\n{\n    // In directional (non-specular) mode Enlighten bakes dominant light direction\n    // in a way, that using it for half Lambert and then dividing by a \"rebalancing coefficient\"\n    // gives a result close to plain diffuse response lightmaps, but normalmapped.\n\n    // Note that dir is not unit length on purpose. Its length is \"directionality\", like\n    // for the directional specular lightmaps.\n\n    half halfLambert = dot(normalWorld, dirTex.xyz - 0.5) + 0.5;\n\n    return color * halfLambert / max(1e-4h, dirTex.w);\n}\n#endif\n\n#ifdef _LIGHTMAPMODE_SH\nvoid BakerySH(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 L0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 nL1x = BakeryTex2D(_RNM0, lmUV) * 2 - 1;\n    float3 nL1y = BakeryTex2D(_RNM1, lmUV) * 2 - 1;\n    float3 nL1z = BakeryTex2D(_RNM2, lmUV) * 2 - 1;\n    float3 L1x = nL1x * L0 * 2;\n    float3 L1y = nL1y * L0 * 2;\n    float3 L1z = nL1z * L0 * 2;\n\n    float3 sh;\n#if BAKERY_SHNONLINEAR\n    float lumaL0 = dot(L0, 1);\n    float lumaL1x = dot(L1x, 1);\n    float lumaL1y = dot(L1y, 1);\n    float lumaL1z = dot(L1z, 1);\n    float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    float regularLumaSH = dot(sh, 1);\n    //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n    sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n    //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n    //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n#else\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n#endif\n\n    diffuseColor = max(sh, 0.0);\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n        float focus = saturate(length(dominantDir));\n        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n        half nh = saturate(dot(normalWorld, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n\n        sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n\n        specularColor = max(spec * sh, 0.0);\n    #endif\n}\n#endif\n\n#endif // include guards\n\n\n    void Ext_ModifyVertex15 (inout VertexData v, inout ExtraV2F e)\n    {\n        #if _USEBAKERY\n\t\t    #if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\t\t\t    // Unpack from RGBM\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.a * 8.0f;\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.rgb;\n\n\t\t\t    #ifdef BAKERY_VERTEXLMMASK\n\t\t\t\t    e.extraV2F4.xyzw = unpack4NFloats(v.texcoord1);\n\t\t\t    #endif\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXSH\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n                e.extraV2F6.xyz = unpack3NFloats(v.texcoord3.x) * 2 - 1;\n                e.extraV2F7.xyz = unpack3NFloats(v.texcoord3.y) * 2 - 1;\n            #endif\n       #endif\n    }\n\n#if _HDRP || _URP\n    half3 SHEvalLinearL0L1 (half4 normal)\n    {\n        half3 x;\n\n        // Linear (L1) + constant (L0) polynomial terms\n        x.r = dot(unity_SHAr,normal);\n        x.g = dot(unity_SHAg,normal);\n        x.b = dot(unity_SHAb,normal);\n\n        return x;\n    }\n\n    // normal should be normalized, w=1.0\n    half3 SHEvalLinearL2 (half4 normal)\n    {\n        half3 x1, x2;\n        // 4 of the quadratic (L2) polynomials\n        half4 vB = normal.xyzz * normal.yzzx;\n        x1.r = dot(unity_SHBr,vB);\n        x1.g = dot(unity_SHBg,vB);\n        x1.b = dot(unity_SHBb,vB);\n\n        // Final (5th) quadratic (L2) polynomial\n        half vC = normal.x*normal.x - normal.y*normal.y;\n        x2 = unity_SHC.rgb * vC;\n\n        return x1 + x2;\n    }\n\n    half3 ShadeSH9 (half4 normal)\n    {\n        // Linear + constant polynomial terms\n        half3 res = SHEvalLinearL0L1 (normal);\n\n        // Quadratic polynomials\n        res += SHEvalLinearL2 (normal);\n\n        #ifdef UNITY_COLORSPACE_GAMMA\n            res = LinearToGamma (res);\n        #endif\n\n        return res;\n\n    }\n#endif\n\n\n\n\tvoid DoBakeryStuff(inout float3 indDif, inout float3 indSpec, inout float4 shadowmask, float3 tangentNormal, float smoothness, ShaderData d)\n\t{\n\t\t// Quality!\n\t\tindDif = 1;\n\t\tindSpec = 0;\n\n        #if defined(_PASSFORWARD) || defined(_PASSGBUFFER) // forward pass on URP/Standard/HDRP + built-in deferred\n\n            float3 normalWorld = mul(tangentNormal, d.TBNMatrix);\n\n\t\t\t#ifdef LIGHTMAP_ON\n\n                // Static\n\n\t\t\t\tfloat2 lmUV = d.texcoord1 * unity_LightmapST.xy + unity_LightmapST.zw;\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_STANDARD\n\t\t\t\t\tindDif = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n\n\t\t\t\t\t#ifdef DIRLIGHTMAP_COMBINED\n\t\t\t\t\t\tfloat4 dirMap = BakeryTex2D(unity_LightmapInd, lmUV);\n\t\t\t\t\t\tindDif = Unity_DecodeDirectionalLightmap(indDif, dirMap, normalWorld);\n\n\t\t\t\t\t\t#ifdef BAKERY_LMSPEC\n\t\t\t\t\t\t\tindSpec = BakeryDirectionalLightmapSpecular(lmUV, normalWorld, -d.worldSpaceViewDir, smoothness) * indDif;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\n\t\t\t\t\tindDif = d.vertexColor;\n\n                    #ifdef BAKERY_VERTEXLMMASK\n                        shadowmask = d.extraV2F4;\n                    #endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n\t\t\t\t\t\t// worldSpaceNormal is per-vertex\n\t\t\t\t\t\t// normalWorld is per-pixel\n\t\t\t\t\t\tfloat3 bakedLightDirection = d.extraV2F5;\n\t\t\t\t\t\tBakeryVertexLMDirection(indDif, indSpec, bakedLightDirection, d.worldSpaceNormal, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXSH\n\t\t\t\t\t\tBakeryVertexLMSH(indDif, indSpec, d.extraV2F5, d.extraV2F6, d.extraV2F7, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_RNM\n\t\t\t\t\tBakeryRNM(indDif, indSpec, lmUV, tangentNormal, smoothness, -d.tangentSpaceViewDir);\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_SH\n\t\t\t\t\tBakerySH(indDif, indSpec, lmUV, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t#endif\n\n            #else\n\n                // Dynamic\n\n                #ifdef BAKERY_VOLUME\n\n                    bool isGlobal = dot(abs(_VolumeInvSize),1) == 0;\n                    float3 volViewDir = -d.worldSpaceViewDir;\n                    #ifdef BAKERY_VOLROTATION\n                        float4x4 volMatrix = (isGlobal ? _GlobalVolumeMatrix : _VolumeMatrix);\n                        float3 volInvSize = (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 lpUV = mul(volMatrix, float4(d.worldSpacePosition,1)).xyz * volInvSize + 0.5f;\n                        float3 volNormal = mul((float3x3)volMatrix, normalWorld);\n                        #ifdef BAKERY_LMSPEC\n                            volViewDir = mul((float3x3)volMatrix, volViewDir);\n                        #endif\n                    #else\n                        float3 lpUV = (d.worldSpacePosition - (isGlobal ? _GlobalVolumeMin : _VolumeMin)) * (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 volNormal = normalWorld;\n                    #endif\n\n                    #ifdef BAKERY_COMPRESSED_VOLUME\n                        float4 tex0, tex1, tex2, tex3;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex3 = _Volume3.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz * L0;\n                        L1y = tex2.xyz * L0;\n                        L1z = tex3.xyz * L0;\n                    #else\n                        float4 tex0, tex1, tex2;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV);\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV);\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz;\n                        L1y = tex2.xyz;\n                        L1z = float3(tex0.w, tex1.w, tex2.w);\n                    #endif\n                    indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), volNormal);\n                    indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), volNormal);\n                    indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), volNormal);\n\n                    #ifdef UNITY_COLORSPACE_GAMMA\n                        indDif = pow(indDif, 1.0f / 2.2f);\n                    #endif\n\n                    #ifdef BAKERY_LMSPEC\n                        float3 nL1x = L1x / L0;\n                        float3 nL1y = L1y / L0;\n                        float3 nL1z = L1z / L0;\n                        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n                        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - volViewDir);\n                        half nh = saturate(dot(volNormal, halfDir));\n                        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n                        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n                        half spec = GGXTerm(nh, roughness);\n                        float3 sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n                        indSpec = max(spec * sh, 0.0);\n                    #endif\n\n                    shadowmask = _VolumeMask.Sample(sampler_Volume0, lpUV);\n\n                #else\n\n                    #ifdef BAKERY_SHNONLINEAR\n                        float3 L0 = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);\n                        indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, unity_SHAr.xyz, normalWorld);\n                        indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, unity_SHAg.xyz, normalWorld);\n                        indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, unity_SHAb.xyz, normalWorld);\n                    #else\n                        indDif = ShadeSH9(float4(normalWorld,1));\n                    #endif\n\n                #endif\n\n\t\t\t#endif\n\n        #endif\n\t}\n\n\t// this is the main surface function. Surface is like a surface shader output structure, but\n\t// with our new outputs as well.\n\tvoid Ext_SurfaceFunction15 (inout Surface o, ShaderData d)\n\t{\n        #if _USEBAKERY\n\t\t    float3 indDif;\n\t\t    float3 indSpec;\n            float4 shadowmask = 1;\n\t\t    DoBakeryStuff(indDif, indSpec, shadowmask, o.Normal, o.Smoothness, d);\n\t\t    o.DiffuseGI = indDif;\n\t\t    o.BackDiffuseGI = indDif;\n\t\t    o.SpecularGI = indSpec;\n            o.ShadowMask = shadowmask;\n        #endif\n\t}\n\n\n\n\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                  Ext_SurfaceFunction1(l, d);\n                  Ext_SurfaceFunction2(l, d);\n                  Ext_SurfaceFunction3(l, d);\n                  Ext_SurfaceFunction4(l, d);\n                  Ext_SurfaceFunction5(l, d);\n                  Ext_SurfaceFunction6(l, d);\n                  Ext_SurfaceFunction7(l, d);\n                  Ext_SurfaceFunction8(l, d);\n                  Ext_SurfaceFunction9(l, d);\n\t\t            Ext_SurfaceFunction10(l, d);\n                  Ext_SurfaceFunction11(l, d);\n                  Ext_SurfaceFunction12(l, d);\n                  Ext_SurfaceFunction13(l, d);\n                  Ext_SurfaceFunction14(l, d);\n                  Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraV2F d;\n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                  Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                  Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                  #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                  v2p.extraV2F4 = d.extraV2F4;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                  v2p.extraV2F5 = d.extraV2F5;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F6 = d.extraV2F6;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F7 = d.extraV2F7;\n                  #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                d.extraV2F4 = v2p.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                d.extraV2F5 = v2p.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F6 = v2p.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F7 = v2p.extraV2F7;\n                #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n                Ext_ModifyTessellatedVertex2(v, d);\n                Ext_ModifyTessellatedVertex3(v, d);\n                Ext_ModifyTessellatedVertex4(v, d);\n                Ext_ModifyTessellatedVertex5(v, d);\n                Ext_ModifyTessellatedVertex6(v, d);\n                Ext_ModifyTessellatedVertex7(v, d);\n                Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                v2p.extraV2F4 = d.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                v2p.extraV2F5 = d.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F6 = d.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F7 = d.extraV2F7;\n                #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n            // d.texcoord3 = i.texcoord3;\n             #endif\n\n             d.isFrontFace = facing;\n             #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n             d.vertexColor = i.vertexColor;\n             #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(i.worldPos, 1)).xyz;\n            #endif\n             d.localSpaceNormal = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n             #if LOD_FADE_CROSSFADE\n             d.screenPos = i.screenPos;\n             d.screenUV = (i.screenPos.xy / i.screenPos.w);\n             #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n             #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n             d.extraV2F4 = i.extraV2F4;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n             d.extraV2F5 = i.extraV2F5;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F6 = i.extraV2F6;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F7 = i.extraV2F7;\n             #endif\n\n            return d;\n         }\n         \n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n   #ifdef VARYINGS_NEED_POSITION_WS\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex);\n   #endif\n\n   #ifdef VARYINGS_NEED_TANGENT_TO_WORLD\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n   #endif\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n        #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n       // output.texcoord3 = inputMesh.texcoord3;\n        #endif\n        #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n        output.vertexColor = inputMesh.vertexColor;\n        #endif\n\n       return output;\n   }\n#else\n\n   #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n    \n       ChainModifyVertex(input, output);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n        #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n       // output.texcoord3 = input.texcoord3;\n        #endif\n\n        #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n        output.vertexColor = input.vertexColor;\n        #endif\n\n        #if LOD_FADE_CROSSFADE\n        output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n        #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(output.worldPos.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? input.previousPositionOS : input.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n\n            VertexData previousMesh = input;\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            // Remap time to old time\n            float4 oldTime = _Time;\n            _Time.y = _LastTimeParameters.x;\n            _Time.x = _LastTimeParameters.x / 20;\n            _Time.z = _LastTimeParameters.x * 2;\n            _Time.w = _LastTimeParameters.x * 3;\n            ChainModifyVertex(previousMesh, dummy);\n            _Time = oldTime;\n\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = output.worldPos.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n            \n                    output.positionRWS = input.worldPos;\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n            \n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n                    #if defined(_ENABLE_SHADOW_MATTE) && SHADERPASS == SHADERPASS_FORWARD_UNLIT\n                        HDShadowContext shadowContext = InitShadowContext();\n                        float shadow;\n                        float3 shadow3;\n                        // We need to recompute some coordinate not computed by default for shadow matte\n                        posInput = GetPositionInput(fragInputs.positionSS.xy, _ScreenSize.zw, fragInputs.positionSS.z, UNITY_MATRIX_I_VP, GetWorldToViewMatrix());\n                        float3 upWS = normalize(fragInputs.tangentToWorld[1]);\n                        uint renderingLayers = GetMeshRenderingLightLayer();\n                        ShadowLoopMin(shadowContext, posInput, upWS, asuint(_ShadowMatteFilter), renderingLayers, shadow3);\n                        shadow = dot(shadow3, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));\n                \n                        float4 shadowColor = (1.0 - shadow) * surfaceDescription.ShadowTint.rgba;\n                        float  localAlpha  = saturate(shadowColor.a + surfaceDescription.Alpha);\n                \n                        // Keep the nested lerp\n                        // With no Color (bsdfData.color.rgb, bsdfData.color.a == 0.0f), just use ShadowColor*Color to avoid a ring of \"white\" around the shadow\n                        // And mix color to consider the Color & ShadowColor alpha (from texture or/and color picker)\n                        #ifdef _SURFACE_TYPE_TRANSPARENT\n                            surfaceData.baseColor = lerp(shadowColor.rgb * surfaceData.baseColor, lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow), surfaceDescription.Alpha);\n                        #else\n                            surfaceData.baseColor = lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow);\n                        #endif\n                        localAlpha = ApplyBlendMode(surfaceData.baseColor, localAlpha).a;\n                \n                        surfaceDescription.Alpha = localAlpha;\n                    #endif\n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n                \n\n                   // tangent-space normal\n                   float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                   normalTS = surfaceDescription.Normal;\n        \n                   // compute world space normal\n                   #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(normalTS, fragInputs.tangentToWorld);\n                   #else\n                      surfaceData.normalWS = normalTS;\n                   #endif\n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                    #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                \n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2], alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                    #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 //builtinData.vtPackedFeedback = surfaceDescription.VTPackedFeedback;\n        \n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     //builtinData.distortion = surfaceData.Distortion;\n                     //builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n        \n\n            \n            void Frag(  VertexToPixel IN\n            #ifdef WRITE_NORMAL_BUFFER\n            , out float4 outNormalBuffer : SV_Target0\n                #ifdef WRITE_MSAA_DEPTH\n                , out float1 depthColor : SV_Target1\n                #endif\n            #elif defined(WRITE_MSAA_DEPTH) // When only WRITE_MSAA_DEPTH is define and not WRITE_NORMAL_BUFFER it mean we are Unlit and only need depth, but we still have normal buffer binded\n            , out float4 outNormalBuffer : SV_Target0\n            , out float1 depthColor : SV_Target1\n            #elif defined(SCENESELECTIONPASS)\n            , out float4 outColor : SV_Target0\n            #endif\n\n            #ifdef _DEPTHOFFSET_ON\n            , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n        )\n         {\n             UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n             FragInputs input = BuildFragInputs(IN);\n\n             // input.positionSS is SV_Position\n             PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n         #ifdef VARYINGS_NEED_POSITION_WS\n             float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n         #else\n             // Unused\n             float3 V = float3(1.0, 1.0, 1.0); // Avoid the division by 0\n         #endif\n\n            SurfaceData surfaceData;\n            BuiltinData builtinData;\n            Surface l;\n            ShaderData d;\n            GetSurfaceAndBuiltinData(IN, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n\n\n         #ifdef _DEPTHOFFSET_ON\n             outputDepth = l.outputDepth;\n         #endif\n\n         #ifdef WRITE_NORMAL_BUFFER\n             EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), posInput.positionSS, outNormalBuffer);\n             #ifdef WRITE_MSAA_DEPTH\n             // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer\n             depthColor = v2f.pos.z;\n             #endif\n         #elif defined(WRITE_MSAA_DEPTH) // When we are MSAA depth only without normal buffer\n             // Due to the binding order of these two render targets, we need to have them both declared\n             outNormalBuffer = float4(0.0, 0.0, 0.0, 1.0);\n             // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer\n             depthColor = v2f.pos.z;\n         #elif defined(SCENESELECTIONPASS)\n             // We use depth prepass for scene selection in the editor, this code allow to output the outline correctly\n             outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);\n         #endif\n         }\n\n         ENDHLSL\n     }\n\n        \n              Pass\n        {\n            Name \"ScenePickingPass\"\n            Tags\n            {\n               \"LightMode\" = \"Picking\"\n            }\n            \n               Cull [_CullMode]\n\n            \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone vulkan metal switch\n            #pragma multi_compile_instancing\n            #pragma editor_sync_compilation\n            #pragma instancing_options renderinglayer\n\n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n            #pragma multi_compile _ WRITE_DECAL_BUFFER\n        \n\n            #define SHADERPASS SHADERPASS_DEPTH_ONLY\n            #define SCENEPICKINGPASS\n\n            \n            \n\n\n   #pragma shader_feature_local_fragment _ _PACKEDFAST\n   #pragma shader_feature_local _ _TRIPLANAR\n   #pragma shader_feature_local_fragment _ _NORMALMAP \n   #pragma shader_feature_local_fragment _ _MASKMAP\n   #pragma shader_feature_local_fragment _ _DETAIL\n   #pragma shader_feature_local_fragment _ _DETAILTRIPLANAR\n   #pragma shader_feature_local_fragment _ _DETAILSTOCHASTIC\n   #pragma shader_feature_local_fragment _ _EMISSION\n   #pragma shader_feature_local_fragment _ _FLATSHADE\n   #pragma shader_feature_local _ _STOCHASTIC\n   #pragma shader_feature_local_fragment _ _PARALLAX //_POM\n   #pragma shader_feature_local_fragment _ _SPECULAR\n   #pragma shader_feature_local _ _NOISEWORLD _NOISELOCAL\n   #pragma shader_feature_local _ _NOISEHQ _NOISETEXTURE _NOISEWORLEY\n   // only for URP/Standard Forward\n   #pragma shader_feature_local_fragment _ _SIMPLELIT\n\n\n   #pragma shader_feature_local_fragment _ _TINTMASK\n\n\n    #pragma shader_feature_local _ _LAYERVERTEXMASK _LAYERTEXTUREMASK\n\n    #define _HAS_WEIGHTTEXTURE_MASK 1\n\n\n   #pragma shader_feature_local _ _USELAYER\n   #pragma shader_feature_local _ _LAYERTRIPLANAR\n   #pragma shader_feature_local _ _LAYERALBEDO\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL\n   #pragma shader_feature_local _ _LAYERMASK\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION\n   #pragma shader_feature_local _ _LAYERNOISE\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC\n   #pragma shader_feature_local _ _LAYERANGLEFILTER\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_1\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_1\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_1\n   #pragma shader_feature_local _ _LAYERMASK_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_1\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_1\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_1\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_1\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_2\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_2\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_2\n   #pragma shader_feature_local _ _LAYERMASK_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_2\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_2\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_2\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_2\n\n\n   #pragma shader_feature_local _ _TRAX_ON\n\n\n   #pragma shader_feature_local_fragment _ _WETNESS\n   #pragma shader_feature_local_fragment _ _PUDDLES\n   #pragma shader_feature_local_fragment _ _PUDDLENOISE\n   #pragma shader_feature_local_fragment _ _RAINDROPS\n\n\n   #pragma shader_feature_local _ _SNOW\n   #pragma shader_feature_local _ _SNOWMASKMAP\n   #pragma shader_feature_local _ _SNOWNOISE\n   #pragma shader_feature_local_fragment _SNOWSTOCHASTIC\n\n\n   #pragma shader_feature_local_fragment _ _WIND_ON\n\n\n\n\n   #pragma shader_feature_local_fragment _ _SURFACEGRADIENT _AUTONORMAL\n   #define _WORLDSPACENORMAL 1\n\n\n   #pragma shader_feature_local _ _DEBUG_SAMPLECOUNT\n\n\n\t#pragma shader_feature_local_fragment _ _DISSOLVE\n\n\n   #pragma multi_compile_local  LOD_FADE_CROSSFADE\n\n\n\n#pragma instancing_options procedural:setupVSPro forwardadd\n\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\nstruct IndirectShaderData\n{\n\tfloat4x4 PositionMatrix;\n\tfloat4x4 InversePositionMatrix;\n\tfloat4 ControlData;\n};\n\n#if defined(SHADER_API_GLCORE) || defined(SHADER_API_D3D11) || defined(SHADER_API_GLES3) || defined(SHADER_API_METAL) || defined(SHADER_API_VULKAN) || defined(SHADER_API_PSSL) || defined(SHADER_API_XBOXONE)\n\tuniform StructuredBuffer<IndirectShaderData> VisibleShaderDataBuffer;\n#endif\n\n#endif\n\nfloat VSPRenderingLayerMask;\n\nvoid setupVSPro()\n{\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\n    #if _HDRP\n\t    unity_RenderingLayer.x = VSPRenderingLayerMask;\n    #endif\n\n\t#ifdef unity_ObjectToWorld\n\t#undef unity_ObjectToWorld\n\t#endif\n\n\t#ifdef unity_WorldToObject\n\t#undef unity_WorldToObject\n\t#endif\n\n\tunity_ObjectToWorld = VisibleShaderDataBuffer[unity_InstanceID].PositionMatrix;\n\tunity_WorldToObject = VisibleShaderDataBuffer[unity_InstanceID].InversePositionMatrix;\n#endif\n\n}\n\n\n\t#pragma multi_compile _LIGHTMAPMODE_STANDARD _LIGHTMAPMODE_RNM _LIGHTMAPMODE_SH _LIGHTMAPMODE_VERTEX _LIGHTMAPMODE_VERTEXDIRECTIONAL _LIGHTMAPMODE_VERTEXSH\n\n    #pragma shader_feature USEBAKERY\n    #pragma shader_feature BAKERY_VERTEXLMMASK\n    #pragma shader_feature BAKERY_SHNONLINEAR\n    #pragma shader_feature BAKERY_LMSPEC\n    #pragma shader_feature BAKERY_BICUBIC\n    #pragma shader_feature BAKERY_VOLUME\n    #pragma shader_feature BAKERY_VOLROTATION\n    #pragma shader_feature BAKERY_COMPRESSED_VOLUME\n\n    #if _USEBAKERY\n\t    #define _OVERRIDE_BAKEDGI\n        #if BAKERY_VOLUME || (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)) && defined(BAKERY_VERTEXLMMASK)\n            #define _OVERRIDE_SHADOWMASK\n        #endif\n    #endif\n\n\n\n\n\n\n\n\n   #define _HDRP 1\n#define _BLENDMODE_ALPHA 1\n#define _SURFACE_TYPE_TRANSPARENT 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\" // Need to be here for Gradient struct definition\n         \n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n\n\n   half4 _Tint;\n   half _UVSource;\n   half _TriplanarContrast;\n   half _AlbedoContrast;\n   half _AlbedoBrightness;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half3 _EmissionColor;\n   float _DetailUVSource;\n   half _StochasticScale;\n   half _DetailStochasticScale;\n   half _Smoothness;\n   half _Metallic;\n   half2 _SmoothnessRemap;\n   half2 _AORemap;\n   half2 _MetallicRemap;\n   half2 _HeightRemap;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n   half _AlphaThreshold;\n   half _Cutoff; // for Unity's light mapper\n   half _TriplanarSpace;\n   half _DetailTriplanarSpace;\n   half _DetailTriplanarContrast;\n   half _MicroShadowStrength;\n   half3 _FuzzyShadingColor;\n   half _FuzzyShadingOn;\n   half3 _FuzzyShadingParams;\n\n   //int _POMMaxSamples;\n   //float _POMMin;\n   //float _POMFade;\n#if _FLATSHADE\n   half _FlatShadingBlend;\n#endif\n\n   half _StochasticContrast;\n   half _DetailStochasticContrast;\n\n#if _PARALLAX || _POM\n   half _ParallaxHeight;\n#endif\n\n\n\n\tfloat4 _TintMask_ST;\n\thalf3 _RColor;\n\thalf3 _GColor;\n\thalf3 _BColor;\n\thalf3 _AColor;\n\n\n\thalf _LayerTextureMaskUVMode;\n    float4 _LayerTextureMask_ST;\n\n\n   //#if _USELAYER\n       float4 _LayerAlbedoMap_ST;\n       half3 _LayerTint;\n       half _LayerBlendMode;\n       float _LayerUVSource;\n       half _LayerAlbedoBrightness;\n       half _LayerAlbedoContrast;\n       half _LayerHeightContrast;\n       half _LayerStrength;\n       half _LayerAlbedoStrength;\n       half _LayerNormalStrength;\n       half _LayerSmoothnessStrength;\n       half _LayerSmoothness;\n       half _LayerMetallic;\n       half _LayerStochasticScale;\n       half2 _LayerSmoothnessRemap;\n       half2 _LayerAORemap;\n       half2 _LayerMetallicRemap;\n       half2 _LayerHeightRemap;\n       float4 _LayerWeightOverDistance;\n       half _LayerMicroShadowStrength;\n       //#if _LAYERNOISE\n           float _LayerNoiseFrequency;\n           float _LayerNoiseAmplitude;\n           float _LayerNoiseOffset;\n           float _LayerNoiseCenter;\n           half3 _LayerBlendTint;\n       //#endif\n       //#if _LAYERANGLEFILTER\n           half _LayerFalloff;\n           half _LayerAngleMin;\n           half _LayerHeight;\n           half _LayerInvertHeight;\n           half _LayerVertexNormalBlend;\n       //#endif\n       half _LayerTriplanarSpace;\n       half _LayerTriplanarContrast;\n       half _LayerBlendContrast;\n       half3 _LayerEmissionColor;\n       half _LayerStochasticContrast;\n       half _LayerTessStrength;\n       half3 _LayerFuzzyShadingColor;\n       half _LayerFuzzyShadingOn;\n       half3 _LayerFuzzyShadingParams;\n   //#endif\n\n\n   //#if _USELAYER_DEF_1\n       float4 _LayerAlbedoMap_Ext_1_ST;\n       half3 _LayerTint_Ext_1;\n       half _LayerBlendMode_Ext_1;\n       float _LayerUVSource_Ext_1;\n       half _LayerAlbedoBrightness_Ext_1;\n       half _LayerAlbedoContrast_Ext_1;\n       half _LayerHeightContrast_Ext_1;\n       half _LayerStrength_Ext_1;\n       half _LayerAlbedoStrength_Ext_1;\n       half _LayerNormalStrength_Ext_1;\n       half _LayerSmoothnessStrength_Ext_1;\n       half _LayerSmoothness_Ext_1;\n       half _LayerMetallic_Ext_1;\n       half _LayerStochasticScale_Ext_1;\n       half2 _LayerSmoothnessRemap_Ext_1;\n       half2 _LayerAORemap_Ext_1;\n       half2 _LayerMetallicRemap_Ext_1;\n       half2 _LayerHeightRemap_Ext_1;\n       float4 _LayerWeightOverDistance_Ext_1;\n       half _LayerMicroShadowStrength_Ext_1;\n       //#if _LAYERNOISE_DEF_1\n           float _LayerNoiseFrequency_Ext_1;\n           float _LayerNoiseAmplitude_Ext_1;\n           float _LayerNoiseOffset_Ext_1;\n           float _LayerNoiseCenter_Ext_1;\n           half3 _LayerBlendTint_Ext_1;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_1\n           half _LayerFalloff_Ext_1;\n           half _LayerAngleMin_Ext_1;\n           half _LayerHeight_Ext_1;\n           half _LayerInvertHeight_Ext_1;\n           half _LayerVertexNormalBlend_Ext_1;\n       //#endif\n       half _LayerTriplanarSpace_Ext_1;\n       half _LayerTriplanarContrast_Ext_1;\n       half _LayerBlendContrast_Ext_1;\n       half3 _LayerEmissionColor_Ext_1;\n       half _LayerStochasticContrast_Ext_1;\n       half _LayerTessStrength_Ext_1;\n       half3 _LayerFuzzyShadingColor_Ext_1;\n       half _LayerFuzzyShadingOn_Ext_1;\n       half3 _LayerFuzzyShadingParams_Ext_1;\n   //#endif\n\n\n   //#if _USELAYER_DEF_2\n       float4 _LayerAlbedoMap_Ext_2_ST;\n       half3 _LayerTint_Ext_2;\n       half _LayerBlendMode_Ext_2;\n       float _LayerUVSource_Ext_2;\n       half _LayerAlbedoBrightness_Ext_2;\n       half _LayerAlbedoContrast_Ext_2;\n       half _LayerHeightContrast_Ext_2;\n       half _LayerStrength_Ext_2;\n       half _LayerAlbedoStrength_Ext_2;\n       half _LayerNormalStrength_Ext_2;\n       half _LayerSmoothnessStrength_Ext_2;\n       half _LayerSmoothness_Ext_2;\n       half _LayerMetallic_Ext_2;\n       half _LayerStochasticScale_Ext_2;\n       half2 _LayerSmoothnessRemap_Ext_2;\n       half2 _LayerAORemap_Ext_2;\n       half2 _LayerMetallicRemap_Ext_2;\n       half2 _LayerHeightRemap_Ext_2;\n       float4 _LayerWeightOverDistance_Ext_2;\n       half _LayerMicroShadowStrength_Ext_2;\n       //#if _LAYERNOISE_DEF_2\n           float _LayerNoiseFrequency_Ext_2;\n           float _LayerNoiseAmplitude_Ext_2;\n           float _LayerNoiseOffset_Ext_2;\n           float _LayerNoiseCenter_Ext_2;\n           half3 _LayerBlendTint_Ext_2;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_2\n           half _LayerFalloff_Ext_2;\n           half _LayerAngleMin_Ext_2;\n           half _LayerHeight_Ext_2;\n           half _LayerInvertHeight_Ext_2;\n           half _LayerVertexNormalBlend_Ext_2;\n       //#endif\n       half _LayerTriplanarSpace_Ext_2;\n       half _LayerTriplanarContrast_Ext_2;\n       half _LayerBlendContrast_Ext_2;\n       half3 _LayerEmissionColor_Ext_2;\n       half _LayerStochasticContrast_Ext_2;\n       half _LayerTessStrength_Ext_2;\n       half3 _LayerFuzzyShadingColor_Ext_2;\n       half _LayerFuzzyShadingOn_Ext_2;\n       half3 _LayerFuzzyShadingParams_Ext_2;\n   //#endif\n\n\n    half _TraxDisplacementDepth;\n    half _TraxDisplacementStrength;\n    half _TraxMipBias;\n    half _TraxNormalStrength;\n    float4 _TraxAlbedo_ST;\n    half _TraxInterpContrast;\n    half _TraxHeightContrast;\n    half3 _TraxTint;\n\n\n\n    half _Porosity;\n    int _WetnessMode;\n    int _PuddleMode;\n\n    half  _PuddleAmount;\n    half  _PuddleFalloff;\n    half4 _PuddleColor;\n    half _PuddleNoiseFrequency;\n    half _PuddleNoiseAmplitude;\n    half _PuddleNoiseOffset;\n    half _PuddleNoiseCenter;\n    half _PuddleAngleMin;\n\n    half _WetnessAmount;\n\thalf _WetnessMin;\n    half _WetnessMax;\n    half _WetnessFalloff;\n\thalf _WetnessAngleMin;\n    float _WetnessShoreline;\n\n    int _RainMode;\n    half3 _RainIntensityScale;\n\n\n\n\n    float4 _SnowAlbedo_ST;\n    half3 _SnowTint;\n    half _SnowAmount;\n    half _SnowAngle;\n    half _SnowContrast;\n    half _SnowVertexHeight;\n    half _SnowMode;\n    half3 _SnowWorldFade; // z is on/off\n    float4 _SnowTraxAlbedo_ST;\n    half3 _SnowTraxTint;\n\n    half _SnowNoiseFreq; \n    half _SnowNoiseAmp;\n    half _SnowNoiseOffset;\n    half _SnowStochasticContrast;\n    half _SnowStochasticScale;\n\n\n    half     _WindParticulateSpace;\n    half     _WindParticulateRotation;\n    half      _WindParticulateSpeed;\n    float4     _WindParticulate_ST;\n    half      _WindParticulatePower;\n    half4    _WindParticulateColor;\n    half4    _WindParticulateWorldHeightMask;\n    half4    _WindParticulateAngleMask;\n    half      _WindParticulateOcclusionStrength;\n    half      _WindParticulateStrength;\n    half4    _WindParticulateEmissive;\n    half     _WindParticulateTextureHeight;\n\n\n   float _DoubleSidedNormalMode;\n\n\n\thalf _AutoNormalStrength;\n\n\n\tint _DebugSampleCountThreshold;\n\n\n\thalf _DissolveAmount;\n\thalf _DissolveEmissiveStr;\n\thalf _DissolveEdgeContrast;\n\thalf _DissolveColoration;\n\tfloat4 _DissolveTexture_ST;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCCOORD3;\n               float4 texcoord1 : TEXCCOORD4;\n               float4 texcoord2 : TEXCCOORD5;\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n               // float4 texcoord3 : TEXCCOORD6;\n                #endif\n\n                #if LOD_FADE_CROSSFADE\n                float4 screenPos : TEXCOORD7;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR_centroid;\n                #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                float4 extraV2F4 : TEXCOORD12_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                float4 extraV2F5 : TEXCOORD13_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F6 : TEXCOORD14_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F7 : TEXCOORD15_centroid;\n                #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/PickingSpaceTransforms.hlsl\"\n    \n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n   half4 weightTextureMask;\n   \n\n\n   float traxBuffer;\n\n\n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // would love to strip these, but they are used in certain\n               // combinations of the lighting system, and may be used\n               // by the user as well, so no easy way to strip them.\n\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR_centroid;\n                #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                float4 extraV2F4 : TEXCOORD9_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                float4 extraV2F5 : TEXCOORD10_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F6 : TEXCOORD11_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F7 : TEXCOORD12_centroid;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n               #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n               #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n               #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n               #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()     unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n               #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V   unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n               #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V    mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n               #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n               #endif\n               #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\n#ifndef __STACKABLEFUNCLIBRARY_INCLUDES__\n#define __STACKABLEFUNCLIBRARY_INCLUDES__\n\n   #if _DEBUG_SAMPLECOUNT\n      int _sampleCount;\n      #define COUNTSAMPLE { _sampleCount++; }\n   #else\n      #define COUNTSAMPLE\n   #endif\n\n   TEXTURE2D(_NoiseTex);\n   SAMPLER(sampler_NoiseTex);\n\n\n\n   half3 AdjustContrast(half3 color, half contrast)\n   {\n       half3 comp = 0.5;\n   #if !UNITY_COLORSPACE_GAMMA\n       comp = 0.22;\n   #endif\n       color = saturate(lerp(comp, color, contrast));\n       return color;\n   }\n\n   float2 DoParallaxOffset( half h, half height, half3 viewDir)\n   {\n      h = h * height - height/2.0;\n      float3 v = normalize(viewDir);\n      v.z += 0.42;\n      return h * (v.xy / v.z);\n   }\n\n\n\n   #define SAMPLEBARY SampleTexBary\n\n   struct SampleConfig\n   {\n      float2 uv0;\n      float2 uv1;\n      float2 uv2;\n      float2 dx0;\n      float2 dy0;\n      float2 dx1;\n      float2 dy1;\n      float2 dx2;\n      float2 dy2;\n      float3 weights;\n      float3 origWeights;\n   };\n\n   struct Config\n   {\n      float2 origUV; // unscaled uv\n      float2 origScale;\n      float2 uv;        // no stocastic or triplanar\n      float2 dx;\n      float2 dy;\n      SampleConfig uvT; // just stochastic, or just triplanar\n      SampleConfig uvX; // stochastic and triplanar\n      SampleConfig uvY;\n      SampleConfig uvZ;\n\n      \n      float3 absVertNormal;\n      half3 axisSign;\n      float3 normal;\n   };\n\n\n    float2 Hash2D( float2 x )\n    {\n        float2 k = float2( 0.3183099, 0.3678794 );\n        x = x*k + k.yx;\n        return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );\n    }\n\n    float Noise2D(float2 p )\n    {\n        float2 i = floor( p );\n        float2 f = frac( p );\n         \n        float2 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), \n                        dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),\n                    lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), \n                        dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);\n    }\n      \n\n    float2 WorleyHash2D(float2 p)\n    {\n \t    return frac(cos(mul(p, float2x2(-64.2,71.3,81.4,-29.8)))*8321.3); \n    }\n    float WorleyNoise2D(float2 p)\n    {\n        float dist = 1;\n        float2 i = floor(p);\n        float2 f = frac(p);\n    \n        for(int x = -1;x<=1;x++)\n        {\n            for(int y = -1;y<=1;y++)\n            {\n                float d = distance(WorleyHash2D(i+float2(x,y))+float2(x,y),f);\n                dist = min(dist,d);\n            }\n        }\n        return dist;\n\t\n    }\n\n#ifndef PI\n    #define PI 3.14159265359\n#endif\n\n    float GetIntegerNoise(float2 p)\n    {\n        p  = 53.7 * frac( (p*0.3183099) + float2(0.71,0.113));\n        return frac( p.x*p.y*(p.x+p.y) );\n    }\n\n    float WorleyHash3D(float f)\n    {\n        return frac(sin(f)*43758.5453);\n    }\n\n    float WorleyHash31(float3 v)\n    {\n        return WorleyHash3D(dot(v, float3(253.14, 453.74, 183.3)));\n    }\n\n    float3 WorleyRandom3D( float3 p )\n    {\n        return frac(sin(float3(dot(p,float3(127.1,311.7,217.3)),dot(p,float3(269.5,183.3,431.1)), dot(p,float3(365.6,749.9,323.7))))*437158.5453);\n    }\n\n    float WorleyNoise3D(float3 uvw)\n    {\n        float noise = 0.0;\n    \n        float3 p = floor(uvw);\n        float3 f = frac(uvw);\n    \n        float4 res = 1;\n        for(int x = -1; x <=1; ++x)\n        {\n            for(int y = -1; y <=1; ++y)\n            {\n                for(int z = -1; z <=1; ++z)\n                {\n                    float3 gp = p + float3(x, y, z);\n\n                    float3 v = WorleyRandom3D(gp);\n\n\t\t\t\t    float3 diff = gp + v - uvw;\n                \n                    float d = length(diff);\n                \n                    if(d < res.x)\n                    {\n                        res.xyz = float3(d, res.x, res.y);\n                    }\n                    else if(d < res.y)\n                    {\n                        res.xyz = float3(res.x, d, res.y);\n                    }\n                    else if(d < res.z)\n                    {\n                        res.z = d;\n                    }\n                \n                    res.w = WorleyHash31(gp);\n                }\n            }\n        }\n\n        return res.x;\n    }\n    \n      \n    float3 Hash3D( float3 p )\n    {\n        p = float3( dot(p,float3(127.1,311.7, 74.7)),\n                dot(p,float3(269.5,183.3,246.1)),\n                dot(p,float3(113.5,271.9,124.6)));\n\n        return -1.0 + 2.0*frac(sin(p)*437.5453123);\n    }\n\n    float Noise3D( float3 p )\n    {\n        float3 i = floor( p );\n        float3 f = frac( p );\n         \n        float3 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),\n                    lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n    }\n\n    \n    float FBM2D(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           return SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n\n    }\n      \n    float FBM3D(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           half A = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.zy).g;\n           half B = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33).g;\n           half C = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoise(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3D(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3D(d.localSpacePosition * frequency+ offset, d.localSpaceNormal);\n        #else\n           return FBM2D(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n    \n    #if _SURFACEGRADIENT  \n\n    #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)\n\n      \n      \n    half3 SurfaceGradientFromTBN(ShaderData d, half2 deriv)\n    {\n        return deriv.x * d.TBNMatrix[0] + deriv.y * d.TBNMatrix[1];\n    }\n\n    half2 TspaceNormalToDerivative(half3 vM)\n    {\n        const half scale = 1.0/128.0;\n        const half3 vMa = abs(vM);\n        const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));\n\n        return -half2(vM.x, vM.y)/z_ma;\n    }\n\n    half3 SurfgradFromVolumeGradient(ShaderData d, half3 grad)\n    {\n        return grad - dot(d.worldSpaceNormal, grad) * d.worldSpaceNormal;\n    }\n\n    half3 SurfgradFromTriplanarProjection(ShaderData d, half3 pN, half3 xN, half3 yN, half3 zN)\n    {\n        const half w0 = pN.x;\n        const half w1 = pN.y;\n        const half w2 = pN.z;\n\n        half2 xD = TspaceNormalToDerivative(xN);\n        half2 yD = TspaceNormalToDerivative(yN);\n        half2 zD = TspaceNormalToDerivative(zN);\n\n        half3 volumeGrad = half3(w2 * zD.x + w1 * yD.y, w2 * zD.y + w0 * xD.y, w0 * xD.x + w1 * yD.x);\n\n        return SurfgradFromVolumeGradient(d, volumeGrad);\n    }\n\n    half3 ConvertNormalToGradient(ShaderData d, half3 normal)\n    {\n        half2 deriv = TspaceNormalToDerivative(normal);\n\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n    half3 ConvertNormal2ToGradient(ShaderData d, half2 packedNormal)\n    {\n        half2 tNormal = packedNormal;\n        half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF\n        half2 deriv = tNormal * -rcpZ;\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n\n    half3 ResolveNormalFromSurfaceGradient(ShaderData d, half3 gradient)\n    {\n        return normalize(d.worldSpaceNormal - gradient);\n    }\n\n    #endif // _SURFACEGRADIENT\n\n\n    // normals are in surface gradient or world space depending on settings, and can also be generated by height\n    half3 GetWorldSpaceNormal(ShaderData d, half3 normal, half pheight)\n    {\n       #if _SURFACEGRADIENT\n          return ResolveNormalFromSurfaceGradient(d, normal);\n       #elif _AUTONORMAL\n          float3 dx = ddx(d.worldSpacePosition);\n          float3 dy = ddy(d.worldSpacePosition);\n          float3 crossX = cross(float3(0,1,0), dx);\n          float3 crossY = cross(float3(0,1,0), dy);\n          float3 dt = abs(dot(crossY, dx));\n          float height = _AutoNormalStrength * 0.5 * pheight;\n          float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n          n.y *= -1.0;\n          return TangentToWorldSpace(d, normalize((dt * float3(0,1,0)) - n).xzy);\n       #else\n          return TangentToWorldSpace(d, normal);\n          \n       #endif\n       \n    }\n\n   void WaterBRDF (inout half3 albedo, inout half smoothness, half metallic, half wetFactor, half surfPorosity) \n   {\n      half porosity = saturate((( (1 - smoothness) - 0.5)) / max(surfPorosity, 0.001));\n      half factor = lerp(1, 0.2, (1 - metallic) * porosity);\n      albedo *= lerp(1.0, factor, wetFactor);\n      smoothness = lerp(smoothness, 0.92f, wetFactor);\n   }\n\n   void OffsetUV(inout Config c, float2 offset)\n   {\n       c.uv += offset;\n       c.uvT.uv0 += offset;\n       c.uvT.uv1 += offset;\n       c.uvT.uv2 += offset;\n       c.uvX.uv0 += offset;\n       c.uvX.uv1 += offset;\n       c.uvX.uv2 += offset;\n       c.uvY.uv0 += offset;\n       c.uvY.uv1 += offset;\n       c.uvY.uv2 += offset;\n       c.uvZ.uv0 += offset;\n       c.uvZ.uv1 += offset;\n       c.uvZ.uv2 += offset;\n   }\n\n\n    void TriangleGrid(float2 uv, float scale,\n       out float w1, out float w2, out float w3,\n       out int2 vertex1, out int2 vertex2, out int2 vertex3)\n    {\n       // Scaling of the input\n       uv *= 3.464 * scale; // 2 * sqrt(3)\n\n       // Skew input space into simplex triangle grid\n       const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);\n       float2 skewedCoord = mul(gridToSkewedGrid, uv);\n\n       // Compute local triangle vertex IDs and local barycentric coordinates\n       int2 baseId = int2(floor(skewedCoord));\n       float3 temp = float3(frac(skewedCoord), 0);\n       temp.z = 1.0 - temp.x - temp.y;\n       if (temp.z > 0.0)\n       {\n          w1 = temp.z;\n          w2 = temp.y;\n          w3 = temp.x;\n          vertex1 = baseId;\n          vertex2 = baseId + int2(0, 1);\n          vertex3 = baseId + int2(1, 0);\n       }\n       else\n       {\n          w1 = -temp.z;\n          w2 = 1.0 - temp.y;\n          w3 = 1.0 - temp.x;\n          vertex1 = baseId + int2(1, 1);\n          vertex2 = baseId + int2(1, 0);\n          vertex3 = baseId + int2(0, 1);\n       }\n    }\n\n    // Fast random hash function\n    float2 SimpleHash2(float2 p)\n    {\n       return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 43758.5453);\n    }\n\n\n    half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)\n    {\n        // compute weight with height map\n        const half epsilon = 1.0f / 1024.0f;\n        half3 weights = half3(iWeights.x * (tex0 + epsilon), \n                                 iWeights.y * (tex1 + epsilon),\n                                 iWeights.z * (tex2 + epsilon));\n\n        // Contrast weights\n        half maxWeight = max(weights.x, max(weights.y, weights.z));\n        half transition = contrast * maxWeight;\n        half threshold = maxWeight - transition;\n        half scale = 1.0f / transition;\n        weights = saturate((weights - threshold) * scale);\n        // Normalize weights.\n        half weightScale = 1.0f / (weights.x + weights.y + weights.z);\n        weights *= weightScale;\n        return weights;\n    }\n\n\n    half3 PackedUnpackScaleNormal(half4 packedNormal, float scale)\n   {\n       #if _PACKEDFAST\n          half3 normal;\n          normal.xy = (packedNormal.ag * 2 - 1) * scale;\n          normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n          return normal;  \n       #endif\n       return UnpackScaleNormal(packedNormal, scale);\n   }\n\n    void InitStochasticDxDy(inout SampleConfig c, Config cfg)\n    {\n      c.dx0 = ddx(cfg.origUV) * cfg.origScale;\n      c.dy0 = ddy(cfg.origUV) * cfg.origScale;\n      c.dx1 = c.dx0; c.dx1 = c.dx0;\n      c.dx2 = c.dy0; c.dy2 = c.dy0;\n    }\n\n    void PrepareStochasticUVs(float scale, float2 uv, out SampleConfig c)\n    {\n       // Get triangle info\n       ZERO_INITIALIZE(SampleConfig, c);\n       float w1, w2, w3;\n       int2 vertex1, vertex2, vertex3;\n       TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n       // Assign random offset to each triangle vertex\n       c.uv0 = uv;\n       c.uv1 = uv;\n       c.uv2 = uv;\n   \n       c.uv0.xy += SimpleHash2(vertex1);\n       c.uv1.xy += SimpleHash2(vertex2);\n       c.uv2.xy += SimpleHash2(vertex3);\n       c.weights = half3(w1, w2, w3);\n       c.origWeights = half3(w1, w2, w3);\n    }\n\n\n   half3 LitBlendDetailNormal(half3 n1, half3 n2)\n   {\n      #if _SURFACEGRADIENT\n         return n1 + n2;\n      #else\n         return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n      #endif\n   }\n\n   float3 TriplanarBlendUnpackedRNM(float3 n1, float3 n2)\n   {\n       n1.z += 1;\n       n2.xy = -n2.xy;\n       return n1 * dot(n1, n2) / n1.z - n2;\n   }\n\n   void InitConfigDxDy(inout Config c)\n   {\n      c.uvT.dx0 = ddx(c.uvT.uv0);\n      c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1);\n      c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2);\n      c.uvT.dy2 = ddy(c.uvT.uv2);\n   }\n\n   Config CreateConfig(ShaderData d, float4 scale, float space, int uvsource, half triplanarContrast)\n   {\n      Config c;\n      ZERO_INITIALIZE(Config, c);\n\n      float3 pos = d.worldSpacePosition;\n      float3 normal = d.worldSpaceNormal;\n      if (space > 0)\n      {\n         pos = d.localSpacePosition;\n         normal = d.localSpaceNormal;\n      }\n\n      c.uv = d.texcoord0.xy;\n      \n      if (uvsource == 1)\n        c.uv = d.texcoord1.xy;\n      else if (uvsource == 2)\n        c.uv = pos.yz * float2(1, -1);\n      else if (uvsource == 3)\n        c.uv = pos.xz * float2(1, -1);\n      else if (uvsource == 4)\n        c.uv = pos.xy * float2(1, -1);\n\n      c.origUV = c.uv;\n      c.origScale = scale.xy;\n\n      c.uv = c.uv * scale.xy + scale.zw;\n      c.dx = ddx(c.uv);\n      c.dy = ddy(c.uv);\n\n      c.normal = normal;\n      c.uvT.uv0 = pos.zy * scale.xy + scale.zw;\n      c.uvT.uv1 = pos.xz * scale.xy + scale.zw;\n      c.uvT.uv2 = pos.xy * scale.xy + scale.zw;\n        \n      c.uvT.uv1 += 0.33;\n      c.uvT.uv2 += 0.67;\n\n      c.uvT.dx0 = ddx(c.uvT.uv0); c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1); c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2); c.uvT.dy2 = ddy(c.uvT.uv2);\n\n      half3 triblend = saturate(pow(abs(c.normal), triplanarContrast));\n      triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n      c.uvT.weights = triblend;\n      c.uvT.origWeights = triblend;\n      c.axisSign = d.worldSpaceNormal < 0 ? -1 : 1;\n      c.absVertNormal = abs(d.worldSpaceNormal);\n     \n\n      return c;\n   }\n\n\n   half4 TriSample(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0) * c.weights.x;\n      }\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1) * c.weights.y;\n      }  \n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2) * c.weights.z;\n      }\n\n      return res;\n   }\n\n   half4 TriSampleBary(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      c.weights = BaryWeightBlend(c.origWeights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   half4 TriSampleGrad(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvX, contrast, d) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvY, contrast, d) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n           res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvZ, contrast, d) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   \n   half4 SampleTexBaryStochastic(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   half4 SampleTexBaryTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleGrad(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   \n   half4 SampleTexBary(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        COUNTSAMPLE\n        return SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv, c.dx, c.dy);\n   }\n\n   half4 SampleTexStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ) * c.uvT.weights.z;\n\n        return res;     \n   }\n\n   \n   half4 SampleTexStochastic(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n\n   half4 SampleTexTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n   \n   half4 SampleTex(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       COUNTSAMPLE\n       return SAMPLE_TEXTURE2D(tex, ss, c.uv);\n   }\n   \n\n \n   half3 SampleNormalStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n         dataX = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n         dataY = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n         dataZ = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ));\n\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n\n          return WorldToTangentSpace(d, worldNormal);\n       #endif\n   }\n\n\n   half3 SampleNormalTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n      {\n          COUNTSAMPLE\n          dataX = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv0, c.uvT.dx0, c.uvT.dy0));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n      {\n          COUNTSAMPLE\n          dataY = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv1, c.uvT.dx1, c.uvT.dy1));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n      {\n         COUNTSAMPLE\n         dataZ = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv2, c.uvT.dx2, c.uvT.dy2));\n      }\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n          return WorldToTangentSpace(d, worldNormal);\n      #endif\n   }\n\n   half3 SampleNormalStochastic(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n     half4 normal = TriSample(tex, ss, c.uvT);\n     #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half3 SampleNormal(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 normal = SAMPLE_TEXTURE2D(tex, ss, c.uv);\n      #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half HeightBlend(half h1, half h2, half slope, half contrast)\n   {\n      h2 = 1 - h2;\n      half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); \n      half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));\n      return blend;\n   }\n\n\n    #if _POM\n    float2 POM(TEXTURE2D_PARAM(tex, ss), Config c, float contrast, ShaderData d)\n    {\n       float2 curv = float2(0, 0);\n       float refPlane = 0;\n\n       float result = 0;\n       int stepIndex = 0;\n       int maxSamples = _POMMaxSamples;\n       int minSamples = 4;\n       float camDist = distance(_WorldSpaceCameraPos, d.worldSpacePosition);\n       float distanceFade = 1 - saturate((camDist - _POMMin) / max(1, _POMFade));\n       int numSteps = ( int )lerp( maxSamples, minSamples, dot( d.worldSpaceNormal, d.worldSpaceViewDir )) * distanceFade;\n       if (numSteps < 1)\n           numSteps = 1;\n       float layerHeight = 1.0 / numSteps;\n       float2 plane = _ParallaxHeight * ( d.tangentSpaceViewDir.xy / d.tangentSpaceViewDir.z ) * distanceFade;\n       OffsetUV(c, refPlane * plane);\n       float2 deltaTex = -plane * layerHeight;\n       float2 prevTexOffset = 0;\n       float prevRayZ = 1.0f;\n       float prevHeight = 0.0f;\n       float2 currTexOffset = deltaTex;\n       float currRayZ = 1.0f - layerHeight;\n       float currHeight = 0.0f;\n       float intersection = 0;\n       float2 finalTexOffset = 0;\n\n       while ( stepIndex < numSteps + 1 )\n       {\n          result = dot( curv, currTexOffset * currTexOffset );\n          Config cfg = c;\n          OffsetUV(cfg, currTexOffset);\n          currHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( currHeight > currRayZ )\n          {\n             stepIndex = numSteps + 1;\n          }\n          else\n          {\n             stepIndex++;\n             prevTexOffset = currTexOffset;\n             prevRayZ = currRayZ;\n             prevHeight = currHeight;\n             currTexOffset += deltaTex;\n             currRayZ -= layerHeight * ( 1 - result );\n          }\n       }\n       int sectionSteps = 10;\n       int sectionIndex = 0;\n       float newZ = 0;\n       float newHeight = 0;\n       while ( sectionIndex < sectionSteps )\n       {\n          intersection = ( prevHeight - prevRayZ ) / ( prevHeight - currHeight + currRayZ - prevRayZ );\n          finalTexOffset = prevTexOffset + intersection * deltaTex;\n          newZ = prevRayZ - intersection * layerHeight;\n          Config cfg = c;\n          OffsetUV(cfg, finalTexOffset);\n          newHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( newHeight > newZ )\n          {\n             currTexOffset = finalTexOffset;\n             currHeight = newHeight;\n             currRayZ = newZ;\n             deltaTex = intersection * deltaTex;\n             layerHeight = intersection * layerHeight;\n          }\n          else\n          {\n             prevTexOffset = finalTexOffset;\n             prevHeight = newHeight;\n             prevRayZ = newZ;\n             deltaTex = ( 1 - intersection ) * deltaTex;\n             layerHeight = ( 1 - intersection ) * layerHeight;\n          }\n          sectionIndex++;\n       }\n       #if _PASSHADOWS\n       if ( unity_LightShadowBias.z == 0.0 )\n       {\n       #endif\n          if ( result > 1 )\n             clip( -1 );\n       #if _PASSHADOWS\n       }\n       #endif\n       return finalTexOffset;\n    }\n    #endif\n\n   \n\n   // tess versions\n   #if _TESSELLATION_ON\n   half4 TriSampleLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias) * c.weights.x;\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias) * c.weights.y;\n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias) * c.weights.z;\n\n      return res;\n   }\n\n   half4 TriSampleBaryLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias, float contrast)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias);\n      half4 r2 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias);\n      half4 r3 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias);\n      c.weights = BaryWeightBlend(c.weights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryLODStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvX, bias, contrast) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvY, bias, contrast) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvZ, bias, contrast) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   half4 SampleTexBaryLODStochastic(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n       return TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias, contrast);\n   }\n\n   half4 SampleTexBaryLODTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return TriSampleLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias);\n   }\n\n   half4 SampleTexBaryLOD(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv, bias);\n   }\n\n\n    float FBM2DLOD(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           return SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv, _TessellationMipBias).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n        \n        \n    }\n\n    float FBM3DLOD(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           half A = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.zy, _TessellationMipBias).g;\n           half B = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33, _TessellationMipBias).g;\n           half C = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67, _TessellationMipBias).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoiseLOD(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3DLOD(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3DLOD(d.localSpacePosition * frequency + offset, d.localSpaceNormal);\n        #else\n           return FBM2DLOD(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n   #endif //_TESSELLATION_ON\n\n\n    half3 FuzzyShade(ShaderData d, half height, half3 color, half3 normal, half coreMult, half edgeMult, half power)\n    {\n        float3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half dt = saturate(dot(d.worldSpaceViewDir, worldNormal));\n        half dark = 1.0 - (coreMult * dt);\n        half edge = pow(1-dt, abs(power)) * edgeMult;\n        return color * (dark + edge);\n    }\n\n\thalf MicroShadow(ShaderData d, half3 normal, half height, half ao, half strength)\n\t{\n        float3 sun;\n\t\tfloat3 sunColor;\n\t\tGetSun(sun, sunColor);\n\t\tfloat3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half shadow = saturate(abs(dot(worldNormal, sun)) + (ao * ao * 2.0) - 1.0);\n        return 1 - ((1-shadow) * strength);\n\t}\n\n\n#endif\n\n\n\n   #if defined(_SPECULAR)\n      #define _USESPECULAR 1\n      #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n   #endif\n\n   \n   TEXTURE2D(_AlbedoMap);\n   SAMPLER(sampler_AlbedoMap);\n   TEXTURE2D(_NormalMap);\n   SAMPLER(sampler_NormalMap);\n   TEXTURE2D(_MaskMap);\n   TEXTURE2D(_DetailMap);\n   TEXTURE2D(_EmissionMap);\n\n   #if _SPECULAR\n       TEXTURE2D(_SpecularMap);\n   #endif\n\n   \n   \n   void Ext_SurfaceFunction0 (inout Surface o, inout ShaderData d)\n   {\n      // define samplers based on settings\n      #undef SAMPLEBARY\n      #undef SAMPLE\n      #undef SAMPLENORMAL\n      #if _STOCHASTIC && _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n        #define SAMPLE     SampleTexStochasticTriplanar\n        #define SAMPLENORMAL SampleNormalStochasticTriplanar\n      #elif _STOCHASTIC\n        #define SAMPLEBARY SampleTexBaryStochastic\n        #define SAMPLE     SampleTexStochastic\n        #define SAMPLENORMAL SampleNormalStochastic\n      #elif _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryTriplanar\n        #define SAMPLE     SampleTexTriplanar\n        #define SAMPLENORMAL SampleNormalTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBary\n        #define SAMPLE     SampleTex\n        #define SAMPLENORMAL SampleNormal\n      #endif\n\n      Config c = CreateConfig(d, _AlbedoMap_ST, _TriplanarSpace, _UVSource, _TriplanarContrast);\n      InitConfigDxDy(c);\n      #if _STOCHASTIC && !_TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uv, c.uvT);\n         InitStochasticDxDy(c.uvT, c);\n      #elif _STOCHASTIC && _TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv0, c.uvX);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv1, c.uvY);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv2, c.uvZ);\n         InitStochasticDxDy(c.uvX, c);\n         InitStochasticDxDy(c.uvY, c);\n         InitStochasticDxDy(c.uvZ, c);\n      #endif\n\n      #if _POM\n          // would need to handle height remapping if we ever want to ship this\n          float2 pomOffset = POM(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n          OffsetUV(c, pomOffset);\n      #endif\n\n      half4 albedo = SAMPLEBARY(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n      \n      #if _PARALLAX\n         float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n         OffsetUV(c, offset);\n         albedo = SAMPLE(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c);\n         \n      #endif\n      albedo.a = lerp(_HeightRemap.x, _HeightRemap.y, albedo.a);\n      albedo.rgb *= _Tint.rgb;\n\n      albedo.rgb = AdjustContrast(albedo.rgb, _AlbedoContrast);\n      albedo.rgb += _AlbedoBrightness;\n\n\n      if (_AlphaThreshold > 0)\n      {\n         clip(albedo.a - _AlphaThreshold);\n      }\n\n      #if defined(_FLATSHADE)\n\t\t     float3 dx = ddx(d.worldSpacePosition);\n\t\t     float3 dy = ddy(d.worldSpacePosition);\n\t\t     float3 worldNormal = normalize(cross(dy, dx));\n\t\t     worldNormal = lerp(d.worldSpaceNormal, worldNormal, _FlatShadingBlend);\n\t\t     d.worldSpaceNormal = worldNormal;\n\t\t     d.TBNMatrix[2] = worldNormal;\n      #endif\n\n\n\n      o.Albedo = albedo.rgb;\n      o.Alpha = albedo.a;\n\n      float smoothness = _Smoothness;\n      float ao = 1;\n\n      #if defined(_NORMALMAP) && !defined(_AUTONORMAL)\n         o.Normal = SAMPLENORMAL(TEXTURE2D_ARGS(_NormalMap, sampler_NormalMap), c, d, _NormalStrength, smoothness, ao);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, ao);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n      #endif\n\n      half detailMask = 1;\n      o.Smoothness = smoothness;\n      o.Occlusion = ao;\n      o.Metallic = _Metallic;\n      #if defined(_MASKMAP) && !_PACKEDFAST\n         // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = SampleTex(TEXTURE2D_ARGS(_MaskMap, sampler_AlbedoMap), c);\n         o.Metallic = lerp(_MetallicRemap.x, _MetallicRemap.y, mask.r);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, mask.g);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, mask.a);\n         detailMask = mask.b;\n      #endif // separate maps\n\n      #if _SPECULAR\n         o.Specular = SAMPLE(TEXTURE2D_ARGS(_SpecularMap, sampler_AlbedoMap), c).rgb;\n      #endif\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = SAMPLE(TEXTURE2D_ARGS(_EmissionMap, sampler_AlbedoMap), c).rgb * _EmissionColor;\n      #endif\n\n      if (_FuzzyShadingOn > 0)\n      {\n        o.Albedo *= FuzzyShade(d, albedo.a, _FuzzyShadingColor, o.Normal, _FuzzyShadingParams.x, _FuzzyShadingParams.y, _FuzzyShadingParams.z);\n      }\n\n\n      // HDRP style detail texturing\n\n      #if defined(_DETAIL)\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _DETAILSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n         Config dc = CreateConfig(d, _DetailMap_ST, _DetailTriplanarSpace, _DetailUVSource, _DetailTriplanarContrast);\n         InitConfigDxDy(dc);\n         #if _DETAILSTOCHASTIC && !_DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uv, dc.uvT);\n             InitStochasticDxDy(dc.uvT, dc);\n         #elif _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv0, dc.uvX);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv1, dc.uvY);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv2, dc.uvZ);\n             InitStochasticDxDy(dc.uvX, dc);\n             InitStochasticDxDy(dc.uvY, dc);\n             InitStochasticDxDy(dc.uvZ, dc);\n         #endif\n\n         half4 detailSample = SAMPLEBARY(TEXTURE2D_ARGS(_DetailMap, sampler_AlbedoMap), dc, _DetailStochasticContrast, d);\n         smoothness = detailSample.z;\n         #if !_AUTONORMAL\n            half3 dnormal = float3(detailSample.ag * 2 - 1, 1) * detailMask * _DetailNormalStrength;\n            dnormal.z = sqrt(1 - dnormal.x * dnormal.x - dnormal.y * dnormal.y);\n            #if _SURFACEGRADIENT\n               dnormal = ConvertNormalToGradient(d, dnormal);\n            #endif\n            o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n         #endif\n     \n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * smoothness, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n      if (_MicroShadowStrength > 0)\n      {\n        o.Occlusion *= MicroShadow(d, o.Normal, o.Alpha, o.Occlusion, _MicroShadowStrength);\n      }\n  \n      // in case something needs height in the stack..\n      o.Height = o.Alpha;\n\n\n      \n   }\n\n\n\n\t#if _TINTMASK\n\t\tTEXTURE2D(_TintMask);\n\t\tSAMPLER(sampler_TintMask);\n\t#endif\n\n\tvoid Ext_SurfaceFunction1 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _TINTMASK\n\t\t   half4 w = SAMPLE_TEXTURE2D(_TintMask, sampler_TintMask, d.texcoord0.xy * _TintMask_ST.xy + _TintMask_ST.zw);\n\t\t   // allow black to be no tint..\n\t\t   half3 tint = o.Albedo * (_RColor.rgb * 2 * w.r + _GColor.rgb * 2 * w.g + _BColor.rgb * 2 * w.b + _AColor.rgb * 2 * w.a);\n\t\t   o.Albedo = lerp(o.Albedo, tint, saturate(w.r + w.g + w.b + w.a));\n\t\t#endif\n\t}\n\n\n\n\n\t#if _LAYERTEXTUREMASK\n       TEXTURE2D(_LayerTextureMask);\n       SAMPLER(sampler_LayerTextureMask); \n    #endif\n\n   void Ext_ModifyTessellatedVertex2 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON\n          float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n\n          #if _LAYERTEXTUREMASK\n               float2 layerUV = v.texcoord0.xy;\n               if (_LayerTextureMaskUVMode == 1)\n                  layerUV = v.texcoord1.xy;\n               else if (_LayerTextureMaskUVMode == 2)\n                  layerUV = worldSpacePosition.yz;\n               else if (_LayerTextureMaskUVMode == 3)\n                  layerUV = worldSpacePosition.xz;\n               else if (_LayerTextureMaskUVMode == 4)\n                  layerUV = worldSpacePosition.xy;\n\n              e.blackboard.weightTextureMask = SAMPLE_TEXTURE2D_LOD(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw, _TessellationMipBias);\n          #endif\n      #endif\n    }\n\n\n\tvoid Ext_SurfaceFunction2 (inout Surface o, inout ShaderData d)\n\t{\n\t\t#if _LAYERTEXTUREMASK\n           float2 layerUV = d.texcoord0.xy;\n           if (_LayerTextureMaskUVMode == 1)\n              layerUV = d.texcoord1.xy;\n           else if (_LayerTextureMaskUVMode == 2)\n              layerUV = d.worldSpacePosition.yz;\n           else if (_LayerTextureMaskUVMode == 3)\n              layerUV = d.worldSpacePosition.xz;\n           else if (_LayerTextureMaskUVMode == 4)\n              layerUV = d.worldSpacePosition.xy;\n\n          d.blackboard.weightTextureMask = SAMPLE_TEXTURE2D(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw);\n      #endif\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap);\n   SAMPLER(sampler_LayerAlbedoMap);\n   TEXTURE2D(_LayerNormalMap);\n   TEXTURE2D(_LayerMaskMap);\n   TEXTURE2D(_LayerEmissionMap);\n\n   \n\n   void Ext_ModifyTessellatedVertex3 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER) && defined(_LAYERALBEDO) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n         half detailMask = 1;\n         #if _LAYERNOISE\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency,  _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin;\n            dt = saturate(dt * _LayerFalloff);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight) * _LayerFalloff);\n            if (_LayerInvertHeight > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength;\n         detailMask *= _LayerTessStrength;\n\n         #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast).a;\n         albedo = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo);\n\n         if (_LayerBlendMode == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction3 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n            // noise up the mask\n            #if _LAYERNOISE\n               mask = DoNoise(d, _LayerNoiseFrequency, _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend);\n\t    \n                dt -= _LayerAngleMin;\n                dt = saturate(dt * _LayerFalloff);\n\n                float hf = saturate((o.Height - _LayerHeight) * _LayerFalloff);\n                if (_LayerInvertHeight > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 0\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 0\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength;\n\n            #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint, 0.5);\n            #if defined(_LAYERALBEDO)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c, _LayerStochasticContrast, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c);\n                #endif\n                albedo.rgb *= _LayerTint;\n                albedo.a = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL || _LAYERMASK\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap, sampler_LayerAlbedoMap, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast);\n            albedo.rgb += _LayerAlbedoBrightness;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap, sampler_LayerAlbedoMap), c, d, _LayerNormalStrength * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO)\n                if (_LayerFuzzyShadingOn > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor.rgb, dnormal,\n                                            _LayerFuzzyShadingParams.x, _LayerFuzzyShadingParams.y, _LayerFuzzyShadingParams.z);\n                }\n\n                if (_LayerBlendMode == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast);\n                else if (_LayerBlendMode == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE\n                      float maskDif = (_LayerBlendContrast * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength);\n                   #if _LAYERNOISE\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap, sampler_LayerAlbedoMap), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength);\n                }\n\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap, sampler_LayerAlbedoMap), c).rgb * _LayerEmissionColor;\n                #if _LAYERALBEDO\n                    if (_LayerBlendMode > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_1);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_1);\n   TEXTURE2D(_LayerNormalMap_Ext_1);\n   TEXTURE2D(_LayerMaskMap_Ext_1);\n   TEXTURE2D(_LayerEmissionMap_Ext_1);\n\n   \n\n   void Ext_ModifyTessellatedVertex4 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_1) && defined(_LAYERALBEDO_DEF_1) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_1\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_1,  _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_1\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_1;\n            dt = saturate(dt * _LayerFalloff_Ext_1);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n            if (_LayerInvertHeight_Ext_1 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_1;\n         detailMask *= _LayerTessStrength_Ext_1;\n\n         #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_1).a;\n         albedo = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo);\n\n         if (_LayerBlendMode_Ext_1 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_1);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_1 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction4 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_1)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_1\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_1, _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_1\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_1);\n\t    \n                dt -= _LayerAngleMin_Ext_1;\n                dt = saturate(dt * _LayerFalloff_Ext_1);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n                if (_LayerInvertHeight_Ext_1 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 01\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 01\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_1;\n\n            #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_1, 0.5);\n            #if defined(_LAYERALBEDO_DEF_1)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, _LayerStochasticContrast_Ext_1, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_1;\n                albedo.a = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_1 || _LAYERMASK_DEF_1\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_1);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_1;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, d, _LayerNormalStrength_Ext_1 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_1)\n                if (_LayerFuzzyShadingOn_Ext_1 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_1.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_1.x, _LayerFuzzyShadingParams_Ext_1.y, _LayerFuzzyShadingParams_Ext_1.z);\n                }\n\n                if (_LayerBlendMode_Ext_1 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_1);\n                else if (_LayerBlendMode_Ext_1 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_1 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_1);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_1\n                      float maskDif = (_LayerBlendContrast_Ext_1 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_1 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                   #if _LAYERNOISE_DEF_1\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_1));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_1 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_1);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_1) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_1 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_1);\n                }\n\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_1);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_1, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_1, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_1\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c).rgb * _LayerEmissionColor_Ext_1;\n                #if _LAYERALBEDO_DEF_1\n                    if (_LayerBlendMode_Ext_1 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_2);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_2);\n   TEXTURE2D(_LayerNormalMap_Ext_2);\n   TEXTURE2D(_LayerMaskMap_Ext_2);\n   TEXTURE2D(_LayerEmissionMap_Ext_2);\n\n   \n\n   void Ext_ModifyTessellatedVertex5 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_2) && defined(_LAYERALBEDO_DEF_2) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_2\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_2,  _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_2\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_2;\n            dt = saturate(dt * _LayerFalloff_Ext_2);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n            if (_LayerInvertHeight_Ext_2 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_2;\n         detailMask *= _LayerTessStrength_Ext_2;\n\n         #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_2).a;\n         albedo = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo);\n\n         if (_LayerBlendMode_Ext_2 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_2);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_2 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction5 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_2)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_2\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_2, _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_2\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_2);\n\t    \n                dt -= _LayerAngleMin_Ext_2;\n                dt = saturate(dt * _LayerFalloff_Ext_2);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n                if (_LayerInvertHeight_Ext_2 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 02\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 02\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_2;\n\n            #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_2, 0.5);\n            #if defined(_LAYERALBEDO_DEF_2)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, _LayerStochasticContrast_Ext_2, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_2;\n                albedo.a = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_2 || _LAYERMASK_DEF_2\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_2);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_2;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, d, _LayerNormalStrength_Ext_2 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_2)\n                if (_LayerFuzzyShadingOn_Ext_2 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_2.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_2.x, _LayerFuzzyShadingParams_Ext_2.y, _LayerFuzzyShadingParams_Ext_2.z);\n                }\n\n                if (_LayerBlendMode_Ext_2 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_2);\n                else if (_LayerBlendMode_Ext_2 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_2 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_2);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_2\n                      float maskDif = (_LayerBlendContrast_Ext_2 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_2 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                   #if _LAYERNOISE_DEF_2\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_2));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_2 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_2);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_2) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_2 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_2);\n                }\n\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_2);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_2, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_2, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_2\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c).rgb * _LayerEmissionColor_Ext_2;\n                #if _LAYERALBEDO_DEF_2\n                    if (_LayerBlendMode_Ext_2 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   #if _TRAX_ON\n   TEXTURE2D(_TraxAlbedo);\n   SAMPLER(sampler_TraxAlbedo);\n   TEXTURE2D(_TraxPackedNormal);\n   TEXTURE2D(_TraxMask);\n\n   sampler2D_float _GMSTraxBuffer;\n\n   float4 _GMSTraxBuffer_TexelSize;\n   float3 _GMSTraxBufferPosition;\n   float _GMSTraxBufferWorldSize;\n   float _GMSTraxFudgeFactor;\n\n   float SampleTraxBufferLOD(float3 worldPos)\n   {    \n      // generate UVs for the buffer, which is moving\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 8);\n      uv *= 0.5;\n      uv += 0.5;\n            \n      float s =  tex2Dlod(_GMSTraxBuffer, float4(uv, 0, 0)).r;\n\n      return 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n   }\n         \n        \n   float SampleTraxBuffer(float3 worldPos, out float3 norm)\n   {\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 3);\n      uv *= 0.5;\n      uv += 0.5;\n            \n\n      float2 offset = _GMSTraxBuffer_TexelSize.xy;\n\n      float s = tex2D(_GMSTraxBuffer, uv).r;\n               \n      float s1 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, -1)).r;\n      float s2 = tex2D(_GMSTraxBuffer, uv + offset * float2(-1, 0)).r;\n      float s3 = tex2D(_GMSTraxBuffer, uv + offset * float2(1, 0)).r;\n      float s4 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, 1)).r;\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      float r = 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n \n      // generate normals\n      norm.x = (s1 - s4) * 0.25; \n      norm.y = (s2 - s3) * 0.25;\n      norm.z = 2;\n      norm = normalize(norm);\n     \n      norm.xy *= 1 - r;\n            \n      return r;\n   }\n   #endif\n\n   void Ext_ModifyTessellatedVertex6 (inout VertexData v, inout ExtraV2F d)\n   {\n       #if _TESSELLATION_ON && _TRAX_ON && _HAS_LIT_TESSELLATION\n          \n           float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n           float3 worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n           float traxBuffer = SampleTraxBufferLOD(worldSpacePosition);\n           d.blackboard.traxBuffer = traxBuffer;\n           float2 uv = worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n           half albedo = SAMPLE_TEXTURE2D_LOD(_TraxAlbedo, sampler_TraxAlbedo, uv, _TraxMipBias).a;\n\n           float traxOffset = albedo * _TraxDisplacementStrength;\n           traxOffset *= 1 - v.texcoord0.z;\n           traxOffset *= _TessellationDisplacement;\n           float dig = _TraxDisplacementDepth * (1 - v.texcoord0.z);\n           float3 traxVertex = d.blackboard.originalVertexPosition + (v.normal * (traxOffset - dig));\n           v.vertex.xyz = lerp(traxVertex, v.vertex.xyz, traxBuffer);\n\n           d.blackboard.vertexHeightOffset = lerp(traxOffset-dig, d.blackboard.vertexHeightOffset, traxBuffer);\n\n       #endif\n\n   }\n\n   void Ext_SurfaceFunction6 (inout Surface o, inout ShaderData d)\n   {\n      #if _TRAX_ON\n        float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n        float2 fsdx = ddx(uv);\n        float2 fsdy = ddy(uv);\n\n        float3 traxNormal;\n        float traxBuffer = SampleTraxBuffer(d.worldSpacePosition, traxNormal);\n        \n        #if _TESSELLATION_ON\n            traxBuffer -= _TraxDisplacementDepth;\n        #endif\n\n        d.blackboard.traxBuffer = traxBuffer;\n\n        UNITY_BRANCH\n        if (traxBuffer > 0)\n        {\n            half4 albedo = SAMPLE_TEXTURE2D_GRAD(_TraxAlbedo, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            albedo.rgb *= _TraxTint.rgb;\n            half4 normalSample = SAMPLE_TEXTURE2D_GRAD(_TraxPackedNormal, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n\n            half smoothness = normalSample.r;\n            half ao = normalSample.b;\n            half3 normal;\n            normal.xy = (normalSample.ag * 2 - 1) * _TraxNormalStrength;\n            normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n\n            \n            half h = HeightBlend(albedo.a, o.Alpha, traxBuffer, _TraxHeightContrast);\n\n            h = lerp(traxBuffer, h, _TraxInterpContrast);\n\n            o.Albedo = lerp(albedo, o.Albedo, h);\n\n            #if _SURFACEGRADIENT\n                o.Normal = lerp(normal, o.Normal, h);\n            #else\n                o.Normal = lerp(normal + traxNormal, o.Normal, h);\n            #endif\n        \n            o.Smoothness = lerp(smoothness, o.Smoothness, h);\n            o.Occlusion = lerp(ao, o.Occlusion, h);\n        }\n      #endif\n   }\n\n\n\n\n    #if _RAINDROPS\n       TEXTURE2D(_RainDropTexture);\n       SAMPLER(sampler_RainDropTexture);\n       half _Global_RainIntensity;\n    #endif\n\n    #if _WETNESS\n       half2 _Global_WetnessParams; // global, not in cbuffer\n    #endif\n   \n    #if _RAINDROPS\n    half2 ComputeRipple(float2 uv, half time, half weight)\n    {\n        half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_RainDropTexture, uv);\n        COUNTSAMPLE\n        ripple.yz = ripple.yz * 2 - 1;\n\n        half dropFrac = frac(ripple.w + time);\n        half timeFrac = dropFrac - 1.0 + ripple.x;\n        half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);\n        half finalFactor = dropFactor * ripple.x * \n                                sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);\n\n        return half2(ripple.yz * finalFactor);\n    }\n    #endif\n\n    half2 DoRain(half2 waterNorm, float2 uv, out half2 ripple)\n    {\n        #if _RAINDROPS\n            float rainIntensity = _RainIntensityScale.x;\n            if (_RainMode > 1)\n            {\n                rainIntensity = _Global_RainIntensity;\n            }\n\n            half dropStrength = rainIntensity;\n            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); \n            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);\n            half4 times = _Time.yyyy;\n            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);\n\n            float2 ruv1 = uv * _RainIntensityScale.yy;\n            float2 ruv2 = ruv1;\n\n            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);\n            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);\n            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);\n            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);\n            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);\n            weights = saturate(weights * 4);\n\n            half2 rippleNormal = half2( weights.x * ripple1.xy +\n                        weights.y * ripple2.xy + \n                        weights.z * ripple3.xy + \n                        weights.w * ripple4.xy);\n\n            ripple = rippleNormal * dropStrength * rainIntensity;\n            waterNorm = lerp(waterNorm, normalize(half3(rippleNormal.xy + rippleNormal.xy, 1)).xy, rainIntensity * dropStrength); \n            return waterNorm;                        \n        #else\n            return waterNorm;\n        #endif\n    }\n\n   half2 _Global_PuddleParams;   // this is a global, so keep it out of the cbuffer\n   void GetPuddleParams(ShaderData d, inout float puddleMask, inout float pudHeight)\n   {\n      #if _PUDDLES || _GLOBALPUDDLES\n          pudHeight = _PuddleAmount;\n          if (_PuddleMode > 0)\n             pudHeight = _Global_PuddleParams.x;    \n      \n\n          half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t      dt -= _PuddleAngleMin;\n          dt = saturate(dt * _PuddleFalloff);\n          puddleMask *= dt;\n      #endif\n   }\n   \n   void Ext_ModifyTessellatedVertex7 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _PUDDLES && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n         half mask = 1;\n         half pudHeight = 1;\n\n         // save some ops by doing this in 2d\n         #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2DLOD(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2DLOD(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #else\n                mask = (FBM2DLOD(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n         #endif\n\n         GetPuddleParams(d, mask, pudHeight);\n         float height = pudHeight * mask;\n         if (e.blackboard.vertexHeightOffset < height)\n         {\n            e.blackboard.vertexHeightOffset = height;\n            height -= _TessellationOffset; \n            // dampen cracks\n            height *= 1 - v.texcoord0.z;\n            height *= _TessellationDisplacement;\n            v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n            \n        }\n      #endif\n   }\n\n\n#if _WETNESS\n\n   float GetWetnessLevel(Surface o, ShaderData d, float wetnessMask)\n   {\n      float wetLevel = clamp(_WetnessAmount, _WetnessMin, _WetnessMax);\n      \n      if (_WetnessMode > 0)\n         wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);\n\n      wetLevel = saturate(wetLevel + (1 - saturate(d.worldSpacePosition.y - _WetnessShoreline)));\n      float3x3 tbn = float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal);\n      float dt = dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0));\n      dt -= _WetnessAngleMin;\n      dt = saturate(dt * _WetnessFalloff * wetLevel);\n      dt *= wetnessMask;\n      return dt;\n   }\n#endif\n   \n\n   void Ext_SurfaceFunction7 (inout Surface o, ShaderData d)\n   {\n      half wetnessLevel = 0;\n      #if _WETNESS\n          wetnessLevel = GetWetnessLevel(o, d, 1); // mask one day?\n      #endif\n\n      half depthMask = 0;\n      half depth = 0;\n\n      #if _PUDDLES\n          half mask = 1;\n          half pudHeight = 1;\n          #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2D(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2D(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);      \n            #else\n                mask = (FBM2D(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n          #endif\n\n          GetPuddleParams(d, mask, pudHeight);\n          pudHeight *= mask;\n          depth = pudHeight - o.Height;\n          depthMask = saturate(depth * _PuddleFalloff);\n          depthMask *= _PuddleColor.a;\n          depth = o.Height - pudHeight;\n\n          // extend wetness slighting higher than the puddle\n          half wetmask = saturate((pudHeight + 0.05 - o.Height) * _PuddleFalloff);\n          wetnessLevel = max(wetmask, wetnessLevel);\n       #endif\n\n       \n       #if _WETNESS || _PUDDLES\n          half3 waterNorm = half3(0,0,1);\n          half3 wetAlbedo = o.Albedo;\n          half wetSmoothness = o.Smoothness;\n          #if _PUDDLES\n             wetAlbedo *= _PuddleColor.rgb;\n          #endif\n          WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetnessLevel, _Porosity);\n\n          half ri = 0;\n          half2 ripple = 0;\n          #if (_RAINDROPS || _GLOBALRAIN) && (_PUDDLES || _GLOBALPUDDLES)\n             ri = _RainIntensityScale.z;\n             waterNorm.xy = DoRain(waterNorm.xy, d.texcoord0.xy, ripple) * depthMask;\n          #endif\n\n          o.Normal = lerp(o.Normal, waterNorm, depthMask);\n          o.Normal = lerp(o.Normal, LitBlendDetailNormal(o.Normal, half3(ripple.xy, 1)), saturate(ri - depthMask) * wetnessLevel);\n          o.Occlusion = lerp(o.Occlusion, 1, depthMask);\n          o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetnessLevel);\n          o.Albedo = lerp(o.Albedo, wetAlbedo, wetnessLevel);\n          o.Emission *= 1 + depth;\n          o.Metallic *= 1 + depth;\n          o.Specular *= 1 + depth;\n\n       #endif\n\n   }\n\n\n\n\n    #if _SNOW\n       TEXTURE2D(_SnowAlbedo);\n       SAMPLER(sampler_SnowAlbedo);\n       TEXTURE2D(_SnowNormal);\n       TEXTURE2D(_SnowMaskMap);\n       #if _TRAX_ON\n          TEXTURE2D(_SnowTraxAlbedo);\n          TEXTURE2D(_SnowTraxNormal);\n          TEXTURE2D(_SnowTraxMaskMap);\n       #endif\n    #endif\n\n   float _Global_SnowLevel;\n\n\n   void Ext_ModifyVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n    #if (_SNOW)\n        float amount = _SnowAmount;\n        if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n        float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n        float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n        snowAmount -= _SnowAngle;\n        snowAmount *= _SnowContrast * 0.5;\n        snowAmount = saturate(snowAmount) * amount;\n        float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n        if (_SnowWorldFade.z > 0)\n        {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n        }\n        #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n        #endif\n        snowAmount = saturate(snowAmount);\n\n        #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n        #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n        #endif\n\n        float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n        v.vertex.xyz = v.vertex.xyz + displacementVec * snowAmount * snowAmount * _SnowVertexHeight;\n    #endif\n   }\n\n   void Ext_ModifyTessellatedVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _SNOW && _HAS_LIT_TESSELLATION\n         float amount = _SnowAmount;\n         if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n         float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n         float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n         snowAmount -= _SnowAngle;\n         snowAmount *= _SnowContrast * 0.5;\n         float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n         if (_SnowWorldFade.z > 0)\n         {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n         }\n\n         snowAmount = saturate(snowAmount) * amount;\n\n         #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n         #endif\n         snowAmount = saturate(snowAmount);\n\n         #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n         #endif\n\n         float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n         half heightMap = SAMPLE_TEXTURE2D_LOD(_SnowAlbedo, sampler_SnowAlbedo, worldPos.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw, 2);\n\n         float height = max(_SnowVertexHeight * 3 * snowAmount + snowAmount * heightMap, e.blackboard.vertexHeightOffset);\n         #if _TRAX_ON\n            height *= e.blackboard.traxBuffer;\n         #endif\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n\n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n         \n      #endif\n\n   }\n\n   void SampleSnowSurface(TEXTURE2D_PARAM(alb, ss), TEXTURE2D_PARAM(norm, ss2), TEXTURE2D_PARAM(mask, ss3),\n        ShaderData d, float2 uv, float2 dx, float2 dy, out half4 albedo, out half3 normal, out half2 smoothAO)\n   {\n      #if _SNOWSTOCHASTIC\n         float w1, w2, w3;\n         int2 vertex1, vertex2, vertex3;\n         TriangleGrid(uv, _SnowStochasticScale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n         // Assign random offset to each triangle vertex\n         float2 uv0 = uv;\n         float2 uv1 = uv;\n         float2 uv2 = uv;\n   \n         uv0.xy += SimpleHash2(vertex1);\n         uv1.xy += SimpleHash2(vertex2);\n         uv2.xy += SimpleHash2(vertex3);\n         half3 weights = half3(w1, w2, w3);\n\n         half4 albedo0 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv0, dx, dy);\n         half4 albedo1 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv1, dx, dy);\n         half4 albedo2 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv2, dx, dy);\n         COUNTSAMPLE\n         COUNTSAMPLE\n         COUNTSAMPLE\n         weights = BaryWeightBlend(weights, albedo0.a, albedo1.a, albedo2.a, _SnowStochasticContrast);\n         albedo = albedo0 * weights.x + albedo1 * weights.y + albedo2 * weights.z;\n\n         normal = half3(0,0,1);\n         smoothAO = half2(0, 1);\n\n         #if !_AUTONORMAL\n            half4 n0 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv0, dx, dy);\n            half4 n1 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv1, dx, dy);\n            half4 n2 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n            half4 snowNormSamp = n0 * weights.x + n1 * weights.y + n2 * weights.z;\n\n            normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n                \n            #if _PACKEDFAST\n               smoothAO.x = snowNormSamp.r;\n               smoothAO.y = snowNormSamp.b;\n            #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask0 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv0, dx, dy);\n            half4 snowMask1 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv1, dx, dy);\n            half4 snowMask2 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n            half4 snowMask = snowMask0 * weights.x + snowMask1 * weights.y + snowMask2 * weights.z;\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n      #else // not stochastic\n          albedo = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv, dx, dy);\n          COUNTSAMPLE\n\n          normal = half3(0,0,1);\n          smoothAO = half2(0, 1);\n\n          #if !_AUTONORMAL\n             half4 snowNormSamp = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv, dx, dy);\n             COUNTSAMPLE\n             normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n             #if _SURFACEGRADIENT\n                normal = ConvertNormalToGradient(d, normal);\n             #endif\n                 \n             #if _PACKEDFAST\n                smoothAO.x = snowNormSamp.r;\n                smoothAO.y = snowNormSamp.b;\n             #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv, dx, dy);\n            COUNTSAMPLE\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n     #endif // stochastic\n   }\n\n   \n   void Ext_SurfaceFunction8 (inout Surface o, ShaderData d)\n   {\n      #if _SNOW\n          float amount = _SnowAmount;\n          if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n          float snowAmount = lerp(dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), dot(d.worldSpaceNormal, float3(0,1,0)), amount * 0.8) + 1;\n          snowAmount -= _SnowAngle;\n          snowAmount *= _SnowContrast;\n          snowAmount = saturate(snowAmount) - (1-amount) * (1-amount);\n\n          if (_SnowWorldFade.z > 0)\n          {\n             float worldFade = saturate((d.worldSpacePosition.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n             snowAmount *= worldFade;\n          }\n\n          #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(d.worldSpacePosition.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n          #endif\n          snowAmount = saturate(snowAmount);\n\n          float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw;\n          float2 dx = ddx(uv);\n          float2 dy = ddy(uv);\n\n          #if _TRAX_ON\n              float2 tuv = d.worldSpacePosition.xz * float2(1, -1) * _SnowTraxAlbedo_ST.xy + _SnowTraxAlbedo_ST.zw;\n              float2 tdx = ddx(uv);\n              float2 tdy = ddy(uv);\n          #endif\n\n          #if _LAYERVERTEXMASK\n              snowAmount *= d.vertexColor.a;\n          #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n              snowAmount *= d.blackboard.weightTextureMask.a;\n          #endif\n\n          UNITY_BRANCH\n          if (snowAmount > 0)\n          {\n             half4 snowAlbedo;\n             half3 snowNormal;\n             half2 snowSmoothAO;\n             SampleSnowSurface(TEXTURE2D_ARGS(_SnowAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowNormal, sampler_SnowAlbedo),\n                    TEXTURE2D_ARGS(_SnowMaskMap, sampler_SnowAlbedo), d, uv, dx, dy, snowAlbedo, snowNormal, snowSmoothAO);\n\n             snowAlbedo.rgb *= _SnowTint.rgb;\n\n             #if _TRAX_ON\n                half traxBuffer = 1 - d.blackboard.traxBuffer;\n                UNITY_BRANCH\n                if (traxBuffer > 0)\n                {\n                    half4 tsnowAlbedo;\n                    half3 tsnowNormal;\n                    half2 tsnowSmoothAO;\n                    SampleSnowSurface(TEXTURE2D_ARGS(_SnowTraxAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowTraxNormal, sampler_SnowAlbedo),\n                        TEXTURE2D_ARGS(_SnowTraxMaskMap, sampler_SnowAlbedo), d, tuv, tdx, tdy, tsnowAlbedo, tsnowNormal, tsnowSmoothAO);\n\n                    tsnowAlbedo.rgb *= _SnowTraxTint;\n                    half h = HeightBlend(snowAlbedo.a, tsnowAlbedo.a, traxBuffer, 0.5);\n                    snowAlbedo = lerp(snowAlbedo, tsnowAlbedo, h);\n                    snowNormal = lerp(snowNormal, tsnowNormal, h);\n                    snowSmoothAO = lerp(snowSmoothAO, tsnowSmoothAO, h);\n                }\n             #endif\n\n             #if !_AUTONORMAL\n                o.Normal = lerp(o.Normal, snowNormal, snowAmount);\n             #endif\n             o.Albedo = lerp(o.Albedo, snowAlbedo.rgb, snowAmount);\n             o.Alpha = lerp(o.Alpha, snowAlbedo.a, snowAmount);\n             o.Smoothness = lerp(o.Smoothness, snowSmoothAO.x, snowAmount);\n             o.Occlusion = lerp(o.Occlusion, snowSmoothAO.y, snowAmount);\n             o.Height = o.Alpha;\n\n          }\n      #endif\n   }\n\n   \n\n\n\n\n\n   TEXTURE2D(_WindParticulate);\n   SAMPLER(sampler_WindParticulate);\n\n// In case we want to read it more than once..\n\n#ifndef __STACKABLE_WIND_INCLUDES__\n#define __STACKABLE_WIND_INCLUDES__\n\n\n   half FilterRange(float4 range, float y)\n   {\n      half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));\n      w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));\n      return w;\n   }\n\n   \n   float2 RotateUV(float2 uv, float amt)\n   {\n      uv -=0.5;\n      float s = sin ( amt);\n      float c = cos ( amt );\n      float2x2 mtx = float2x2( c, -s, s, c);\n      mtx *= 0.5;\n      mtx += 0.5;\n      mtx = mtx * 2-1;\n      uv = mul ( uv, mtx );\n      uv += 0.5;\n      return uv;\n   }\n\n\n   half FilterWindParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)\n   {\n      float2 windDir = RotateUV(float2(1, 0), windRot);\n      float2 flow = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));\n      float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill\n      return FilterRange(range, cofacing);\n   }\n\n   half ProcessWindParticulateMask(inout half mask, float contrast)\n   {\n      mask = pow(abs(mask), abs(contrast));\n      half invMask = 1.0 - mask;\n      invMask *= invMask; \n      invMask *= invMask;\n      return invMask;\n   }\n#endif // include guard\n\n   void Ext_SurfaceFunction9 (inout Surface o, ShaderData d)\n   {\n      #if _WIND_ON && !_PASSMETA\n   \n         float3 upVector = float3(0,0,1);\n\n         half upDot = max(0.0, dot(d.worldSpaceNormal, float3(0, 1, 0)));\n\n         float2 uv = d.worldSpacePosition.xz;\n         if (_WindParticulateSpace > 0.5)\n            uv = d.texcoord0.xy;\n         float windRotation = _WindParticulateRotation;\n         float windStrength = _WindParticulateStrength;\n\n         float2 wuv = RotateUV(uv, windRotation);\n\n         half windBlend = 1.0;\n\n         float windWorldMask = FilterRange(_WindParticulateWorldHeightMask, d.worldSpacePosition.y);\n         windWorldMask *= FilterRange(_WindParticulateAngleMask, upDot);\n\n         // compute mask\n         wuv *= float2(_WindParticulate_ST.x, 1) * _WindParticulate_ST.y + _WindParticulate_ST.zw;\n         float speed = _Time.x * _WindParticulateSpeed;\n         half w1 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv * 3 + speed * float2(1,0)).g;\n         half w2 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv + speed * float2(1.1,0)).a;\n         half windMask = (w1 * w2);\n\n         windMask *= windStrength * windBlend * windWorldMask;\n         windMask *= saturate((_WindParticulateTextureHeight - o.Height) * 10);\n\n         half windInvMask = ProcessWindParticulateMask(windMask, _WindParticulatePower);\n    \n         o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);\n         o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindParticulateEmissive.rgb;\n         o.Normal.xy *= windInvMask;\n         o.Smoothness *= windInvMask;\n         o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;\n         o.Metallic *= windInvMask;\n      #endif\n\n   }\n\n\n\n\n\tvoid Ext_SurfaceFunction10 (inout Surface o, ShaderData d)\n\t{\n        if (_DoubleSidedNormalMode == 0)\n        {\n           o.Normal *= d.isFrontFace ? 1 : -1;\n        }\n        else if (_DoubleSidedNormalMode == 1)\n        {\n\t\t   o.Normal.z *= d.isFrontFace ? 1 : -1;\n        }\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction11 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _SURFACEGRADIENT\n\t\t\to.Normal = ResolveNormalFromSurfaceGradient(d, o.Normal);\n\t    #elif _AUTONORMAL\n\t        float3 dx = ddx(d.worldSpacePosition);\n\t\t\tfloat3 dy = ddy(d.worldSpacePosition);\n\t\t\tfloat3 crossX = cross(float3(0,1,0), dx);\n\t\t\tfloat3 crossY = cross(float3(0,1,0), dy);\n\t\t\tfloat3 dt = abs(dot(crossY, dx));\n\t\t\tfloat height = _AutoNormalStrength * 0.5 * o.Alpha;\n\t\t\tfloat3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n\t\t\tn.y *= -1.0;\n\t\t\to.Normal = normalize((dt * float3(0,1,0)) - n).xzy;\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#else\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#endif\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction12 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DEBUG_SAMPLECOUNT\n\t\t\tif (_sampleCount > _DebugSampleCountThreshold)\n\t\t\t{\n\t\t\t\to.Albedo.r = 1;\n\t\t\t\to.Albedo.gb *= 0.2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\to.Albedo.b = 1;\n\t\t\t}\n\n        #endif\n\t}\n\n\n\n\n\tSAMPLER(sampler_DissolveTexture);\n\tTEXTURE2D(_DissolveTexture);\n\tTEXTURE2D(_DissolveGradient);\n\n\tvoid Ext_SurfaceFunction13 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DISSOLVE\n\t\tfloat2 uv = d.texcoord0.xy * _DissolveTexture_ST.xy + _DissolveTexture_ST.zw;\n\t\tfloat2 dx = ddx(uv);\n\t\tfloat2 dy = ddy(uv);\n\n\t\tUNITY_BRANCH\n\t\tif (_DissolveAmount > 0)\n\t\t{\n\t\t\thalf dissolve = SAMPLE_TEXTURE2D_GRAD(_DissolveTexture, sampler_DissolveTexture, uv, dx, dy).g;\n\t\t\thalf cp =  saturate(_DissolveAmount - (dissolve - _DissolveAmount) * _DissolveEdgeContrast) + _DissolveAmount;\n\t\t\thalf cp2 = saturate(1.0 - abs((dissolve - _DissolveAmount) * _DissolveEdgeContrast));\n\t\t\tclip(1.0 - cp);\n\t\t\tfloat2 fuv = float2(cp2, 0.5);\n\t\t\thalf3 col = SAMPLE_TEXTURE2D_LOD(_DissolveGradient, sampler_DissolveTexture, fuv, 0).rgb;\n\t\t\t\t\n\t\t\to.Albedo = lerp(o.Albedo, col, _DissolveColoration * cp2);\n\t\t\to.Emission = lerp(o.Emission, col * _DissolveEmissiveStr, _DissolveColoration * cp2);\n\t\t}\n\t\t#endif\n\t}\n\n\n\n\n    float Dither8x8Bayer( int x, int y )\n    {\n        const float dither[ 64 ] = {\n                1, 49, 13, 61,  4, 52, 16, 64,\n            33, 17, 45, 29, 36, 20, 48, 32,\n                9, 57,  5, 53, 12, 60,  8, 56,\n            41, 25, 37, 21, 44, 28, 40, 24,\n                3, 51, 15, 63,  2, 50, 14, 62,\n            35, 19, 47, 31, 34, 18, 46, 30,\n            11, 59,  7, 55, 10, 58,  6, 54,\n            43, 27, 39, 23, 42, 26, 38, 22};\n        int r = y * 8 + x;\n        return dither[r] / 64; \n    }\n\n    void ApplyDitherCrossFadeVSP(float2 vpos, float fadeValue)\n    {\n        float dither = Dither8x8Bayer( fmod(vpos.x, 8), fmod(vpos.y, 8) );\n        float sgn = fadeValue > 0 ? 1.0f : -1.0f;\n        clip(dither - (1-fadeValue) * sgn);\n    }\n    \n\n\tvoid Ext_SurfaceFunction14 (inout Surface o, ShaderData d)\n\t{\n\t\t#if LOD_FADE_CROSSFADE\n            float4 screenPosNorm = d.screenPos / d.screenPos.w;\n            screenPosNorm.z = ( UNITY_NEAR_CLIP_VALUE >= 0 ) ? screenPosNorm.z : screenPosNorm.z * 0.5 + 0.5;\n            float2 clipScreen = screenPosNorm.xy * _ScreenParams.xy;\n            ApplyDitherCrossFadeVSP(clipScreen,unity_LODFade.x);\n        #endif\n\t}\n\n\n\n\n\n\n// declare outside of CBuffer\n\nfloat4x4 _GlobalVolumeMatrix;\nfloat4x4 _VolumeMatrix;\nfloat3 _VolumeMin;\nfloat3 _VolumeInvSize;\nfloat3 _GlobalVolumeMin;\nfloat3 _GlobalVolumeInvSize;\n\n// I inlined a section of your include. You can use includes in better shaders, but doing it via a subshader or this way\n// is much better. The reason is that this allows your shader to be all inclusive, and packed up for asset store distribition,\n// without requiring specific paths to other files, etc.\n//\n\n#ifndef BAKERY_INCLUDED\n#define BAKERY_INCLUDED\n\n#define BAKERYMODE_DEFAULT 0\n#define BAKERYMODE_VERTEXLM 1.0f\n#define BAKERYMODE_RNM 2.0f\n#define BAKERYMODE_SH 3.0f\n\n\n// can't fit vertexLM SH to sm3_0 interpolators\n#ifndef SHADER_API_D3D11\n    #undef _LIGHTMAPMODE_VERTEXSH\n#endif\n\n// can't do stuff on sm2_0 due to standard shader alrady taking up all instructions\n#if SHADER_TARGET < 30\n    #undef BAKERY_BICUBIC\n    #undef BAKERY_LMSPEC\n\n    #undef _LIGHTMAPMODE_RNM\n    #undef _LIGHTMAPMODE_SH\n    #undef _LIGHTMAPMODE_VERTEX\n#endif\n\n#define lumaConv float3(0.2125f, 0.7154f, 0.0721f)\n\n#ifdef BAKERY_VOLUME\n    #ifdef BAKERY_COMPRESSED_VOLUME\n        Texture3D _Volume3;\n    #endif\n#endif\n\n\nhalf3 LinearToGamma (half3 linRGB)\n{\n    linRGB = max(linRGB, half3(0.h, 0.h, 0.h));\n    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n    return max(1.055h * pow(linRGB, 0.416666667h) - 0.055h, 0.h);\n}\n\nfloat shEvaluateDiffuseL1Geomerics(float L0, float3 L1, float3 n)\n{\n    // average energy\n    float R0 = L0;\n\n    // avg direction of incoming light\n    float3 R1 = 0.5f * L1;\n\n    // directional brightness\n    float lenR1 = length(R1);\n\n    // linear angle between normal and direction 0-1\n    //float q = 0.5f * (1.0f + dot(R1 / lenR1, n));\n    //float q = dot(R1 / lenR1, n) * 0.5 + 0.5;\n    float q = dot(normalize(R1), n) * 0.5 + 0.5;\n\n    // power for q\n    // lerps from 1 (linear) to 3 (cubic) based on directionality\n    float p = 1.0f + 2.0f * lenR1 / R0;\n\n    // dynamic range constant\n    // should vary between 4 (highly directional) and 0 (ambient)\n    float a = (1.0f - lenR1 / R0) / (1.0f + lenR1 / R0);\n\n    return R0 * (a + (1.0f - a) * (p + 1.0f) * pow(q, p));\n}\n\n#ifdef BAKERY_VERTEXLMMASK\n    float4 unpack4NFloats(float src)\n\t{\n        //return fmod(float4(src / 262144.0, src / 4096.0, src / 64.0, src), 64.0)/64.0;\n        return frac(float4(src / (262144.0*64), src / (4096.0*64), src / (64.0*64), src));\n    }\n#endif\n\n#if defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n    float3 unpack3NFloats(float src)\n\t{\n        float r = frac(src);\n        float g = frac(src * 256.0);\n        float b = frac(src * 65536.0);\n        return float3(r, g, b);\n    }\n#endif\n\n// Unity defines these under different names in each SRP, so use our own\ninline float3 Bakery_SafeNormalize(float3 inVec)\n{\n    float dp3 = max(0.001f, dot(inVec, inVec));\n    return inVec * rsqrt(dp3);\n}\n\n#if _URP || _HDRP\n\nfloat SmoothnessToPerceptualRoughness(float smoothness)\n{\n    return (1 - smoothness);\n}\n#endif\n\n#if !_STANDARD\nhalf4 unity_Lightmap_HDR;\ninline half3 DecodeLightmap( half4 color )\n{\n    return DecodeLightmap( color, unity_Lightmap_HDR );\n}\n\n#define UNITY_INV_PI        0.31830988618f\ninline float GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return UNITY_INV_PI * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n    void BakeryVertexLMDirection(inout float3 diffuseColor, inout float3 specularColor, float3 lightDirection, float3 vertexNormalWorld, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 dominantDir = Bakery_SafeNormalize(lightDirection);\n        half halfLambert = dot(normalWorld, dominantDir) * 0.5 + 0.5;\n        half flatNormalHalfLambert = dot(vertexNormalWorld, dominantDir) * 0.5 + 0.5;\n\n        #ifdef BAKERY_LMSPEC\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = spec * diffuseColor;\n        #endif\n\n        diffuseColor *= halfLambert / max(1e-4h, flatNormalHalfLambert);\n    }\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXSH\n    void BakeryVertexLMSH(inout float3 diffuseColor, inout float3 specularColor, float3 shL1x, float3 shL1y, float3 shL1z, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 L0 = diffuseColor;\n        float3 nL1x = shL1x;\n        float3 nL1y = shL1y;\n        float3 nL1z = shL1z;\n        float3 L1x = nL1x * L0 * 2;\n        float3 L1y = nL1y * L0 * 2;\n        float3 L1z = nL1z * L0 * 2;\n\n        float3 sh;\n    #if BAKERY_SHNONLINEAR\n        //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n        //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n        //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n        float lumaL0 = dot(L0, 1);\n        float lumaL1x = dot(L1x, 1);\n        float lumaL1y = dot(L1y, 1);\n        float lumaL1z = dot(L1z, 1);\n        float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n        float regularLumaSH = dot(sh, 1);\n        //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n        sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    #else\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    #endif\n\n        diffuseColor = max(sh, 0.0);\n\n        #ifdef BAKERY_LMSPEC\n            float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n            float focus = saturate(length(dominantDir));\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = max(spec * sh, 0.0);\n        #endif\n    }\n#endif\n\n\n\n#ifdef BAKERY_BICUBIC\nfloat BakeryBicubic_w0(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-a + 3.0f) - 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w1(float a)\n{\n    return (1.0f/6.0f)*(a*a*(3.0f*a - 6.0f) + 4.0f);\n}\n\nfloat BakeryBicubic_w2(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-3.0f*a + 3.0f) + 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w3(float a)\n{\n    return (1.0f/6.0f)*(a*a*a);\n}\n\nfloat BakeryBicubic_g0(float a)\n{\n    return BakeryBicubic_w0(a) + BakeryBicubic_w1(a);\n}\n\nfloat BakeryBicubic_g1(float a)\n{\n    return BakeryBicubic_w2(a) + BakeryBicubic_w3(a);\n}\n\nfloat BakeryBicubic_h0(float a)\n{\n    return -1.0f + BakeryBicubic_w1(a) / (BakeryBicubic_w0(a) + BakeryBicubic_w1(a)) + 0.5f;\n}\n\nfloat BakeryBicubic_h1(float a)\n{\n    return 1.0f + BakeryBicubic_w3(a) / (BakeryBicubic_w2(a) + BakeryBicubic_w3(a)) + 0.5f;\n}\n#endif\n\n\n#if defined(_LIGHTMAPMODE_RNM) || defined(_LIGHTMAPMODE_SH)\nTexture2D _RNM0, _RNM1, _RNM2;\n#endif\n\n#ifdef BAKERY_VOLUME\nTexture3D _Volume0, _Volume1, _Volume2, _VolumeMask;\nSamplerState sampler_Volume0;\n#endif\n\n#if defined(BAKERY_BICUBIC) && defined(LIGHTMAP_ON) && defined(SHADER_API_D3D11)\n    // Bicubic\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\tfloat width, height;\n\t\ttex.GetDimensions(width, height);\n\t\tfloat texelSize = 1.0f / width;\n\n        float x = uv.x * width;\n        float y = uv.y * width;\n\n        x -= 0.5f;\n        y -= 0.5f;\n\n        float px = floor(x);\n        float py = floor(y);\n\n        float fx = x - px;\n        float fy = y - py;\n\n        float g0x = BakeryBicubic_g0(fx);\n        float g1x = BakeryBicubic_g1(fx);\n        float h0x = BakeryBicubic_h0(fx);\n        float h1x = BakeryBicubic_h1(fx);\n        float h0y = BakeryBicubic_h0(fy);\n        float h1y = BakeryBicubic_h1(fy);\n\n        return     BakeryBicubic_g0(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h0y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h0y) * texelSize))) +\n\n                   BakeryBicubic_g1(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h1y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h1y) * texelSize)));\n    }\n#else\n    // Bilinear\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\t#ifdef LIGHTMAP_ON\n\t\t\treturn tex.Sample(samplerunity_Lightmap, uv);\n\t\t#else\n\t\t\treturn float4(1,0,0,1);\n\t\t#endif\n    }\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\n#ifdef BAKERY_LMSPEC\nfloat BakeryDirectionalLightmapSpecular(float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 dominantDir = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap, lmUV).xyz * 2 - 1;\n    half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n    half nh = saturate(dot(normalWorld, halfDir));\n    half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n    half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n    half spec = GGXTerm(nh, roughness);\n    return spec;\n}\n#endif\n#endif\n\n\n\n#ifdef _LIGHTMAPMODE_RNM\nvoid BakeryRNM(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalMap, float smoothness, float3 viewDirT)\n{\n    const float3 rnmBasis0 = float3(0.816496580927726f, 0, 0.5773502691896258f);\n    const float3 rnmBasis1 = float3(-0.4082482904638631f, 0.7071067811865475f, 0.5773502691896258f);\n    const float3 rnmBasis2 = float3(-0.4082482904638631f, -0.7071067811865475f, 0.5773502691896258f);\n\n    float3 rnm0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 rnm1 = DecodeLightmap(BakeryTex2D(_RNM1, lmUV));\n    float3 rnm2 = DecodeLightmap(BakeryTex2D(_RNM2, lmUV));\n\n    #ifdef BAKERY_SSBUMP\n        diffuseColor = normalMap.x * rnm0\n                     + normalMap.z * rnm1\n                     + normalMap.y * rnm2;\n         diffuseColor *= 2;\n    #else\n        diffuseColor = saturate(dot(rnmBasis0, normalMap)) * rnm0\n                     + saturate(dot(rnmBasis1, normalMap)) * rnm1\n                     + saturate(dot(rnmBasis2, normalMap)) * rnm2;\n    #endif\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDirT = rnmBasis0 * dot(rnm0, lumaConv) +\n                              rnmBasis1 * dot(rnm1, lumaConv) +\n                              rnmBasis2 * dot(rnm2, lumaConv);\n\n        float3 dominantDirTN = normalize(dominantDirT);\n        float3 specColor = saturate(dot(rnmBasis0, dominantDirTN)) * rnm0 +\n                           saturate(dot(rnmBasis1, dominantDirTN)) * rnm1 +\n                           saturate(dot(rnmBasis2, dominantDirTN)) * rnm2;\n\n        half3 halfDir = Bakery_SafeNormalize(dominantDirTN - viewDirT);\n        half nh = saturate(dot(normalMap, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n        specularColor = spec * specColor;\n    #endif\n}\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\ninline half3 Unity_DecodeDirectionalLightmap(half3 color, half4 dirTex, half3 normalWorld)\n{\n    // In directional (non-specular) mode Enlighten bakes dominant light direction\n    // in a way, that using it for half Lambert and then dividing by a \"rebalancing coefficient\"\n    // gives a result close to plain diffuse response lightmaps, but normalmapped.\n\n    // Note that dir is not unit length on purpose. Its length is \"directionality\", like\n    // for the directional specular lightmaps.\n\n    half halfLambert = dot(normalWorld, dirTex.xyz - 0.5) + 0.5;\n\n    return color * halfLambert / max(1e-4h, dirTex.w);\n}\n#endif\n\n#ifdef _LIGHTMAPMODE_SH\nvoid BakerySH(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 L0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 nL1x = BakeryTex2D(_RNM0, lmUV) * 2 - 1;\n    float3 nL1y = BakeryTex2D(_RNM1, lmUV) * 2 - 1;\n    float3 nL1z = BakeryTex2D(_RNM2, lmUV) * 2 - 1;\n    float3 L1x = nL1x * L0 * 2;\n    float3 L1y = nL1y * L0 * 2;\n    float3 L1z = nL1z * L0 * 2;\n\n    float3 sh;\n#if BAKERY_SHNONLINEAR\n    float lumaL0 = dot(L0, 1);\n    float lumaL1x = dot(L1x, 1);\n    float lumaL1y = dot(L1y, 1);\n    float lumaL1z = dot(L1z, 1);\n    float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    float regularLumaSH = dot(sh, 1);\n    //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n    sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n    //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n    //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n#else\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n#endif\n\n    diffuseColor = max(sh, 0.0);\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n        float focus = saturate(length(dominantDir));\n        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n        half nh = saturate(dot(normalWorld, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n\n        sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n\n        specularColor = max(spec * sh, 0.0);\n    #endif\n}\n#endif\n\n#endif // include guards\n\n\n    void Ext_ModifyVertex15 (inout VertexData v, inout ExtraV2F e)\n    {\n        #if _USEBAKERY\n\t\t    #if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\t\t\t    // Unpack from RGBM\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.a * 8.0f;\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.rgb;\n\n\t\t\t    #ifdef BAKERY_VERTEXLMMASK\n\t\t\t\t    e.extraV2F4.xyzw = unpack4NFloats(v.texcoord1);\n\t\t\t    #endif\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXSH\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n                e.extraV2F6.xyz = unpack3NFloats(v.texcoord3.x) * 2 - 1;\n                e.extraV2F7.xyz = unpack3NFloats(v.texcoord3.y) * 2 - 1;\n            #endif\n       #endif\n    }\n\n#if _HDRP || _URP\n    half3 SHEvalLinearL0L1 (half4 normal)\n    {\n        half3 x;\n\n        // Linear (L1) + constant (L0) polynomial terms\n        x.r = dot(unity_SHAr,normal);\n        x.g = dot(unity_SHAg,normal);\n        x.b = dot(unity_SHAb,normal);\n\n        return x;\n    }\n\n    // normal should be normalized, w=1.0\n    half3 SHEvalLinearL2 (half4 normal)\n    {\n        half3 x1, x2;\n        // 4 of the quadratic (L2) polynomials\n        half4 vB = normal.xyzz * normal.yzzx;\n        x1.r = dot(unity_SHBr,vB);\n        x1.g = dot(unity_SHBg,vB);\n        x1.b = dot(unity_SHBb,vB);\n\n        // Final (5th) quadratic (L2) polynomial\n        half vC = normal.x*normal.x - normal.y*normal.y;\n        x2 = unity_SHC.rgb * vC;\n\n        return x1 + x2;\n    }\n\n    half3 ShadeSH9 (half4 normal)\n    {\n        // Linear + constant polynomial terms\n        half3 res = SHEvalLinearL0L1 (normal);\n\n        // Quadratic polynomials\n        res += SHEvalLinearL2 (normal);\n\n        #ifdef UNITY_COLORSPACE_GAMMA\n            res = LinearToGamma (res);\n        #endif\n\n        return res;\n\n    }\n#endif\n\n\n\n\tvoid DoBakeryStuff(inout float3 indDif, inout float3 indSpec, inout float4 shadowmask, float3 tangentNormal, float smoothness, ShaderData d)\n\t{\n\t\t// Quality!\n\t\tindDif = 1;\n\t\tindSpec = 0;\n\n        #if defined(_PASSFORWARD) || defined(_PASSGBUFFER) // forward pass on URP/Standard/HDRP + built-in deferred\n\n            float3 normalWorld = mul(tangentNormal, d.TBNMatrix);\n\n\t\t\t#ifdef LIGHTMAP_ON\n\n                // Static\n\n\t\t\t\tfloat2 lmUV = d.texcoord1 * unity_LightmapST.xy + unity_LightmapST.zw;\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_STANDARD\n\t\t\t\t\tindDif = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n\n\t\t\t\t\t#ifdef DIRLIGHTMAP_COMBINED\n\t\t\t\t\t\tfloat4 dirMap = BakeryTex2D(unity_LightmapInd, lmUV);\n\t\t\t\t\t\tindDif = Unity_DecodeDirectionalLightmap(indDif, dirMap, normalWorld);\n\n\t\t\t\t\t\t#ifdef BAKERY_LMSPEC\n\t\t\t\t\t\t\tindSpec = BakeryDirectionalLightmapSpecular(lmUV, normalWorld, -d.worldSpaceViewDir, smoothness) * indDif;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\n\t\t\t\t\tindDif = d.vertexColor;\n\n                    #ifdef BAKERY_VERTEXLMMASK\n                        shadowmask = d.extraV2F4;\n                    #endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n\t\t\t\t\t\t// worldSpaceNormal is per-vertex\n\t\t\t\t\t\t// normalWorld is per-pixel\n\t\t\t\t\t\tfloat3 bakedLightDirection = d.extraV2F5;\n\t\t\t\t\t\tBakeryVertexLMDirection(indDif, indSpec, bakedLightDirection, d.worldSpaceNormal, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXSH\n\t\t\t\t\t\tBakeryVertexLMSH(indDif, indSpec, d.extraV2F5, d.extraV2F6, d.extraV2F7, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_RNM\n\t\t\t\t\tBakeryRNM(indDif, indSpec, lmUV, tangentNormal, smoothness, -d.tangentSpaceViewDir);\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_SH\n\t\t\t\t\tBakerySH(indDif, indSpec, lmUV, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t#endif\n\n            #else\n\n                // Dynamic\n\n                #ifdef BAKERY_VOLUME\n\n                    bool isGlobal = dot(abs(_VolumeInvSize),1) == 0;\n                    float3 volViewDir = -d.worldSpaceViewDir;\n                    #ifdef BAKERY_VOLROTATION\n                        float4x4 volMatrix = (isGlobal ? _GlobalVolumeMatrix : _VolumeMatrix);\n                        float3 volInvSize = (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 lpUV = mul(volMatrix, float4(d.worldSpacePosition,1)).xyz * volInvSize + 0.5f;\n                        float3 volNormal = mul((float3x3)volMatrix, normalWorld);\n                        #ifdef BAKERY_LMSPEC\n                            volViewDir = mul((float3x3)volMatrix, volViewDir);\n                        #endif\n                    #else\n                        float3 lpUV = (d.worldSpacePosition - (isGlobal ? _GlobalVolumeMin : _VolumeMin)) * (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 volNormal = normalWorld;\n                    #endif\n\n                    #ifdef BAKERY_COMPRESSED_VOLUME\n                        float4 tex0, tex1, tex2, tex3;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex3 = _Volume3.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz * L0;\n                        L1y = tex2.xyz * L0;\n                        L1z = tex3.xyz * L0;\n                    #else\n                        float4 tex0, tex1, tex2;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV);\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV);\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz;\n                        L1y = tex2.xyz;\n                        L1z = float3(tex0.w, tex1.w, tex2.w);\n                    #endif\n                    indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), volNormal);\n                    indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), volNormal);\n                    indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), volNormal);\n\n                    #ifdef UNITY_COLORSPACE_GAMMA\n                        indDif = pow(indDif, 1.0f / 2.2f);\n                    #endif\n\n                    #ifdef BAKERY_LMSPEC\n                        float3 nL1x = L1x / L0;\n                        float3 nL1y = L1y / L0;\n                        float3 nL1z = L1z / L0;\n                        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n                        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - volViewDir);\n                        half nh = saturate(dot(volNormal, halfDir));\n                        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n                        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n                        half spec = GGXTerm(nh, roughness);\n                        float3 sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n                        indSpec = max(spec * sh, 0.0);\n                    #endif\n\n                    shadowmask = _VolumeMask.Sample(sampler_Volume0, lpUV);\n\n                #else\n\n                    #ifdef BAKERY_SHNONLINEAR\n                        float3 L0 = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);\n                        indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, unity_SHAr.xyz, normalWorld);\n                        indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, unity_SHAg.xyz, normalWorld);\n                        indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, unity_SHAb.xyz, normalWorld);\n                    #else\n                        indDif = ShadeSH9(float4(normalWorld,1));\n                    #endif\n\n                #endif\n\n\t\t\t#endif\n\n        #endif\n\t}\n\n\t// this is the main surface function. Surface is like a surface shader output structure, but\n\t// with our new outputs as well.\n\tvoid Ext_SurfaceFunction15 (inout Surface o, ShaderData d)\n\t{\n        #if _USEBAKERY\n\t\t    float3 indDif;\n\t\t    float3 indSpec;\n            float4 shadowmask = 1;\n\t\t    DoBakeryStuff(indDif, indSpec, shadowmask, o.Normal, o.Smoothness, d);\n\t\t    o.DiffuseGI = indDif;\n\t\t    o.BackDiffuseGI = indDif;\n\t\t    o.SpecularGI = indSpec;\n            o.ShadowMask = shadowmask;\n        #endif\n\t}\n\n\n\n\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                  Ext_SurfaceFunction1(l, d);\n                  Ext_SurfaceFunction2(l, d);\n                  Ext_SurfaceFunction3(l, d);\n                  Ext_SurfaceFunction4(l, d);\n                  Ext_SurfaceFunction5(l, d);\n                  Ext_SurfaceFunction6(l, d);\n                  Ext_SurfaceFunction7(l, d);\n                  Ext_SurfaceFunction8(l, d);\n                  Ext_SurfaceFunction9(l, d);\n\t\t            Ext_SurfaceFunction10(l, d);\n                  Ext_SurfaceFunction11(l, d);\n                  Ext_SurfaceFunction12(l, d);\n                  Ext_SurfaceFunction13(l, d);\n                  Ext_SurfaceFunction14(l, d);\n                  Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraV2F d;\n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                  Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                  Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                  #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                  v2p.extraV2F4 = d.extraV2F4;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                  v2p.extraV2F5 = d.extraV2F5;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F6 = d.extraV2F6;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F7 = d.extraV2F7;\n                  #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                d.extraV2F4 = v2p.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                d.extraV2F5 = v2p.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F6 = v2p.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F7 = v2p.extraV2F7;\n                #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n                Ext_ModifyTessellatedVertex2(v, d);\n                Ext_ModifyTessellatedVertex3(v, d);\n                Ext_ModifyTessellatedVertex4(v, d);\n                Ext_ModifyTessellatedVertex5(v, d);\n                Ext_ModifyTessellatedVertex6(v, d);\n                Ext_ModifyTessellatedVertex7(v, d);\n                Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                v2p.extraV2F4 = d.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                v2p.extraV2F5 = d.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F6 = d.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F7 = d.extraV2F7;\n                #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n            // d.texcoord3 = i.texcoord3;\n             #endif\n\n             d.isFrontFace = facing;\n             #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n             d.vertexColor = i.vertexColor;\n             #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(i.worldPos, 1)).xyz;\n            #endif\n             d.localSpaceNormal = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n             #if LOD_FADE_CROSSFADE\n             d.screenPos = i.screenPos;\n             d.screenUV = (i.screenPos.xy / i.screenPos.w);\n             #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n             #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n             d.extraV2F4 = i.extraV2F4;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n             d.extraV2F5 = i.extraV2F5;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F6 = i.extraV2F6;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F7 = i.extraV2F7;\n             #endif\n\n            return d;\n         }\n         \n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n   #ifdef VARYINGS_NEED_POSITION_WS\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex);\n   #endif\n\n   #ifdef VARYINGS_NEED_TANGENT_TO_WORLD\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n   #endif\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n        #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n       // output.texcoord3 = inputMesh.texcoord3;\n        #endif\n        #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n        output.vertexColor = inputMesh.vertexColor;\n        #endif\n\n       return output;\n   }\n#else\n\n   #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n    \n       ChainModifyVertex(input, output);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n        #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n       // output.texcoord3 = input.texcoord3;\n        #endif\n\n        #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n        output.vertexColor = input.vertexColor;\n        #endif\n\n        #if LOD_FADE_CROSSFADE\n        output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n        #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(output.worldPos.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? input.previousPositionOS : input.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n\n            VertexData previousMesh = input;\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            // Remap time to old time\n            float4 oldTime = _Time;\n            _Time.y = _LastTimeParameters.x;\n            _Time.x = _LastTimeParameters.x / 20;\n            _Time.z = _LastTimeParameters.x * 2;\n            _Time.w = _LastTimeParameters.x * 3;\n            ChainModifyVertex(previousMesh, dummy);\n            _Time = oldTime;\n\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = output.worldPos.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n            \n                    output.positionRWS = input.worldPos;\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n            \n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n                    #if defined(_ENABLE_SHADOW_MATTE) && SHADERPASS == SHADERPASS_FORWARD_UNLIT\n                        HDShadowContext shadowContext = InitShadowContext();\n                        float shadow;\n                        float3 shadow3;\n                        // We need to recompute some coordinate not computed by default for shadow matte\n                        posInput = GetPositionInput(fragInputs.positionSS.xy, _ScreenSize.zw, fragInputs.positionSS.z, UNITY_MATRIX_I_VP, GetWorldToViewMatrix());\n                        float3 upWS = normalize(fragInputs.tangentToWorld[1]);\n                        uint renderingLayers = GetMeshRenderingLightLayer();\n                        ShadowLoopMin(shadowContext, posInput, upWS, asuint(_ShadowMatteFilter), renderingLayers, shadow3);\n                        shadow = dot(shadow3, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));\n                \n                        float4 shadowColor = (1.0 - shadow) * surfaceDescription.ShadowTint.rgba;\n                        float  localAlpha  = saturate(shadowColor.a + surfaceDescription.Alpha);\n                \n                        // Keep the nested lerp\n                        // With no Color (bsdfData.color.rgb, bsdfData.color.a == 0.0f), just use ShadowColor*Color to avoid a ring of \"white\" around the shadow\n                        // And mix color to consider the Color & ShadowColor alpha (from texture or/and color picker)\n                        #ifdef _SURFACE_TYPE_TRANSPARENT\n                            surfaceData.baseColor = lerp(shadowColor.rgb * surfaceData.baseColor, lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow), surfaceDescription.Alpha);\n                        #else\n                            surfaceData.baseColor = lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow);\n                        #endif\n                        localAlpha = ApplyBlendMode(surfaceData.baseColor, localAlpha).a;\n                \n                        surfaceDescription.Alpha = localAlpha;\n                    #endif\n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n                \n\n                   // tangent-space normal\n                   float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                   normalTS = surfaceDescription.Normal;\n        \n                   // compute world space normal\n                   #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(normalTS, fragInputs.tangentToWorld);\n                   #else\n                      surfaceData.normalWS = normalTS;\n                   #endif\n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                    #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                \n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2], alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                    #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 //builtinData.vtPackedFeedback = surfaceDescription.VTPackedFeedback;\n        \n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     //builtinData.distortion = surfaceData.Distortion;\n                     //builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n\n\n            void Frag( VertexToPixel v2f\n                          #if defined(SCENESELECTIONPASS) || defined(SCENEPICKINGPASS)\n                          , out float4 outColor : SV_Target0\n                          #else\n                          #ifdef WRITE_MSAA_DEPTH\n                            // We need the depth color as SV_Target0 for alpha to coverage\n                            , out float4 depthColor : SV_Target0\n                                #ifdef WRITE_NORMAL_BUFFER\n                                , out float4 outNormalBuffer : SV_Target1\n                                #endif\n                            #else\n                                #ifdef WRITE_NORMAL_BUFFER\n                                , out float4 outNormalBuffer : SV_Target0\n                                #endif\n                            #endif\n\n                            // Decal buffer must be last as it is bind but we can optionally write into it (based on _DISABLE_DECALS)\n                            #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                            , out float4 outDecalBuffer : SV_TARGET_DECAL\n                            #endif\n                        #endif\n                        #if NEED_FACING\n                           , bool facing : SV_IsFrontFace\n                        #endif\n\n                      )\n              {\n                  UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2f);\n                  FragInputs input = BuildFragInputs(v2f);\n\n                  // input.positionSS is SV_Position\n                  PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n                  #ifdef VARYINGS_NEED_POSITION_WS\n                     float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n                  #else\n                     // Unused\n                     float3 V = float3(1.0, 1.0, 1.0); // Avoid the division by 0\n                  #endif\n\n                  SurfaceData surfaceData;\n                  BuiltinData builtinData;\n                  Surface l;\n                  ShaderData d;\n                  GetSurfaceAndBuiltinData(v2f, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n\n\n                  \n                  #ifdef SCENESELECTIONPASS\n                      // We use depth prepass for scene selection in the editor, this code allow to output the outline correctly\n                      outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);\n                  #elif defined(SCENEPICKINGPASS)\n                      outColor = _SelectionID;\n                  #else\n                     #ifdef WRITE_MSAA_DEPTH\n                       // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer\n                       depthColor = v2p.pos.z;\n\n                       #ifdef _ALPHATOMASK_ON\n                          // Alpha channel is used for alpha to coverage\n                          depthColor.a = SharpenAlpha(builtinData.opacity, builtinData.alphaClipTreshold);\n                       #endif // alphatomask\n                     #endif // msaa_depth\n                  \n\n                     #if defined(WRITE_NORMAL_BUFFER)\n                        EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), outNormalBuffer);\n                     #endif\n\n                     #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                        DecalPrepassData decalPrepassData;\n                        // We don't have the right to access SurfaceData in a shaderpass.\n                        // However it would be painful to have to add a function like ConvertSurfaceDataToDecalPrepassData() to every Material to return geomNormalWS anyway\n                        // Here we will put the constrain that any Material requiring to support Decal, will need to have geomNormalWS as member of surfaceData (and we already require normalWS anyway)\n                        decalPrepassData.geomNormalWS = surfaceData.geomNormalWS;\n                        decalPrepassData.decalLayerMask = GetMeshRenderingDecalLayer();\n                        EncodeIntoDecalPrepassBuffer(decalPrepassData, outDecalBuffer);\n                     #endif\n                  #endif\n\n\n              }\n\n         ENDHLSL\n        }\n\n      \n      \n              Pass\n        {\n            Name \"FullScreenDebug\"\n            Tags\n            {\n               \"LightMode\" = \"FullScreenDebug\"\n            }\n    \n            // Render State\n            Cull Back\n            ZTest LEqual\n            ZWrite Off\n            \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone vulkan metal switch\n\n\n\n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n                \n        \n\n            #define SHADERPASS SHADERPASS_FULL_SCREEN_DEBUG\n            #define _PASSFULLSCREENDEBUG 1\n            \n            \n\n\n   #pragma shader_feature_local_fragment _ _PACKEDFAST\n   #pragma shader_feature_local _ _TRIPLANAR\n   #pragma shader_feature_local_fragment _ _NORMALMAP \n   #pragma shader_feature_local_fragment _ _MASKMAP\n   #pragma shader_feature_local_fragment _ _DETAIL\n   #pragma shader_feature_local_fragment _ _DETAILTRIPLANAR\n   #pragma shader_feature_local_fragment _ _DETAILSTOCHASTIC\n   #pragma shader_feature_local_fragment _ _EMISSION\n   #pragma shader_feature_local_fragment _ _FLATSHADE\n   #pragma shader_feature_local _ _STOCHASTIC\n   #pragma shader_feature_local_fragment _ _PARALLAX //_POM\n   #pragma shader_feature_local_fragment _ _SPECULAR\n   #pragma shader_feature_local _ _NOISEWORLD _NOISELOCAL\n   #pragma shader_feature_local _ _NOISEHQ _NOISETEXTURE _NOISEWORLEY\n   // only for URP/Standard Forward\n   #pragma shader_feature_local_fragment _ _SIMPLELIT\n\n\n   #pragma shader_feature_local_fragment _ _TINTMASK\n\n\n    #pragma shader_feature_local _ _LAYERVERTEXMASK _LAYERTEXTUREMASK\n\n    #define _HAS_WEIGHTTEXTURE_MASK 1\n\n\n   #pragma shader_feature_local _ _USELAYER\n   #pragma shader_feature_local _ _LAYERTRIPLANAR\n   #pragma shader_feature_local _ _LAYERALBEDO\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL\n   #pragma shader_feature_local _ _LAYERMASK\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION\n   #pragma shader_feature_local _ _LAYERNOISE\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC\n   #pragma shader_feature_local _ _LAYERANGLEFILTER\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_1\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_1\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_1\n   #pragma shader_feature_local _ _LAYERMASK_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_1\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_1\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_1\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_1\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_2\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_2\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_2\n   #pragma shader_feature_local _ _LAYERMASK_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_2\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_2\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_2\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_2\n\n\n   #pragma shader_feature_local _ _TRAX_ON\n\n\n   #pragma shader_feature_local_fragment _ _WETNESS\n   #pragma shader_feature_local_fragment _ _PUDDLES\n   #pragma shader_feature_local_fragment _ _PUDDLENOISE\n   #pragma shader_feature_local_fragment _ _RAINDROPS\n\n\n   #pragma shader_feature_local _ _SNOW\n   #pragma shader_feature_local _ _SNOWMASKMAP\n   #pragma shader_feature_local _ _SNOWNOISE\n   #pragma shader_feature_local_fragment _SNOWSTOCHASTIC\n\n\n   #pragma shader_feature_local_fragment _ _WIND_ON\n\n\n\n\n   #pragma shader_feature_local_fragment _ _SURFACEGRADIENT _AUTONORMAL\n   #define _WORLDSPACENORMAL 1\n\n\n   #pragma shader_feature_local _ _DEBUG_SAMPLECOUNT\n\n\n\t#pragma shader_feature_local_fragment _ _DISSOLVE\n\n\n   #pragma multi_compile_local  LOD_FADE_CROSSFADE\n\n\n\n#pragma instancing_options procedural:setupVSPro forwardadd\n\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\nstruct IndirectShaderData\n{\n\tfloat4x4 PositionMatrix;\n\tfloat4x4 InversePositionMatrix;\n\tfloat4 ControlData;\n};\n\n#if defined(SHADER_API_GLCORE) || defined(SHADER_API_D3D11) || defined(SHADER_API_GLES3) || defined(SHADER_API_METAL) || defined(SHADER_API_VULKAN) || defined(SHADER_API_PSSL) || defined(SHADER_API_XBOXONE)\n\tuniform StructuredBuffer<IndirectShaderData> VisibleShaderDataBuffer;\n#endif\n\n#endif\n\nfloat VSPRenderingLayerMask;\n\nvoid setupVSPro()\n{\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\n    #if _HDRP\n\t    unity_RenderingLayer.x = VSPRenderingLayerMask;\n    #endif\n\n\t#ifdef unity_ObjectToWorld\n\t#undef unity_ObjectToWorld\n\t#endif\n\n\t#ifdef unity_WorldToObject\n\t#undef unity_WorldToObject\n\t#endif\n\n\tunity_ObjectToWorld = VisibleShaderDataBuffer[unity_InstanceID].PositionMatrix;\n\tunity_WorldToObject = VisibleShaderDataBuffer[unity_InstanceID].InversePositionMatrix;\n#endif\n\n}\n\n\n\t#pragma multi_compile _LIGHTMAPMODE_STANDARD _LIGHTMAPMODE_RNM _LIGHTMAPMODE_SH _LIGHTMAPMODE_VERTEX _LIGHTMAPMODE_VERTEXDIRECTIONAL _LIGHTMAPMODE_VERTEXSH\n\n    #pragma shader_feature USEBAKERY\n    #pragma shader_feature BAKERY_VERTEXLMMASK\n    #pragma shader_feature BAKERY_SHNONLINEAR\n    #pragma shader_feature BAKERY_LMSPEC\n    #pragma shader_feature BAKERY_BICUBIC\n    #pragma shader_feature BAKERY_VOLUME\n    #pragma shader_feature BAKERY_VOLROTATION\n    #pragma shader_feature BAKERY_COMPRESSED_VOLUME\n\n    #if _USEBAKERY\n\t    #define _OVERRIDE_BAKEDGI\n        #if BAKERY_VOLUME || (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)) && defined(BAKERY_VERTEXLMMASK)\n            #define _OVERRIDE_SHADOWMASK\n        #endif\n    #endif\n\n\n\n\n\n\n\n\n   #define _HDRP 1\n#define _BLENDMODE_ALPHA 1\n#define _SURFACE_TYPE_TRANSPARENT 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\" // Need to be here for Gradient struct definition\n         \n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n\n\n   half4 _Tint;\n   half _UVSource;\n   half _TriplanarContrast;\n   half _AlbedoContrast;\n   half _AlbedoBrightness;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half3 _EmissionColor;\n   float _DetailUVSource;\n   half _StochasticScale;\n   half _DetailStochasticScale;\n   half _Smoothness;\n   half _Metallic;\n   half2 _SmoothnessRemap;\n   half2 _AORemap;\n   half2 _MetallicRemap;\n   half2 _HeightRemap;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n   half _AlphaThreshold;\n   half _Cutoff; // for Unity's light mapper\n   half _TriplanarSpace;\n   half _DetailTriplanarSpace;\n   half _DetailTriplanarContrast;\n   half _MicroShadowStrength;\n   half3 _FuzzyShadingColor;\n   half _FuzzyShadingOn;\n   half3 _FuzzyShadingParams;\n\n   //int _POMMaxSamples;\n   //float _POMMin;\n   //float _POMFade;\n#if _FLATSHADE\n   half _FlatShadingBlend;\n#endif\n\n   half _StochasticContrast;\n   half _DetailStochasticContrast;\n\n#if _PARALLAX || _POM\n   half _ParallaxHeight;\n#endif\n\n\n\n\tfloat4 _TintMask_ST;\n\thalf3 _RColor;\n\thalf3 _GColor;\n\thalf3 _BColor;\n\thalf3 _AColor;\n\n\n\thalf _LayerTextureMaskUVMode;\n    float4 _LayerTextureMask_ST;\n\n\n   //#if _USELAYER\n       float4 _LayerAlbedoMap_ST;\n       half3 _LayerTint;\n       half _LayerBlendMode;\n       float _LayerUVSource;\n       half _LayerAlbedoBrightness;\n       half _LayerAlbedoContrast;\n       half _LayerHeightContrast;\n       half _LayerStrength;\n       half _LayerAlbedoStrength;\n       half _LayerNormalStrength;\n       half _LayerSmoothnessStrength;\n       half _LayerSmoothness;\n       half _LayerMetallic;\n       half _LayerStochasticScale;\n       half2 _LayerSmoothnessRemap;\n       half2 _LayerAORemap;\n       half2 _LayerMetallicRemap;\n       half2 _LayerHeightRemap;\n       float4 _LayerWeightOverDistance;\n       half _LayerMicroShadowStrength;\n       //#if _LAYERNOISE\n           float _LayerNoiseFrequency;\n           float _LayerNoiseAmplitude;\n           float _LayerNoiseOffset;\n           float _LayerNoiseCenter;\n           half3 _LayerBlendTint;\n       //#endif\n       //#if _LAYERANGLEFILTER\n           half _LayerFalloff;\n           half _LayerAngleMin;\n           half _LayerHeight;\n           half _LayerInvertHeight;\n           half _LayerVertexNormalBlend;\n       //#endif\n       half _LayerTriplanarSpace;\n       half _LayerTriplanarContrast;\n       half _LayerBlendContrast;\n       half3 _LayerEmissionColor;\n       half _LayerStochasticContrast;\n       half _LayerTessStrength;\n       half3 _LayerFuzzyShadingColor;\n       half _LayerFuzzyShadingOn;\n       half3 _LayerFuzzyShadingParams;\n   //#endif\n\n\n   //#if _USELAYER_DEF_1\n       float4 _LayerAlbedoMap_Ext_1_ST;\n       half3 _LayerTint_Ext_1;\n       half _LayerBlendMode_Ext_1;\n       float _LayerUVSource_Ext_1;\n       half _LayerAlbedoBrightness_Ext_1;\n       half _LayerAlbedoContrast_Ext_1;\n       half _LayerHeightContrast_Ext_1;\n       half _LayerStrength_Ext_1;\n       half _LayerAlbedoStrength_Ext_1;\n       half _LayerNormalStrength_Ext_1;\n       half _LayerSmoothnessStrength_Ext_1;\n       half _LayerSmoothness_Ext_1;\n       half _LayerMetallic_Ext_1;\n       half _LayerStochasticScale_Ext_1;\n       half2 _LayerSmoothnessRemap_Ext_1;\n       half2 _LayerAORemap_Ext_1;\n       half2 _LayerMetallicRemap_Ext_1;\n       half2 _LayerHeightRemap_Ext_1;\n       float4 _LayerWeightOverDistance_Ext_1;\n       half _LayerMicroShadowStrength_Ext_1;\n       //#if _LAYERNOISE_DEF_1\n           float _LayerNoiseFrequency_Ext_1;\n           float _LayerNoiseAmplitude_Ext_1;\n           float _LayerNoiseOffset_Ext_1;\n           float _LayerNoiseCenter_Ext_1;\n           half3 _LayerBlendTint_Ext_1;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_1\n           half _LayerFalloff_Ext_1;\n           half _LayerAngleMin_Ext_1;\n           half _LayerHeight_Ext_1;\n           half _LayerInvertHeight_Ext_1;\n           half _LayerVertexNormalBlend_Ext_1;\n       //#endif\n       half _LayerTriplanarSpace_Ext_1;\n       half _LayerTriplanarContrast_Ext_1;\n       half _LayerBlendContrast_Ext_1;\n       half3 _LayerEmissionColor_Ext_1;\n       half _LayerStochasticContrast_Ext_1;\n       half _LayerTessStrength_Ext_1;\n       half3 _LayerFuzzyShadingColor_Ext_1;\n       half _LayerFuzzyShadingOn_Ext_1;\n       half3 _LayerFuzzyShadingParams_Ext_1;\n   //#endif\n\n\n   //#if _USELAYER_DEF_2\n       float4 _LayerAlbedoMap_Ext_2_ST;\n       half3 _LayerTint_Ext_2;\n       half _LayerBlendMode_Ext_2;\n       float _LayerUVSource_Ext_2;\n       half _LayerAlbedoBrightness_Ext_2;\n       half _LayerAlbedoContrast_Ext_2;\n       half _LayerHeightContrast_Ext_2;\n       half _LayerStrength_Ext_2;\n       half _LayerAlbedoStrength_Ext_2;\n       half _LayerNormalStrength_Ext_2;\n       half _LayerSmoothnessStrength_Ext_2;\n       half _LayerSmoothness_Ext_2;\n       half _LayerMetallic_Ext_2;\n       half _LayerStochasticScale_Ext_2;\n       half2 _LayerSmoothnessRemap_Ext_2;\n       half2 _LayerAORemap_Ext_2;\n       half2 _LayerMetallicRemap_Ext_2;\n       half2 _LayerHeightRemap_Ext_2;\n       float4 _LayerWeightOverDistance_Ext_2;\n       half _LayerMicroShadowStrength_Ext_2;\n       //#if _LAYERNOISE_DEF_2\n           float _LayerNoiseFrequency_Ext_2;\n           float _LayerNoiseAmplitude_Ext_2;\n           float _LayerNoiseOffset_Ext_2;\n           float _LayerNoiseCenter_Ext_2;\n           half3 _LayerBlendTint_Ext_2;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_2\n           half _LayerFalloff_Ext_2;\n           half _LayerAngleMin_Ext_2;\n           half _LayerHeight_Ext_2;\n           half _LayerInvertHeight_Ext_2;\n           half _LayerVertexNormalBlend_Ext_2;\n       //#endif\n       half _LayerTriplanarSpace_Ext_2;\n       half _LayerTriplanarContrast_Ext_2;\n       half _LayerBlendContrast_Ext_2;\n       half3 _LayerEmissionColor_Ext_2;\n       half _LayerStochasticContrast_Ext_2;\n       half _LayerTessStrength_Ext_2;\n       half3 _LayerFuzzyShadingColor_Ext_2;\n       half _LayerFuzzyShadingOn_Ext_2;\n       half3 _LayerFuzzyShadingParams_Ext_2;\n   //#endif\n\n\n    half _TraxDisplacementDepth;\n    half _TraxDisplacementStrength;\n    half _TraxMipBias;\n    half _TraxNormalStrength;\n    float4 _TraxAlbedo_ST;\n    half _TraxInterpContrast;\n    half _TraxHeightContrast;\n    half3 _TraxTint;\n\n\n\n    half _Porosity;\n    int _WetnessMode;\n    int _PuddleMode;\n\n    half  _PuddleAmount;\n    half  _PuddleFalloff;\n    half4 _PuddleColor;\n    half _PuddleNoiseFrequency;\n    half _PuddleNoiseAmplitude;\n    half _PuddleNoiseOffset;\n    half _PuddleNoiseCenter;\n    half _PuddleAngleMin;\n\n    half _WetnessAmount;\n\thalf _WetnessMin;\n    half _WetnessMax;\n    half _WetnessFalloff;\n\thalf _WetnessAngleMin;\n    float _WetnessShoreline;\n\n    int _RainMode;\n    half3 _RainIntensityScale;\n\n\n\n\n    float4 _SnowAlbedo_ST;\n    half3 _SnowTint;\n    half _SnowAmount;\n    half _SnowAngle;\n    half _SnowContrast;\n    half _SnowVertexHeight;\n    half _SnowMode;\n    half3 _SnowWorldFade; // z is on/off\n    float4 _SnowTraxAlbedo_ST;\n    half3 _SnowTraxTint;\n\n    half _SnowNoiseFreq; \n    half _SnowNoiseAmp;\n    half _SnowNoiseOffset;\n    half _SnowStochasticContrast;\n    half _SnowStochasticScale;\n\n\n    half     _WindParticulateSpace;\n    half     _WindParticulateRotation;\n    half      _WindParticulateSpeed;\n    float4     _WindParticulate_ST;\n    half      _WindParticulatePower;\n    half4    _WindParticulateColor;\n    half4    _WindParticulateWorldHeightMask;\n    half4    _WindParticulateAngleMask;\n    half      _WindParticulateOcclusionStrength;\n    half      _WindParticulateStrength;\n    half4    _WindParticulateEmissive;\n    half     _WindParticulateTextureHeight;\n\n\n   float _DoubleSidedNormalMode;\n\n\n\thalf _AutoNormalStrength;\n\n\n\tint _DebugSampleCountThreshold;\n\n\n\thalf _DissolveAmount;\n\thalf _DissolveEmissiveStr;\n\thalf _DissolveEdgeContrast;\n\thalf _DissolveColoration;\n\tfloat4 _DissolveTexture_ST;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCCOORD3;\n               float4 texcoord1 : TEXCCOORD4;\n               float4 texcoord2 : TEXCCOORD5;\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n               // float4 texcoord3 : TEXCCOORD6;\n                #endif\n\n                #if LOD_FADE_CROSSFADE\n                float4 screenPos : TEXCOORD7;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR_centroid;\n                #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                float4 extraV2F4 : TEXCOORD12_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                float4 extraV2F5 : TEXCOORD13_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F6 : TEXCOORD14_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F7 : TEXCOORD15_centroid;\n                #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n    \n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n   half4 weightTextureMask;\n   \n\n\n   float traxBuffer;\n\n\n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // would love to strip these, but they are used in certain\n               // combinations of the lighting system, and may be used\n               // by the user as well, so no easy way to strip them.\n\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR_centroid;\n                #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                float4 extraV2F4 : TEXCOORD9_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                float4 extraV2F5 : TEXCOORD10_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F6 : TEXCOORD11_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F7 : TEXCOORD12_centroid;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n               #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n               #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n               #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n               #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()     unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n               #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V   unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n               #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V    mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n               #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n               #endif\n               #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\n#ifndef __STACKABLEFUNCLIBRARY_INCLUDES__\n#define __STACKABLEFUNCLIBRARY_INCLUDES__\n\n   #if _DEBUG_SAMPLECOUNT\n      int _sampleCount;\n      #define COUNTSAMPLE { _sampleCount++; }\n   #else\n      #define COUNTSAMPLE\n   #endif\n\n   TEXTURE2D(_NoiseTex);\n   SAMPLER(sampler_NoiseTex);\n\n\n\n   half3 AdjustContrast(half3 color, half contrast)\n   {\n       half3 comp = 0.5;\n   #if !UNITY_COLORSPACE_GAMMA\n       comp = 0.22;\n   #endif\n       color = saturate(lerp(comp, color, contrast));\n       return color;\n   }\n\n   float2 DoParallaxOffset( half h, half height, half3 viewDir)\n   {\n      h = h * height - height/2.0;\n      float3 v = normalize(viewDir);\n      v.z += 0.42;\n      return h * (v.xy / v.z);\n   }\n\n\n\n   #define SAMPLEBARY SampleTexBary\n\n   struct SampleConfig\n   {\n      float2 uv0;\n      float2 uv1;\n      float2 uv2;\n      float2 dx0;\n      float2 dy0;\n      float2 dx1;\n      float2 dy1;\n      float2 dx2;\n      float2 dy2;\n      float3 weights;\n      float3 origWeights;\n   };\n\n   struct Config\n   {\n      float2 origUV; // unscaled uv\n      float2 origScale;\n      float2 uv;        // no stocastic or triplanar\n      float2 dx;\n      float2 dy;\n      SampleConfig uvT; // just stochastic, or just triplanar\n      SampleConfig uvX; // stochastic and triplanar\n      SampleConfig uvY;\n      SampleConfig uvZ;\n\n      \n      float3 absVertNormal;\n      half3 axisSign;\n      float3 normal;\n   };\n\n\n    float2 Hash2D( float2 x )\n    {\n        float2 k = float2( 0.3183099, 0.3678794 );\n        x = x*k + k.yx;\n        return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );\n    }\n\n    float Noise2D(float2 p )\n    {\n        float2 i = floor( p );\n        float2 f = frac( p );\n         \n        float2 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), \n                        dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),\n                    lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), \n                        dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);\n    }\n      \n\n    float2 WorleyHash2D(float2 p)\n    {\n \t    return frac(cos(mul(p, float2x2(-64.2,71.3,81.4,-29.8)))*8321.3); \n    }\n    float WorleyNoise2D(float2 p)\n    {\n        float dist = 1;\n        float2 i = floor(p);\n        float2 f = frac(p);\n    \n        for(int x = -1;x<=1;x++)\n        {\n            for(int y = -1;y<=1;y++)\n            {\n                float d = distance(WorleyHash2D(i+float2(x,y))+float2(x,y),f);\n                dist = min(dist,d);\n            }\n        }\n        return dist;\n\t\n    }\n\n#ifndef PI\n    #define PI 3.14159265359\n#endif\n\n    float GetIntegerNoise(float2 p)\n    {\n        p  = 53.7 * frac( (p*0.3183099) + float2(0.71,0.113));\n        return frac( p.x*p.y*(p.x+p.y) );\n    }\n\n    float WorleyHash3D(float f)\n    {\n        return frac(sin(f)*43758.5453);\n    }\n\n    float WorleyHash31(float3 v)\n    {\n        return WorleyHash3D(dot(v, float3(253.14, 453.74, 183.3)));\n    }\n\n    float3 WorleyRandom3D( float3 p )\n    {\n        return frac(sin(float3(dot(p,float3(127.1,311.7,217.3)),dot(p,float3(269.5,183.3,431.1)), dot(p,float3(365.6,749.9,323.7))))*437158.5453);\n    }\n\n    float WorleyNoise3D(float3 uvw)\n    {\n        float noise = 0.0;\n    \n        float3 p = floor(uvw);\n        float3 f = frac(uvw);\n    \n        float4 res = 1;\n        for(int x = -1; x <=1; ++x)\n        {\n            for(int y = -1; y <=1; ++y)\n            {\n                for(int z = -1; z <=1; ++z)\n                {\n                    float3 gp = p + float3(x, y, z);\n\n                    float3 v = WorleyRandom3D(gp);\n\n\t\t\t\t    float3 diff = gp + v - uvw;\n                \n                    float d = length(diff);\n                \n                    if(d < res.x)\n                    {\n                        res.xyz = float3(d, res.x, res.y);\n                    }\n                    else if(d < res.y)\n                    {\n                        res.xyz = float3(res.x, d, res.y);\n                    }\n                    else if(d < res.z)\n                    {\n                        res.z = d;\n                    }\n                \n                    res.w = WorleyHash31(gp);\n                }\n            }\n        }\n\n        return res.x;\n    }\n    \n      \n    float3 Hash3D( float3 p )\n    {\n        p = float3( dot(p,float3(127.1,311.7, 74.7)),\n                dot(p,float3(269.5,183.3,246.1)),\n                dot(p,float3(113.5,271.9,124.6)));\n\n        return -1.0 + 2.0*frac(sin(p)*437.5453123);\n    }\n\n    float Noise3D( float3 p )\n    {\n        float3 i = floor( p );\n        float3 f = frac( p );\n         \n        float3 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),\n                    lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n    }\n\n    \n    float FBM2D(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           return SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n\n    }\n      \n    float FBM3D(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           half A = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.zy).g;\n           half B = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33).g;\n           half C = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoise(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3D(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3D(d.localSpacePosition * frequency+ offset, d.localSpaceNormal);\n        #else\n           return FBM2D(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n    \n    #if _SURFACEGRADIENT  \n\n    #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)\n\n      \n      \n    half3 SurfaceGradientFromTBN(ShaderData d, half2 deriv)\n    {\n        return deriv.x * d.TBNMatrix[0] + deriv.y * d.TBNMatrix[1];\n    }\n\n    half2 TspaceNormalToDerivative(half3 vM)\n    {\n        const half scale = 1.0/128.0;\n        const half3 vMa = abs(vM);\n        const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));\n\n        return -half2(vM.x, vM.y)/z_ma;\n    }\n\n    half3 SurfgradFromVolumeGradient(ShaderData d, half3 grad)\n    {\n        return grad - dot(d.worldSpaceNormal, grad) * d.worldSpaceNormal;\n    }\n\n    half3 SurfgradFromTriplanarProjection(ShaderData d, half3 pN, half3 xN, half3 yN, half3 zN)\n    {\n        const half w0 = pN.x;\n        const half w1 = pN.y;\n        const half w2 = pN.z;\n\n        half2 xD = TspaceNormalToDerivative(xN);\n        half2 yD = TspaceNormalToDerivative(yN);\n        half2 zD = TspaceNormalToDerivative(zN);\n\n        half3 volumeGrad = half3(w2 * zD.x + w1 * yD.y, w2 * zD.y + w0 * xD.y, w0 * xD.x + w1 * yD.x);\n\n        return SurfgradFromVolumeGradient(d, volumeGrad);\n    }\n\n    half3 ConvertNormalToGradient(ShaderData d, half3 normal)\n    {\n        half2 deriv = TspaceNormalToDerivative(normal);\n\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n    half3 ConvertNormal2ToGradient(ShaderData d, half2 packedNormal)\n    {\n        half2 tNormal = packedNormal;\n        half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF\n        half2 deriv = tNormal * -rcpZ;\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n\n    half3 ResolveNormalFromSurfaceGradient(ShaderData d, half3 gradient)\n    {\n        return normalize(d.worldSpaceNormal - gradient);\n    }\n\n    #endif // _SURFACEGRADIENT\n\n\n    // normals are in surface gradient or world space depending on settings, and can also be generated by height\n    half3 GetWorldSpaceNormal(ShaderData d, half3 normal, half pheight)\n    {\n       #if _SURFACEGRADIENT\n          return ResolveNormalFromSurfaceGradient(d, normal);\n       #elif _AUTONORMAL\n          float3 dx = ddx(d.worldSpacePosition);\n          float3 dy = ddy(d.worldSpacePosition);\n          float3 crossX = cross(float3(0,1,0), dx);\n          float3 crossY = cross(float3(0,1,0), dy);\n          float3 dt = abs(dot(crossY, dx));\n          float height = _AutoNormalStrength * 0.5 * pheight;\n          float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n          n.y *= -1.0;\n          return TangentToWorldSpace(d, normalize((dt * float3(0,1,0)) - n).xzy);\n       #else\n          return TangentToWorldSpace(d, normal);\n          \n       #endif\n       \n    }\n\n   void WaterBRDF (inout half3 albedo, inout half smoothness, half metallic, half wetFactor, half surfPorosity) \n   {\n      half porosity = saturate((( (1 - smoothness) - 0.5)) / max(surfPorosity, 0.001));\n      half factor = lerp(1, 0.2, (1 - metallic) * porosity);\n      albedo *= lerp(1.0, factor, wetFactor);\n      smoothness = lerp(smoothness, 0.92f, wetFactor);\n   }\n\n   void OffsetUV(inout Config c, float2 offset)\n   {\n       c.uv += offset;\n       c.uvT.uv0 += offset;\n       c.uvT.uv1 += offset;\n       c.uvT.uv2 += offset;\n       c.uvX.uv0 += offset;\n       c.uvX.uv1 += offset;\n       c.uvX.uv2 += offset;\n       c.uvY.uv0 += offset;\n       c.uvY.uv1 += offset;\n       c.uvY.uv2 += offset;\n       c.uvZ.uv0 += offset;\n       c.uvZ.uv1 += offset;\n       c.uvZ.uv2 += offset;\n   }\n\n\n    void TriangleGrid(float2 uv, float scale,\n       out float w1, out float w2, out float w3,\n       out int2 vertex1, out int2 vertex2, out int2 vertex3)\n    {\n       // Scaling of the input\n       uv *= 3.464 * scale; // 2 * sqrt(3)\n\n       // Skew input space into simplex triangle grid\n       const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);\n       float2 skewedCoord = mul(gridToSkewedGrid, uv);\n\n       // Compute local triangle vertex IDs and local barycentric coordinates\n       int2 baseId = int2(floor(skewedCoord));\n       float3 temp = float3(frac(skewedCoord), 0);\n       temp.z = 1.0 - temp.x - temp.y;\n       if (temp.z > 0.0)\n       {\n          w1 = temp.z;\n          w2 = temp.y;\n          w3 = temp.x;\n          vertex1 = baseId;\n          vertex2 = baseId + int2(0, 1);\n          vertex3 = baseId + int2(1, 0);\n       }\n       else\n       {\n          w1 = -temp.z;\n          w2 = 1.0 - temp.y;\n          w3 = 1.0 - temp.x;\n          vertex1 = baseId + int2(1, 1);\n          vertex2 = baseId + int2(1, 0);\n          vertex3 = baseId + int2(0, 1);\n       }\n    }\n\n    // Fast random hash function\n    float2 SimpleHash2(float2 p)\n    {\n       return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 43758.5453);\n    }\n\n\n    half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)\n    {\n        // compute weight with height map\n        const half epsilon = 1.0f / 1024.0f;\n        half3 weights = half3(iWeights.x * (tex0 + epsilon), \n                                 iWeights.y * (tex1 + epsilon),\n                                 iWeights.z * (tex2 + epsilon));\n\n        // Contrast weights\n        half maxWeight = max(weights.x, max(weights.y, weights.z));\n        half transition = contrast * maxWeight;\n        half threshold = maxWeight - transition;\n        half scale = 1.0f / transition;\n        weights = saturate((weights - threshold) * scale);\n        // Normalize weights.\n        half weightScale = 1.0f / (weights.x + weights.y + weights.z);\n        weights *= weightScale;\n        return weights;\n    }\n\n\n    half3 PackedUnpackScaleNormal(half4 packedNormal, float scale)\n   {\n       #if _PACKEDFAST\n          half3 normal;\n          normal.xy = (packedNormal.ag * 2 - 1) * scale;\n          normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n          return normal;  \n       #endif\n       return UnpackScaleNormal(packedNormal, scale);\n   }\n\n    void InitStochasticDxDy(inout SampleConfig c, Config cfg)\n    {\n      c.dx0 = ddx(cfg.origUV) * cfg.origScale;\n      c.dy0 = ddy(cfg.origUV) * cfg.origScale;\n      c.dx1 = c.dx0; c.dx1 = c.dx0;\n      c.dx2 = c.dy0; c.dy2 = c.dy0;\n    }\n\n    void PrepareStochasticUVs(float scale, float2 uv, out SampleConfig c)\n    {\n       // Get triangle info\n       ZERO_INITIALIZE(SampleConfig, c);\n       float w1, w2, w3;\n       int2 vertex1, vertex2, vertex3;\n       TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n       // Assign random offset to each triangle vertex\n       c.uv0 = uv;\n       c.uv1 = uv;\n       c.uv2 = uv;\n   \n       c.uv0.xy += SimpleHash2(vertex1);\n       c.uv1.xy += SimpleHash2(vertex2);\n       c.uv2.xy += SimpleHash2(vertex3);\n       c.weights = half3(w1, w2, w3);\n       c.origWeights = half3(w1, w2, w3);\n    }\n\n\n   half3 LitBlendDetailNormal(half3 n1, half3 n2)\n   {\n      #if _SURFACEGRADIENT\n         return n1 + n2;\n      #else\n         return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n      #endif\n   }\n\n   float3 TriplanarBlendUnpackedRNM(float3 n1, float3 n2)\n   {\n       n1.z += 1;\n       n2.xy = -n2.xy;\n       return n1 * dot(n1, n2) / n1.z - n2;\n   }\n\n   void InitConfigDxDy(inout Config c)\n   {\n      c.uvT.dx0 = ddx(c.uvT.uv0);\n      c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1);\n      c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2);\n      c.uvT.dy2 = ddy(c.uvT.uv2);\n   }\n\n   Config CreateConfig(ShaderData d, float4 scale, float space, int uvsource, half triplanarContrast)\n   {\n      Config c;\n      ZERO_INITIALIZE(Config, c);\n\n      float3 pos = d.worldSpacePosition;\n      float3 normal = d.worldSpaceNormal;\n      if (space > 0)\n      {\n         pos = d.localSpacePosition;\n         normal = d.localSpaceNormal;\n      }\n\n      c.uv = d.texcoord0.xy;\n      \n      if (uvsource == 1)\n        c.uv = d.texcoord1.xy;\n      else if (uvsource == 2)\n        c.uv = pos.yz * float2(1, -1);\n      else if (uvsource == 3)\n        c.uv = pos.xz * float2(1, -1);\n      else if (uvsource == 4)\n        c.uv = pos.xy * float2(1, -1);\n\n      c.origUV = c.uv;\n      c.origScale = scale.xy;\n\n      c.uv = c.uv * scale.xy + scale.zw;\n      c.dx = ddx(c.uv);\n      c.dy = ddy(c.uv);\n\n      c.normal = normal;\n      c.uvT.uv0 = pos.zy * scale.xy + scale.zw;\n      c.uvT.uv1 = pos.xz * scale.xy + scale.zw;\n      c.uvT.uv2 = pos.xy * scale.xy + scale.zw;\n        \n      c.uvT.uv1 += 0.33;\n      c.uvT.uv2 += 0.67;\n\n      c.uvT.dx0 = ddx(c.uvT.uv0); c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1); c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2); c.uvT.dy2 = ddy(c.uvT.uv2);\n\n      half3 triblend = saturate(pow(abs(c.normal), triplanarContrast));\n      triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n      c.uvT.weights = triblend;\n      c.uvT.origWeights = triblend;\n      c.axisSign = d.worldSpaceNormal < 0 ? -1 : 1;\n      c.absVertNormal = abs(d.worldSpaceNormal);\n     \n\n      return c;\n   }\n\n\n   half4 TriSample(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0) * c.weights.x;\n      }\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1) * c.weights.y;\n      }  \n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2) * c.weights.z;\n      }\n\n      return res;\n   }\n\n   half4 TriSampleBary(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      c.weights = BaryWeightBlend(c.origWeights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   half4 TriSampleGrad(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvX, contrast, d) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvY, contrast, d) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n           res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvZ, contrast, d) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   \n   half4 SampleTexBaryStochastic(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   half4 SampleTexBaryTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleGrad(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   \n   half4 SampleTexBary(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        COUNTSAMPLE\n        return SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv, c.dx, c.dy);\n   }\n\n   half4 SampleTexStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ) * c.uvT.weights.z;\n\n        return res;     \n   }\n\n   \n   half4 SampleTexStochastic(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n\n   half4 SampleTexTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n   \n   half4 SampleTex(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       COUNTSAMPLE\n       return SAMPLE_TEXTURE2D(tex, ss, c.uv);\n   }\n   \n\n \n   half3 SampleNormalStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n         dataX = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n         dataY = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n         dataZ = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ));\n\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n\n          return WorldToTangentSpace(d, worldNormal);\n       #endif\n   }\n\n\n   half3 SampleNormalTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n      {\n          COUNTSAMPLE\n          dataX = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv0, c.uvT.dx0, c.uvT.dy0));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n      {\n          COUNTSAMPLE\n          dataY = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv1, c.uvT.dx1, c.uvT.dy1));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n      {\n         COUNTSAMPLE\n         dataZ = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv2, c.uvT.dx2, c.uvT.dy2));\n      }\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n          return WorldToTangentSpace(d, worldNormal);\n      #endif\n   }\n\n   half3 SampleNormalStochastic(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n     half4 normal = TriSample(tex, ss, c.uvT);\n     #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half3 SampleNormal(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 normal = SAMPLE_TEXTURE2D(tex, ss, c.uv);\n      #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half HeightBlend(half h1, half h2, half slope, half contrast)\n   {\n      h2 = 1 - h2;\n      half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); \n      half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));\n      return blend;\n   }\n\n\n    #if _POM\n    float2 POM(TEXTURE2D_PARAM(tex, ss), Config c, float contrast, ShaderData d)\n    {\n       float2 curv = float2(0, 0);\n       float refPlane = 0;\n\n       float result = 0;\n       int stepIndex = 0;\n       int maxSamples = _POMMaxSamples;\n       int minSamples = 4;\n       float camDist = distance(_WorldSpaceCameraPos, d.worldSpacePosition);\n       float distanceFade = 1 - saturate((camDist - _POMMin) / max(1, _POMFade));\n       int numSteps = ( int )lerp( maxSamples, minSamples, dot( d.worldSpaceNormal, d.worldSpaceViewDir )) * distanceFade;\n       if (numSteps < 1)\n           numSteps = 1;\n       float layerHeight = 1.0 / numSteps;\n       float2 plane = _ParallaxHeight * ( d.tangentSpaceViewDir.xy / d.tangentSpaceViewDir.z ) * distanceFade;\n       OffsetUV(c, refPlane * plane);\n       float2 deltaTex = -plane * layerHeight;\n       float2 prevTexOffset = 0;\n       float prevRayZ = 1.0f;\n       float prevHeight = 0.0f;\n       float2 currTexOffset = deltaTex;\n       float currRayZ = 1.0f - layerHeight;\n       float currHeight = 0.0f;\n       float intersection = 0;\n       float2 finalTexOffset = 0;\n\n       while ( stepIndex < numSteps + 1 )\n       {\n          result = dot( curv, currTexOffset * currTexOffset );\n          Config cfg = c;\n          OffsetUV(cfg, currTexOffset);\n          currHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( currHeight > currRayZ )\n          {\n             stepIndex = numSteps + 1;\n          }\n          else\n          {\n             stepIndex++;\n             prevTexOffset = currTexOffset;\n             prevRayZ = currRayZ;\n             prevHeight = currHeight;\n             currTexOffset += deltaTex;\n             currRayZ -= layerHeight * ( 1 - result );\n          }\n       }\n       int sectionSteps = 10;\n       int sectionIndex = 0;\n       float newZ = 0;\n       float newHeight = 0;\n       while ( sectionIndex < sectionSteps )\n       {\n          intersection = ( prevHeight - prevRayZ ) / ( prevHeight - currHeight + currRayZ - prevRayZ );\n          finalTexOffset = prevTexOffset + intersection * deltaTex;\n          newZ = prevRayZ - intersection * layerHeight;\n          Config cfg = c;\n          OffsetUV(cfg, finalTexOffset);\n          newHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( newHeight > newZ )\n          {\n             currTexOffset = finalTexOffset;\n             currHeight = newHeight;\n             currRayZ = newZ;\n             deltaTex = intersection * deltaTex;\n             layerHeight = intersection * layerHeight;\n          }\n          else\n          {\n             prevTexOffset = finalTexOffset;\n             prevHeight = newHeight;\n             prevRayZ = newZ;\n             deltaTex = ( 1 - intersection ) * deltaTex;\n             layerHeight = ( 1 - intersection ) * layerHeight;\n          }\n          sectionIndex++;\n       }\n       #if _PASSHADOWS\n       if ( unity_LightShadowBias.z == 0.0 )\n       {\n       #endif\n          if ( result > 1 )\n             clip( -1 );\n       #if _PASSHADOWS\n       }\n       #endif\n       return finalTexOffset;\n    }\n    #endif\n\n   \n\n   // tess versions\n   #if _TESSELLATION_ON\n   half4 TriSampleLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias) * c.weights.x;\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias) * c.weights.y;\n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias) * c.weights.z;\n\n      return res;\n   }\n\n   half4 TriSampleBaryLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias, float contrast)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias);\n      half4 r2 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias);\n      half4 r3 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias);\n      c.weights = BaryWeightBlend(c.weights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryLODStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvX, bias, contrast) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvY, bias, contrast) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvZ, bias, contrast) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   half4 SampleTexBaryLODStochastic(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n       return TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias, contrast);\n   }\n\n   half4 SampleTexBaryLODTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return TriSampleLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias);\n   }\n\n   half4 SampleTexBaryLOD(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv, bias);\n   }\n\n\n    float FBM2DLOD(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           return SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv, _TessellationMipBias).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n        \n        \n    }\n\n    float FBM3DLOD(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           half A = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.zy, _TessellationMipBias).g;\n           half B = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33, _TessellationMipBias).g;\n           half C = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67, _TessellationMipBias).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoiseLOD(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3DLOD(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3DLOD(d.localSpacePosition * frequency + offset, d.localSpaceNormal);\n        #else\n           return FBM2DLOD(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n   #endif //_TESSELLATION_ON\n\n\n    half3 FuzzyShade(ShaderData d, half height, half3 color, half3 normal, half coreMult, half edgeMult, half power)\n    {\n        float3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half dt = saturate(dot(d.worldSpaceViewDir, worldNormal));\n        half dark = 1.0 - (coreMult * dt);\n        half edge = pow(1-dt, abs(power)) * edgeMult;\n        return color * (dark + edge);\n    }\n\n\thalf MicroShadow(ShaderData d, half3 normal, half height, half ao, half strength)\n\t{\n        float3 sun;\n\t\tfloat3 sunColor;\n\t\tGetSun(sun, sunColor);\n\t\tfloat3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half shadow = saturate(abs(dot(worldNormal, sun)) + (ao * ao * 2.0) - 1.0);\n        return 1 - ((1-shadow) * strength);\n\t}\n\n\n#endif\n\n\n\n   #if defined(_SPECULAR)\n      #define _USESPECULAR 1\n      #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n   #endif\n\n   \n   TEXTURE2D(_AlbedoMap);\n   SAMPLER(sampler_AlbedoMap);\n   TEXTURE2D(_NormalMap);\n   SAMPLER(sampler_NormalMap);\n   TEXTURE2D(_MaskMap);\n   TEXTURE2D(_DetailMap);\n   TEXTURE2D(_EmissionMap);\n\n   #if _SPECULAR\n       TEXTURE2D(_SpecularMap);\n   #endif\n\n   \n   \n   void Ext_SurfaceFunction0 (inout Surface o, inout ShaderData d)\n   {\n      // define samplers based on settings\n      #undef SAMPLEBARY\n      #undef SAMPLE\n      #undef SAMPLENORMAL\n      #if _STOCHASTIC && _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n        #define SAMPLE     SampleTexStochasticTriplanar\n        #define SAMPLENORMAL SampleNormalStochasticTriplanar\n      #elif _STOCHASTIC\n        #define SAMPLEBARY SampleTexBaryStochastic\n        #define SAMPLE     SampleTexStochastic\n        #define SAMPLENORMAL SampleNormalStochastic\n      #elif _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryTriplanar\n        #define SAMPLE     SampleTexTriplanar\n        #define SAMPLENORMAL SampleNormalTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBary\n        #define SAMPLE     SampleTex\n        #define SAMPLENORMAL SampleNormal\n      #endif\n\n      Config c = CreateConfig(d, _AlbedoMap_ST, _TriplanarSpace, _UVSource, _TriplanarContrast);\n      InitConfigDxDy(c);\n      #if _STOCHASTIC && !_TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uv, c.uvT);\n         InitStochasticDxDy(c.uvT, c);\n      #elif _STOCHASTIC && _TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv0, c.uvX);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv1, c.uvY);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv2, c.uvZ);\n         InitStochasticDxDy(c.uvX, c);\n         InitStochasticDxDy(c.uvY, c);\n         InitStochasticDxDy(c.uvZ, c);\n      #endif\n\n      #if _POM\n          // would need to handle height remapping if we ever want to ship this\n          float2 pomOffset = POM(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n          OffsetUV(c, pomOffset);\n      #endif\n\n      half4 albedo = SAMPLEBARY(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n      \n      #if _PARALLAX\n         float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n         OffsetUV(c, offset);\n         albedo = SAMPLE(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c);\n         \n      #endif\n      albedo.a = lerp(_HeightRemap.x, _HeightRemap.y, albedo.a);\n      albedo.rgb *= _Tint.rgb;\n\n      albedo.rgb = AdjustContrast(albedo.rgb, _AlbedoContrast);\n      albedo.rgb += _AlbedoBrightness;\n\n\n      if (_AlphaThreshold > 0)\n      {\n         clip(albedo.a - _AlphaThreshold);\n      }\n\n      #if defined(_FLATSHADE)\n\t\t     float3 dx = ddx(d.worldSpacePosition);\n\t\t     float3 dy = ddy(d.worldSpacePosition);\n\t\t     float3 worldNormal = normalize(cross(dy, dx));\n\t\t     worldNormal = lerp(d.worldSpaceNormal, worldNormal, _FlatShadingBlend);\n\t\t     d.worldSpaceNormal = worldNormal;\n\t\t     d.TBNMatrix[2] = worldNormal;\n      #endif\n\n\n\n      o.Albedo = albedo.rgb;\n      o.Alpha = albedo.a;\n\n      float smoothness = _Smoothness;\n      float ao = 1;\n\n      #if defined(_NORMALMAP) && !defined(_AUTONORMAL)\n         o.Normal = SAMPLENORMAL(TEXTURE2D_ARGS(_NormalMap, sampler_NormalMap), c, d, _NormalStrength, smoothness, ao);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, ao);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n      #endif\n\n      half detailMask = 1;\n      o.Smoothness = smoothness;\n      o.Occlusion = ao;\n      o.Metallic = _Metallic;\n      #if defined(_MASKMAP) && !_PACKEDFAST\n         // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = SampleTex(TEXTURE2D_ARGS(_MaskMap, sampler_AlbedoMap), c);\n         o.Metallic = lerp(_MetallicRemap.x, _MetallicRemap.y, mask.r);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, mask.g);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, mask.a);\n         detailMask = mask.b;\n      #endif // separate maps\n\n      #if _SPECULAR\n         o.Specular = SAMPLE(TEXTURE2D_ARGS(_SpecularMap, sampler_AlbedoMap), c).rgb;\n      #endif\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = SAMPLE(TEXTURE2D_ARGS(_EmissionMap, sampler_AlbedoMap), c).rgb * _EmissionColor;\n      #endif\n\n      if (_FuzzyShadingOn > 0)\n      {\n        o.Albedo *= FuzzyShade(d, albedo.a, _FuzzyShadingColor, o.Normal, _FuzzyShadingParams.x, _FuzzyShadingParams.y, _FuzzyShadingParams.z);\n      }\n\n\n      // HDRP style detail texturing\n\n      #if defined(_DETAIL)\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _DETAILSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n         Config dc = CreateConfig(d, _DetailMap_ST, _DetailTriplanarSpace, _DetailUVSource, _DetailTriplanarContrast);\n         InitConfigDxDy(dc);\n         #if _DETAILSTOCHASTIC && !_DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uv, dc.uvT);\n             InitStochasticDxDy(dc.uvT, dc);\n         #elif _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv0, dc.uvX);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv1, dc.uvY);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv2, dc.uvZ);\n             InitStochasticDxDy(dc.uvX, dc);\n             InitStochasticDxDy(dc.uvY, dc);\n             InitStochasticDxDy(dc.uvZ, dc);\n         #endif\n\n         half4 detailSample = SAMPLEBARY(TEXTURE2D_ARGS(_DetailMap, sampler_AlbedoMap), dc, _DetailStochasticContrast, d);\n         smoothness = detailSample.z;\n         #if !_AUTONORMAL\n            half3 dnormal = float3(detailSample.ag * 2 - 1, 1) * detailMask * _DetailNormalStrength;\n            dnormal.z = sqrt(1 - dnormal.x * dnormal.x - dnormal.y * dnormal.y);\n            #if _SURFACEGRADIENT\n               dnormal = ConvertNormalToGradient(d, dnormal);\n            #endif\n            o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n         #endif\n     \n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * smoothness, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n      if (_MicroShadowStrength > 0)\n      {\n        o.Occlusion *= MicroShadow(d, o.Normal, o.Alpha, o.Occlusion, _MicroShadowStrength);\n      }\n  \n      // in case something needs height in the stack..\n      o.Height = o.Alpha;\n\n\n      \n   }\n\n\n\n\t#if _TINTMASK\n\t\tTEXTURE2D(_TintMask);\n\t\tSAMPLER(sampler_TintMask);\n\t#endif\n\n\tvoid Ext_SurfaceFunction1 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _TINTMASK\n\t\t   half4 w = SAMPLE_TEXTURE2D(_TintMask, sampler_TintMask, d.texcoord0.xy * _TintMask_ST.xy + _TintMask_ST.zw);\n\t\t   // allow black to be no tint..\n\t\t   half3 tint = o.Albedo * (_RColor.rgb * 2 * w.r + _GColor.rgb * 2 * w.g + _BColor.rgb * 2 * w.b + _AColor.rgb * 2 * w.a);\n\t\t   o.Albedo = lerp(o.Albedo, tint, saturate(w.r + w.g + w.b + w.a));\n\t\t#endif\n\t}\n\n\n\n\n\t#if _LAYERTEXTUREMASK\n       TEXTURE2D(_LayerTextureMask);\n       SAMPLER(sampler_LayerTextureMask); \n    #endif\n\n   void Ext_ModifyTessellatedVertex2 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON\n          float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n\n          #if _LAYERTEXTUREMASK\n               float2 layerUV = v.texcoord0.xy;\n               if (_LayerTextureMaskUVMode == 1)\n                  layerUV = v.texcoord1.xy;\n               else if (_LayerTextureMaskUVMode == 2)\n                  layerUV = worldSpacePosition.yz;\n               else if (_LayerTextureMaskUVMode == 3)\n                  layerUV = worldSpacePosition.xz;\n               else if (_LayerTextureMaskUVMode == 4)\n                  layerUV = worldSpacePosition.xy;\n\n              e.blackboard.weightTextureMask = SAMPLE_TEXTURE2D_LOD(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw, _TessellationMipBias);\n          #endif\n      #endif\n    }\n\n\n\tvoid Ext_SurfaceFunction2 (inout Surface o, inout ShaderData d)\n\t{\n\t\t#if _LAYERTEXTUREMASK\n           float2 layerUV = d.texcoord0.xy;\n           if (_LayerTextureMaskUVMode == 1)\n              layerUV = d.texcoord1.xy;\n           else if (_LayerTextureMaskUVMode == 2)\n              layerUV = d.worldSpacePosition.yz;\n           else if (_LayerTextureMaskUVMode == 3)\n              layerUV = d.worldSpacePosition.xz;\n           else if (_LayerTextureMaskUVMode == 4)\n              layerUV = d.worldSpacePosition.xy;\n\n          d.blackboard.weightTextureMask = SAMPLE_TEXTURE2D(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw);\n      #endif\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap);\n   SAMPLER(sampler_LayerAlbedoMap);\n   TEXTURE2D(_LayerNormalMap);\n   TEXTURE2D(_LayerMaskMap);\n   TEXTURE2D(_LayerEmissionMap);\n\n   \n\n   void Ext_ModifyTessellatedVertex3 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER) && defined(_LAYERALBEDO) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n         half detailMask = 1;\n         #if _LAYERNOISE\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency,  _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin;\n            dt = saturate(dt * _LayerFalloff);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight) * _LayerFalloff);\n            if (_LayerInvertHeight > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength;\n         detailMask *= _LayerTessStrength;\n\n         #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast).a;\n         albedo = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo);\n\n         if (_LayerBlendMode == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction3 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n            // noise up the mask\n            #if _LAYERNOISE\n               mask = DoNoise(d, _LayerNoiseFrequency, _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend);\n\t    \n                dt -= _LayerAngleMin;\n                dt = saturate(dt * _LayerFalloff);\n\n                float hf = saturate((o.Height - _LayerHeight) * _LayerFalloff);\n                if (_LayerInvertHeight > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 0\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 0\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength;\n\n            #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint, 0.5);\n            #if defined(_LAYERALBEDO)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c, _LayerStochasticContrast, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c);\n                #endif\n                albedo.rgb *= _LayerTint;\n                albedo.a = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL || _LAYERMASK\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap, sampler_LayerAlbedoMap, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast);\n            albedo.rgb += _LayerAlbedoBrightness;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap, sampler_LayerAlbedoMap), c, d, _LayerNormalStrength * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO)\n                if (_LayerFuzzyShadingOn > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor.rgb, dnormal,\n                                            _LayerFuzzyShadingParams.x, _LayerFuzzyShadingParams.y, _LayerFuzzyShadingParams.z);\n                }\n\n                if (_LayerBlendMode == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast);\n                else if (_LayerBlendMode == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE\n                      float maskDif = (_LayerBlendContrast * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength);\n                   #if _LAYERNOISE\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap, sampler_LayerAlbedoMap), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength);\n                }\n\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap, sampler_LayerAlbedoMap), c).rgb * _LayerEmissionColor;\n                #if _LAYERALBEDO\n                    if (_LayerBlendMode > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_1);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_1);\n   TEXTURE2D(_LayerNormalMap_Ext_1);\n   TEXTURE2D(_LayerMaskMap_Ext_1);\n   TEXTURE2D(_LayerEmissionMap_Ext_1);\n\n   \n\n   void Ext_ModifyTessellatedVertex4 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_1) && defined(_LAYERALBEDO_DEF_1) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_1\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_1,  _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_1\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_1;\n            dt = saturate(dt * _LayerFalloff_Ext_1);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n            if (_LayerInvertHeight_Ext_1 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_1;\n         detailMask *= _LayerTessStrength_Ext_1;\n\n         #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_1).a;\n         albedo = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo);\n\n         if (_LayerBlendMode_Ext_1 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_1);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_1 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction4 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_1)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_1\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_1, _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_1\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_1);\n\t    \n                dt -= _LayerAngleMin_Ext_1;\n                dt = saturate(dt * _LayerFalloff_Ext_1);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n                if (_LayerInvertHeight_Ext_1 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 01\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 01\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_1;\n\n            #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_1, 0.5);\n            #if defined(_LAYERALBEDO_DEF_1)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, _LayerStochasticContrast_Ext_1, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_1;\n                albedo.a = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_1 || _LAYERMASK_DEF_1\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_1);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_1;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, d, _LayerNormalStrength_Ext_1 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_1)\n                if (_LayerFuzzyShadingOn_Ext_1 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_1.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_1.x, _LayerFuzzyShadingParams_Ext_1.y, _LayerFuzzyShadingParams_Ext_1.z);\n                }\n\n                if (_LayerBlendMode_Ext_1 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_1);\n                else if (_LayerBlendMode_Ext_1 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_1 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_1);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_1\n                      float maskDif = (_LayerBlendContrast_Ext_1 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_1 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                   #if _LAYERNOISE_DEF_1\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_1));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_1 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_1);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_1) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_1 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_1);\n                }\n\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_1);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_1, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_1, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_1\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c).rgb * _LayerEmissionColor_Ext_1;\n                #if _LAYERALBEDO_DEF_1\n                    if (_LayerBlendMode_Ext_1 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_2);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_2);\n   TEXTURE2D(_LayerNormalMap_Ext_2);\n   TEXTURE2D(_LayerMaskMap_Ext_2);\n   TEXTURE2D(_LayerEmissionMap_Ext_2);\n\n   \n\n   void Ext_ModifyTessellatedVertex5 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_2) && defined(_LAYERALBEDO_DEF_2) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_2\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_2,  _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_2\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_2;\n            dt = saturate(dt * _LayerFalloff_Ext_2);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n            if (_LayerInvertHeight_Ext_2 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_2;\n         detailMask *= _LayerTessStrength_Ext_2;\n\n         #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_2).a;\n         albedo = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo);\n\n         if (_LayerBlendMode_Ext_2 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_2);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_2 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction5 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_2)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_2\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_2, _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_2\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_2);\n\t    \n                dt -= _LayerAngleMin_Ext_2;\n                dt = saturate(dt * _LayerFalloff_Ext_2);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n                if (_LayerInvertHeight_Ext_2 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 02\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 02\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_2;\n\n            #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_2, 0.5);\n            #if defined(_LAYERALBEDO_DEF_2)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, _LayerStochasticContrast_Ext_2, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_2;\n                albedo.a = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_2 || _LAYERMASK_DEF_2\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_2);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_2;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, d, _LayerNormalStrength_Ext_2 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_2)\n                if (_LayerFuzzyShadingOn_Ext_2 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_2.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_2.x, _LayerFuzzyShadingParams_Ext_2.y, _LayerFuzzyShadingParams_Ext_2.z);\n                }\n\n                if (_LayerBlendMode_Ext_2 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_2);\n                else if (_LayerBlendMode_Ext_2 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_2 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_2);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_2\n                      float maskDif = (_LayerBlendContrast_Ext_2 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_2 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                   #if _LAYERNOISE_DEF_2\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_2));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_2 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_2);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_2) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_2 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_2);\n                }\n\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_2);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_2, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_2, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_2\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c).rgb * _LayerEmissionColor_Ext_2;\n                #if _LAYERALBEDO_DEF_2\n                    if (_LayerBlendMode_Ext_2 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   #if _TRAX_ON\n   TEXTURE2D(_TraxAlbedo);\n   SAMPLER(sampler_TraxAlbedo);\n   TEXTURE2D(_TraxPackedNormal);\n   TEXTURE2D(_TraxMask);\n\n   sampler2D_float _GMSTraxBuffer;\n\n   float4 _GMSTraxBuffer_TexelSize;\n   float3 _GMSTraxBufferPosition;\n   float _GMSTraxBufferWorldSize;\n   float _GMSTraxFudgeFactor;\n\n   float SampleTraxBufferLOD(float3 worldPos)\n   {    \n      // generate UVs for the buffer, which is moving\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 8);\n      uv *= 0.5;\n      uv += 0.5;\n            \n      float s =  tex2Dlod(_GMSTraxBuffer, float4(uv, 0, 0)).r;\n\n      return 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n   }\n         \n        \n   float SampleTraxBuffer(float3 worldPos, out float3 norm)\n   {\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 3);\n      uv *= 0.5;\n      uv += 0.5;\n            \n\n      float2 offset = _GMSTraxBuffer_TexelSize.xy;\n\n      float s = tex2D(_GMSTraxBuffer, uv).r;\n               \n      float s1 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, -1)).r;\n      float s2 = tex2D(_GMSTraxBuffer, uv + offset * float2(-1, 0)).r;\n      float s3 = tex2D(_GMSTraxBuffer, uv + offset * float2(1, 0)).r;\n      float s4 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, 1)).r;\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      float r = 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n \n      // generate normals\n      norm.x = (s1 - s4) * 0.25; \n      norm.y = (s2 - s3) * 0.25;\n      norm.z = 2;\n      norm = normalize(norm);\n     \n      norm.xy *= 1 - r;\n            \n      return r;\n   }\n   #endif\n\n   void Ext_ModifyTessellatedVertex6 (inout VertexData v, inout ExtraV2F d)\n   {\n       #if _TESSELLATION_ON && _TRAX_ON && _HAS_LIT_TESSELLATION\n          \n           float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n           float3 worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n           float traxBuffer = SampleTraxBufferLOD(worldSpacePosition);\n           d.blackboard.traxBuffer = traxBuffer;\n           float2 uv = worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n           half albedo = SAMPLE_TEXTURE2D_LOD(_TraxAlbedo, sampler_TraxAlbedo, uv, _TraxMipBias).a;\n\n           float traxOffset = albedo * _TraxDisplacementStrength;\n           traxOffset *= 1 - v.texcoord0.z;\n           traxOffset *= _TessellationDisplacement;\n           float dig = _TraxDisplacementDepth * (1 - v.texcoord0.z);\n           float3 traxVertex = d.blackboard.originalVertexPosition + (v.normal * (traxOffset - dig));\n           v.vertex.xyz = lerp(traxVertex, v.vertex.xyz, traxBuffer);\n\n           d.blackboard.vertexHeightOffset = lerp(traxOffset-dig, d.blackboard.vertexHeightOffset, traxBuffer);\n\n       #endif\n\n   }\n\n   void Ext_SurfaceFunction6 (inout Surface o, inout ShaderData d)\n   {\n      #if _TRAX_ON\n        float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n        float2 fsdx = ddx(uv);\n        float2 fsdy = ddy(uv);\n\n        float3 traxNormal;\n        float traxBuffer = SampleTraxBuffer(d.worldSpacePosition, traxNormal);\n        \n        #if _TESSELLATION_ON\n            traxBuffer -= _TraxDisplacementDepth;\n        #endif\n\n        d.blackboard.traxBuffer = traxBuffer;\n\n        UNITY_BRANCH\n        if (traxBuffer > 0)\n        {\n            half4 albedo = SAMPLE_TEXTURE2D_GRAD(_TraxAlbedo, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            albedo.rgb *= _TraxTint.rgb;\n            half4 normalSample = SAMPLE_TEXTURE2D_GRAD(_TraxPackedNormal, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n\n            half smoothness = normalSample.r;\n            half ao = normalSample.b;\n            half3 normal;\n            normal.xy = (normalSample.ag * 2 - 1) * _TraxNormalStrength;\n            normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n\n            \n            half h = HeightBlend(albedo.a, o.Alpha, traxBuffer, _TraxHeightContrast);\n\n            h = lerp(traxBuffer, h, _TraxInterpContrast);\n\n            o.Albedo = lerp(albedo, o.Albedo, h);\n\n            #if _SURFACEGRADIENT\n                o.Normal = lerp(normal, o.Normal, h);\n            #else\n                o.Normal = lerp(normal + traxNormal, o.Normal, h);\n            #endif\n        \n            o.Smoothness = lerp(smoothness, o.Smoothness, h);\n            o.Occlusion = lerp(ao, o.Occlusion, h);\n        }\n      #endif\n   }\n\n\n\n\n    #if _RAINDROPS\n       TEXTURE2D(_RainDropTexture);\n       SAMPLER(sampler_RainDropTexture);\n       half _Global_RainIntensity;\n    #endif\n\n    #if _WETNESS\n       half2 _Global_WetnessParams; // global, not in cbuffer\n    #endif\n   \n    #if _RAINDROPS\n    half2 ComputeRipple(float2 uv, half time, half weight)\n    {\n        half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_RainDropTexture, uv);\n        COUNTSAMPLE\n        ripple.yz = ripple.yz * 2 - 1;\n\n        half dropFrac = frac(ripple.w + time);\n        half timeFrac = dropFrac - 1.0 + ripple.x;\n        half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);\n        half finalFactor = dropFactor * ripple.x * \n                                sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);\n\n        return half2(ripple.yz * finalFactor);\n    }\n    #endif\n\n    half2 DoRain(half2 waterNorm, float2 uv, out half2 ripple)\n    {\n        #if _RAINDROPS\n            float rainIntensity = _RainIntensityScale.x;\n            if (_RainMode > 1)\n            {\n                rainIntensity = _Global_RainIntensity;\n            }\n\n            half dropStrength = rainIntensity;\n            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); \n            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);\n            half4 times = _Time.yyyy;\n            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);\n\n            float2 ruv1 = uv * _RainIntensityScale.yy;\n            float2 ruv2 = ruv1;\n\n            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);\n            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);\n            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);\n            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);\n            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);\n            weights = saturate(weights * 4);\n\n            half2 rippleNormal = half2( weights.x * ripple1.xy +\n                        weights.y * ripple2.xy + \n                        weights.z * ripple3.xy + \n                        weights.w * ripple4.xy);\n\n            ripple = rippleNormal * dropStrength * rainIntensity;\n            waterNorm = lerp(waterNorm, normalize(half3(rippleNormal.xy + rippleNormal.xy, 1)).xy, rainIntensity * dropStrength); \n            return waterNorm;                        \n        #else\n            return waterNorm;\n        #endif\n    }\n\n   half2 _Global_PuddleParams;   // this is a global, so keep it out of the cbuffer\n   void GetPuddleParams(ShaderData d, inout float puddleMask, inout float pudHeight)\n   {\n      #if _PUDDLES || _GLOBALPUDDLES\n          pudHeight = _PuddleAmount;\n          if (_PuddleMode > 0)\n             pudHeight = _Global_PuddleParams.x;    \n      \n\n          half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t      dt -= _PuddleAngleMin;\n          dt = saturate(dt * _PuddleFalloff);\n          puddleMask *= dt;\n      #endif\n   }\n   \n   void Ext_ModifyTessellatedVertex7 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _PUDDLES && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n         half mask = 1;\n         half pudHeight = 1;\n\n         // save some ops by doing this in 2d\n         #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2DLOD(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2DLOD(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #else\n                mask = (FBM2DLOD(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n         #endif\n\n         GetPuddleParams(d, mask, pudHeight);\n         float height = pudHeight * mask;\n         if (e.blackboard.vertexHeightOffset < height)\n         {\n            e.blackboard.vertexHeightOffset = height;\n            height -= _TessellationOffset; \n            // dampen cracks\n            height *= 1 - v.texcoord0.z;\n            height *= _TessellationDisplacement;\n            v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n            \n        }\n      #endif\n   }\n\n\n#if _WETNESS\n\n   float GetWetnessLevel(Surface o, ShaderData d, float wetnessMask)\n   {\n      float wetLevel = clamp(_WetnessAmount, _WetnessMin, _WetnessMax);\n      \n      if (_WetnessMode > 0)\n         wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);\n\n      wetLevel = saturate(wetLevel + (1 - saturate(d.worldSpacePosition.y - _WetnessShoreline)));\n      float3x3 tbn = float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal);\n      float dt = dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0));\n      dt -= _WetnessAngleMin;\n      dt = saturate(dt * _WetnessFalloff * wetLevel);\n      dt *= wetnessMask;\n      return dt;\n   }\n#endif\n   \n\n   void Ext_SurfaceFunction7 (inout Surface o, ShaderData d)\n   {\n      half wetnessLevel = 0;\n      #if _WETNESS\n          wetnessLevel = GetWetnessLevel(o, d, 1); // mask one day?\n      #endif\n\n      half depthMask = 0;\n      half depth = 0;\n\n      #if _PUDDLES\n          half mask = 1;\n          half pudHeight = 1;\n          #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2D(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2D(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);      \n            #else\n                mask = (FBM2D(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n          #endif\n\n          GetPuddleParams(d, mask, pudHeight);\n          pudHeight *= mask;\n          depth = pudHeight - o.Height;\n          depthMask = saturate(depth * _PuddleFalloff);\n          depthMask *= _PuddleColor.a;\n          depth = o.Height - pudHeight;\n\n          // extend wetness slighting higher than the puddle\n          half wetmask = saturate((pudHeight + 0.05 - o.Height) * _PuddleFalloff);\n          wetnessLevel = max(wetmask, wetnessLevel);\n       #endif\n\n       \n       #if _WETNESS || _PUDDLES\n          half3 waterNorm = half3(0,0,1);\n          half3 wetAlbedo = o.Albedo;\n          half wetSmoothness = o.Smoothness;\n          #if _PUDDLES\n             wetAlbedo *= _PuddleColor.rgb;\n          #endif\n          WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetnessLevel, _Porosity);\n\n          half ri = 0;\n          half2 ripple = 0;\n          #if (_RAINDROPS || _GLOBALRAIN) && (_PUDDLES || _GLOBALPUDDLES)\n             ri = _RainIntensityScale.z;\n             waterNorm.xy = DoRain(waterNorm.xy, d.texcoord0.xy, ripple) * depthMask;\n          #endif\n\n          o.Normal = lerp(o.Normal, waterNorm, depthMask);\n          o.Normal = lerp(o.Normal, LitBlendDetailNormal(o.Normal, half3(ripple.xy, 1)), saturate(ri - depthMask) * wetnessLevel);\n          o.Occlusion = lerp(o.Occlusion, 1, depthMask);\n          o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetnessLevel);\n          o.Albedo = lerp(o.Albedo, wetAlbedo, wetnessLevel);\n          o.Emission *= 1 + depth;\n          o.Metallic *= 1 + depth;\n          o.Specular *= 1 + depth;\n\n       #endif\n\n   }\n\n\n\n\n    #if _SNOW\n       TEXTURE2D(_SnowAlbedo);\n       SAMPLER(sampler_SnowAlbedo);\n       TEXTURE2D(_SnowNormal);\n       TEXTURE2D(_SnowMaskMap);\n       #if _TRAX_ON\n          TEXTURE2D(_SnowTraxAlbedo);\n          TEXTURE2D(_SnowTraxNormal);\n          TEXTURE2D(_SnowTraxMaskMap);\n       #endif\n    #endif\n\n   float _Global_SnowLevel;\n\n\n   void Ext_ModifyVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n    #if (_SNOW)\n        float amount = _SnowAmount;\n        if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n        float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n        float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n        snowAmount -= _SnowAngle;\n        snowAmount *= _SnowContrast * 0.5;\n        snowAmount = saturate(snowAmount) * amount;\n        float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n        if (_SnowWorldFade.z > 0)\n        {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n        }\n        #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n        #endif\n        snowAmount = saturate(snowAmount);\n\n        #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n        #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n        #endif\n\n        float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n        v.vertex.xyz = v.vertex.xyz + displacementVec * snowAmount * snowAmount * _SnowVertexHeight;\n    #endif\n   }\n\n   void Ext_ModifyTessellatedVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _SNOW && _HAS_LIT_TESSELLATION\n         float amount = _SnowAmount;\n         if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n         float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n         float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n         snowAmount -= _SnowAngle;\n         snowAmount *= _SnowContrast * 0.5;\n         float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n         if (_SnowWorldFade.z > 0)\n         {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n         }\n\n         snowAmount = saturate(snowAmount) * amount;\n\n         #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n         #endif\n         snowAmount = saturate(snowAmount);\n\n         #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n         #endif\n\n         float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n         half heightMap = SAMPLE_TEXTURE2D_LOD(_SnowAlbedo, sampler_SnowAlbedo, worldPos.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw, 2);\n\n         float height = max(_SnowVertexHeight * 3 * snowAmount + snowAmount * heightMap, e.blackboard.vertexHeightOffset);\n         #if _TRAX_ON\n            height *= e.blackboard.traxBuffer;\n         #endif\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n\n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n         \n      #endif\n\n   }\n\n   void SampleSnowSurface(TEXTURE2D_PARAM(alb, ss), TEXTURE2D_PARAM(norm, ss2), TEXTURE2D_PARAM(mask, ss3),\n        ShaderData d, float2 uv, float2 dx, float2 dy, out half4 albedo, out half3 normal, out half2 smoothAO)\n   {\n      #if _SNOWSTOCHASTIC\n         float w1, w2, w3;\n         int2 vertex1, vertex2, vertex3;\n         TriangleGrid(uv, _SnowStochasticScale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n         // Assign random offset to each triangle vertex\n         float2 uv0 = uv;\n         float2 uv1 = uv;\n         float2 uv2 = uv;\n   \n         uv0.xy += SimpleHash2(vertex1);\n         uv1.xy += SimpleHash2(vertex2);\n         uv2.xy += SimpleHash2(vertex3);\n         half3 weights = half3(w1, w2, w3);\n\n         half4 albedo0 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv0, dx, dy);\n         half4 albedo1 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv1, dx, dy);\n         half4 albedo2 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv2, dx, dy);\n         COUNTSAMPLE\n         COUNTSAMPLE\n         COUNTSAMPLE\n         weights = BaryWeightBlend(weights, albedo0.a, albedo1.a, albedo2.a, _SnowStochasticContrast);\n         albedo = albedo0 * weights.x + albedo1 * weights.y + albedo2 * weights.z;\n\n         normal = half3(0,0,1);\n         smoothAO = half2(0, 1);\n\n         #if !_AUTONORMAL\n            half4 n0 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv0, dx, dy);\n            half4 n1 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv1, dx, dy);\n            half4 n2 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n            half4 snowNormSamp = n0 * weights.x + n1 * weights.y + n2 * weights.z;\n\n            normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n                \n            #if _PACKEDFAST\n               smoothAO.x = snowNormSamp.r;\n               smoothAO.y = snowNormSamp.b;\n            #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask0 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv0, dx, dy);\n            half4 snowMask1 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv1, dx, dy);\n            half4 snowMask2 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n            half4 snowMask = snowMask0 * weights.x + snowMask1 * weights.y + snowMask2 * weights.z;\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n      #else // not stochastic\n          albedo = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv, dx, dy);\n          COUNTSAMPLE\n\n          normal = half3(0,0,1);\n          smoothAO = half2(0, 1);\n\n          #if !_AUTONORMAL\n             half4 snowNormSamp = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv, dx, dy);\n             COUNTSAMPLE\n             normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n             #if _SURFACEGRADIENT\n                normal = ConvertNormalToGradient(d, normal);\n             #endif\n                 \n             #if _PACKEDFAST\n                smoothAO.x = snowNormSamp.r;\n                smoothAO.y = snowNormSamp.b;\n             #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv, dx, dy);\n            COUNTSAMPLE\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n     #endif // stochastic\n   }\n\n   \n   void Ext_SurfaceFunction8 (inout Surface o, ShaderData d)\n   {\n      #if _SNOW\n          float amount = _SnowAmount;\n          if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n          float snowAmount = lerp(dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), dot(d.worldSpaceNormal, float3(0,1,0)), amount * 0.8) + 1;\n          snowAmount -= _SnowAngle;\n          snowAmount *= _SnowContrast;\n          snowAmount = saturate(snowAmount) - (1-amount) * (1-amount);\n\n          if (_SnowWorldFade.z > 0)\n          {\n             float worldFade = saturate((d.worldSpacePosition.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n             snowAmount *= worldFade;\n          }\n\n          #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(d.worldSpacePosition.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n          #endif\n          snowAmount = saturate(snowAmount);\n\n          float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw;\n          float2 dx = ddx(uv);\n          float2 dy = ddy(uv);\n\n          #if _TRAX_ON\n              float2 tuv = d.worldSpacePosition.xz * float2(1, -1) * _SnowTraxAlbedo_ST.xy + _SnowTraxAlbedo_ST.zw;\n              float2 tdx = ddx(uv);\n              float2 tdy = ddy(uv);\n          #endif\n\n          #if _LAYERVERTEXMASK\n              snowAmount *= d.vertexColor.a;\n          #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n              snowAmount *= d.blackboard.weightTextureMask.a;\n          #endif\n\n          UNITY_BRANCH\n          if (snowAmount > 0)\n          {\n             half4 snowAlbedo;\n             half3 snowNormal;\n             half2 snowSmoothAO;\n             SampleSnowSurface(TEXTURE2D_ARGS(_SnowAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowNormal, sampler_SnowAlbedo),\n                    TEXTURE2D_ARGS(_SnowMaskMap, sampler_SnowAlbedo), d, uv, dx, dy, snowAlbedo, snowNormal, snowSmoothAO);\n\n             snowAlbedo.rgb *= _SnowTint.rgb;\n\n             #if _TRAX_ON\n                half traxBuffer = 1 - d.blackboard.traxBuffer;\n                UNITY_BRANCH\n                if (traxBuffer > 0)\n                {\n                    half4 tsnowAlbedo;\n                    half3 tsnowNormal;\n                    half2 tsnowSmoothAO;\n                    SampleSnowSurface(TEXTURE2D_ARGS(_SnowTraxAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowTraxNormal, sampler_SnowAlbedo),\n                        TEXTURE2D_ARGS(_SnowTraxMaskMap, sampler_SnowAlbedo), d, tuv, tdx, tdy, tsnowAlbedo, tsnowNormal, tsnowSmoothAO);\n\n                    tsnowAlbedo.rgb *= _SnowTraxTint;\n                    half h = HeightBlend(snowAlbedo.a, tsnowAlbedo.a, traxBuffer, 0.5);\n                    snowAlbedo = lerp(snowAlbedo, tsnowAlbedo, h);\n                    snowNormal = lerp(snowNormal, tsnowNormal, h);\n                    snowSmoothAO = lerp(snowSmoothAO, tsnowSmoothAO, h);\n                }\n             #endif\n\n             #if !_AUTONORMAL\n                o.Normal = lerp(o.Normal, snowNormal, snowAmount);\n             #endif\n             o.Albedo = lerp(o.Albedo, snowAlbedo.rgb, snowAmount);\n             o.Alpha = lerp(o.Alpha, snowAlbedo.a, snowAmount);\n             o.Smoothness = lerp(o.Smoothness, snowSmoothAO.x, snowAmount);\n             o.Occlusion = lerp(o.Occlusion, snowSmoothAO.y, snowAmount);\n             o.Height = o.Alpha;\n\n          }\n      #endif\n   }\n\n   \n\n\n\n\n\n   TEXTURE2D(_WindParticulate);\n   SAMPLER(sampler_WindParticulate);\n\n// In case we want to read it more than once..\n\n#ifndef __STACKABLE_WIND_INCLUDES__\n#define __STACKABLE_WIND_INCLUDES__\n\n\n   half FilterRange(float4 range, float y)\n   {\n      half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));\n      w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));\n      return w;\n   }\n\n   \n   float2 RotateUV(float2 uv, float amt)\n   {\n      uv -=0.5;\n      float s = sin ( amt);\n      float c = cos ( amt );\n      float2x2 mtx = float2x2( c, -s, s, c);\n      mtx *= 0.5;\n      mtx += 0.5;\n      mtx = mtx * 2-1;\n      uv = mul ( uv, mtx );\n      uv += 0.5;\n      return uv;\n   }\n\n\n   half FilterWindParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)\n   {\n      float2 windDir = RotateUV(float2(1, 0), windRot);\n      float2 flow = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));\n      float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill\n      return FilterRange(range, cofacing);\n   }\n\n   half ProcessWindParticulateMask(inout half mask, float contrast)\n   {\n      mask = pow(abs(mask), abs(contrast));\n      half invMask = 1.0 - mask;\n      invMask *= invMask; \n      invMask *= invMask;\n      return invMask;\n   }\n#endif // include guard\n\n   void Ext_SurfaceFunction9 (inout Surface o, ShaderData d)\n   {\n      #if _WIND_ON && !_PASSMETA\n   \n         float3 upVector = float3(0,0,1);\n\n         half upDot = max(0.0, dot(d.worldSpaceNormal, float3(0, 1, 0)));\n\n         float2 uv = d.worldSpacePosition.xz;\n         if (_WindParticulateSpace > 0.5)\n            uv = d.texcoord0.xy;\n         float windRotation = _WindParticulateRotation;\n         float windStrength = _WindParticulateStrength;\n\n         float2 wuv = RotateUV(uv, windRotation);\n\n         half windBlend = 1.0;\n\n         float windWorldMask = FilterRange(_WindParticulateWorldHeightMask, d.worldSpacePosition.y);\n         windWorldMask *= FilterRange(_WindParticulateAngleMask, upDot);\n\n         // compute mask\n         wuv *= float2(_WindParticulate_ST.x, 1) * _WindParticulate_ST.y + _WindParticulate_ST.zw;\n         float speed = _Time.x * _WindParticulateSpeed;\n         half w1 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv * 3 + speed * float2(1,0)).g;\n         half w2 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv + speed * float2(1.1,0)).a;\n         half windMask = (w1 * w2);\n\n         windMask *= windStrength * windBlend * windWorldMask;\n         windMask *= saturate((_WindParticulateTextureHeight - o.Height) * 10);\n\n         half windInvMask = ProcessWindParticulateMask(windMask, _WindParticulatePower);\n    \n         o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);\n         o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindParticulateEmissive.rgb;\n         o.Normal.xy *= windInvMask;\n         o.Smoothness *= windInvMask;\n         o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;\n         o.Metallic *= windInvMask;\n      #endif\n\n   }\n\n\n\n\n\tvoid Ext_SurfaceFunction10 (inout Surface o, ShaderData d)\n\t{\n        if (_DoubleSidedNormalMode == 0)\n        {\n           o.Normal *= d.isFrontFace ? 1 : -1;\n        }\n        else if (_DoubleSidedNormalMode == 1)\n        {\n\t\t   o.Normal.z *= d.isFrontFace ? 1 : -1;\n        }\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction11 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _SURFACEGRADIENT\n\t\t\to.Normal = ResolveNormalFromSurfaceGradient(d, o.Normal);\n\t    #elif _AUTONORMAL\n\t        float3 dx = ddx(d.worldSpacePosition);\n\t\t\tfloat3 dy = ddy(d.worldSpacePosition);\n\t\t\tfloat3 crossX = cross(float3(0,1,0), dx);\n\t\t\tfloat3 crossY = cross(float3(0,1,0), dy);\n\t\t\tfloat3 dt = abs(dot(crossY, dx));\n\t\t\tfloat height = _AutoNormalStrength * 0.5 * o.Alpha;\n\t\t\tfloat3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n\t\t\tn.y *= -1.0;\n\t\t\to.Normal = normalize((dt * float3(0,1,0)) - n).xzy;\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#else\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#endif\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction12 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DEBUG_SAMPLECOUNT\n\t\t\tif (_sampleCount > _DebugSampleCountThreshold)\n\t\t\t{\n\t\t\t\to.Albedo.r = 1;\n\t\t\t\to.Albedo.gb *= 0.2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\to.Albedo.b = 1;\n\t\t\t}\n\n        #endif\n\t}\n\n\n\n\n\tSAMPLER(sampler_DissolveTexture);\n\tTEXTURE2D(_DissolveTexture);\n\tTEXTURE2D(_DissolveGradient);\n\n\tvoid Ext_SurfaceFunction13 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DISSOLVE\n\t\tfloat2 uv = d.texcoord0.xy * _DissolveTexture_ST.xy + _DissolveTexture_ST.zw;\n\t\tfloat2 dx = ddx(uv);\n\t\tfloat2 dy = ddy(uv);\n\n\t\tUNITY_BRANCH\n\t\tif (_DissolveAmount > 0)\n\t\t{\n\t\t\thalf dissolve = SAMPLE_TEXTURE2D_GRAD(_DissolveTexture, sampler_DissolveTexture, uv, dx, dy).g;\n\t\t\thalf cp =  saturate(_DissolveAmount - (dissolve - _DissolveAmount) * _DissolveEdgeContrast) + _DissolveAmount;\n\t\t\thalf cp2 = saturate(1.0 - abs((dissolve - _DissolveAmount) * _DissolveEdgeContrast));\n\t\t\tclip(1.0 - cp);\n\t\t\tfloat2 fuv = float2(cp2, 0.5);\n\t\t\thalf3 col = SAMPLE_TEXTURE2D_LOD(_DissolveGradient, sampler_DissolveTexture, fuv, 0).rgb;\n\t\t\t\t\n\t\t\to.Albedo = lerp(o.Albedo, col, _DissolveColoration * cp2);\n\t\t\to.Emission = lerp(o.Emission, col * _DissolveEmissiveStr, _DissolveColoration * cp2);\n\t\t}\n\t\t#endif\n\t}\n\n\n\n\n    float Dither8x8Bayer( int x, int y )\n    {\n        const float dither[ 64 ] = {\n                1, 49, 13, 61,  4, 52, 16, 64,\n            33, 17, 45, 29, 36, 20, 48, 32,\n                9, 57,  5, 53, 12, 60,  8, 56,\n            41, 25, 37, 21, 44, 28, 40, 24,\n                3, 51, 15, 63,  2, 50, 14, 62,\n            35, 19, 47, 31, 34, 18, 46, 30,\n            11, 59,  7, 55, 10, 58,  6, 54,\n            43, 27, 39, 23, 42, 26, 38, 22};\n        int r = y * 8 + x;\n        return dither[r] / 64; \n    }\n\n    void ApplyDitherCrossFadeVSP(float2 vpos, float fadeValue)\n    {\n        float dither = Dither8x8Bayer( fmod(vpos.x, 8), fmod(vpos.y, 8) );\n        float sgn = fadeValue > 0 ? 1.0f : -1.0f;\n        clip(dither - (1-fadeValue) * sgn);\n    }\n    \n\n\tvoid Ext_SurfaceFunction14 (inout Surface o, ShaderData d)\n\t{\n\t\t#if LOD_FADE_CROSSFADE\n            float4 screenPosNorm = d.screenPos / d.screenPos.w;\n            screenPosNorm.z = ( UNITY_NEAR_CLIP_VALUE >= 0 ) ? screenPosNorm.z : screenPosNorm.z * 0.5 + 0.5;\n            float2 clipScreen = screenPosNorm.xy * _ScreenParams.xy;\n            ApplyDitherCrossFadeVSP(clipScreen,unity_LODFade.x);\n        #endif\n\t}\n\n\n\n\n\n\n// declare outside of CBuffer\n\nfloat4x4 _GlobalVolumeMatrix;\nfloat4x4 _VolumeMatrix;\nfloat3 _VolumeMin;\nfloat3 _VolumeInvSize;\nfloat3 _GlobalVolumeMin;\nfloat3 _GlobalVolumeInvSize;\n\n// I inlined a section of your include. You can use includes in better shaders, but doing it via a subshader or this way\n// is much better. The reason is that this allows your shader to be all inclusive, and packed up for asset store distribition,\n// without requiring specific paths to other files, etc.\n//\n\n#ifndef BAKERY_INCLUDED\n#define BAKERY_INCLUDED\n\n#define BAKERYMODE_DEFAULT 0\n#define BAKERYMODE_VERTEXLM 1.0f\n#define BAKERYMODE_RNM 2.0f\n#define BAKERYMODE_SH 3.0f\n\n\n// can't fit vertexLM SH to sm3_0 interpolators\n#ifndef SHADER_API_D3D11\n    #undef _LIGHTMAPMODE_VERTEXSH\n#endif\n\n// can't do stuff on sm2_0 due to standard shader alrady taking up all instructions\n#if SHADER_TARGET < 30\n    #undef BAKERY_BICUBIC\n    #undef BAKERY_LMSPEC\n\n    #undef _LIGHTMAPMODE_RNM\n    #undef _LIGHTMAPMODE_SH\n    #undef _LIGHTMAPMODE_VERTEX\n#endif\n\n#define lumaConv float3(0.2125f, 0.7154f, 0.0721f)\n\n#ifdef BAKERY_VOLUME\n    #ifdef BAKERY_COMPRESSED_VOLUME\n        Texture3D _Volume3;\n    #endif\n#endif\n\n\nhalf3 LinearToGamma (half3 linRGB)\n{\n    linRGB = max(linRGB, half3(0.h, 0.h, 0.h));\n    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n    return max(1.055h * pow(linRGB, 0.416666667h) - 0.055h, 0.h);\n}\n\nfloat shEvaluateDiffuseL1Geomerics(float L0, float3 L1, float3 n)\n{\n    // average energy\n    float R0 = L0;\n\n    // avg direction of incoming light\n    float3 R1 = 0.5f * L1;\n\n    // directional brightness\n    float lenR1 = length(R1);\n\n    // linear angle between normal and direction 0-1\n    //float q = 0.5f * (1.0f + dot(R1 / lenR1, n));\n    //float q = dot(R1 / lenR1, n) * 0.5 + 0.5;\n    float q = dot(normalize(R1), n) * 0.5 + 0.5;\n\n    // power for q\n    // lerps from 1 (linear) to 3 (cubic) based on directionality\n    float p = 1.0f + 2.0f * lenR1 / R0;\n\n    // dynamic range constant\n    // should vary between 4 (highly directional) and 0 (ambient)\n    float a = (1.0f - lenR1 / R0) / (1.0f + lenR1 / R0);\n\n    return R0 * (a + (1.0f - a) * (p + 1.0f) * pow(q, p));\n}\n\n#ifdef BAKERY_VERTEXLMMASK\n    float4 unpack4NFloats(float src)\n\t{\n        //return fmod(float4(src / 262144.0, src / 4096.0, src / 64.0, src), 64.0)/64.0;\n        return frac(float4(src / (262144.0*64), src / (4096.0*64), src / (64.0*64), src));\n    }\n#endif\n\n#if defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n    float3 unpack3NFloats(float src)\n\t{\n        float r = frac(src);\n        float g = frac(src * 256.0);\n        float b = frac(src * 65536.0);\n        return float3(r, g, b);\n    }\n#endif\n\n// Unity defines these under different names in each SRP, so use our own\ninline float3 Bakery_SafeNormalize(float3 inVec)\n{\n    float dp3 = max(0.001f, dot(inVec, inVec));\n    return inVec * rsqrt(dp3);\n}\n\n#if _URP || _HDRP\n\nfloat SmoothnessToPerceptualRoughness(float smoothness)\n{\n    return (1 - smoothness);\n}\n#endif\n\n#if !_STANDARD\nhalf4 unity_Lightmap_HDR;\ninline half3 DecodeLightmap( half4 color )\n{\n    return DecodeLightmap( color, unity_Lightmap_HDR );\n}\n\n#define UNITY_INV_PI        0.31830988618f\ninline float GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return UNITY_INV_PI * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n    void BakeryVertexLMDirection(inout float3 diffuseColor, inout float3 specularColor, float3 lightDirection, float3 vertexNormalWorld, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 dominantDir = Bakery_SafeNormalize(lightDirection);\n        half halfLambert = dot(normalWorld, dominantDir) * 0.5 + 0.5;\n        half flatNormalHalfLambert = dot(vertexNormalWorld, dominantDir) * 0.5 + 0.5;\n\n        #ifdef BAKERY_LMSPEC\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = spec * diffuseColor;\n        #endif\n\n        diffuseColor *= halfLambert / max(1e-4h, flatNormalHalfLambert);\n    }\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXSH\n    void BakeryVertexLMSH(inout float3 diffuseColor, inout float3 specularColor, float3 shL1x, float3 shL1y, float3 shL1z, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 L0 = diffuseColor;\n        float3 nL1x = shL1x;\n        float3 nL1y = shL1y;\n        float3 nL1z = shL1z;\n        float3 L1x = nL1x * L0 * 2;\n        float3 L1y = nL1y * L0 * 2;\n        float3 L1z = nL1z * L0 * 2;\n\n        float3 sh;\n    #if BAKERY_SHNONLINEAR\n        //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n        //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n        //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n        float lumaL0 = dot(L0, 1);\n        float lumaL1x = dot(L1x, 1);\n        float lumaL1y = dot(L1y, 1);\n        float lumaL1z = dot(L1z, 1);\n        float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n        float regularLumaSH = dot(sh, 1);\n        //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n        sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    #else\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    #endif\n\n        diffuseColor = max(sh, 0.0);\n\n        #ifdef BAKERY_LMSPEC\n            float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n            float focus = saturate(length(dominantDir));\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = max(spec * sh, 0.0);\n        #endif\n    }\n#endif\n\n\n\n#ifdef BAKERY_BICUBIC\nfloat BakeryBicubic_w0(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-a + 3.0f) - 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w1(float a)\n{\n    return (1.0f/6.0f)*(a*a*(3.0f*a - 6.0f) + 4.0f);\n}\n\nfloat BakeryBicubic_w2(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-3.0f*a + 3.0f) + 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w3(float a)\n{\n    return (1.0f/6.0f)*(a*a*a);\n}\n\nfloat BakeryBicubic_g0(float a)\n{\n    return BakeryBicubic_w0(a) + BakeryBicubic_w1(a);\n}\n\nfloat BakeryBicubic_g1(float a)\n{\n    return BakeryBicubic_w2(a) + BakeryBicubic_w3(a);\n}\n\nfloat BakeryBicubic_h0(float a)\n{\n    return -1.0f + BakeryBicubic_w1(a) / (BakeryBicubic_w0(a) + BakeryBicubic_w1(a)) + 0.5f;\n}\n\nfloat BakeryBicubic_h1(float a)\n{\n    return 1.0f + BakeryBicubic_w3(a) / (BakeryBicubic_w2(a) + BakeryBicubic_w3(a)) + 0.5f;\n}\n#endif\n\n\n#if defined(_LIGHTMAPMODE_RNM) || defined(_LIGHTMAPMODE_SH)\nTexture2D _RNM0, _RNM1, _RNM2;\n#endif\n\n#ifdef BAKERY_VOLUME\nTexture3D _Volume0, _Volume1, _Volume2, _VolumeMask;\nSamplerState sampler_Volume0;\n#endif\n\n#if defined(BAKERY_BICUBIC) && defined(LIGHTMAP_ON) && defined(SHADER_API_D3D11)\n    // Bicubic\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\tfloat width, height;\n\t\ttex.GetDimensions(width, height);\n\t\tfloat texelSize = 1.0f / width;\n\n        float x = uv.x * width;\n        float y = uv.y * width;\n\n        x -= 0.5f;\n        y -= 0.5f;\n\n        float px = floor(x);\n        float py = floor(y);\n\n        float fx = x - px;\n        float fy = y - py;\n\n        float g0x = BakeryBicubic_g0(fx);\n        float g1x = BakeryBicubic_g1(fx);\n        float h0x = BakeryBicubic_h0(fx);\n        float h1x = BakeryBicubic_h1(fx);\n        float h0y = BakeryBicubic_h0(fy);\n        float h1y = BakeryBicubic_h1(fy);\n\n        return     BakeryBicubic_g0(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h0y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h0y) * texelSize))) +\n\n                   BakeryBicubic_g1(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h1y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h1y) * texelSize)));\n    }\n#else\n    // Bilinear\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\t#ifdef LIGHTMAP_ON\n\t\t\treturn tex.Sample(samplerunity_Lightmap, uv);\n\t\t#else\n\t\t\treturn float4(1,0,0,1);\n\t\t#endif\n    }\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\n#ifdef BAKERY_LMSPEC\nfloat BakeryDirectionalLightmapSpecular(float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 dominantDir = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap, lmUV).xyz * 2 - 1;\n    half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n    half nh = saturate(dot(normalWorld, halfDir));\n    half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n    half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n    half spec = GGXTerm(nh, roughness);\n    return spec;\n}\n#endif\n#endif\n\n\n\n#ifdef _LIGHTMAPMODE_RNM\nvoid BakeryRNM(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalMap, float smoothness, float3 viewDirT)\n{\n    const float3 rnmBasis0 = float3(0.816496580927726f, 0, 0.5773502691896258f);\n    const float3 rnmBasis1 = float3(-0.4082482904638631f, 0.7071067811865475f, 0.5773502691896258f);\n    const float3 rnmBasis2 = float3(-0.4082482904638631f, -0.7071067811865475f, 0.5773502691896258f);\n\n    float3 rnm0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 rnm1 = DecodeLightmap(BakeryTex2D(_RNM1, lmUV));\n    float3 rnm2 = DecodeLightmap(BakeryTex2D(_RNM2, lmUV));\n\n    #ifdef BAKERY_SSBUMP\n        diffuseColor = normalMap.x * rnm0\n                     + normalMap.z * rnm1\n                     + normalMap.y * rnm2;\n         diffuseColor *= 2;\n    #else\n        diffuseColor = saturate(dot(rnmBasis0, normalMap)) * rnm0\n                     + saturate(dot(rnmBasis1, normalMap)) * rnm1\n                     + saturate(dot(rnmBasis2, normalMap)) * rnm2;\n    #endif\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDirT = rnmBasis0 * dot(rnm0, lumaConv) +\n                              rnmBasis1 * dot(rnm1, lumaConv) +\n                              rnmBasis2 * dot(rnm2, lumaConv);\n\n        float3 dominantDirTN = normalize(dominantDirT);\n        float3 specColor = saturate(dot(rnmBasis0, dominantDirTN)) * rnm0 +\n                           saturate(dot(rnmBasis1, dominantDirTN)) * rnm1 +\n                           saturate(dot(rnmBasis2, dominantDirTN)) * rnm2;\n\n        half3 halfDir = Bakery_SafeNormalize(dominantDirTN - viewDirT);\n        half nh = saturate(dot(normalMap, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n        specularColor = spec * specColor;\n    #endif\n}\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\ninline half3 Unity_DecodeDirectionalLightmap(half3 color, half4 dirTex, half3 normalWorld)\n{\n    // In directional (non-specular) mode Enlighten bakes dominant light direction\n    // in a way, that using it for half Lambert and then dividing by a \"rebalancing coefficient\"\n    // gives a result close to plain diffuse response lightmaps, but normalmapped.\n\n    // Note that dir is not unit length on purpose. Its length is \"directionality\", like\n    // for the directional specular lightmaps.\n\n    half halfLambert = dot(normalWorld, dirTex.xyz - 0.5) + 0.5;\n\n    return color * halfLambert / max(1e-4h, dirTex.w);\n}\n#endif\n\n#ifdef _LIGHTMAPMODE_SH\nvoid BakerySH(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 L0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 nL1x = BakeryTex2D(_RNM0, lmUV) * 2 - 1;\n    float3 nL1y = BakeryTex2D(_RNM1, lmUV) * 2 - 1;\n    float3 nL1z = BakeryTex2D(_RNM2, lmUV) * 2 - 1;\n    float3 L1x = nL1x * L0 * 2;\n    float3 L1y = nL1y * L0 * 2;\n    float3 L1z = nL1z * L0 * 2;\n\n    float3 sh;\n#if BAKERY_SHNONLINEAR\n    float lumaL0 = dot(L0, 1);\n    float lumaL1x = dot(L1x, 1);\n    float lumaL1y = dot(L1y, 1);\n    float lumaL1z = dot(L1z, 1);\n    float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    float regularLumaSH = dot(sh, 1);\n    //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n    sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n    //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n    //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n#else\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n#endif\n\n    diffuseColor = max(sh, 0.0);\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n        float focus = saturate(length(dominantDir));\n        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n        half nh = saturate(dot(normalWorld, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n\n        sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n\n        specularColor = max(spec * sh, 0.0);\n    #endif\n}\n#endif\n\n#endif // include guards\n\n\n    void Ext_ModifyVertex15 (inout VertexData v, inout ExtraV2F e)\n    {\n        #if _USEBAKERY\n\t\t    #if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\t\t\t    // Unpack from RGBM\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.a * 8.0f;\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.rgb;\n\n\t\t\t    #ifdef BAKERY_VERTEXLMMASK\n\t\t\t\t    e.extraV2F4.xyzw = unpack4NFloats(v.texcoord1);\n\t\t\t    #endif\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXSH\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n                e.extraV2F6.xyz = unpack3NFloats(v.texcoord3.x) * 2 - 1;\n                e.extraV2F7.xyz = unpack3NFloats(v.texcoord3.y) * 2 - 1;\n            #endif\n       #endif\n    }\n\n#if _HDRP || _URP\n    half3 SHEvalLinearL0L1 (half4 normal)\n    {\n        half3 x;\n\n        // Linear (L1) + constant (L0) polynomial terms\n        x.r = dot(unity_SHAr,normal);\n        x.g = dot(unity_SHAg,normal);\n        x.b = dot(unity_SHAb,normal);\n\n        return x;\n    }\n\n    // normal should be normalized, w=1.0\n    half3 SHEvalLinearL2 (half4 normal)\n    {\n        half3 x1, x2;\n        // 4 of the quadratic (L2) polynomials\n        half4 vB = normal.xyzz * normal.yzzx;\n        x1.r = dot(unity_SHBr,vB);\n        x1.g = dot(unity_SHBg,vB);\n        x1.b = dot(unity_SHBb,vB);\n\n        // Final (5th) quadratic (L2) polynomial\n        half vC = normal.x*normal.x - normal.y*normal.y;\n        x2 = unity_SHC.rgb * vC;\n\n        return x1 + x2;\n    }\n\n    half3 ShadeSH9 (half4 normal)\n    {\n        // Linear + constant polynomial terms\n        half3 res = SHEvalLinearL0L1 (normal);\n\n        // Quadratic polynomials\n        res += SHEvalLinearL2 (normal);\n\n        #ifdef UNITY_COLORSPACE_GAMMA\n            res = LinearToGamma (res);\n        #endif\n\n        return res;\n\n    }\n#endif\n\n\n\n\tvoid DoBakeryStuff(inout float3 indDif, inout float3 indSpec, inout float4 shadowmask, float3 tangentNormal, float smoothness, ShaderData d)\n\t{\n\t\t// Quality!\n\t\tindDif = 1;\n\t\tindSpec = 0;\n\n        #if defined(_PASSFORWARD) || defined(_PASSGBUFFER) // forward pass on URP/Standard/HDRP + built-in deferred\n\n            float3 normalWorld = mul(tangentNormal, d.TBNMatrix);\n\n\t\t\t#ifdef LIGHTMAP_ON\n\n                // Static\n\n\t\t\t\tfloat2 lmUV = d.texcoord1 * unity_LightmapST.xy + unity_LightmapST.zw;\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_STANDARD\n\t\t\t\t\tindDif = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n\n\t\t\t\t\t#ifdef DIRLIGHTMAP_COMBINED\n\t\t\t\t\t\tfloat4 dirMap = BakeryTex2D(unity_LightmapInd, lmUV);\n\t\t\t\t\t\tindDif = Unity_DecodeDirectionalLightmap(indDif, dirMap, normalWorld);\n\n\t\t\t\t\t\t#ifdef BAKERY_LMSPEC\n\t\t\t\t\t\t\tindSpec = BakeryDirectionalLightmapSpecular(lmUV, normalWorld, -d.worldSpaceViewDir, smoothness) * indDif;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\n\t\t\t\t\tindDif = d.vertexColor;\n\n                    #ifdef BAKERY_VERTEXLMMASK\n                        shadowmask = d.extraV2F4;\n                    #endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n\t\t\t\t\t\t// worldSpaceNormal is per-vertex\n\t\t\t\t\t\t// normalWorld is per-pixel\n\t\t\t\t\t\tfloat3 bakedLightDirection = d.extraV2F5;\n\t\t\t\t\t\tBakeryVertexLMDirection(indDif, indSpec, bakedLightDirection, d.worldSpaceNormal, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXSH\n\t\t\t\t\t\tBakeryVertexLMSH(indDif, indSpec, d.extraV2F5, d.extraV2F6, d.extraV2F7, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_RNM\n\t\t\t\t\tBakeryRNM(indDif, indSpec, lmUV, tangentNormal, smoothness, -d.tangentSpaceViewDir);\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_SH\n\t\t\t\t\tBakerySH(indDif, indSpec, lmUV, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t#endif\n\n            #else\n\n                // Dynamic\n\n                #ifdef BAKERY_VOLUME\n\n                    bool isGlobal = dot(abs(_VolumeInvSize),1) == 0;\n                    float3 volViewDir = -d.worldSpaceViewDir;\n                    #ifdef BAKERY_VOLROTATION\n                        float4x4 volMatrix = (isGlobal ? _GlobalVolumeMatrix : _VolumeMatrix);\n                        float3 volInvSize = (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 lpUV = mul(volMatrix, float4(d.worldSpacePosition,1)).xyz * volInvSize + 0.5f;\n                        float3 volNormal = mul((float3x3)volMatrix, normalWorld);\n                        #ifdef BAKERY_LMSPEC\n                            volViewDir = mul((float3x3)volMatrix, volViewDir);\n                        #endif\n                    #else\n                        float3 lpUV = (d.worldSpacePosition - (isGlobal ? _GlobalVolumeMin : _VolumeMin)) * (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 volNormal = normalWorld;\n                    #endif\n\n                    #ifdef BAKERY_COMPRESSED_VOLUME\n                        float4 tex0, tex1, tex2, tex3;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex3 = _Volume3.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz * L0;\n                        L1y = tex2.xyz * L0;\n                        L1z = tex3.xyz * L0;\n                    #else\n                        float4 tex0, tex1, tex2;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV);\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV);\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz;\n                        L1y = tex2.xyz;\n                        L1z = float3(tex0.w, tex1.w, tex2.w);\n                    #endif\n                    indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), volNormal);\n                    indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), volNormal);\n                    indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), volNormal);\n\n                    #ifdef UNITY_COLORSPACE_GAMMA\n                        indDif = pow(indDif, 1.0f / 2.2f);\n                    #endif\n\n                    #ifdef BAKERY_LMSPEC\n                        float3 nL1x = L1x / L0;\n                        float3 nL1y = L1y / L0;\n                        float3 nL1z = L1z / L0;\n                        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n                        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - volViewDir);\n                        half nh = saturate(dot(volNormal, halfDir));\n                        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n                        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n                        half spec = GGXTerm(nh, roughness);\n                        float3 sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n                        indSpec = max(spec * sh, 0.0);\n                    #endif\n\n                    shadowmask = _VolumeMask.Sample(sampler_Volume0, lpUV);\n\n                #else\n\n                    #ifdef BAKERY_SHNONLINEAR\n                        float3 L0 = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);\n                        indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, unity_SHAr.xyz, normalWorld);\n                        indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, unity_SHAg.xyz, normalWorld);\n                        indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, unity_SHAb.xyz, normalWorld);\n                    #else\n                        indDif = ShadeSH9(float4(normalWorld,1));\n                    #endif\n\n                #endif\n\n\t\t\t#endif\n\n        #endif\n\t}\n\n\t// this is the main surface function. Surface is like a surface shader output structure, but\n\t// with our new outputs as well.\n\tvoid Ext_SurfaceFunction15 (inout Surface o, ShaderData d)\n\t{\n        #if _USEBAKERY\n\t\t    float3 indDif;\n\t\t    float3 indSpec;\n            float4 shadowmask = 1;\n\t\t    DoBakeryStuff(indDif, indSpec, shadowmask, o.Normal, o.Smoothness, d);\n\t\t    o.DiffuseGI = indDif;\n\t\t    o.BackDiffuseGI = indDif;\n\t\t    o.SpecularGI = indSpec;\n            o.ShadowMask = shadowmask;\n        #endif\n\t}\n\n\n\n\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                  Ext_SurfaceFunction1(l, d);\n                  Ext_SurfaceFunction2(l, d);\n                  Ext_SurfaceFunction3(l, d);\n                  Ext_SurfaceFunction4(l, d);\n                  Ext_SurfaceFunction5(l, d);\n                  Ext_SurfaceFunction6(l, d);\n                  Ext_SurfaceFunction7(l, d);\n                  Ext_SurfaceFunction8(l, d);\n                  Ext_SurfaceFunction9(l, d);\n\t\t            Ext_SurfaceFunction10(l, d);\n                  Ext_SurfaceFunction11(l, d);\n                  Ext_SurfaceFunction12(l, d);\n                  Ext_SurfaceFunction13(l, d);\n                  Ext_SurfaceFunction14(l, d);\n                  Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraV2F d;\n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                  Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                  Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                  #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                  v2p.extraV2F4 = d.extraV2F4;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                  v2p.extraV2F5 = d.extraV2F5;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F6 = d.extraV2F6;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F7 = d.extraV2F7;\n                  #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                d.extraV2F4 = v2p.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                d.extraV2F5 = v2p.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F6 = v2p.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F7 = v2p.extraV2F7;\n                #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n                Ext_ModifyTessellatedVertex2(v, d);\n                Ext_ModifyTessellatedVertex3(v, d);\n                Ext_ModifyTessellatedVertex4(v, d);\n                Ext_ModifyTessellatedVertex5(v, d);\n                Ext_ModifyTessellatedVertex6(v, d);\n                Ext_ModifyTessellatedVertex7(v, d);\n                Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                v2p.extraV2F4 = d.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                v2p.extraV2F5 = d.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F6 = d.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F7 = d.extraV2F7;\n                #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n            // d.texcoord3 = i.texcoord3;\n             #endif\n\n             d.isFrontFace = facing;\n             #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n             d.vertexColor = i.vertexColor;\n             #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(i.worldPos, 1)).xyz;\n            #endif\n             d.localSpaceNormal = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n             #if LOD_FADE_CROSSFADE\n             d.screenPos = i.screenPos;\n             d.screenUV = (i.screenPos.xy / i.screenPos.w);\n             #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n             #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n             d.extraV2F4 = i.extraV2F4;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n             d.extraV2F5 = i.extraV2F5;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F6 = i.extraV2F6;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F7 = i.extraV2F7;\n             #endif\n\n            return d;\n         }\n         \n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n   #ifdef VARYINGS_NEED_POSITION_WS\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex);\n   #endif\n\n   #ifdef VARYINGS_NEED_TANGENT_TO_WORLD\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n   #endif\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n        #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n       // output.texcoord3 = inputMesh.texcoord3;\n        #endif\n        #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n        output.vertexColor = inputMesh.vertexColor;\n        #endif\n\n       return output;\n   }\n#else\n\n   #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n    \n       ChainModifyVertex(input, output);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n        #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n       // output.texcoord3 = input.texcoord3;\n        #endif\n\n        #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n        output.vertexColor = input.vertexColor;\n        #endif\n\n        #if LOD_FADE_CROSSFADE\n        output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n        #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(output.worldPos.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? input.previousPositionOS : input.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n\n            VertexData previousMesh = input;\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            // Remap time to old time\n            float4 oldTime = _Time;\n            _Time.y = _LastTimeParameters.x;\n            _Time.x = _LastTimeParameters.x / 20;\n            _Time.z = _LastTimeParameters.x * 2;\n            _Time.w = _LastTimeParameters.x * 3;\n            ChainModifyVertex(previousMesh, dummy);\n            _Time = oldTime;\n\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = output.worldPos.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n            \n                    output.positionRWS = input.worldPos;\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n            \n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n                    #if defined(_ENABLE_SHADOW_MATTE) && SHADERPASS == SHADERPASS_FORWARD_UNLIT\n                        HDShadowContext shadowContext = InitShadowContext();\n                        float shadow;\n                        float3 shadow3;\n                        // We need to recompute some coordinate not computed by default for shadow matte\n                        posInput = GetPositionInput(fragInputs.positionSS.xy, _ScreenSize.zw, fragInputs.positionSS.z, UNITY_MATRIX_I_VP, GetWorldToViewMatrix());\n                        float3 upWS = normalize(fragInputs.tangentToWorld[1]);\n                        uint renderingLayers = GetMeshRenderingLightLayer();\n                        ShadowLoopMin(shadowContext, posInput, upWS, asuint(_ShadowMatteFilter), renderingLayers, shadow3);\n                        shadow = dot(shadow3, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));\n                \n                        float4 shadowColor = (1.0 - shadow) * surfaceDescription.ShadowTint.rgba;\n                        float  localAlpha  = saturate(shadowColor.a + surfaceDescription.Alpha);\n                \n                        // Keep the nested lerp\n                        // With no Color (bsdfData.color.rgb, bsdfData.color.a == 0.0f), just use ShadowColor*Color to avoid a ring of \"white\" around the shadow\n                        // And mix color to consider the Color & ShadowColor alpha (from texture or/and color picker)\n                        #ifdef _SURFACE_TYPE_TRANSPARENT\n                            surfaceData.baseColor = lerp(shadowColor.rgb * surfaceData.baseColor, lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow), surfaceDescription.Alpha);\n                        #else\n                            surfaceData.baseColor = lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow);\n                        #endif\n                        localAlpha = ApplyBlendMode(surfaceData.baseColor, localAlpha).a;\n                \n                        surfaceDescription.Alpha = localAlpha;\n                    #endif\n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n                \n\n                   // tangent-space normal\n                   float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                   normalTS = surfaceDescription.Normal;\n        \n                   // compute world space normal\n                   #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(normalTS, fragInputs.tangentToWorld);\n                   #else\n                      surfaceData.normalWS = normalTS;\n                   #endif\n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                    #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                \n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2], alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                    #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 //builtinData.vtPackedFeedback = surfaceDescription.VTPackedFeedback;\n        \n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     //builtinData.distortion = surfaceData.Distortion;\n                     //builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n\n\n\n#define DEBUG_DISPLAY\n#include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n#include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/FullScreenDebug.hlsl\"\n\n         #if !defined(_DEPTHOFFSET_ON)\n         [earlydepthstencil] // quad overshading debug mode writes to UAV\n         #endif\n         void Frag(VertexToPixel v2f\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n         )\n         {\n             UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2f);\n             FragInputs input = BuildFragInputs(v2f);\n\n             PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS.xyz);\n\n         #ifdef PLATFORM_SUPPORTS_PRIMITIVE_ID_IN_PIXEL_SHADER\n             if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_QUAD_OVERDRAW)\n             {\n                 IncrementQuadOverdrawCounter(posInput.positionSS.xy, input.primitiveID);\n             }\n         #endif\n         }\n\n            ENDHLSL\n        }\n\n      \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      \n   }\n\n   \n   \n   CustomEditor \"JBooth.BetterLit.LitBaseMaterialEditor\"\n}\n"},{"srpTarget":1,"UnityVersionMin":20202,"UnityVersionMax":30000,"shader":{"instanceID":0},"shaderSrc":"////////////////////////////////////////\n// Generated with Better Shaders\n//\n// Auto-generated shader code, don't hand edit!\n//\n//   Unity Version: 2020.3.0f1\n//   Render Pipeline: URP2020\n//   Platform: OSXEditor\n////////////////////////////////////////\n\n\nShader \"Hidden/Better Lit/Lit Alpha\"\n{\n   Properties\n   {\n      [HideInInspector][NoScaleOffset]unity_Lightmaps(\"unity_Lightmaps\", 2DArray) = \"\" {}\n      [HideInInspector][NoScaleOffset]unity_LightmapsInd(\"unity_LightmapsInd\", 2DArray) = \"\" {}\n      [HideInInspector][NoScaleOffset]unity_ShadowMasks(\"unity_ShadowMasks\", 2DArray) = \"\" {}\n      \n   [HideInInspector]_NoiseTex(\"Noise Texture\", 2D) = \"black\" {}\n\n\n    [HideInInspector]_MainTex(\"Unity Standard Shader Hack Property\", 2D) = \"white\" {} // use this to do material conversion.\n    [HideInInspector]_BaseColor(\"Unity HDRP/URP Shader Hack Property\", 2D) = \"white\" {} // use this to do material conversion.\n    [HideInInspector]_BumpMap(\"Unity Standard Shader Hack Property\", 2D) = \"bump\" {} // use this to do material conversion.\n    [HideInInspector]_IsConverted(\"Have we done one time conversion yet?\", Float) = 0\n    \n    _TriplanarSpace (\"Triplanar Space\", Float) = 0\n    _TriplanarContrast (\"Triplanar Contrast\", Range(1, 10)) = 4\n    _UVSource(\"UV Source\", Float) = 0\n    _AlbedoMap(\"Albedo/Height\", 2D) = \"white\" {}\n    _Tint (\"Tint\", Color) = (1, 1, 1, 1)\n    _AlbedoBrightness(\"Brightness\", Range(-1, 1)) = 0\n    _AlbedoContrast(\"Contrast\", Range(0,2)) = 1\n    _AlphaThreshold(\"Alpha Threshold\", Range(0,1)) = 0.0\n    _Cutoff(\"Unity Lightmapper sucks\", Range(0, 1)) = 0.0\n    _NormalMap(\"Normal\", 2D) = \"bump\" {}\n    _NormalStrength(\"Normal Strength\", Range(0,2)) = 1\n    \n    _MaskMap(\"Mask Map\", 2D) = \"black\" {}\n    _Smoothness(\"Smoothness\", Range(0,1)) = 0\n    _Metallic(\"Metallic\", Range(0,1)) = 0\n    _SpecularMap(\"Specular Map\", 2D) = \"black\" {}\n\n    _EmissionMap(\"Emission Map\", 2D) = \"black\" {}\n    _EmissionColor(\"Emission Strength\", Color) = (0,0,0,0)\n\n    _SmoothnessRemap(\"Smoothness Remap\", Vector) = (0, 1, 0, 0)\n    _AORemap(\"AO Remap\", Vector) = (0, 1, 0, 0)\n    _MetallicRemap(\"Metallic Remap\", Vector) = (0, 1, 0, 0)\n    _HeightRemap(\"Height Remap\", Vector) = (0, 1, 0, 0)\n\n    _DetailUVSource(\"Detail UV Source\", Float) = 0\n    _DetailMap(\"Detail Map\", 2D) = \"white\" {}\n    _DetailAlbedoStrength(\"Detail Albedo Strength\", Range(0, 2)) = 1\n    _DetailNormalStrength(\"Detail Normal Strength\", Range(0, 2)) = 1\n    _DetailSmoothnessStrength(\"Detail Smoothness Strength\", Range(0, 2)) = 1\n    _DetailTriplanarSpace (\"Triplanar Space\", Float) = 0\n    _DetailTriplanarContrast (\"Triplanar Contrast\", Range(1, 10)) = 4\n    _DetailStochasticContrast(\"Stochastic Contrast\", Range(0.01,0.999)) = 0.7\n    _DetailStochasticScale(\"Stochastic Contrast\", Range(0.2,1.5)) = 0.5\n    _FlatShadingBlend(\"Flat Shading Blend\", Range(0,4)) = 1\n    _StochasticContrast(\"Stochastic Contrast\", Range(0.01,0.999)) = 0.7\n    _StochasticScale(\"Stochastic Contrast\", Range(0.2,1.5)) = 0.5\n    _ParallaxHeight(\"Parallax Height\", Range(0, 0.25)) = 0\n\n    _MicroShadowStrength(\"Micro Shadow Strength\", Range(0, 2)) = 0\n    _FuzzyShadingOn(\"FuzzyShadingToggle\", Float) = 0\n    _FuzzyShadingColor(\"Fuzzy Shading Color\", Color) = (1,1,1,1)\n    _FuzzyShadingParams(\"Fuzzy Shading Params\", Vector) = (0.3,1,1.5,1) // coreMult, edgeMult, power\n\n    //_POMMaxSamples (\"POM Max Samples\", Range(4, 32)) = 8\n    //_POMMin (\"POM Min Distance\", Float) = 25\n    //_POMFade (\"Pom Fade Range\", Float) = 25\n\n\n\n\t_TintMask(\"Tint Mask\", 2D) = \"white\" {}\n\t_RColor(\"R Color\", Color) = (0.5,0.5,0.5,1)\n\t_GColor(\"G Color\", Color) = (0.5,0.5,0.5,1)\n\t_BColor(\"B Color\", Color) = (0.5,0.5,0.5,1)\n\t_AColor(\"A Color\", Color) = (0.5,0.5,0.5,1)\n\n\n\t_LayerTextureMask(\"Layer Texture Mask\", 2D) = \"white\" {}\n    _LayerTextureMaskUVMode(\"Layer Texture Mask UV Mode\", Float) = 0\n\n\n\t_LayerUVSource(\"Detail UV Source\", Float) = 0\n    [Enum(Multiply2X, 0, AlphaBlend, 1, HeightBlend, 2)]_LayerBlendMode(\"Layer Blend Mode\", Float) = 0\n    _LayerStrength(\"Layer Strength\", Range(0,2)) = 1\n    _LayerAlbedoStrength(\"Detail Albedo Strength\", Range(0, 2)) = 1\n    _LayerNormalStrength(\"Detail Normal Strength\", Range(0, 2)) = 1\n    _LayerSmoothnessRemap(\"Smoothness Remap\", Vector) = (0, 1, 0, 0)\n    _LayerAORemap(\"Occlusion Remap\", Vector) = (0, 1, 0, 0)\n    _LayerMetallicRemap(\"Metallic Remap\", Vector) = (0, 1, 0, 0)\n    _LayerSmoothness(\"Smoothness\", Range(0,1)) = 0\n    _LayerSmoothnessStrength(\"Smoothness Strength\", Range(0,1)) = 1\n    _LayerHeightRemap(\"Height Remap\", Vector) = (0, 1, 0, 0)\n    _LayerHeightContrast(\"Height Contrast\", Range(0.01, 0.99)) = 0.5\n    _LayerMetallic(\"Metallic\", Range(0,1)) = 0\n    _LayerScale(\"Detail UV Scale\", Float) = 3\n    _LayerTriplanarSpace (\"Triplanar Space\", Float) = 0\n    _LayerTriplanarContrast (\"Triplanar Contrast\", Range(1, 10)) = 4\n    _LayerAlbedoMap(\"Albedo/Height\", 2D) = \"white\" {}\n    _LayerNormalMap(\"Normal\", 2D) = \"bump\" {}\n    _LayerMaskMap(\"Mask Map\", 2D) = \"black\" {}\n    _LayerNoiseFrequency(\"Noise Frequency\", Float) = 1\n    _LayerNoiseAmplitude(\"Noise Amplitude\", Range(0,10)) = 0.5\n    _LayerNoiseOffset(\"Noise Offset\", Float) = 0\n    _LayerNoiseCenter(\"Noise Center\", Range(-5, 5)) = 0\n    _LayerStochasticContrast(\"Stochastic Contrast\", Range(0.01,0.999)) = 0.7\n    _LayerStochasticScale(\"Stochastic Scale\", Range(0.2,1.5)) = 0.5\n    _LayerBlendTint(\"Layer Blend Tint\", Color) = (1,1,1,1)\n    _LayerBlendContrast(\"Layer Blend Contrast\", Range(0.5, 8)) = 2\n    _LayerTint(\"Layer Tint\", Color) = (1,1,1,1)\n    _LayerAlbedoBrightness(\"Layer Brightness\", Range(-1, 1)) = 0\n    _LayerAlbedoContrast(\"Layer Contrast\", Range(0, 2)) = 1\n    _LayerEmissionMap(\"Layer Emission Map\", 2D) = \"black\" {}\n    _LayerEmissionColor(\"Layer Emission Multiplier\", Color) = (0,0,0,0)\n    _LayerAngleMin(\"Angle Minimum\", Range(0,1)) = 0.1\n    _LayerVertexNormalBlend(\"Vertex->Normal Filter\", Range(0,1)) = 0.8\n    _LayerHeight(\"Height Filter\", Range(0,1)) = 0\n    [Enum(Top,0,Bottom,1)] _LayerInvertHeight (\"Layer on\", Float) = 0\n    _LayerFalloff(\"Angle Falloff Contrast\", Range(2, 40)) = 8\n    _LayerTessStrength(\"Displacement Strength\", Range(0,1)) = 1\n    _LayerWeightOverDistance(\"Weight Over Distance\", Vector) = (1,1,1,1) // start distance/weight, end fade range/weight\n    _LayerMicroShadowStrength(\"Micro Shadow Strength\", Range(0,2)) = 0\n    _LayerFuzzyShadingOn(\"FuzzyShadingToggle\", Float) = 0\n    _LayerFuzzyShadingColor(\"Fuzzy Shading Color\", Color) = (1,1,1,1)\n    _LayerFuzzyShadingParams(\"Fuzzy Shading Params\", Vector) = (0.3,1,1.5,1) // coreMult, edgeMult, power\n\n\n\n\n\t_LayerUVSource_Ext_1(\"Detail UV Source\", Float) = 0\n    [Enum(Multiply2X, 0, AlphaBlend, 1, HeightBlend, 2)]_LayerBlendMode_Ext_1(\"Layer Blend Mode\", Float) = 0\n    _LayerStrength_Ext_1(\"Layer Strength\", Range(0,2)) = 1\n    _LayerAlbedoStrength_Ext_1(\"Detail Albedo Strength\", Range(0, 2)) = 1\n    _LayerNormalStrength_Ext_1(\"Detail Normal Strength\", Range(0, 2)) = 1\n    _LayerSmoothnessRemap_Ext_1(\"Smoothness Remap\", Vector) = (0, 1, 0, 0)\n    _LayerAORemap_Ext_1(\"Occlusion Remap\", Vector) = (0, 1, 0, 0)\n    _LayerMetallicRemap_Ext_1(\"Metallic Remap\", Vector) = (0, 1, 0, 0)\n    _LayerSmoothness_Ext_1(\"Smoothness\", Range(0,1)) = 0\n    _LayerSmoothnessStrength_Ext_1(\"Smoothness Strength\", Range(0,1)) = 1\n    _LayerHeightRemap_Ext_1(\"Height Remap\", Vector) = (0, 1, 0, 0)\n    _LayerHeightContrast_Ext_1(\"Height Contrast\", Range(0.01, 0.99)) = 0.5\n    _LayerMetallic_Ext_1(\"Metallic\", Range(0,1)) = 0\n    _LayerScale_Ext_1(\"Detail UV Scale\", Float) = 3\n    _LayerTriplanarSpace_Ext_1 (\"Triplanar Space\", Float) = 0\n    _LayerTriplanarContrast_Ext_1 (\"Triplanar Contrast\", Range(1, 10)) = 4\n    _LayerAlbedoMap_Ext_1(\"Albedo/Height\", 2D) = \"white\" {}\n    _LayerNormalMap_Ext_1(\"Normal\", 2D) = \"bump\" {}\n    _LayerMaskMap_Ext_1(\"Mask Map\", 2D) = \"black\" {}\n    _LayerNoiseFrequency_Ext_1(\"Noise Frequency\", Float) = 1\n    _LayerNoiseAmplitude_Ext_1(\"Noise Amplitude\", Range(0,10)) = 0.5\n    _LayerNoiseOffset_Ext_1(\"Noise Offset\", Float) = 0\n    _LayerNoiseCenter_Ext_1(\"Noise Center\", Range(-5, 5)) = 0\n    _LayerStochasticContrast_Ext_1(\"Stochastic Contrast\", Range(0.01,0.999)) = 0.7\n    _LayerStochasticScale_Ext_1(\"Stochastic Scale\", Range(0.2,1.5)) = 0.5\n    _LayerBlendTint_Ext_1(\"Layer Blend Tint\", Color) = (1,1,1,1)\n    _LayerBlendContrast_Ext_1(\"Layer Blend Contrast\", Range(0.5, 8)) = 2\n    _LayerTint_Ext_1(\"Layer Tint\", Color) = (1,1,1,1)\n    _LayerAlbedoBrightness_Ext_1(\"Layer Brightness\", Range(-1, 1)) = 0\n    _LayerAlbedoContrast_Ext_1(\"Layer Contrast\", Range(0, 2)) = 1\n    _LayerEmissionMap_Ext_1(\"Layer Emission Map\", 2D) = \"black\" {}\n    _LayerEmissionColor_Ext_1(\"Layer Emission Multiplier\", Color) = (0,0,0,0)\n    _LayerAngleMin_Ext_1(\"Angle Minimum\", Range(0,1)) = 0.1\n    _LayerVertexNormalBlend_Ext_1(\"Vertex->Normal Filter\", Range(0,1)) = 0.8\n    _LayerHeight_Ext_1(\"Height Filter\", Range(0,1)) = 0\n    [Enum(Top,0,Bottom,1)] _LayerInvertHeight_Ext_1 (\"Layer on\", Float) = 0\n    _LayerFalloff_Ext_1(\"Angle Falloff Contrast\", Range(2, 40)) = 8\n    _LayerTessStrength_Ext_1(\"Displacement Strength\", Range(0,1)) = 1\n    _LayerWeightOverDistance_Ext_1(\"Weight Over Distance\", Vector) = (1,1,1,1) // start distance/weight, end fade range/weight\n    _LayerMicroShadowStrength_Ext_1(\"Micro Shadow Strength\", Range(0,2)) = 0\n    _LayerFuzzyShadingOn_Ext_1(\"FuzzyShadingToggle\", Float) = 0\n    _LayerFuzzyShadingColor_Ext_1(\"Fuzzy Shading Color\", Color) = (1,1,1,1)\n    _LayerFuzzyShadingParams_Ext_1(\"Fuzzy Shading Params\", Vector) = (0.3,1,1.5,1) // coreMult, edgeMult, power\n\n\n\n\n\t_LayerUVSource_Ext_2(\"Detail UV Source\", Float) = 0\n    [Enum(Multiply2X, 0, AlphaBlend, 1, HeightBlend, 2)]_LayerBlendMode_Ext_2(\"Layer Blend Mode\", Float) = 0\n    _LayerStrength_Ext_2(\"Layer Strength\", Range(0,2)) = 1\n    _LayerAlbedoStrength_Ext_2(\"Detail Albedo Strength\", Range(0, 2)) = 1\n    _LayerNormalStrength_Ext_2(\"Detail Normal Strength\", Range(0, 2)) = 1\n    _LayerSmoothnessRemap_Ext_2(\"Smoothness Remap\", Vector) = (0, 1, 0, 0)\n    _LayerAORemap_Ext_2(\"Occlusion Remap\", Vector) = (0, 1, 0, 0)\n    _LayerMetallicRemap_Ext_2(\"Metallic Remap\", Vector) = (0, 1, 0, 0)\n    _LayerSmoothness_Ext_2(\"Smoothness\", Range(0,1)) = 0\n    _LayerSmoothnessStrength_Ext_2(\"Smoothness Strength\", Range(0,1)) = 1\n    _LayerHeightRemap_Ext_2(\"Height Remap\", Vector) = (0, 1, 0, 0)\n    _LayerHeightContrast_Ext_2(\"Height Contrast\", Range(0.01, 0.99)) = 0.5\n    _LayerMetallic_Ext_2(\"Metallic\", Range(0,1)) = 0\n    _LayerScale_Ext_2(\"Detail UV Scale\", Float) = 3\n    _LayerTriplanarSpace_Ext_2 (\"Triplanar Space\", Float) = 0\n    _LayerTriplanarContrast_Ext_2 (\"Triplanar Contrast\", Range(1, 10)) = 4\n    _LayerAlbedoMap_Ext_2(\"Albedo/Height\", 2D) = \"white\" {}\n    _LayerNormalMap_Ext_2(\"Normal\", 2D) = \"bump\" {}\n    _LayerMaskMap_Ext_2(\"Mask Map\", 2D) = \"black\" {}\n    _LayerNoiseFrequency_Ext_2(\"Noise Frequency\", Float) = 1\n    _LayerNoiseAmplitude_Ext_2(\"Noise Amplitude\", Range(0,10)) = 0.5\n    _LayerNoiseOffset_Ext_2(\"Noise Offset\", Float) = 0\n    _LayerNoiseCenter_Ext_2(\"Noise Center\", Range(-5, 5)) = 0\n    _LayerStochasticContrast_Ext_2(\"Stochastic Contrast\", Range(0.01,0.999)) = 0.7\n    _LayerStochasticScale_Ext_2(\"Stochastic Scale\", Range(0.2,1.5)) = 0.5\n    _LayerBlendTint_Ext_2(\"Layer Blend Tint\", Color) = (1,1,1,1)\n    _LayerBlendContrast_Ext_2(\"Layer Blend Contrast\", Range(0.5, 8)) = 2\n    _LayerTint_Ext_2(\"Layer Tint\", Color) = (1,1,1,1)\n    _LayerAlbedoBrightness_Ext_2(\"Layer Brightness\", Range(-1, 1)) = 0\n    _LayerAlbedoContrast_Ext_2(\"Layer Contrast\", Range(0, 2)) = 1\n    _LayerEmissionMap_Ext_2(\"Layer Emission Map\", 2D) = \"black\" {}\n    _LayerEmissionColor_Ext_2(\"Layer Emission Multiplier\", Color) = (0,0,0,0)\n    _LayerAngleMin_Ext_2(\"Angle Minimum\", Range(0,1)) = 0.1\n    _LayerVertexNormalBlend_Ext_2(\"Vertex->Normal Filter\", Range(0,1)) = 0.8\n    _LayerHeight_Ext_2(\"Height Filter\", Range(0,1)) = 0\n    [Enum(Top,0,Bottom,1)] _LayerInvertHeight_Ext_2 (\"Layer on\", Float) = 0\n    _LayerFalloff_Ext_2(\"Angle Falloff Contrast\", Range(2, 40)) = 8\n    _LayerTessStrength_Ext_2(\"Displacement Strength\", Range(0,1)) = 1\n    _LayerWeightOverDistance_Ext_2(\"Weight Over Distance\", Vector) = (1,1,1,1) // start distance/weight, end fade range/weight\n    _LayerMicroShadowStrength_Ext_2(\"Micro Shadow Strength\", Range(0,2)) = 0\n    _LayerFuzzyShadingOn_Ext_2(\"FuzzyShadingToggle\", Float) = 0\n    _LayerFuzzyShadingColor_Ext_2(\"Fuzzy Shading Color\", Color) = (1,1,1,1)\n    _LayerFuzzyShadingParams_Ext_2(\"Fuzzy Shading Params\", Vector) = (0.3,1,1.5,1) // coreMult, edgeMult, power\n\n\n\n\n    [Toggle] _Trax(\"Enable Trax\", Float) = 0\n    _TraxAlbedo(\"Trax Albedo\", 2D) = \"white\" {}\n    _TraxPackedNormal(\"Trax Packed Normal\", 2D) = \"bump\" {}\n    _TraxNormalStrength(\"Normal Strength\", Range(0,2)) = 1\n    _TraxDisplacementDepth(\"Trax Depression Depth\", Float) = 0.1\n    _TraxDisplacementStrength(\"Trax Displacement\", Range(0,3)) = 0.2\n    _TraxMipBias(\"Trax Mip Bias\", Range(0, 5)) = 3\n    _TraxInterpContrast(\"Interpolation Contrast\", Range(0,1)) = 0.9\n    _TraxHeightContrast(\"Height Contrast\", Range(0,1)) = 0.5\n    _TraxTint(\"Tint Color\", Color) = (1,1,1,1)\n\n\n   _WetnessMode(\"Wetness Mode\", Int) = 0\n   _PuddleMode(\"Puddle Mode\", Int) = 0\n   _RainMode(\"Rain Mode\", Int) = 0\n   _WetnessAmount(\"Wetness Amount\", Range(0,1)) = 0\n   _Porosity(\"Porosity\", Range(0,1)) = 0.4\n   _WetnessMin(\"Minimum Wetness\", Range(0,1)) = 0\n   _WetnessMax(\"Maximum Wetness\", Range(0,1)) = 1\n   _WetnessFalloff(\"Angle Falloff\", Range(0,1)) = 1\n   _WetnessAngleMin(\"Wetness Minimum Angle\", Range(-1,1)) = -1\n   _PuddleAmount(\"Puddle Amount\", Range(0,1)) = 0\n   _PuddleFalloff(\"Puddle Contrast\", Range(2, 50)) = 12\n   _PuddleAngleMin(\"Moss Angle Minimum\", Range(0,1)) = 0.1\n   _PuddleColor(\"Puddle Color\", Color) = (0.2, 0.2, 0.2, 0.7)\n   _PuddleNoiseFrequency(\"Noise Frequency\", Float) = 1\n   _PuddleNoiseAmplitude(\"Noise Amplitude\", Range(0,10)) = 0.5\n   _PuddleNoiseCenter(\"Noise Center\", Range(-5, 5)) = 0\n   _PuddleNoiseOffset(\"Noise Offset\", Float) = 0\n   _RainDropTexture(\"RainDrop Texture\", 2D) = \"white\" {}\n   _RainIntensityScale(\"Intensity/Scale/MinWet\", Vector) = (1, 25, 0, 0)\n   _WetnessShoreline(\"Wetness Shore Height\", Float) = -99999\n\n\n    _SnowMode(\"Snow Mode\", Int) = 0\n    _SnowAlbedo(\"Snow Albedo\", 2D) = \"white\" {}\n    _SnowTint(\"Snow Trax Albedo\", Color) = (1,1,1,1)\n    _SnowNormal(\"Snow Normal\", 2D) = \"bump\" {}\n    _SnowMaskMap(\"Snow Mask Map\", 2D) = \"black\" {}\n    _SnowAmount(\"Snow Amount\", Range(0,1)) = 1\n    _SnowAngle(\"Snow Angle Falloff\", Range(0,2)) = 1\n    _SnowContrast(\"Snow Contrast\", Range(0.5, 4)) = 1.5\n    _SnowVertexHeight(\"Snow Vertex Height\", Range(0,1)) = 0.05\n    _SnowWorldFade(\"Snow Height Fade\", Vector) = (100, 50, 0, 0)\n    _SnowTraxAlbedo(\"Snow Trax Albedo\", 2D) = \"white\" {}\n    _SnowTraxTint(\"Snow Trax Albedo\", Color) = (1,1,1,1)\n    _SnowTraxNormal(\"Snow Trax Normal\", 2D) = \"bump\" {}\n    _SnowTraxMaskMap(\"Snow Trax Mask Map\", 2D) = \"black\" {}\n    _SnowNoiseFreq(\"Snow Noise Frequency\", Float) = 1\n    _SnowNoiseAmp(\"Snow Noise Amplitude\", Float) = 1\n    _SnowNoiseOffset(\"Snow Noise Offset\", Float) = 0\n    _SnowStochasticContrast(\"Snow Stochastic Contrast\", Range(0.01, 0.99)) = 0.7\n    _SnowStochasticScale(\"Snow Stochastic Scale\", Range(0,2)) = 1\n\n\n   [BetterHeader(Wind Particulate)]\n   [Toggle] _Wind(\"Enable Wind\", Float) = 0\n   [Enum(World, 0, UV, 1)]_WindParticulateSpace(\"Wind UV Source\", Float) = 0\n   _WindParticulate(\"Wind Texture\", 2D) = \"black\" {}\n   _WindParticulateStrength(\"Strength\", Range(0, 3)) = 2\n   _WindParticulateSpeed(\"Speed\", Float) = 1\n   _WindParticulatePower(\"Contrast\", Range(0.2, 6)) = 1\n   _WindParticulateRotation(\"Rotation\", Float) = 0\n   _WindParticulateColor(\"Color, strength\", Color) = (1, 1, 1, 1)\n   _WindParticulateWorldHeightMask(\"Wind Height Mask\", Vector) = (-99999, -99999, 99999, 99999)\n   _WindParticulateTextureHeight(\"Wind Texture Height\", Range(0,1)) = 1\n   _WindParticulateAngleMask(\"Wind Angle Mask\", Vector) = (-1, -1, 1, 1)\n   _WindParticulateOcclusionStrength(\"Wind Occlusion Strength\", Range(0,1)) = 1\n   _WindParticulateEmissive(\"Wind Emissive\", Color) = (0,0,0,0)\n\n\n   [Enum(Off,0,Front,1,Back,2)]_CullMode(\"Culling Mode\", Float) = 2\n   [Enum(Flip, 0, Mirror, 1, None, 2)] _DoubleSidedNormalMode(\"Double sided normal mode\", Float) = 1\n\n\n   _AutoNormalStrength(\"Auto Normal Strength\", Range(0,2)) = 0.5\n\n\n\t_DebugSampleCountThreshold (\"Debug Sample Threshold\", Int) = 12\n\n\n\t[Toggle(_DISSOLVE)] _DissolveEnabled (\"Enable Dissolve\", Float) = 0\n    _DissolveAmount(\"Dissolve Amount\", Range(0,1)) = 0\n\t_DissolveTexture(\"Dissolve Texture\", 2D) = \"black\" {}\n    _DissolveGradient(\"Dissolve Gradient\", 2D) = \"white\" {}\n\t_DissolveColoration(\"Dissolve Coloration\", Range(0,1)) = 1\n\t_DissolveEdgeContrast(\"Dissolve Edge Contrast\", Range(2, 128)) = 10\n    _DissolveEmissiveStr(\"Dissolve Emissive Strength\", Range(0,4)) = 0\n\n\n\n\n\n\n\t[BetterHeader(Bakery)]\n    [Toggle(USEBAKERY)] _USEBAKERY (\"Enabled Bakery\", Float) = 0\n\t[KeywordEnum(Standard, RNM, SH, Vertex, VertexDirectional, VertexSH)] _LightmapMode (\"Lightmapping mode\", Float) = 0\n    [Toggle(BAKERY_VERTEXLMMASK)] _BAKERY_VERTEXLMMASK (\"Enable vertex shadowmask\", Float) = 0\n    [Toggle(BAKERY_SHNONLINEAR)] _BAKERY_SHNONLINEAR (\"SH non-linear mode\", Float) = 1\n    [Toggle(BAKERY_LMSPEC)] _BAKERY_LMSPEC (\"Enable Lightmap Specular\", Float) = 0\n    [Toggle(BAKERY_BICUBIC)] _BAKERY_BICUBIC (\"Enable Bicubic Filter\", Float) = 0\n    [Toggle(BAKERY_VOLUME)] _BAKERY_VOLUME (\"Use volumes\", Float) = 0\n    [Toggle(BAKERY_VOLROTATION)] _BAKERY_VOLROTATION (\"Allow volume rotation\", Float) = 0\n\n\n\n\n\n   _IsAlpha(\"Not Used or set, just so the editor knows we are an alpha shader\", Float) = 0\n\n\n   }\n   SubShader\n   {\n      Tags { \"RenderPipeline\"=\"UniversalPipeline\" \"RenderType\" = \"Transparent\" \"UniversalMaterialType\" = \"Lit\" \"Queue\" = \"Transparent\" }\n\n      \n\n      \nZWrite Off ColorMask RGB\n\n\n        Pass\n        {\n            Name \"Universal Forward\"\n            Tags \n            { \n                \"LightMode\" = \"UniversalForward\"\n            }\n            Cull Back\n            Blend One Zero\n            ZTest LEqual\n            ZWrite On\n\n            Blend SrcAlpha OneMinusSrcAlpha, One OneMinusSrcAlpha\nCull Back\n ZTest LEqual\nZWrite Off\n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n            #pragma multi_compile_fog\n            #pragma multi_compile_instancing\n            #pragma multi_compile _ DOTS_INSTANCING_ON\n        \n            // Keywords\n            #pragma multi_compile _ _SCREEN_SPACE_OCCLUSION\n            #pragma multi_compile _ LIGHTMAP_ON\n            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS\n            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE\n            #pragma multi_compile _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS _ADDITIONAL_OFF\n            #pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS\n            #pragma multi_compile _ _SHADOWS_SOFT\n            #pragma multi_compile _ LIGHTMAP_SHADOW_MIXING\n            #pragma multi_compile _ SHADOWS_SHADOWMASK\n            // GraphKeywords: <None>\n\n            #define SHADER_PASS SHADERPASS_FORWARD\n            #define SHADERPASS_FORWARD\n            #define VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n            #define _PASSFORWARD 1\n            \n\n            \n\n\n   #pragma shader_feature_local_fragment _ _PACKEDFAST\n   #pragma shader_feature_local _ _TRIPLANAR\n   #pragma shader_feature_local_fragment _ _NORMALMAP \n   #pragma shader_feature_local_fragment _ _MASKMAP\n   #pragma shader_feature_local_fragment _ _DETAIL\n   #pragma shader_feature_local_fragment _ _DETAILTRIPLANAR\n   #pragma shader_feature_local_fragment _ _DETAILSTOCHASTIC\n   #pragma shader_feature_local_fragment _ _EMISSION\n   #pragma shader_feature_local_fragment _ _FLATSHADE\n   #pragma shader_feature_local _ _STOCHASTIC\n   #pragma shader_feature_local_fragment _ _PARALLAX //_POM\n   #pragma shader_feature_local_fragment _ _SPECULAR\n   #pragma shader_feature_local _ _NOISEWORLD _NOISELOCAL\n   #pragma shader_feature_local _ _NOISEHQ _NOISETEXTURE _NOISEWORLEY\n   // only for URP/Standard Forward\n   #pragma shader_feature_local_fragment _ _SIMPLELIT\n\n\n   #pragma shader_feature_local_fragment _ _TINTMASK\n\n\n    #pragma shader_feature_local _ _LAYERVERTEXMASK _LAYERTEXTUREMASK\n\n    #define _HAS_WEIGHTTEXTURE_MASK 1\n\n\n   #pragma shader_feature_local _ _USELAYER\n   #pragma shader_feature_local _ _LAYERTRIPLANAR\n   #pragma shader_feature_local _ _LAYERALBEDO\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL\n   #pragma shader_feature_local _ _LAYERMASK\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION\n   #pragma shader_feature_local _ _LAYERNOISE\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC\n   #pragma shader_feature_local _ _LAYERANGLEFILTER\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_1\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_1\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_1\n   #pragma shader_feature_local _ _LAYERMASK_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_1\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_1\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_1\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_1\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_2\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_2\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_2\n   #pragma shader_feature_local _ _LAYERMASK_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_2\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_2\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_2\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_2\n\n\n   #pragma shader_feature_local _ _TRAX_ON\n\n\n   #pragma shader_feature_local_fragment _ _WETNESS\n   #pragma shader_feature_local_fragment _ _PUDDLES\n   #pragma shader_feature_local_fragment _ _PUDDLENOISE\n   #pragma shader_feature_local_fragment _ _RAINDROPS\n\n\n   #pragma shader_feature_local _ _SNOW\n   #pragma shader_feature_local _ _SNOWMASKMAP\n   #pragma shader_feature_local _ _SNOWNOISE\n   #pragma shader_feature_local_fragment _SNOWSTOCHASTIC\n\n\n   #pragma shader_feature_local_fragment _ _WIND_ON\n\n\n\n\n   #pragma shader_feature_local_fragment _ _SURFACEGRADIENT _AUTONORMAL\n   #define _WORLDSPACENORMAL 1\n\n\n   #pragma shader_feature_local _ _DEBUG_SAMPLECOUNT\n\n\n\t#pragma shader_feature_local_fragment _ _DISSOLVE\n\n\n   #pragma multi_compile_local  LOD_FADE_CROSSFADE\n\n\n\n#pragma instancing_options procedural:setupVSPro forwardadd\n\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\nstruct IndirectShaderData\n{\n\tfloat4x4 PositionMatrix;\n\tfloat4x4 InversePositionMatrix;\n\tfloat4 ControlData;\n};\n\n#if defined(SHADER_API_GLCORE) || defined(SHADER_API_D3D11) || defined(SHADER_API_GLES3) || defined(SHADER_API_METAL) || defined(SHADER_API_VULKAN) || defined(SHADER_API_PSSL) || defined(SHADER_API_XBOXONE)\n\tuniform StructuredBuffer<IndirectShaderData> VisibleShaderDataBuffer;\n#endif\n\n#endif\n\nfloat VSPRenderingLayerMask;\n\nvoid setupVSPro()\n{\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\n    #if _HDRP\n\t    unity_RenderingLayer.x = VSPRenderingLayerMask;\n    #endif\n\n\t#ifdef unity_ObjectToWorld\n\t#undef unity_ObjectToWorld\n\t#endif\n\n\t#ifdef unity_WorldToObject\n\t#undef unity_WorldToObject\n\t#endif\n\n\tunity_ObjectToWorld = VisibleShaderDataBuffer[unity_InstanceID].PositionMatrix;\n\tunity_WorldToObject = VisibleShaderDataBuffer[unity_InstanceID].InversePositionMatrix;\n#endif\n\n}\n\n\n\t#pragma multi_compile _LIGHTMAPMODE_STANDARD _LIGHTMAPMODE_RNM _LIGHTMAPMODE_SH _LIGHTMAPMODE_VERTEX _LIGHTMAPMODE_VERTEXDIRECTIONAL _LIGHTMAPMODE_VERTEXSH\n\n    #pragma shader_feature USEBAKERY\n    #pragma shader_feature BAKERY_VERTEXLMMASK\n    #pragma shader_feature BAKERY_SHNONLINEAR\n    #pragma shader_feature BAKERY_LMSPEC\n    #pragma shader_feature BAKERY_BICUBIC\n    #pragma shader_feature BAKERY_VOLUME\n    #pragma shader_feature BAKERY_VOLROTATION\n    #pragma shader_feature BAKERY_COMPRESSED_VOLUME\n\n    #if _USEBAKERY\n\t    #define _OVERRIDE_BAKEDGI\n        #if BAKERY_VOLUME || (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)) && defined(BAKERY_VERTEXLMMASK)\n            #define _OVERRIDE_SHADOWMASK\n        #endif\n    #endif\n\n\n\n\n\n\n\n\n   #define _URP 1\n\n   #define _ALPHABLEND_ON 1\n#define _ALPHABLEND_ON 1\n#define _SURFACE_TYPE_TRANSPARENT 1\n#define NEED_FACING 1\n\n            // this has to be here or specular color will be ignored. Not in SG code\n            #if _SIMPLELIT\n               #define _SPECULAR_COLOR\n            #endif\n\n\n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl\"\n\n\n        \n\n               #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCCOORD3;\n          float4 texcoord1 : TEXCCOORD4;\n         // float4 texcoord2 : TEXCCOORD5;\n\n          #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n         // float4 texcoord3 : TEXCCOORD6;\n          #endif\n\n          #if LOD_FADE_CROSSFADE\n          float4 screenPos : TEXCOORD7;\n          #endif\n\n          #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n          half4 vertexColor : COLOR_centroid;\n          #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n         // float4 extraV2F0 : TEXCOORD12;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n         // float4 extraV2F1 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n         // float4 extraV2F2 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n         // float4 extraV2F3 : TEXCOORD15;\n         // #endif\n\n          #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n          float4 extraV2F4 : TEXCOORD16_centroid;\n          #endif\n\n          #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n          float4 extraV2F5 : TEXCOORD17_centroid;\n          #endif\n\n          #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n          float4 extraV2F6 : TEXCOORD18_centroid;\n          #endif\n\n          #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n          float4 extraV2F7 : TEXCOORD19_centroid;\n          #endif\n            \n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD9;\n         #endif\n            float4 fogFactorAndVertexLight : TEXCOORD10;\n            float4 shadowCoord : TEXCOORD11;\n         #if UNITY_ANY_INSTANCING_ENABLED\n            uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n            uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n            uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n            FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n      };\n\n\n         \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n   half4 weightTextureMask;\n   \n\n\n   float traxBuffer;\n\n\n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // would love to strip these, but they are used in certain\n               // combinations of the lighting system, and may be used\n               // by the user as well, so no easy way to strip them.\n\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR_centroid;\n                #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                float4 extraV2F4 : TEXCOORD9_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                float4 extraV2F5 : TEXCOORD10_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F6 : TEXCOORD11_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F7 : TEXCOORD12_centroid;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n               #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n               #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n               #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n               #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()     unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n               #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V   unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n               #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V    mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n               #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n               #endif\n               #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n         CBUFFER_START(UnityPerMaterial)\n\n            \n\n\n   half4 _Tint;\n   half _UVSource;\n   half _TriplanarContrast;\n   half _AlbedoContrast;\n   half _AlbedoBrightness;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half3 _EmissionColor;\n   float _DetailUVSource;\n   half _StochasticScale;\n   half _DetailStochasticScale;\n   half _Smoothness;\n   half _Metallic;\n   half2 _SmoothnessRemap;\n   half2 _AORemap;\n   half2 _MetallicRemap;\n   half2 _HeightRemap;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n   half _AlphaThreshold;\n   half _Cutoff; // for Unity's light mapper\n   half _TriplanarSpace;\n   half _DetailTriplanarSpace;\n   half _DetailTriplanarContrast;\n   half _MicroShadowStrength;\n   half3 _FuzzyShadingColor;\n   half _FuzzyShadingOn;\n   half3 _FuzzyShadingParams;\n\n   //int _POMMaxSamples;\n   //float _POMMin;\n   //float _POMFade;\n#if _FLATSHADE\n   half _FlatShadingBlend;\n#endif\n\n   half _StochasticContrast;\n   half _DetailStochasticContrast;\n\n#if _PARALLAX || _POM\n   half _ParallaxHeight;\n#endif\n\n\n\n\tfloat4 _TintMask_ST;\n\thalf3 _RColor;\n\thalf3 _GColor;\n\thalf3 _BColor;\n\thalf3 _AColor;\n\n\n\thalf _LayerTextureMaskUVMode;\n    float4 _LayerTextureMask_ST;\n\n\n   //#if _USELAYER\n       float4 _LayerAlbedoMap_ST;\n       half3 _LayerTint;\n       half _LayerBlendMode;\n       float _LayerUVSource;\n       half _LayerAlbedoBrightness;\n       half _LayerAlbedoContrast;\n       half _LayerHeightContrast;\n       half _LayerStrength;\n       half _LayerAlbedoStrength;\n       half _LayerNormalStrength;\n       half _LayerSmoothnessStrength;\n       half _LayerSmoothness;\n       half _LayerMetallic;\n       half _LayerStochasticScale;\n       half2 _LayerSmoothnessRemap;\n       half2 _LayerAORemap;\n       half2 _LayerMetallicRemap;\n       half2 _LayerHeightRemap;\n       float4 _LayerWeightOverDistance;\n       half _LayerMicroShadowStrength;\n       //#if _LAYERNOISE\n           float _LayerNoiseFrequency;\n           float _LayerNoiseAmplitude;\n           float _LayerNoiseOffset;\n           float _LayerNoiseCenter;\n           half3 _LayerBlendTint;\n       //#endif\n       //#if _LAYERANGLEFILTER\n           half _LayerFalloff;\n           half _LayerAngleMin;\n           half _LayerHeight;\n           half _LayerInvertHeight;\n           half _LayerVertexNormalBlend;\n       //#endif\n       half _LayerTriplanarSpace;\n       half _LayerTriplanarContrast;\n       half _LayerBlendContrast;\n       half3 _LayerEmissionColor;\n       half _LayerStochasticContrast;\n       half _LayerTessStrength;\n       half3 _LayerFuzzyShadingColor;\n       half _LayerFuzzyShadingOn;\n       half3 _LayerFuzzyShadingParams;\n   //#endif\n\n\n   //#if _USELAYER_DEF_1\n       float4 _LayerAlbedoMap_Ext_1_ST;\n       half3 _LayerTint_Ext_1;\n       half _LayerBlendMode_Ext_1;\n       float _LayerUVSource_Ext_1;\n       half _LayerAlbedoBrightness_Ext_1;\n       half _LayerAlbedoContrast_Ext_1;\n       half _LayerHeightContrast_Ext_1;\n       half _LayerStrength_Ext_1;\n       half _LayerAlbedoStrength_Ext_1;\n       half _LayerNormalStrength_Ext_1;\n       half _LayerSmoothnessStrength_Ext_1;\n       half _LayerSmoothness_Ext_1;\n       half _LayerMetallic_Ext_1;\n       half _LayerStochasticScale_Ext_1;\n       half2 _LayerSmoothnessRemap_Ext_1;\n       half2 _LayerAORemap_Ext_1;\n       half2 _LayerMetallicRemap_Ext_1;\n       half2 _LayerHeightRemap_Ext_1;\n       float4 _LayerWeightOverDistance_Ext_1;\n       half _LayerMicroShadowStrength_Ext_1;\n       //#if _LAYERNOISE_DEF_1\n           float _LayerNoiseFrequency_Ext_1;\n           float _LayerNoiseAmplitude_Ext_1;\n           float _LayerNoiseOffset_Ext_1;\n           float _LayerNoiseCenter_Ext_1;\n           half3 _LayerBlendTint_Ext_1;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_1\n           half _LayerFalloff_Ext_1;\n           half _LayerAngleMin_Ext_1;\n           half _LayerHeight_Ext_1;\n           half _LayerInvertHeight_Ext_1;\n           half _LayerVertexNormalBlend_Ext_1;\n       //#endif\n       half _LayerTriplanarSpace_Ext_1;\n       half _LayerTriplanarContrast_Ext_1;\n       half _LayerBlendContrast_Ext_1;\n       half3 _LayerEmissionColor_Ext_1;\n       half _LayerStochasticContrast_Ext_1;\n       half _LayerTessStrength_Ext_1;\n       half3 _LayerFuzzyShadingColor_Ext_1;\n       half _LayerFuzzyShadingOn_Ext_1;\n       half3 _LayerFuzzyShadingParams_Ext_1;\n   //#endif\n\n\n   //#if _USELAYER_DEF_2\n       float4 _LayerAlbedoMap_Ext_2_ST;\n       half3 _LayerTint_Ext_2;\n       half _LayerBlendMode_Ext_2;\n       float _LayerUVSource_Ext_2;\n       half _LayerAlbedoBrightness_Ext_2;\n       half _LayerAlbedoContrast_Ext_2;\n       half _LayerHeightContrast_Ext_2;\n       half _LayerStrength_Ext_2;\n       half _LayerAlbedoStrength_Ext_2;\n       half _LayerNormalStrength_Ext_2;\n       half _LayerSmoothnessStrength_Ext_2;\n       half _LayerSmoothness_Ext_2;\n       half _LayerMetallic_Ext_2;\n       half _LayerStochasticScale_Ext_2;\n       half2 _LayerSmoothnessRemap_Ext_2;\n       half2 _LayerAORemap_Ext_2;\n       half2 _LayerMetallicRemap_Ext_2;\n       half2 _LayerHeightRemap_Ext_2;\n       float4 _LayerWeightOverDistance_Ext_2;\n       half _LayerMicroShadowStrength_Ext_2;\n       //#if _LAYERNOISE_DEF_2\n           float _LayerNoiseFrequency_Ext_2;\n           float _LayerNoiseAmplitude_Ext_2;\n           float _LayerNoiseOffset_Ext_2;\n           float _LayerNoiseCenter_Ext_2;\n           half3 _LayerBlendTint_Ext_2;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_2\n           half _LayerFalloff_Ext_2;\n           half _LayerAngleMin_Ext_2;\n           half _LayerHeight_Ext_2;\n           half _LayerInvertHeight_Ext_2;\n           half _LayerVertexNormalBlend_Ext_2;\n       //#endif\n       half _LayerTriplanarSpace_Ext_2;\n       half _LayerTriplanarContrast_Ext_2;\n       half _LayerBlendContrast_Ext_2;\n       half3 _LayerEmissionColor_Ext_2;\n       half _LayerStochasticContrast_Ext_2;\n       half _LayerTessStrength_Ext_2;\n       half3 _LayerFuzzyShadingColor_Ext_2;\n       half _LayerFuzzyShadingOn_Ext_2;\n       half3 _LayerFuzzyShadingParams_Ext_2;\n   //#endif\n\n\n    half _TraxDisplacementDepth;\n    half _TraxDisplacementStrength;\n    half _TraxMipBias;\n    half _TraxNormalStrength;\n    float4 _TraxAlbedo_ST;\n    half _TraxInterpContrast;\n    half _TraxHeightContrast;\n    half3 _TraxTint;\n\n\n\n    half _Porosity;\n    int _WetnessMode;\n    int _PuddleMode;\n\n    half  _PuddleAmount;\n    half  _PuddleFalloff;\n    half4 _PuddleColor;\n    half _PuddleNoiseFrequency;\n    half _PuddleNoiseAmplitude;\n    half _PuddleNoiseOffset;\n    half _PuddleNoiseCenter;\n    half _PuddleAngleMin;\n\n    half _WetnessAmount;\n\thalf _WetnessMin;\n    half _WetnessMax;\n    half _WetnessFalloff;\n\thalf _WetnessAngleMin;\n    float _WetnessShoreline;\n\n    int _RainMode;\n    half3 _RainIntensityScale;\n\n\n\n\n    float4 _SnowAlbedo_ST;\n    half3 _SnowTint;\n    half _SnowAmount;\n    half _SnowAngle;\n    half _SnowContrast;\n    half _SnowVertexHeight;\n    half _SnowMode;\n    half3 _SnowWorldFade; // z is on/off\n    float4 _SnowTraxAlbedo_ST;\n    half3 _SnowTraxTint;\n\n    half _SnowNoiseFreq; \n    half _SnowNoiseAmp;\n    half _SnowNoiseOffset;\n    half _SnowStochasticContrast;\n    half _SnowStochasticScale;\n\n\n    half     _WindParticulateSpace;\n    half     _WindParticulateRotation;\n    half      _WindParticulateSpeed;\n    float4     _WindParticulate_ST;\n    half      _WindParticulatePower;\n    half4    _WindParticulateColor;\n    half4    _WindParticulateWorldHeightMask;\n    half4    _WindParticulateAngleMask;\n    half      _WindParticulateOcclusionStrength;\n    half      _WindParticulateStrength;\n    half4    _WindParticulateEmissive;\n    half     _WindParticulateTextureHeight;\n\n\n   float _DoubleSidedNormalMode;\n\n\n\thalf _AutoNormalStrength;\n\n\n\tint _DebugSampleCountThreshold;\n\n\n\thalf _DissolveAmount;\n\thalf _DissolveEmissiveStr;\n\thalf _DissolveEdgeContrast;\n\thalf _DissolveColoration;\n\tfloat4 _DissolveTexture_ST;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n         CBUFFER_END\n\n         \n\n         \n\n         #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\n#ifndef __STACKABLEFUNCLIBRARY_INCLUDES__\n#define __STACKABLEFUNCLIBRARY_INCLUDES__\n\n   #if _DEBUG_SAMPLECOUNT\n      int _sampleCount;\n      #define COUNTSAMPLE { _sampleCount++; }\n   #else\n      #define COUNTSAMPLE\n   #endif\n\n   TEXTURE2D(_NoiseTex);\n   SAMPLER(sampler_NoiseTex);\n\n\n\n   half3 AdjustContrast(half3 color, half contrast)\n   {\n       half3 comp = 0.5;\n   #if !UNITY_COLORSPACE_GAMMA\n       comp = 0.22;\n   #endif\n       color = saturate(lerp(comp, color, contrast));\n       return color;\n   }\n\n   float2 DoParallaxOffset( half h, half height, half3 viewDir)\n   {\n      h = h * height - height/2.0;\n      float3 v = normalize(viewDir);\n      v.z += 0.42;\n      return h * (v.xy / v.z);\n   }\n\n\n\n   #define SAMPLEBARY SampleTexBary\n\n   struct SampleConfig\n   {\n      float2 uv0;\n      float2 uv1;\n      float2 uv2;\n      float2 dx0;\n      float2 dy0;\n      float2 dx1;\n      float2 dy1;\n      float2 dx2;\n      float2 dy2;\n      float3 weights;\n      float3 origWeights;\n   };\n\n   struct Config\n   {\n      float2 origUV; // unscaled uv\n      float2 origScale;\n      float2 uv;        // no stocastic or triplanar\n      float2 dx;\n      float2 dy;\n      SampleConfig uvT; // just stochastic, or just triplanar\n      SampleConfig uvX; // stochastic and triplanar\n      SampleConfig uvY;\n      SampleConfig uvZ;\n\n      \n      float3 absVertNormal;\n      half3 axisSign;\n      float3 normal;\n   };\n\n\n    float2 Hash2D( float2 x )\n    {\n        float2 k = float2( 0.3183099, 0.3678794 );\n        x = x*k + k.yx;\n        return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );\n    }\n\n    float Noise2D(float2 p )\n    {\n        float2 i = floor( p );\n        float2 f = frac( p );\n         \n        float2 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), \n                        dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),\n                    lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), \n                        dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);\n    }\n      \n\n    float2 WorleyHash2D(float2 p)\n    {\n \t    return frac(cos(mul(p, float2x2(-64.2,71.3,81.4,-29.8)))*8321.3); \n    }\n    float WorleyNoise2D(float2 p)\n    {\n        float dist = 1;\n        float2 i = floor(p);\n        float2 f = frac(p);\n    \n        for(int x = -1;x<=1;x++)\n        {\n            for(int y = -1;y<=1;y++)\n            {\n                float d = distance(WorleyHash2D(i+float2(x,y))+float2(x,y),f);\n                dist = min(dist,d);\n            }\n        }\n        return dist;\n\t\n    }\n\n#ifndef PI\n    #define PI 3.14159265359\n#endif\n\n    float GetIntegerNoise(float2 p)\n    {\n        p  = 53.7 * frac( (p*0.3183099) + float2(0.71,0.113));\n        return frac( p.x*p.y*(p.x+p.y) );\n    }\n\n    float WorleyHash3D(float f)\n    {\n        return frac(sin(f)*43758.5453);\n    }\n\n    float WorleyHash31(float3 v)\n    {\n        return WorleyHash3D(dot(v, float3(253.14, 453.74, 183.3)));\n    }\n\n    float3 WorleyRandom3D( float3 p )\n    {\n        return frac(sin(float3(dot(p,float3(127.1,311.7,217.3)),dot(p,float3(269.5,183.3,431.1)), dot(p,float3(365.6,749.9,323.7))))*437158.5453);\n    }\n\n    float WorleyNoise3D(float3 uvw)\n    {\n        float noise = 0.0;\n    \n        float3 p = floor(uvw);\n        float3 f = frac(uvw);\n    \n        float4 res = 1;\n        for(int x = -1; x <=1; ++x)\n        {\n            for(int y = -1; y <=1; ++y)\n            {\n                for(int z = -1; z <=1; ++z)\n                {\n                    float3 gp = p + float3(x, y, z);\n\n                    float3 v = WorleyRandom3D(gp);\n\n\t\t\t\t    float3 diff = gp + v - uvw;\n                \n                    float d = length(diff);\n                \n                    if(d < res.x)\n                    {\n                        res.xyz = float3(d, res.x, res.y);\n                    }\n                    else if(d < res.y)\n                    {\n                        res.xyz = float3(res.x, d, res.y);\n                    }\n                    else if(d < res.z)\n                    {\n                        res.z = d;\n                    }\n                \n                    res.w = WorleyHash31(gp);\n                }\n            }\n        }\n\n        return res.x;\n    }\n    \n      \n    float3 Hash3D( float3 p )\n    {\n        p = float3( dot(p,float3(127.1,311.7, 74.7)),\n                dot(p,float3(269.5,183.3,246.1)),\n                dot(p,float3(113.5,271.9,124.6)));\n\n        return -1.0 + 2.0*frac(sin(p)*437.5453123);\n    }\n\n    float Noise3D( float3 p )\n    {\n        float3 i = floor( p );\n        float3 f = frac( p );\n         \n        float3 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),\n                    lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n    }\n\n    \n    float FBM2D(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           return SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n\n    }\n      \n    float FBM3D(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           half A = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.zy).g;\n           half B = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33).g;\n           half C = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoise(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3D(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3D(d.localSpacePosition * frequency+ offset, d.localSpaceNormal);\n        #else\n           return FBM2D(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n    \n    #if _SURFACEGRADIENT  \n\n    #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)\n\n      \n      \n    half3 SurfaceGradientFromTBN(ShaderData d, half2 deriv)\n    {\n        return deriv.x * d.TBNMatrix[0] + deriv.y * d.TBNMatrix[1];\n    }\n\n    half2 TspaceNormalToDerivative(half3 vM)\n    {\n        const half scale = 1.0/128.0;\n        const half3 vMa = abs(vM);\n        const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));\n\n        return -half2(vM.x, vM.y)/z_ma;\n    }\n\n    half3 SurfgradFromVolumeGradient(ShaderData d, half3 grad)\n    {\n        return grad - dot(d.worldSpaceNormal, grad) * d.worldSpaceNormal;\n    }\n\n    half3 SurfgradFromTriplanarProjection(ShaderData d, half3 pN, half3 xN, half3 yN, half3 zN)\n    {\n        const half w0 = pN.x;\n        const half w1 = pN.y;\n        const half w2 = pN.z;\n\n        half2 xD = TspaceNormalToDerivative(xN);\n        half2 yD = TspaceNormalToDerivative(yN);\n        half2 zD = TspaceNormalToDerivative(zN);\n\n        half3 volumeGrad = half3(w2 * zD.x + w1 * yD.y, w2 * zD.y + w0 * xD.y, w0 * xD.x + w1 * yD.x);\n\n        return SurfgradFromVolumeGradient(d, volumeGrad);\n    }\n\n    half3 ConvertNormalToGradient(ShaderData d, half3 normal)\n    {\n        half2 deriv = TspaceNormalToDerivative(normal);\n\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n    half3 ConvertNormal2ToGradient(ShaderData d, half2 packedNormal)\n    {\n        half2 tNormal = packedNormal;\n        half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF\n        half2 deriv = tNormal * -rcpZ;\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n\n    half3 ResolveNormalFromSurfaceGradient(ShaderData d, half3 gradient)\n    {\n        return normalize(d.worldSpaceNormal - gradient);\n    }\n\n    #endif // _SURFACEGRADIENT\n\n\n    // normals are in surface gradient or world space depending on settings, and can also be generated by height\n    half3 GetWorldSpaceNormal(ShaderData d, half3 normal, half pheight)\n    {\n       #if _SURFACEGRADIENT\n          return ResolveNormalFromSurfaceGradient(d, normal);\n       #elif _AUTONORMAL\n          float3 dx = ddx(d.worldSpacePosition);\n          float3 dy = ddy(d.worldSpacePosition);\n          float3 crossX = cross(float3(0,1,0), dx);\n          float3 crossY = cross(float3(0,1,0), dy);\n          float3 dt = abs(dot(crossY, dx));\n          float height = _AutoNormalStrength * 0.5 * pheight;\n          float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n          n.y *= -1.0;\n          return TangentToWorldSpace(d, normalize((dt * float3(0,1,0)) - n).xzy);\n       #else\n          return TangentToWorldSpace(d, normal);\n          \n       #endif\n       \n    }\n\n   void WaterBRDF (inout half3 albedo, inout half smoothness, half metallic, half wetFactor, half surfPorosity) \n   {\n      half porosity = saturate((( (1 - smoothness) - 0.5)) / max(surfPorosity, 0.001));\n      half factor = lerp(1, 0.2, (1 - metallic) * porosity);\n      albedo *= lerp(1.0, factor, wetFactor);\n      smoothness = lerp(smoothness, 0.92f, wetFactor);\n   }\n\n   void OffsetUV(inout Config c, float2 offset)\n   {\n       c.uv += offset;\n       c.uvT.uv0 += offset;\n       c.uvT.uv1 += offset;\n       c.uvT.uv2 += offset;\n       c.uvX.uv0 += offset;\n       c.uvX.uv1 += offset;\n       c.uvX.uv2 += offset;\n       c.uvY.uv0 += offset;\n       c.uvY.uv1 += offset;\n       c.uvY.uv2 += offset;\n       c.uvZ.uv0 += offset;\n       c.uvZ.uv1 += offset;\n       c.uvZ.uv2 += offset;\n   }\n\n\n    void TriangleGrid(float2 uv, float scale,\n       out float w1, out float w2, out float w3,\n       out int2 vertex1, out int2 vertex2, out int2 vertex3)\n    {\n       // Scaling of the input\n       uv *= 3.464 * scale; // 2 * sqrt(3)\n\n       // Skew input space into simplex triangle grid\n       const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);\n       float2 skewedCoord = mul(gridToSkewedGrid, uv);\n\n       // Compute local triangle vertex IDs and local barycentric coordinates\n       int2 baseId = int2(floor(skewedCoord));\n       float3 temp = float3(frac(skewedCoord), 0);\n       temp.z = 1.0 - temp.x - temp.y;\n       if (temp.z > 0.0)\n       {\n          w1 = temp.z;\n          w2 = temp.y;\n          w3 = temp.x;\n          vertex1 = baseId;\n          vertex2 = baseId + int2(0, 1);\n          vertex3 = baseId + int2(1, 0);\n       }\n       else\n       {\n          w1 = -temp.z;\n          w2 = 1.0 - temp.y;\n          w3 = 1.0 - temp.x;\n          vertex1 = baseId + int2(1, 1);\n          vertex2 = baseId + int2(1, 0);\n          vertex3 = baseId + int2(0, 1);\n       }\n    }\n\n    // Fast random hash function\n    float2 SimpleHash2(float2 p)\n    {\n       return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 43758.5453);\n    }\n\n\n    half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)\n    {\n        // compute weight with height map\n        const half epsilon = 1.0f / 1024.0f;\n        half3 weights = half3(iWeights.x * (tex0 + epsilon), \n                                 iWeights.y * (tex1 + epsilon),\n                                 iWeights.z * (tex2 + epsilon));\n\n        // Contrast weights\n        half maxWeight = max(weights.x, max(weights.y, weights.z));\n        half transition = contrast * maxWeight;\n        half threshold = maxWeight - transition;\n        half scale = 1.0f / transition;\n        weights = saturate((weights - threshold) * scale);\n        // Normalize weights.\n        half weightScale = 1.0f / (weights.x + weights.y + weights.z);\n        weights *= weightScale;\n        return weights;\n    }\n\n\n    half3 PackedUnpackScaleNormal(half4 packedNormal, float scale)\n   {\n       #if _PACKEDFAST\n          half3 normal;\n          normal.xy = (packedNormal.ag * 2 - 1) * scale;\n          normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n          return normal;  \n       #endif\n       return UnpackScaleNormal(packedNormal, scale);\n   }\n\n    void InitStochasticDxDy(inout SampleConfig c, Config cfg)\n    {\n      c.dx0 = ddx(cfg.origUV) * cfg.origScale;\n      c.dy0 = ddy(cfg.origUV) * cfg.origScale;\n      c.dx1 = c.dx0; c.dx1 = c.dx0;\n      c.dx2 = c.dy0; c.dy2 = c.dy0;\n    }\n\n    void PrepareStochasticUVs(float scale, float2 uv, out SampleConfig c)\n    {\n       // Get triangle info\n       ZERO_INITIALIZE(SampleConfig, c);\n       float w1, w2, w3;\n       int2 vertex1, vertex2, vertex3;\n       TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n       // Assign random offset to each triangle vertex\n       c.uv0 = uv;\n       c.uv1 = uv;\n       c.uv2 = uv;\n   \n       c.uv0.xy += SimpleHash2(vertex1);\n       c.uv1.xy += SimpleHash2(vertex2);\n       c.uv2.xy += SimpleHash2(vertex3);\n       c.weights = half3(w1, w2, w3);\n       c.origWeights = half3(w1, w2, w3);\n    }\n\n\n   half3 LitBlendDetailNormal(half3 n1, half3 n2)\n   {\n      #if _SURFACEGRADIENT\n         return n1 + n2;\n      #else\n         return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n      #endif\n   }\n\n   float3 TriplanarBlendUnpackedRNM(float3 n1, float3 n2)\n   {\n       n1.z += 1;\n       n2.xy = -n2.xy;\n       return n1 * dot(n1, n2) / n1.z - n2;\n   }\n\n   void InitConfigDxDy(inout Config c)\n   {\n      c.uvT.dx0 = ddx(c.uvT.uv0);\n      c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1);\n      c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2);\n      c.uvT.dy2 = ddy(c.uvT.uv2);\n   }\n\n   Config CreateConfig(ShaderData d, float4 scale, float space, int uvsource, half triplanarContrast)\n   {\n      Config c;\n      ZERO_INITIALIZE(Config, c);\n\n      float3 pos = d.worldSpacePosition;\n      float3 normal = d.worldSpaceNormal;\n      if (space > 0)\n      {\n         pos = d.localSpacePosition;\n         normal = d.localSpaceNormal;\n      }\n\n      c.uv = d.texcoord0.xy;\n      \n      if (uvsource == 1)\n        c.uv = d.texcoord1.xy;\n      else if (uvsource == 2)\n        c.uv = pos.yz * float2(1, -1);\n      else if (uvsource == 3)\n        c.uv = pos.xz * float2(1, -1);\n      else if (uvsource == 4)\n        c.uv = pos.xy * float2(1, -1);\n\n      c.origUV = c.uv;\n      c.origScale = scale.xy;\n\n      c.uv = c.uv * scale.xy + scale.zw;\n      c.dx = ddx(c.uv);\n      c.dy = ddy(c.uv);\n\n      c.normal = normal;\n      c.uvT.uv0 = pos.zy * scale.xy + scale.zw;\n      c.uvT.uv1 = pos.xz * scale.xy + scale.zw;\n      c.uvT.uv2 = pos.xy * scale.xy + scale.zw;\n        \n      c.uvT.uv1 += 0.33;\n      c.uvT.uv2 += 0.67;\n\n      c.uvT.dx0 = ddx(c.uvT.uv0); c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1); c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2); c.uvT.dy2 = ddy(c.uvT.uv2);\n\n      half3 triblend = saturate(pow(abs(c.normal), triplanarContrast));\n      triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n      c.uvT.weights = triblend;\n      c.uvT.origWeights = triblend;\n      c.axisSign = d.worldSpaceNormal < 0 ? -1 : 1;\n      c.absVertNormal = abs(d.worldSpaceNormal);\n     \n\n      return c;\n   }\n\n\n   half4 TriSample(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0) * c.weights.x;\n      }\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1) * c.weights.y;\n      }  \n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2) * c.weights.z;\n      }\n\n      return res;\n   }\n\n   half4 TriSampleBary(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      c.weights = BaryWeightBlend(c.origWeights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   half4 TriSampleGrad(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvX, contrast, d) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvY, contrast, d) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n           res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvZ, contrast, d) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   \n   half4 SampleTexBaryStochastic(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   half4 SampleTexBaryTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleGrad(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   \n   half4 SampleTexBary(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        COUNTSAMPLE\n        return SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv, c.dx, c.dy);\n   }\n\n   half4 SampleTexStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ) * c.uvT.weights.z;\n\n        return res;     \n   }\n\n   \n   half4 SampleTexStochastic(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n\n   half4 SampleTexTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n   \n   half4 SampleTex(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       COUNTSAMPLE\n       return SAMPLE_TEXTURE2D(tex, ss, c.uv);\n   }\n   \n\n \n   half3 SampleNormalStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n         dataX = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n         dataY = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n         dataZ = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ));\n\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n\n          return WorldToTangentSpace(d, worldNormal);\n       #endif\n   }\n\n\n   half3 SampleNormalTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n      {\n          COUNTSAMPLE\n          dataX = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv0, c.uvT.dx0, c.uvT.dy0));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n      {\n          COUNTSAMPLE\n          dataY = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv1, c.uvT.dx1, c.uvT.dy1));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n      {\n         COUNTSAMPLE\n         dataZ = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv2, c.uvT.dx2, c.uvT.dy2));\n      }\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n          return WorldToTangentSpace(d, worldNormal);\n      #endif\n   }\n\n   half3 SampleNormalStochastic(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n     half4 normal = TriSample(tex, ss, c.uvT);\n     #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half3 SampleNormal(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 normal = SAMPLE_TEXTURE2D(tex, ss, c.uv);\n      #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half HeightBlend(half h1, half h2, half slope, half contrast)\n   {\n      h2 = 1 - h2;\n      half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); \n      half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));\n      return blend;\n   }\n\n\n    #if _POM\n    float2 POM(TEXTURE2D_PARAM(tex, ss), Config c, float contrast, ShaderData d)\n    {\n       float2 curv = float2(0, 0);\n       float refPlane = 0;\n\n       float result = 0;\n       int stepIndex = 0;\n       int maxSamples = _POMMaxSamples;\n       int minSamples = 4;\n       float camDist = distance(_WorldSpaceCameraPos, d.worldSpacePosition);\n       float distanceFade = 1 - saturate((camDist - _POMMin) / max(1, _POMFade));\n       int numSteps = ( int )lerp( maxSamples, minSamples, dot( d.worldSpaceNormal, d.worldSpaceViewDir )) * distanceFade;\n       if (numSteps < 1)\n           numSteps = 1;\n       float layerHeight = 1.0 / numSteps;\n       float2 plane = _ParallaxHeight * ( d.tangentSpaceViewDir.xy / d.tangentSpaceViewDir.z ) * distanceFade;\n       OffsetUV(c, refPlane * plane);\n       float2 deltaTex = -plane * layerHeight;\n       float2 prevTexOffset = 0;\n       float prevRayZ = 1.0f;\n       float prevHeight = 0.0f;\n       float2 currTexOffset = deltaTex;\n       float currRayZ = 1.0f - layerHeight;\n       float currHeight = 0.0f;\n       float intersection = 0;\n       float2 finalTexOffset = 0;\n\n       while ( stepIndex < numSteps + 1 )\n       {\n          result = dot( curv, currTexOffset * currTexOffset );\n          Config cfg = c;\n          OffsetUV(cfg, currTexOffset);\n          currHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( currHeight > currRayZ )\n          {\n             stepIndex = numSteps + 1;\n          }\n          else\n          {\n             stepIndex++;\n             prevTexOffset = currTexOffset;\n             prevRayZ = currRayZ;\n             prevHeight = currHeight;\n             currTexOffset += deltaTex;\n             currRayZ -= layerHeight * ( 1 - result );\n          }\n       }\n       int sectionSteps = 10;\n       int sectionIndex = 0;\n       float newZ = 0;\n       float newHeight = 0;\n       while ( sectionIndex < sectionSteps )\n       {\n          intersection = ( prevHeight - prevRayZ ) / ( prevHeight - currHeight + currRayZ - prevRayZ );\n          finalTexOffset = prevTexOffset + intersection * deltaTex;\n          newZ = prevRayZ - intersection * layerHeight;\n          Config cfg = c;\n          OffsetUV(cfg, finalTexOffset);\n          newHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( newHeight > newZ )\n          {\n             currTexOffset = finalTexOffset;\n             currHeight = newHeight;\n             currRayZ = newZ;\n             deltaTex = intersection * deltaTex;\n             layerHeight = intersection * layerHeight;\n          }\n          else\n          {\n             prevTexOffset = finalTexOffset;\n             prevHeight = newHeight;\n             prevRayZ = newZ;\n             deltaTex = ( 1 - intersection ) * deltaTex;\n             layerHeight = ( 1 - intersection ) * layerHeight;\n          }\n          sectionIndex++;\n       }\n       #if _PASSHADOWS\n       if ( unity_LightShadowBias.z == 0.0 )\n       {\n       #endif\n          if ( result > 1 )\n             clip( -1 );\n       #if _PASSHADOWS\n       }\n       #endif\n       return finalTexOffset;\n    }\n    #endif\n\n   \n\n   // tess versions\n   #if _TESSELLATION_ON\n   half4 TriSampleLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias) * c.weights.x;\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias) * c.weights.y;\n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias) * c.weights.z;\n\n      return res;\n   }\n\n   half4 TriSampleBaryLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias, float contrast)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias);\n      half4 r2 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias);\n      half4 r3 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias);\n      c.weights = BaryWeightBlend(c.weights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryLODStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvX, bias, contrast) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvY, bias, contrast) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvZ, bias, contrast) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   half4 SampleTexBaryLODStochastic(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n       return TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias, contrast);\n   }\n\n   half4 SampleTexBaryLODTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return TriSampleLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias);\n   }\n\n   half4 SampleTexBaryLOD(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv, bias);\n   }\n\n\n    float FBM2DLOD(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           return SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv, _TessellationMipBias).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n        \n        \n    }\n\n    float FBM3DLOD(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           half A = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.zy, _TessellationMipBias).g;\n           half B = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33, _TessellationMipBias).g;\n           half C = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67, _TessellationMipBias).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoiseLOD(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3DLOD(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3DLOD(d.localSpacePosition * frequency + offset, d.localSpaceNormal);\n        #else\n           return FBM2DLOD(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n   #endif //_TESSELLATION_ON\n\n\n    half3 FuzzyShade(ShaderData d, half height, half3 color, half3 normal, half coreMult, half edgeMult, half power)\n    {\n        float3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half dt = saturate(dot(d.worldSpaceViewDir, worldNormal));\n        half dark = 1.0 - (coreMult * dt);\n        half edge = pow(1-dt, abs(power)) * edgeMult;\n        return color * (dark + edge);\n    }\n\n\thalf MicroShadow(ShaderData d, half3 normal, half height, half ao, half strength)\n\t{\n        float3 sun;\n\t\tfloat3 sunColor;\n\t\tGetSun(sun, sunColor);\n\t\tfloat3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half shadow = saturate(abs(dot(worldNormal, sun)) + (ao * ao * 2.0) - 1.0);\n        return 1 - ((1-shadow) * strength);\n\t}\n\n\n#endif\n\n\n\n   #if defined(_SPECULAR)\n      #define _USESPECULAR 1\n      #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n   #endif\n\n   \n   TEXTURE2D(_AlbedoMap);\n   SAMPLER(sampler_AlbedoMap);\n   TEXTURE2D(_NormalMap);\n   SAMPLER(sampler_NormalMap);\n   TEXTURE2D(_MaskMap);\n   TEXTURE2D(_DetailMap);\n   TEXTURE2D(_EmissionMap);\n\n   #if _SPECULAR\n       TEXTURE2D(_SpecularMap);\n   #endif\n\n   \n   \n   void Ext_SurfaceFunction0 (inout Surface o, inout ShaderData d)\n   {\n      // define samplers based on settings\n      #undef SAMPLEBARY\n      #undef SAMPLE\n      #undef SAMPLENORMAL\n      #if _STOCHASTIC && _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n        #define SAMPLE     SampleTexStochasticTriplanar\n        #define SAMPLENORMAL SampleNormalStochasticTriplanar\n      #elif _STOCHASTIC\n        #define SAMPLEBARY SampleTexBaryStochastic\n        #define SAMPLE     SampleTexStochastic\n        #define SAMPLENORMAL SampleNormalStochastic\n      #elif _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryTriplanar\n        #define SAMPLE     SampleTexTriplanar\n        #define SAMPLENORMAL SampleNormalTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBary\n        #define SAMPLE     SampleTex\n        #define SAMPLENORMAL SampleNormal\n      #endif\n\n      Config c = CreateConfig(d, _AlbedoMap_ST, _TriplanarSpace, _UVSource, _TriplanarContrast);\n      InitConfigDxDy(c);\n      #if _STOCHASTIC && !_TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uv, c.uvT);\n         InitStochasticDxDy(c.uvT, c);\n      #elif _STOCHASTIC && _TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv0, c.uvX);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv1, c.uvY);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv2, c.uvZ);\n         InitStochasticDxDy(c.uvX, c);\n         InitStochasticDxDy(c.uvY, c);\n         InitStochasticDxDy(c.uvZ, c);\n      #endif\n\n      #if _POM\n          // would need to handle height remapping if we ever want to ship this\n          float2 pomOffset = POM(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n          OffsetUV(c, pomOffset);\n      #endif\n\n      half4 albedo = SAMPLEBARY(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n      \n      #if _PARALLAX\n         float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n         OffsetUV(c, offset);\n         albedo = SAMPLE(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c);\n         \n      #endif\n      albedo.a = lerp(_HeightRemap.x, _HeightRemap.y, albedo.a);\n      albedo.rgb *= _Tint.rgb;\n\n      albedo.rgb = AdjustContrast(albedo.rgb, _AlbedoContrast);\n      albedo.rgb += _AlbedoBrightness;\n\n\n      if (_AlphaThreshold > 0)\n      {\n         clip(albedo.a - _AlphaThreshold);\n      }\n\n      #if defined(_FLATSHADE)\n\t\t     float3 dx = ddx(d.worldSpacePosition);\n\t\t     float3 dy = ddy(d.worldSpacePosition);\n\t\t     float3 worldNormal = normalize(cross(dy, dx));\n\t\t     worldNormal = lerp(d.worldSpaceNormal, worldNormal, _FlatShadingBlend);\n\t\t     d.worldSpaceNormal = worldNormal;\n\t\t     d.TBNMatrix[2] = worldNormal;\n      #endif\n\n\n\n      o.Albedo = albedo.rgb;\n      o.Alpha = albedo.a;\n\n      float smoothness = _Smoothness;\n      float ao = 1;\n\n      #if defined(_NORMALMAP) && !defined(_AUTONORMAL)\n         o.Normal = SAMPLENORMAL(TEXTURE2D_ARGS(_NormalMap, sampler_NormalMap), c, d, _NormalStrength, smoothness, ao);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, ao);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n      #endif\n\n      half detailMask = 1;\n      o.Smoothness = smoothness;\n      o.Occlusion = ao;\n      o.Metallic = _Metallic;\n      #if defined(_MASKMAP) && !_PACKEDFAST\n         // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = SampleTex(TEXTURE2D_ARGS(_MaskMap, sampler_AlbedoMap), c);\n         o.Metallic = lerp(_MetallicRemap.x, _MetallicRemap.y, mask.r);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, mask.g);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, mask.a);\n         detailMask = mask.b;\n      #endif // separate maps\n\n      #if _SPECULAR\n         o.Specular = SAMPLE(TEXTURE2D_ARGS(_SpecularMap, sampler_AlbedoMap), c).rgb;\n      #endif\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = SAMPLE(TEXTURE2D_ARGS(_EmissionMap, sampler_AlbedoMap), c).rgb * _EmissionColor;\n      #endif\n\n      if (_FuzzyShadingOn > 0)\n      {\n        o.Albedo *= FuzzyShade(d, albedo.a, _FuzzyShadingColor, o.Normal, _FuzzyShadingParams.x, _FuzzyShadingParams.y, _FuzzyShadingParams.z);\n      }\n\n\n      // HDRP style detail texturing\n\n      #if defined(_DETAIL)\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _DETAILSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n         Config dc = CreateConfig(d, _DetailMap_ST, _DetailTriplanarSpace, _DetailUVSource, _DetailTriplanarContrast);\n         InitConfigDxDy(dc);\n         #if _DETAILSTOCHASTIC && !_DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uv, dc.uvT);\n             InitStochasticDxDy(dc.uvT, dc);\n         #elif _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv0, dc.uvX);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv1, dc.uvY);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv2, dc.uvZ);\n             InitStochasticDxDy(dc.uvX, dc);\n             InitStochasticDxDy(dc.uvY, dc);\n             InitStochasticDxDy(dc.uvZ, dc);\n         #endif\n\n         half4 detailSample = SAMPLEBARY(TEXTURE2D_ARGS(_DetailMap, sampler_AlbedoMap), dc, _DetailStochasticContrast, d);\n         smoothness = detailSample.z;\n         #if !_AUTONORMAL\n            half3 dnormal = float3(detailSample.ag * 2 - 1, 1) * detailMask * _DetailNormalStrength;\n            dnormal.z = sqrt(1 - dnormal.x * dnormal.x - dnormal.y * dnormal.y);\n            #if _SURFACEGRADIENT\n               dnormal = ConvertNormalToGradient(d, dnormal);\n            #endif\n            o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n         #endif\n     \n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * smoothness, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n      if (_MicroShadowStrength > 0)\n      {\n        o.Occlusion *= MicroShadow(d, o.Normal, o.Alpha, o.Occlusion, _MicroShadowStrength);\n      }\n  \n      // in case something needs height in the stack..\n      o.Height = o.Alpha;\n\n\n      \n   }\n\n\n\n\t#if _TINTMASK\n\t\tTEXTURE2D(_TintMask);\n\t\tSAMPLER(sampler_TintMask);\n\t#endif\n\n\tvoid Ext_SurfaceFunction1 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _TINTMASK\n\t\t   half4 w = SAMPLE_TEXTURE2D(_TintMask, sampler_TintMask, d.texcoord0.xy * _TintMask_ST.xy + _TintMask_ST.zw);\n\t\t   // allow black to be no tint..\n\t\t   half3 tint = o.Albedo * (_RColor.rgb * 2 * w.r + _GColor.rgb * 2 * w.g + _BColor.rgb * 2 * w.b + _AColor.rgb * 2 * w.a);\n\t\t   o.Albedo = lerp(o.Albedo, tint, saturate(w.r + w.g + w.b + w.a));\n\t\t#endif\n\t}\n\n\n\n\n\t#if _LAYERTEXTUREMASK\n       TEXTURE2D(_LayerTextureMask);\n       SAMPLER(sampler_LayerTextureMask); \n    #endif\n\n   void Ext_ModifyTessellatedVertex2 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON\n          float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n\n          #if _LAYERTEXTUREMASK\n               float2 layerUV = v.texcoord0.xy;\n               if (_LayerTextureMaskUVMode == 1)\n                  layerUV = v.texcoord1.xy;\n               else if (_LayerTextureMaskUVMode == 2)\n                  layerUV = worldSpacePosition.yz;\n               else if (_LayerTextureMaskUVMode == 3)\n                  layerUV = worldSpacePosition.xz;\n               else if (_LayerTextureMaskUVMode == 4)\n                  layerUV = worldSpacePosition.xy;\n\n              e.blackboard.weightTextureMask = SAMPLE_TEXTURE2D_LOD(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw, _TessellationMipBias);\n          #endif\n      #endif\n    }\n\n\n\tvoid Ext_SurfaceFunction2 (inout Surface o, inout ShaderData d)\n\t{\n\t\t#if _LAYERTEXTUREMASK\n           float2 layerUV = d.texcoord0.xy;\n           if (_LayerTextureMaskUVMode == 1)\n              layerUV = d.texcoord1.xy;\n           else if (_LayerTextureMaskUVMode == 2)\n              layerUV = d.worldSpacePosition.yz;\n           else if (_LayerTextureMaskUVMode == 3)\n              layerUV = d.worldSpacePosition.xz;\n           else if (_LayerTextureMaskUVMode == 4)\n              layerUV = d.worldSpacePosition.xy;\n\n          d.blackboard.weightTextureMask = SAMPLE_TEXTURE2D(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw);\n      #endif\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap);\n   SAMPLER(sampler_LayerAlbedoMap);\n   TEXTURE2D(_LayerNormalMap);\n   TEXTURE2D(_LayerMaskMap);\n   TEXTURE2D(_LayerEmissionMap);\n\n   \n\n   void Ext_ModifyTessellatedVertex3 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER) && defined(_LAYERALBEDO) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n         half detailMask = 1;\n         #if _LAYERNOISE\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency,  _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin;\n            dt = saturate(dt * _LayerFalloff);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight) * _LayerFalloff);\n            if (_LayerInvertHeight > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength;\n         detailMask *= _LayerTessStrength;\n\n         #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast).a;\n         albedo = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo);\n\n         if (_LayerBlendMode == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction3 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n            // noise up the mask\n            #if _LAYERNOISE\n               mask = DoNoise(d, _LayerNoiseFrequency, _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend);\n\t    \n                dt -= _LayerAngleMin;\n                dt = saturate(dt * _LayerFalloff);\n\n                float hf = saturate((o.Height - _LayerHeight) * _LayerFalloff);\n                if (_LayerInvertHeight > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 0\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 0\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength;\n\n            #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint, 0.5);\n            #if defined(_LAYERALBEDO)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c, _LayerStochasticContrast, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c);\n                #endif\n                albedo.rgb *= _LayerTint;\n                albedo.a = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL || _LAYERMASK\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap, sampler_LayerAlbedoMap, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast);\n            albedo.rgb += _LayerAlbedoBrightness;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap, sampler_LayerAlbedoMap), c, d, _LayerNormalStrength * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO)\n                if (_LayerFuzzyShadingOn > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor.rgb, dnormal,\n                                            _LayerFuzzyShadingParams.x, _LayerFuzzyShadingParams.y, _LayerFuzzyShadingParams.z);\n                }\n\n                if (_LayerBlendMode == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast);\n                else if (_LayerBlendMode == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE\n                      float maskDif = (_LayerBlendContrast * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength);\n                   #if _LAYERNOISE\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap, sampler_LayerAlbedoMap), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength);\n                }\n\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap, sampler_LayerAlbedoMap), c).rgb * _LayerEmissionColor;\n                #if _LAYERALBEDO\n                    if (_LayerBlendMode > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_1);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_1);\n   TEXTURE2D(_LayerNormalMap_Ext_1);\n   TEXTURE2D(_LayerMaskMap_Ext_1);\n   TEXTURE2D(_LayerEmissionMap_Ext_1);\n\n   \n\n   void Ext_ModifyTessellatedVertex4 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_1) && defined(_LAYERALBEDO_DEF_1) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_1\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_1,  _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_1\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_1;\n            dt = saturate(dt * _LayerFalloff_Ext_1);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n            if (_LayerInvertHeight_Ext_1 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_1;\n         detailMask *= _LayerTessStrength_Ext_1;\n\n         #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_1).a;\n         albedo = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo);\n\n         if (_LayerBlendMode_Ext_1 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_1);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_1 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction4 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_1)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_1\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_1, _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_1\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_1);\n\t    \n                dt -= _LayerAngleMin_Ext_1;\n                dt = saturate(dt * _LayerFalloff_Ext_1);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n                if (_LayerInvertHeight_Ext_1 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 01\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 01\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_1;\n\n            #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_1, 0.5);\n            #if defined(_LAYERALBEDO_DEF_1)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, _LayerStochasticContrast_Ext_1, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_1;\n                albedo.a = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_1 || _LAYERMASK_DEF_1\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_1);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_1;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, d, _LayerNormalStrength_Ext_1 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_1)\n                if (_LayerFuzzyShadingOn_Ext_1 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_1.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_1.x, _LayerFuzzyShadingParams_Ext_1.y, _LayerFuzzyShadingParams_Ext_1.z);\n                }\n\n                if (_LayerBlendMode_Ext_1 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_1);\n                else if (_LayerBlendMode_Ext_1 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_1 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_1);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_1\n                      float maskDif = (_LayerBlendContrast_Ext_1 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_1 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                   #if _LAYERNOISE_DEF_1\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_1));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_1 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_1);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_1) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_1 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_1);\n                }\n\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_1);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_1, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_1, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_1\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c).rgb * _LayerEmissionColor_Ext_1;\n                #if _LAYERALBEDO_DEF_1\n                    if (_LayerBlendMode_Ext_1 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_2);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_2);\n   TEXTURE2D(_LayerNormalMap_Ext_2);\n   TEXTURE2D(_LayerMaskMap_Ext_2);\n   TEXTURE2D(_LayerEmissionMap_Ext_2);\n\n   \n\n   void Ext_ModifyTessellatedVertex5 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_2) && defined(_LAYERALBEDO_DEF_2) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_2\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_2,  _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_2\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_2;\n            dt = saturate(dt * _LayerFalloff_Ext_2);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n            if (_LayerInvertHeight_Ext_2 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_2;\n         detailMask *= _LayerTessStrength_Ext_2;\n\n         #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_2).a;\n         albedo = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo);\n\n         if (_LayerBlendMode_Ext_2 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_2);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_2 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction5 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_2)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_2\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_2, _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_2\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_2);\n\t    \n                dt -= _LayerAngleMin_Ext_2;\n                dt = saturate(dt * _LayerFalloff_Ext_2);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n                if (_LayerInvertHeight_Ext_2 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 02\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 02\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_2;\n\n            #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_2, 0.5);\n            #if defined(_LAYERALBEDO_DEF_2)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, _LayerStochasticContrast_Ext_2, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_2;\n                albedo.a = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_2 || _LAYERMASK_DEF_2\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_2);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_2;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, d, _LayerNormalStrength_Ext_2 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_2)\n                if (_LayerFuzzyShadingOn_Ext_2 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_2.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_2.x, _LayerFuzzyShadingParams_Ext_2.y, _LayerFuzzyShadingParams_Ext_2.z);\n                }\n\n                if (_LayerBlendMode_Ext_2 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_2);\n                else if (_LayerBlendMode_Ext_2 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_2 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_2);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_2\n                      float maskDif = (_LayerBlendContrast_Ext_2 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_2 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                   #if _LAYERNOISE_DEF_2\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_2));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_2 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_2);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_2) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_2 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_2);\n                }\n\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_2);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_2, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_2, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_2\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c).rgb * _LayerEmissionColor_Ext_2;\n                #if _LAYERALBEDO_DEF_2\n                    if (_LayerBlendMode_Ext_2 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   #if _TRAX_ON\n   TEXTURE2D(_TraxAlbedo);\n   SAMPLER(sampler_TraxAlbedo);\n   TEXTURE2D(_TraxPackedNormal);\n   TEXTURE2D(_TraxMask);\n\n   sampler2D_float _GMSTraxBuffer;\n\n   float4 _GMSTraxBuffer_TexelSize;\n   float3 _GMSTraxBufferPosition;\n   float _GMSTraxBufferWorldSize;\n   float _GMSTraxFudgeFactor;\n\n   float SampleTraxBufferLOD(float3 worldPos)\n   {    \n      // generate UVs for the buffer, which is moving\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 8);\n      uv *= 0.5;\n      uv += 0.5;\n            \n      float s =  tex2Dlod(_GMSTraxBuffer, float4(uv, 0, 0)).r;\n\n      return 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n   }\n         \n        \n   float SampleTraxBuffer(float3 worldPos, out float3 norm)\n   {\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 3);\n      uv *= 0.5;\n      uv += 0.5;\n            \n\n      float2 offset = _GMSTraxBuffer_TexelSize.xy;\n\n      float s = tex2D(_GMSTraxBuffer, uv).r;\n               \n      float s1 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, -1)).r;\n      float s2 = tex2D(_GMSTraxBuffer, uv + offset * float2(-1, 0)).r;\n      float s3 = tex2D(_GMSTraxBuffer, uv + offset * float2(1, 0)).r;\n      float s4 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, 1)).r;\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      float r = 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n \n      // generate normals\n      norm.x = (s1 - s4) * 0.25; \n      norm.y = (s2 - s3) * 0.25;\n      norm.z = 2;\n      norm = normalize(norm);\n     \n      norm.xy *= 1 - r;\n            \n      return r;\n   }\n   #endif\n\n   void Ext_ModifyTessellatedVertex6 (inout VertexData v, inout ExtraV2F d)\n   {\n       #if _TESSELLATION_ON && _TRAX_ON && _HAS_LIT_TESSELLATION\n          \n           float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n           float3 worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n           float traxBuffer = SampleTraxBufferLOD(worldSpacePosition);\n           d.blackboard.traxBuffer = traxBuffer;\n           float2 uv = worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n           half albedo = SAMPLE_TEXTURE2D_LOD(_TraxAlbedo, sampler_TraxAlbedo, uv, _TraxMipBias).a;\n\n           float traxOffset = albedo * _TraxDisplacementStrength;\n           traxOffset *= 1 - v.texcoord0.z;\n           traxOffset *= _TessellationDisplacement;\n           float dig = _TraxDisplacementDepth * (1 - v.texcoord0.z);\n           float3 traxVertex = d.blackboard.originalVertexPosition + (v.normal * (traxOffset - dig));\n           v.vertex.xyz = lerp(traxVertex, v.vertex.xyz, traxBuffer);\n\n           d.blackboard.vertexHeightOffset = lerp(traxOffset-dig, d.blackboard.vertexHeightOffset, traxBuffer);\n\n       #endif\n\n   }\n\n   void Ext_SurfaceFunction6 (inout Surface o, inout ShaderData d)\n   {\n      #if _TRAX_ON\n        float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n        float2 fsdx = ddx(uv);\n        float2 fsdy = ddy(uv);\n\n        float3 traxNormal;\n        float traxBuffer = SampleTraxBuffer(d.worldSpacePosition, traxNormal);\n        \n        #if _TESSELLATION_ON\n            traxBuffer -= _TraxDisplacementDepth;\n        #endif\n\n        d.blackboard.traxBuffer = traxBuffer;\n\n        UNITY_BRANCH\n        if (traxBuffer > 0)\n        {\n            half4 albedo = SAMPLE_TEXTURE2D_GRAD(_TraxAlbedo, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            albedo.rgb *= _TraxTint.rgb;\n            half4 normalSample = SAMPLE_TEXTURE2D_GRAD(_TraxPackedNormal, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n\n            half smoothness = normalSample.r;\n            half ao = normalSample.b;\n            half3 normal;\n            normal.xy = (normalSample.ag * 2 - 1) * _TraxNormalStrength;\n            normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n\n            \n            half h = HeightBlend(albedo.a, o.Alpha, traxBuffer, _TraxHeightContrast);\n\n            h = lerp(traxBuffer, h, _TraxInterpContrast);\n\n            o.Albedo = lerp(albedo, o.Albedo, h);\n\n            #if _SURFACEGRADIENT\n                o.Normal = lerp(normal, o.Normal, h);\n            #else\n                o.Normal = lerp(normal + traxNormal, o.Normal, h);\n            #endif\n        \n            o.Smoothness = lerp(smoothness, o.Smoothness, h);\n            o.Occlusion = lerp(ao, o.Occlusion, h);\n        }\n      #endif\n   }\n\n\n\n\n    #if _RAINDROPS\n       TEXTURE2D(_RainDropTexture);\n       SAMPLER(sampler_RainDropTexture);\n       half _Global_RainIntensity;\n    #endif\n\n    #if _WETNESS\n       half2 _Global_WetnessParams; // global, not in cbuffer\n    #endif\n   \n    #if _RAINDROPS\n    half2 ComputeRipple(float2 uv, half time, half weight)\n    {\n        half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_RainDropTexture, uv);\n        COUNTSAMPLE\n        ripple.yz = ripple.yz * 2 - 1;\n\n        half dropFrac = frac(ripple.w + time);\n        half timeFrac = dropFrac - 1.0 + ripple.x;\n        half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);\n        half finalFactor = dropFactor * ripple.x * \n                                sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);\n\n        return half2(ripple.yz * finalFactor);\n    }\n    #endif\n\n    half2 DoRain(half2 waterNorm, float2 uv, out half2 ripple)\n    {\n        #if _RAINDROPS\n            float rainIntensity = _RainIntensityScale.x;\n            if (_RainMode > 1)\n            {\n                rainIntensity = _Global_RainIntensity;\n            }\n\n            half dropStrength = rainIntensity;\n            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); \n            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);\n            half4 times = _Time.yyyy;\n            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);\n\n            float2 ruv1 = uv * _RainIntensityScale.yy;\n            float2 ruv2 = ruv1;\n\n            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);\n            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);\n            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);\n            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);\n            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);\n            weights = saturate(weights * 4);\n\n            half2 rippleNormal = half2( weights.x * ripple1.xy +\n                        weights.y * ripple2.xy + \n                        weights.z * ripple3.xy + \n                        weights.w * ripple4.xy);\n\n            ripple = rippleNormal * dropStrength * rainIntensity;\n            waterNorm = lerp(waterNorm, normalize(half3(rippleNormal.xy + rippleNormal.xy, 1)).xy, rainIntensity * dropStrength); \n            return waterNorm;                        \n        #else\n            return waterNorm;\n        #endif\n    }\n\n   half2 _Global_PuddleParams;   // this is a global, so keep it out of the cbuffer\n   void GetPuddleParams(ShaderData d, inout float puddleMask, inout float pudHeight)\n   {\n      #if _PUDDLES || _GLOBALPUDDLES\n          pudHeight = _PuddleAmount;\n          if (_PuddleMode > 0)\n             pudHeight = _Global_PuddleParams.x;    \n      \n\n          half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t      dt -= _PuddleAngleMin;\n          dt = saturate(dt * _PuddleFalloff);\n          puddleMask *= dt;\n      #endif\n   }\n   \n   void Ext_ModifyTessellatedVertex7 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _PUDDLES && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n         half mask = 1;\n         half pudHeight = 1;\n\n         // save some ops by doing this in 2d\n         #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2DLOD(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2DLOD(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #else\n                mask = (FBM2DLOD(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n         #endif\n\n         GetPuddleParams(d, mask, pudHeight);\n         float height = pudHeight * mask;\n         if (e.blackboard.vertexHeightOffset < height)\n         {\n            e.blackboard.vertexHeightOffset = height;\n            height -= _TessellationOffset; \n            // dampen cracks\n            height *= 1 - v.texcoord0.z;\n            height *= _TessellationDisplacement;\n            v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n            \n        }\n      #endif\n   }\n\n\n#if _WETNESS\n\n   float GetWetnessLevel(Surface o, ShaderData d, float wetnessMask)\n   {\n      float wetLevel = clamp(_WetnessAmount, _WetnessMin, _WetnessMax);\n      \n      if (_WetnessMode > 0)\n         wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);\n\n      wetLevel = saturate(wetLevel + (1 - saturate(d.worldSpacePosition.y - _WetnessShoreline)));\n      float3x3 tbn = float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal);\n      float dt = dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0));\n      dt -= _WetnessAngleMin;\n      dt = saturate(dt * _WetnessFalloff * wetLevel);\n      dt *= wetnessMask;\n      return dt;\n   }\n#endif\n   \n\n   void Ext_SurfaceFunction7 (inout Surface o, ShaderData d)\n   {\n      half wetnessLevel = 0;\n      #if _WETNESS\n          wetnessLevel = GetWetnessLevel(o, d, 1); // mask one day?\n      #endif\n\n      half depthMask = 0;\n      half depth = 0;\n\n      #if _PUDDLES\n          half mask = 1;\n          half pudHeight = 1;\n          #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2D(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2D(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);      \n            #else\n                mask = (FBM2D(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n          #endif\n\n          GetPuddleParams(d, mask, pudHeight);\n          pudHeight *= mask;\n          depth = pudHeight - o.Height;\n          depthMask = saturate(depth * _PuddleFalloff);\n          depthMask *= _PuddleColor.a;\n          depth = o.Height - pudHeight;\n\n          // extend wetness slighting higher than the puddle\n          half wetmask = saturate((pudHeight + 0.05 - o.Height) * _PuddleFalloff);\n          wetnessLevel = max(wetmask, wetnessLevel);\n       #endif\n\n       \n       #if _WETNESS || _PUDDLES\n          half3 waterNorm = half3(0,0,1);\n          half3 wetAlbedo = o.Albedo;\n          half wetSmoothness = o.Smoothness;\n          #if _PUDDLES\n             wetAlbedo *= _PuddleColor.rgb;\n          #endif\n          WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetnessLevel, _Porosity);\n\n          half ri = 0;\n          half2 ripple = 0;\n          #if (_RAINDROPS || _GLOBALRAIN) && (_PUDDLES || _GLOBALPUDDLES)\n             ri = _RainIntensityScale.z;\n             waterNorm.xy = DoRain(waterNorm.xy, d.texcoord0.xy, ripple) * depthMask;\n          #endif\n\n          o.Normal = lerp(o.Normal, waterNorm, depthMask);\n          o.Normal = lerp(o.Normal, LitBlendDetailNormal(o.Normal, half3(ripple.xy, 1)), saturate(ri - depthMask) * wetnessLevel);\n          o.Occlusion = lerp(o.Occlusion, 1, depthMask);\n          o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetnessLevel);\n          o.Albedo = lerp(o.Albedo, wetAlbedo, wetnessLevel);\n          o.Emission *= 1 + depth;\n          o.Metallic *= 1 + depth;\n          o.Specular *= 1 + depth;\n\n       #endif\n\n   }\n\n\n\n\n    #if _SNOW\n       TEXTURE2D(_SnowAlbedo);\n       SAMPLER(sampler_SnowAlbedo);\n       TEXTURE2D(_SnowNormal);\n       TEXTURE2D(_SnowMaskMap);\n       #if _TRAX_ON\n          TEXTURE2D(_SnowTraxAlbedo);\n          TEXTURE2D(_SnowTraxNormal);\n          TEXTURE2D(_SnowTraxMaskMap);\n       #endif\n    #endif\n\n   float _Global_SnowLevel;\n\n\n   void Ext_ModifyVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n    #if (_SNOW)\n        float amount = _SnowAmount;\n        if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n        float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n        float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n        snowAmount -= _SnowAngle;\n        snowAmount *= _SnowContrast * 0.5;\n        snowAmount = saturate(snowAmount) * amount;\n        float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n        if (_SnowWorldFade.z > 0)\n        {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n        }\n        #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n        #endif\n        snowAmount = saturate(snowAmount);\n\n        #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n        #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n        #endif\n\n        float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n        v.vertex.xyz = v.vertex.xyz + displacementVec * snowAmount * snowAmount * _SnowVertexHeight;\n    #endif\n   }\n\n   void Ext_ModifyTessellatedVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _SNOW && _HAS_LIT_TESSELLATION\n         float amount = _SnowAmount;\n         if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n         float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n         float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n         snowAmount -= _SnowAngle;\n         snowAmount *= _SnowContrast * 0.5;\n         float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n         if (_SnowWorldFade.z > 0)\n         {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n         }\n\n         snowAmount = saturate(snowAmount) * amount;\n\n         #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n         #endif\n         snowAmount = saturate(snowAmount);\n\n         #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n         #endif\n\n         float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n         half heightMap = SAMPLE_TEXTURE2D_LOD(_SnowAlbedo, sampler_SnowAlbedo, worldPos.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw, 2);\n\n         float height = max(_SnowVertexHeight * 3 * snowAmount + snowAmount * heightMap, e.blackboard.vertexHeightOffset);\n         #if _TRAX_ON\n            height *= e.blackboard.traxBuffer;\n         #endif\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n\n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n         \n      #endif\n\n   }\n\n   void SampleSnowSurface(TEXTURE2D_PARAM(alb, ss), TEXTURE2D_PARAM(norm, ss2), TEXTURE2D_PARAM(mask, ss3),\n        ShaderData d, float2 uv, float2 dx, float2 dy, out half4 albedo, out half3 normal, out half2 smoothAO)\n   {\n      #if _SNOWSTOCHASTIC\n         float w1, w2, w3;\n         int2 vertex1, vertex2, vertex3;\n         TriangleGrid(uv, _SnowStochasticScale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n         // Assign random offset to each triangle vertex\n         float2 uv0 = uv;\n         float2 uv1 = uv;\n         float2 uv2 = uv;\n   \n         uv0.xy += SimpleHash2(vertex1);\n         uv1.xy += SimpleHash2(vertex2);\n         uv2.xy += SimpleHash2(vertex3);\n         half3 weights = half3(w1, w2, w3);\n\n         half4 albedo0 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv0, dx, dy);\n         half4 albedo1 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv1, dx, dy);\n         half4 albedo2 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv2, dx, dy);\n         COUNTSAMPLE\n         COUNTSAMPLE\n         COUNTSAMPLE\n         weights = BaryWeightBlend(weights, albedo0.a, albedo1.a, albedo2.a, _SnowStochasticContrast);\n         albedo = albedo0 * weights.x + albedo1 * weights.y + albedo2 * weights.z;\n\n         normal = half3(0,0,1);\n         smoothAO = half2(0, 1);\n\n         #if !_AUTONORMAL\n            half4 n0 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv0, dx, dy);\n            half4 n1 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv1, dx, dy);\n            half4 n2 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n            half4 snowNormSamp = n0 * weights.x + n1 * weights.y + n2 * weights.z;\n\n            normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n                \n            #if _PACKEDFAST\n               smoothAO.x = snowNormSamp.r;\n               smoothAO.y = snowNormSamp.b;\n            #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask0 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv0, dx, dy);\n            half4 snowMask1 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv1, dx, dy);\n            half4 snowMask2 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n            half4 snowMask = snowMask0 * weights.x + snowMask1 * weights.y + snowMask2 * weights.z;\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n      #else // not stochastic\n          albedo = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv, dx, dy);\n          COUNTSAMPLE\n\n          normal = half3(0,0,1);\n          smoothAO = half2(0, 1);\n\n          #if !_AUTONORMAL\n             half4 snowNormSamp = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv, dx, dy);\n             COUNTSAMPLE\n             normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n             #if _SURFACEGRADIENT\n                normal = ConvertNormalToGradient(d, normal);\n             #endif\n                 \n             #if _PACKEDFAST\n                smoothAO.x = snowNormSamp.r;\n                smoothAO.y = snowNormSamp.b;\n             #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv, dx, dy);\n            COUNTSAMPLE\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n     #endif // stochastic\n   }\n\n   \n   void Ext_SurfaceFunction8 (inout Surface o, ShaderData d)\n   {\n      #if _SNOW\n          float amount = _SnowAmount;\n          if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n          float snowAmount = lerp(dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), dot(d.worldSpaceNormal, float3(0,1,0)), amount * 0.8) + 1;\n          snowAmount -= _SnowAngle;\n          snowAmount *= _SnowContrast;\n          snowAmount = saturate(snowAmount) - (1-amount) * (1-amount);\n\n          if (_SnowWorldFade.z > 0)\n          {\n             float worldFade = saturate((d.worldSpacePosition.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n             snowAmount *= worldFade;\n          }\n\n          #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(d.worldSpacePosition.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n          #endif\n          snowAmount = saturate(snowAmount);\n\n          float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw;\n          float2 dx = ddx(uv);\n          float2 dy = ddy(uv);\n\n          #if _TRAX_ON\n              float2 tuv = d.worldSpacePosition.xz * float2(1, -1) * _SnowTraxAlbedo_ST.xy + _SnowTraxAlbedo_ST.zw;\n              float2 tdx = ddx(uv);\n              float2 tdy = ddy(uv);\n          #endif\n\n          #if _LAYERVERTEXMASK\n              snowAmount *= d.vertexColor.a;\n          #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n              snowAmount *= d.blackboard.weightTextureMask.a;\n          #endif\n\n          UNITY_BRANCH\n          if (snowAmount > 0)\n          {\n             half4 snowAlbedo;\n             half3 snowNormal;\n             half2 snowSmoothAO;\n             SampleSnowSurface(TEXTURE2D_ARGS(_SnowAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowNormal, sampler_SnowAlbedo),\n                    TEXTURE2D_ARGS(_SnowMaskMap, sampler_SnowAlbedo), d, uv, dx, dy, snowAlbedo, snowNormal, snowSmoothAO);\n\n             snowAlbedo.rgb *= _SnowTint.rgb;\n\n             #if _TRAX_ON\n                half traxBuffer = 1 - d.blackboard.traxBuffer;\n                UNITY_BRANCH\n                if (traxBuffer > 0)\n                {\n                    half4 tsnowAlbedo;\n                    half3 tsnowNormal;\n                    half2 tsnowSmoothAO;\n                    SampleSnowSurface(TEXTURE2D_ARGS(_SnowTraxAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowTraxNormal, sampler_SnowAlbedo),\n                        TEXTURE2D_ARGS(_SnowTraxMaskMap, sampler_SnowAlbedo), d, tuv, tdx, tdy, tsnowAlbedo, tsnowNormal, tsnowSmoothAO);\n\n                    tsnowAlbedo.rgb *= _SnowTraxTint;\n                    half h = HeightBlend(snowAlbedo.a, tsnowAlbedo.a, traxBuffer, 0.5);\n                    snowAlbedo = lerp(snowAlbedo, tsnowAlbedo, h);\n                    snowNormal = lerp(snowNormal, tsnowNormal, h);\n                    snowSmoothAO = lerp(snowSmoothAO, tsnowSmoothAO, h);\n                }\n             #endif\n\n             #if !_AUTONORMAL\n                o.Normal = lerp(o.Normal, snowNormal, snowAmount);\n             #endif\n             o.Albedo = lerp(o.Albedo, snowAlbedo.rgb, snowAmount);\n             o.Alpha = lerp(o.Alpha, snowAlbedo.a, snowAmount);\n             o.Smoothness = lerp(o.Smoothness, snowSmoothAO.x, snowAmount);\n             o.Occlusion = lerp(o.Occlusion, snowSmoothAO.y, snowAmount);\n             o.Height = o.Alpha;\n\n          }\n      #endif\n   }\n\n   \n\n\n\n\n\n   TEXTURE2D(_WindParticulate);\n   SAMPLER(sampler_WindParticulate);\n\n// In case we want to read it more than once..\n\n#ifndef __STACKABLE_WIND_INCLUDES__\n#define __STACKABLE_WIND_INCLUDES__\n\n\n   half FilterRange(float4 range, float y)\n   {\n      half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));\n      w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));\n      return w;\n   }\n\n   \n   float2 RotateUV(float2 uv, float amt)\n   {\n      uv -=0.5;\n      float s = sin ( amt);\n      float c = cos ( amt );\n      float2x2 mtx = float2x2( c, -s, s, c);\n      mtx *= 0.5;\n      mtx += 0.5;\n      mtx = mtx * 2-1;\n      uv = mul ( uv, mtx );\n      uv += 0.5;\n      return uv;\n   }\n\n\n   half FilterWindParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)\n   {\n      float2 windDir = RotateUV(float2(1, 0), windRot);\n      float2 flow = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));\n      float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill\n      return FilterRange(range, cofacing);\n   }\n\n   half ProcessWindParticulateMask(inout half mask, float contrast)\n   {\n      mask = pow(abs(mask), abs(contrast));\n      half invMask = 1.0 - mask;\n      invMask *= invMask; \n      invMask *= invMask;\n      return invMask;\n   }\n#endif // include guard\n\n   void Ext_SurfaceFunction9 (inout Surface o, ShaderData d)\n   {\n      #if _WIND_ON && !_PASSMETA\n   \n         float3 upVector = float3(0,0,1);\n\n         half upDot = max(0.0, dot(d.worldSpaceNormal, float3(0, 1, 0)));\n\n         float2 uv = d.worldSpacePosition.xz;\n         if (_WindParticulateSpace > 0.5)\n            uv = d.texcoord0.xy;\n         float windRotation = _WindParticulateRotation;\n         float windStrength = _WindParticulateStrength;\n\n         float2 wuv = RotateUV(uv, windRotation);\n\n         half windBlend = 1.0;\n\n         float windWorldMask = FilterRange(_WindParticulateWorldHeightMask, d.worldSpacePosition.y);\n         windWorldMask *= FilterRange(_WindParticulateAngleMask, upDot);\n\n         // compute mask\n         wuv *= float2(_WindParticulate_ST.x, 1) * _WindParticulate_ST.y + _WindParticulate_ST.zw;\n         float speed = _Time.x * _WindParticulateSpeed;\n         half w1 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv * 3 + speed * float2(1,0)).g;\n         half w2 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv + speed * float2(1.1,0)).a;\n         half windMask = (w1 * w2);\n\n         windMask *= windStrength * windBlend * windWorldMask;\n         windMask *= saturate((_WindParticulateTextureHeight - o.Height) * 10);\n\n         half windInvMask = ProcessWindParticulateMask(windMask, _WindParticulatePower);\n    \n         o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);\n         o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindParticulateEmissive.rgb;\n         o.Normal.xy *= windInvMask;\n         o.Smoothness *= windInvMask;\n         o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;\n         o.Metallic *= windInvMask;\n      #endif\n\n   }\n\n\n\n\n\tvoid Ext_SurfaceFunction10 (inout Surface o, ShaderData d)\n\t{\n        if (_DoubleSidedNormalMode == 0)\n        {\n           o.Normal *= d.isFrontFace ? 1 : -1;\n        }\n        else if (_DoubleSidedNormalMode == 1)\n        {\n\t\t   o.Normal.z *= d.isFrontFace ? 1 : -1;\n        }\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction11 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _SURFACEGRADIENT\n\t\t\to.Normal = ResolveNormalFromSurfaceGradient(d, o.Normal);\n\t    #elif _AUTONORMAL\n\t        float3 dx = ddx(d.worldSpacePosition);\n\t\t\tfloat3 dy = ddy(d.worldSpacePosition);\n\t\t\tfloat3 crossX = cross(float3(0,1,0), dx);\n\t\t\tfloat3 crossY = cross(float3(0,1,0), dy);\n\t\t\tfloat3 dt = abs(dot(crossY, dx));\n\t\t\tfloat height = _AutoNormalStrength * 0.5 * o.Alpha;\n\t\t\tfloat3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n\t\t\tn.y *= -1.0;\n\t\t\to.Normal = normalize((dt * float3(0,1,0)) - n).xzy;\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#else\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#endif\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction12 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DEBUG_SAMPLECOUNT\n\t\t\tif (_sampleCount > _DebugSampleCountThreshold)\n\t\t\t{\n\t\t\t\to.Albedo.r = 1;\n\t\t\t\to.Albedo.gb *= 0.2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\to.Albedo.b = 1;\n\t\t\t}\n\n        #endif\n\t}\n\n\n\n\n\tSAMPLER(sampler_DissolveTexture);\n\tTEXTURE2D(_DissolveTexture);\n\tTEXTURE2D(_DissolveGradient);\n\n\tvoid Ext_SurfaceFunction13 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DISSOLVE\n\t\tfloat2 uv = d.texcoord0.xy * _DissolveTexture_ST.xy + _DissolveTexture_ST.zw;\n\t\tfloat2 dx = ddx(uv);\n\t\tfloat2 dy = ddy(uv);\n\n\t\tUNITY_BRANCH\n\t\tif (_DissolveAmount > 0)\n\t\t{\n\t\t\thalf dissolve = SAMPLE_TEXTURE2D_GRAD(_DissolveTexture, sampler_DissolveTexture, uv, dx, dy).g;\n\t\t\thalf cp =  saturate(_DissolveAmount - (dissolve - _DissolveAmount) * _DissolveEdgeContrast) + _DissolveAmount;\n\t\t\thalf cp2 = saturate(1.0 - abs((dissolve - _DissolveAmount) * _DissolveEdgeContrast));\n\t\t\tclip(1.0 - cp);\n\t\t\tfloat2 fuv = float2(cp2, 0.5);\n\t\t\thalf3 col = SAMPLE_TEXTURE2D_LOD(_DissolveGradient, sampler_DissolveTexture, fuv, 0).rgb;\n\t\t\t\t\n\t\t\to.Albedo = lerp(o.Albedo, col, _DissolveColoration * cp2);\n\t\t\to.Emission = lerp(o.Emission, col * _DissolveEmissiveStr, _DissolveColoration * cp2);\n\t\t}\n\t\t#endif\n\t}\n\n\n\n\n    float Dither8x8Bayer( int x, int y )\n    {\n        const float dither[ 64 ] = {\n                1, 49, 13, 61,  4, 52, 16, 64,\n            33, 17, 45, 29, 36, 20, 48, 32,\n                9, 57,  5, 53, 12, 60,  8, 56,\n            41, 25, 37, 21, 44, 28, 40, 24,\n                3, 51, 15, 63,  2, 50, 14, 62,\n            35, 19, 47, 31, 34, 18, 46, 30,\n            11, 59,  7, 55, 10, 58,  6, 54,\n            43, 27, 39, 23, 42, 26, 38, 22};\n        int r = y * 8 + x;\n        return dither[r] / 64; \n    }\n\n    void ApplyDitherCrossFadeVSP(float2 vpos, float fadeValue)\n    {\n        float dither = Dither8x8Bayer( fmod(vpos.x, 8), fmod(vpos.y, 8) );\n        float sgn = fadeValue > 0 ? 1.0f : -1.0f;\n        clip(dither - (1-fadeValue) * sgn);\n    }\n    \n\n\tvoid Ext_SurfaceFunction14 (inout Surface o, ShaderData d)\n\t{\n\t\t#if LOD_FADE_CROSSFADE\n            float4 screenPosNorm = d.screenPos / d.screenPos.w;\n            screenPosNorm.z = ( UNITY_NEAR_CLIP_VALUE >= 0 ) ? screenPosNorm.z : screenPosNorm.z * 0.5 + 0.5;\n            float2 clipScreen = screenPosNorm.xy * _ScreenParams.xy;\n            ApplyDitherCrossFadeVSP(clipScreen,unity_LODFade.x);\n        #endif\n\t}\n\n\n\n\n\n\n// declare outside of CBuffer\n\nfloat4x4 _GlobalVolumeMatrix;\nfloat4x4 _VolumeMatrix;\nfloat3 _VolumeMin;\nfloat3 _VolumeInvSize;\nfloat3 _GlobalVolumeMin;\nfloat3 _GlobalVolumeInvSize;\n\n// I inlined a section of your include. You can use includes in better shaders, but doing it via a subshader or this way\n// is much better. The reason is that this allows your shader to be all inclusive, and packed up for asset store distribition,\n// without requiring specific paths to other files, etc.\n//\n\n#ifndef BAKERY_INCLUDED\n#define BAKERY_INCLUDED\n\n#define BAKERYMODE_DEFAULT 0\n#define BAKERYMODE_VERTEXLM 1.0f\n#define BAKERYMODE_RNM 2.0f\n#define BAKERYMODE_SH 3.0f\n\n\n// can't fit vertexLM SH to sm3_0 interpolators\n#ifndef SHADER_API_D3D11\n    #undef _LIGHTMAPMODE_VERTEXSH\n#endif\n\n// can't do stuff on sm2_0 due to standard shader alrady taking up all instructions\n#if SHADER_TARGET < 30\n    #undef BAKERY_BICUBIC\n    #undef BAKERY_LMSPEC\n\n    #undef _LIGHTMAPMODE_RNM\n    #undef _LIGHTMAPMODE_SH\n    #undef _LIGHTMAPMODE_VERTEX\n#endif\n\n#define lumaConv float3(0.2125f, 0.7154f, 0.0721f)\n\n#ifdef BAKERY_VOLUME\n    #ifdef BAKERY_COMPRESSED_VOLUME\n        Texture3D _Volume3;\n    #endif\n#endif\n\n\nhalf3 LinearToGamma (half3 linRGB)\n{\n    linRGB = max(linRGB, half3(0.h, 0.h, 0.h));\n    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n    return max(1.055h * pow(linRGB, 0.416666667h) - 0.055h, 0.h);\n}\n\nfloat shEvaluateDiffuseL1Geomerics(float L0, float3 L1, float3 n)\n{\n    // average energy\n    float R0 = L0;\n\n    // avg direction of incoming light\n    float3 R1 = 0.5f * L1;\n\n    // directional brightness\n    float lenR1 = length(R1);\n\n    // linear angle between normal and direction 0-1\n    //float q = 0.5f * (1.0f + dot(R1 / lenR1, n));\n    //float q = dot(R1 / lenR1, n) * 0.5 + 0.5;\n    float q = dot(normalize(R1), n) * 0.5 + 0.5;\n\n    // power for q\n    // lerps from 1 (linear) to 3 (cubic) based on directionality\n    float p = 1.0f + 2.0f * lenR1 / R0;\n\n    // dynamic range constant\n    // should vary between 4 (highly directional) and 0 (ambient)\n    float a = (1.0f - lenR1 / R0) / (1.0f + lenR1 / R0);\n\n    return R0 * (a + (1.0f - a) * (p + 1.0f) * pow(q, p));\n}\n\n#ifdef BAKERY_VERTEXLMMASK\n    float4 unpack4NFloats(float src)\n\t{\n        //return fmod(float4(src / 262144.0, src / 4096.0, src / 64.0, src), 64.0)/64.0;\n        return frac(float4(src / (262144.0*64), src / (4096.0*64), src / (64.0*64), src));\n    }\n#endif\n\n#if defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n    float3 unpack3NFloats(float src)\n\t{\n        float r = frac(src);\n        float g = frac(src * 256.0);\n        float b = frac(src * 65536.0);\n        return float3(r, g, b);\n    }\n#endif\n\n// Unity defines these under different names in each SRP, so use our own\ninline float3 Bakery_SafeNormalize(float3 inVec)\n{\n    float dp3 = max(0.001f, dot(inVec, inVec));\n    return inVec * rsqrt(dp3);\n}\n\n#if _URP || _HDRP\n\nfloat SmoothnessToPerceptualRoughness(float smoothness)\n{\n    return (1 - smoothness);\n}\n#endif\n\n#if !_STANDARD\nhalf4 unity_Lightmap_HDR;\ninline half3 DecodeLightmap( half4 color )\n{\n    return DecodeLightmap( color, unity_Lightmap_HDR );\n}\n\n#define UNITY_INV_PI        0.31830988618f\ninline float GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return UNITY_INV_PI * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n    void BakeryVertexLMDirection(inout float3 diffuseColor, inout float3 specularColor, float3 lightDirection, float3 vertexNormalWorld, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 dominantDir = Bakery_SafeNormalize(lightDirection);\n        half halfLambert = dot(normalWorld, dominantDir) * 0.5 + 0.5;\n        half flatNormalHalfLambert = dot(vertexNormalWorld, dominantDir) * 0.5 + 0.5;\n\n        #ifdef BAKERY_LMSPEC\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = spec * diffuseColor;\n        #endif\n\n        diffuseColor *= halfLambert / max(1e-4h, flatNormalHalfLambert);\n    }\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXSH\n    void BakeryVertexLMSH(inout float3 diffuseColor, inout float3 specularColor, float3 shL1x, float3 shL1y, float3 shL1z, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 L0 = diffuseColor;\n        float3 nL1x = shL1x;\n        float3 nL1y = shL1y;\n        float3 nL1z = shL1z;\n        float3 L1x = nL1x * L0 * 2;\n        float3 L1y = nL1y * L0 * 2;\n        float3 L1z = nL1z * L0 * 2;\n\n        float3 sh;\n    #if BAKERY_SHNONLINEAR\n        //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n        //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n        //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n        float lumaL0 = dot(L0, 1);\n        float lumaL1x = dot(L1x, 1);\n        float lumaL1y = dot(L1y, 1);\n        float lumaL1z = dot(L1z, 1);\n        float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n        float regularLumaSH = dot(sh, 1);\n        //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n        sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    #else\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    #endif\n\n        diffuseColor = max(sh, 0.0);\n\n        #ifdef BAKERY_LMSPEC\n            float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n            float focus = saturate(length(dominantDir));\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = max(spec * sh, 0.0);\n        #endif\n    }\n#endif\n\n\n\n#ifdef BAKERY_BICUBIC\nfloat BakeryBicubic_w0(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-a + 3.0f) - 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w1(float a)\n{\n    return (1.0f/6.0f)*(a*a*(3.0f*a - 6.0f) + 4.0f);\n}\n\nfloat BakeryBicubic_w2(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-3.0f*a + 3.0f) + 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w3(float a)\n{\n    return (1.0f/6.0f)*(a*a*a);\n}\n\nfloat BakeryBicubic_g0(float a)\n{\n    return BakeryBicubic_w0(a) + BakeryBicubic_w1(a);\n}\n\nfloat BakeryBicubic_g1(float a)\n{\n    return BakeryBicubic_w2(a) + BakeryBicubic_w3(a);\n}\n\nfloat BakeryBicubic_h0(float a)\n{\n    return -1.0f + BakeryBicubic_w1(a) / (BakeryBicubic_w0(a) + BakeryBicubic_w1(a)) + 0.5f;\n}\n\nfloat BakeryBicubic_h1(float a)\n{\n    return 1.0f + BakeryBicubic_w3(a) / (BakeryBicubic_w2(a) + BakeryBicubic_w3(a)) + 0.5f;\n}\n#endif\n\n\n#if defined(_LIGHTMAPMODE_RNM) || defined(_LIGHTMAPMODE_SH)\nTexture2D _RNM0, _RNM1, _RNM2;\n#endif\n\n#ifdef BAKERY_VOLUME\nTexture3D _Volume0, _Volume1, _Volume2, _VolumeMask;\nSamplerState sampler_Volume0;\n#endif\n\n#if defined(BAKERY_BICUBIC) && defined(LIGHTMAP_ON) && defined(SHADER_API_D3D11)\n    // Bicubic\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\tfloat width, height;\n\t\ttex.GetDimensions(width, height);\n\t\tfloat texelSize = 1.0f / width;\n\n        float x = uv.x * width;\n        float y = uv.y * width;\n\n        x -= 0.5f;\n        y -= 0.5f;\n\n        float px = floor(x);\n        float py = floor(y);\n\n        float fx = x - px;\n        float fy = y - py;\n\n        float g0x = BakeryBicubic_g0(fx);\n        float g1x = BakeryBicubic_g1(fx);\n        float h0x = BakeryBicubic_h0(fx);\n        float h1x = BakeryBicubic_h1(fx);\n        float h0y = BakeryBicubic_h0(fy);\n        float h1y = BakeryBicubic_h1(fy);\n\n        return     BakeryBicubic_g0(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h0y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h0y) * texelSize))) +\n\n                   BakeryBicubic_g1(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h1y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h1y) * texelSize)));\n    }\n#else\n    // Bilinear\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\t#ifdef LIGHTMAP_ON\n\t\t\treturn tex.Sample(samplerunity_Lightmap, uv);\n\t\t#else\n\t\t\treturn float4(1,0,0,1);\n\t\t#endif\n    }\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\n#ifdef BAKERY_LMSPEC\nfloat BakeryDirectionalLightmapSpecular(float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 dominantDir = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap, lmUV).xyz * 2 - 1;\n    half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n    half nh = saturate(dot(normalWorld, halfDir));\n    half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n    half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n    half spec = GGXTerm(nh, roughness);\n    return spec;\n}\n#endif\n#endif\n\n\n\n#ifdef _LIGHTMAPMODE_RNM\nvoid BakeryRNM(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalMap, float smoothness, float3 viewDirT)\n{\n    const float3 rnmBasis0 = float3(0.816496580927726f, 0, 0.5773502691896258f);\n    const float3 rnmBasis1 = float3(-0.4082482904638631f, 0.7071067811865475f, 0.5773502691896258f);\n    const float3 rnmBasis2 = float3(-0.4082482904638631f, -0.7071067811865475f, 0.5773502691896258f);\n\n    float3 rnm0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 rnm1 = DecodeLightmap(BakeryTex2D(_RNM1, lmUV));\n    float3 rnm2 = DecodeLightmap(BakeryTex2D(_RNM2, lmUV));\n\n    #ifdef BAKERY_SSBUMP\n        diffuseColor = normalMap.x * rnm0\n                     + normalMap.z * rnm1\n                     + normalMap.y * rnm2;\n         diffuseColor *= 2;\n    #else\n        diffuseColor = saturate(dot(rnmBasis0, normalMap)) * rnm0\n                     + saturate(dot(rnmBasis1, normalMap)) * rnm1\n                     + saturate(dot(rnmBasis2, normalMap)) * rnm2;\n    #endif\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDirT = rnmBasis0 * dot(rnm0, lumaConv) +\n                              rnmBasis1 * dot(rnm1, lumaConv) +\n                              rnmBasis2 * dot(rnm2, lumaConv);\n\n        float3 dominantDirTN = normalize(dominantDirT);\n        float3 specColor = saturate(dot(rnmBasis0, dominantDirTN)) * rnm0 +\n                           saturate(dot(rnmBasis1, dominantDirTN)) * rnm1 +\n                           saturate(dot(rnmBasis2, dominantDirTN)) * rnm2;\n\n        half3 halfDir = Bakery_SafeNormalize(dominantDirTN - viewDirT);\n        half nh = saturate(dot(normalMap, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n        specularColor = spec * specColor;\n    #endif\n}\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\ninline half3 Unity_DecodeDirectionalLightmap(half3 color, half4 dirTex, half3 normalWorld)\n{\n    // In directional (non-specular) mode Enlighten bakes dominant light direction\n    // in a way, that using it for half Lambert and then dividing by a \"rebalancing coefficient\"\n    // gives a result close to plain diffuse response lightmaps, but normalmapped.\n\n    // Note that dir is not unit length on purpose. Its length is \"directionality\", like\n    // for the directional specular lightmaps.\n\n    half halfLambert = dot(normalWorld, dirTex.xyz - 0.5) + 0.5;\n\n    return color * halfLambert / max(1e-4h, dirTex.w);\n}\n#endif\n\n#ifdef _LIGHTMAPMODE_SH\nvoid BakerySH(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 L0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 nL1x = BakeryTex2D(_RNM0, lmUV) * 2 - 1;\n    float3 nL1y = BakeryTex2D(_RNM1, lmUV) * 2 - 1;\n    float3 nL1z = BakeryTex2D(_RNM2, lmUV) * 2 - 1;\n    float3 L1x = nL1x * L0 * 2;\n    float3 L1y = nL1y * L0 * 2;\n    float3 L1z = nL1z * L0 * 2;\n\n    float3 sh;\n#if BAKERY_SHNONLINEAR\n    float lumaL0 = dot(L0, 1);\n    float lumaL1x = dot(L1x, 1);\n    float lumaL1y = dot(L1y, 1);\n    float lumaL1z = dot(L1z, 1);\n    float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    float regularLumaSH = dot(sh, 1);\n    //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n    sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n    //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n    //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n#else\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n#endif\n\n    diffuseColor = max(sh, 0.0);\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n        float focus = saturate(length(dominantDir));\n        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n        half nh = saturate(dot(normalWorld, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n\n        sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n\n        specularColor = max(spec * sh, 0.0);\n    #endif\n}\n#endif\n\n#endif // include guards\n\n\n    void Ext_ModifyVertex15 (inout VertexData v, inout ExtraV2F e)\n    {\n        #if _USEBAKERY\n\t\t    #if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\t\t\t    // Unpack from RGBM\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.a * 8.0f;\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.rgb;\n\n\t\t\t    #ifdef BAKERY_VERTEXLMMASK\n\t\t\t\t    e.extraV2F4.xyzw = unpack4NFloats(v.texcoord1);\n\t\t\t    #endif\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXSH\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n                e.extraV2F6.xyz = unpack3NFloats(v.texcoord3.x) * 2 - 1;\n                e.extraV2F7.xyz = unpack3NFloats(v.texcoord3.y) * 2 - 1;\n            #endif\n       #endif\n    }\n\n#if _HDRP || _URP\n    half3 SHEvalLinearL0L1 (half4 normal)\n    {\n        half3 x;\n\n        // Linear (L1) + constant (L0) polynomial terms\n        x.r = dot(unity_SHAr,normal);\n        x.g = dot(unity_SHAg,normal);\n        x.b = dot(unity_SHAb,normal);\n\n        return x;\n    }\n\n    // normal should be normalized, w=1.0\n    half3 SHEvalLinearL2 (half4 normal)\n    {\n        half3 x1, x2;\n        // 4 of the quadratic (L2) polynomials\n        half4 vB = normal.xyzz * normal.yzzx;\n        x1.r = dot(unity_SHBr,vB);\n        x1.g = dot(unity_SHBg,vB);\n        x1.b = dot(unity_SHBb,vB);\n\n        // Final (5th) quadratic (L2) polynomial\n        half vC = normal.x*normal.x - normal.y*normal.y;\n        x2 = unity_SHC.rgb * vC;\n\n        return x1 + x2;\n    }\n\n    half3 ShadeSH9 (half4 normal)\n    {\n        // Linear + constant polynomial terms\n        half3 res = SHEvalLinearL0L1 (normal);\n\n        // Quadratic polynomials\n        res += SHEvalLinearL2 (normal);\n\n        #ifdef UNITY_COLORSPACE_GAMMA\n            res = LinearToGamma (res);\n        #endif\n\n        return res;\n\n    }\n#endif\n\n\n\n\tvoid DoBakeryStuff(inout float3 indDif, inout float3 indSpec, inout float4 shadowmask, float3 tangentNormal, float smoothness, ShaderData d)\n\t{\n\t\t// Quality!\n\t\tindDif = 1;\n\t\tindSpec = 0;\n\n        #if defined(_PASSFORWARD) || defined(_PASSGBUFFER) // forward pass on URP/Standard/HDRP + built-in deferred\n\n            float3 normalWorld = mul(tangentNormal, d.TBNMatrix);\n\n\t\t\t#ifdef LIGHTMAP_ON\n\n                // Static\n\n\t\t\t\tfloat2 lmUV = d.texcoord1 * unity_LightmapST.xy + unity_LightmapST.zw;\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_STANDARD\n\t\t\t\t\tindDif = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n\n\t\t\t\t\t#ifdef DIRLIGHTMAP_COMBINED\n\t\t\t\t\t\tfloat4 dirMap = BakeryTex2D(unity_LightmapInd, lmUV);\n\t\t\t\t\t\tindDif = Unity_DecodeDirectionalLightmap(indDif, dirMap, normalWorld);\n\n\t\t\t\t\t\t#ifdef BAKERY_LMSPEC\n\t\t\t\t\t\t\tindSpec = BakeryDirectionalLightmapSpecular(lmUV, normalWorld, -d.worldSpaceViewDir, smoothness) * indDif;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\n\t\t\t\t\tindDif = d.vertexColor;\n\n                    #ifdef BAKERY_VERTEXLMMASK\n                        shadowmask = d.extraV2F4;\n                    #endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n\t\t\t\t\t\t// worldSpaceNormal is per-vertex\n\t\t\t\t\t\t// normalWorld is per-pixel\n\t\t\t\t\t\tfloat3 bakedLightDirection = d.extraV2F5;\n\t\t\t\t\t\tBakeryVertexLMDirection(indDif, indSpec, bakedLightDirection, d.worldSpaceNormal, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXSH\n\t\t\t\t\t\tBakeryVertexLMSH(indDif, indSpec, d.extraV2F5, d.extraV2F6, d.extraV2F7, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_RNM\n\t\t\t\t\tBakeryRNM(indDif, indSpec, lmUV, tangentNormal, smoothness, -d.tangentSpaceViewDir);\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_SH\n\t\t\t\t\tBakerySH(indDif, indSpec, lmUV, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t#endif\n\n            #else\n\n                // Dynamic\n\n                #ifdef BAKERY_VOLUME\n\n                    bool isGlobal = dot(abs(_VolumeInvSize),1) == 0;\n                    float3 volViewDir = -d.worldSpaceViewDir;\n                    #ifdef BAKERY_VOLROTATION\n                        float4x4 volMatrix = (isGlobal ? _GlobalVolumeMatrix : _VolumeMatrix);\n                        float3 volInvSize = (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 lpUV = mul(volMatrix, float4(d.worldSpacePosition,1)).xyz * volInvSize + 0.5f;\n                        float3 volNormal = mul((float3x3)volMatrix, normalWorld);\n                        #ifdef BAKERY_LMSPEC\n                            volViewDir = mul((float3x3)volMatrix, volViewDir);\n                        #endif\n                    #else\n                        float3 lpUV = (d.worldSpacePosition - (isGlobal ? _GlobalVolumeMin : _VolumeMin)) * (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 volNormal = normalWorld;\n                    #endif\n\n                    #ifdef BAKERY_COMPRESSED_VOLUME\n                        float4 tex0, tex1, tex2, tex3;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex3 = _Volume3.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz * L0;\n                        L1y = tex2.xyz * L0;\n                        L1z = tex3.xyz * L0;\n                    #else\n                        float4 tex0, tex1, tex2;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV);\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV);\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz;\n                        L1y = tex2.xyz;\n                        L1z = float3(tex0.w, tex1.w, tex2.w);\n                    #endif\n                    indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), volNormal);\n                    indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), volNormal);\n                    indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), volNormal);\n\n                    #ifdef UNITY_COLORSPACE_GAMMA\n                        indDif = pow(indDif, 1.0f / 2.2f);\n                    #endif\n\n                    #ifdef BAKERY_LMSPEC\n                        float3 nL1x = L1x / L0;\n                        float3 nL1y = L1y / L0;\n                        float3 nL1z = L1z / L0;\n                        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n                        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - volViewDir);\n                        half nh = saturate(dot(volNormal, halfDir));\n                        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n                        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n                        half spec = GGXTerm(nh, roughness);\n                        float3 sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n                        indSpec = max(spec * sh, 0.0);\n                    #endif\n\n                    shadowmask = _VolumeMask.Sample(sampler_Volume0, lpUV);\n\n                #else\n\n                    #ifdef BAKERY_SHNONLINEAR\n                        float3 L0 = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);\n                        indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, unity_SHAr.xyz, normalWorld);\n                        indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, unity_SHAg.xyz, normalWorld);\n                        indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, unity_SHAb.xyz, normalWorld);\n                    #else\n                        indDif = ShadeSH9(float4(normalWorld,1));\n                    #endif\n\n                #endif\n\n\t\t\t#endif\n\n        #endif\n\t}\n\n\t// this is the main surface function. Surface is like a surface shader output structure, but\n\t// with our new outputs as well.\n\tvoid Ext_SurfaceFunction15 (inout Surface o, ShaderData d)\n\t{\n        #if _USEBAKERY\n\t\t    float3 indDif;\n\t\t    float3 indSpec;\n            float4 shadowmask = 1;\n\t\t    DoBakeryStuff(indDif, indSpec, shadowmask, o.Normal, o.Smoothness, d);\n\t\t    o.DiffuseGI = indDif;\n\t\t    o.BackDiffuseGI = indDif;\n\t\t    o.SpecularGI = indSpec;\n            o.ShadowMask = shadowmask;\n        #endif\n\t}\n\n\n\n\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                  Ext_SurfaceFunction1(l, d);\n                  Ext_SurfaceFunction2(l, d);\n                  Ext_SurfaceFunction3(l, d);\n                  Ext_SurfaceFunction4(l, d);\n                  Ext_SurfaceFunction5(l, d);\n                  Ext_SurfaceFunction6(l, d);\n                  Ext_SurfaceFunction7(l, d);\n                  Ext_SurfaceFunction8(l, d);\n                  Ext_SurfaceFunction9(l, d);\n\t\t            Ext_SurfaceFunction10(l, d);\n                  Ext_SurfaceFunction11(l, d);\n                  Ext_SurfaceFunction12(l, d);\n                  Ext_SurfaceFunction13(l, d);\n                  Ext_SurfaceFunction14(l, d);\n                  Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraV2F d;\n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                  Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                  Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                  #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                  v2p.extraV2F4 = d.extraV2F4;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                  v2p.extraV2F5 = d.extraV2F5;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F6 = d.extraV2F6;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F7 = d.extraV2F7;\n                  #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                d.extraV2F4 = v2p.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                d.extraV2F5 = v2p.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F6 = v2p.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F7 = v2p.extraV2F7;\n                #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n                Ext_ModifyTessellatedVertex2(v, d);\n                Ext_ModifyTessellatedVertex3(v, d);\n                Ext_ModifyTessellatedVertex4(v, d);\n                Ext_ModifyTessellatedVertex5(v, d);\n                Ext_ModifyTessellatedVertex6(v, d);\n                Ext_ModifyTessellatedVertex7(v, d);\n                Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                v2p.extraV2F4 = d.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                v2p.extraV2F5 = d.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F6 = d.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F7 = d.extraV2F7;\n                #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n\n\n\n         \n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n            // d.texcoord3 = i.texcoord3;\n             #endif\n\n             d.isFrontFace = facing;\n             #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n             d.vertexColor = i.vertexColor;\n             #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(i.worldPos, 1)).xyz;\n            #endif\n             d.localSpaceNormal = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n             #if LOD_FADE_CROSSFADE\n             d.screenPos = i.screenPos;\n             d.screenUV = (i.screenPos.xy / i.screenPos.w);\n             #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n             #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n             d.extraV2F4 = i.extraV2F4;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n             d.extraV2F5 = i.extraV2F5;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F6 = i.extraV2F6;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F7 = i.extraV2F7;\n             #endif\n\n            return d;\n         }\n         \n\n         \n         #if defined(SHADERPASS_SHADOWCASTER)\n            float3 _LightDirection;\n         #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n            o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n            #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n           // o.texcoord3 = v.texcoord3;\n            #endif\n\n            #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n            o.vertexColor = v.vertexColor;\n            #endif\n           \n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n           o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n\n          #if defined(SHADERPASS_SHADOWCASTER)\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, _LightDirection));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif defined(SHADERPASS_META)\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n\n           #if LOD_FADE_CROSSFADE\n           o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n           #endif\n\n          #if defined(SHADERPASS_FORWARD) || (SHADERPASS == SHADERPASS_GBUFFER)\n              float2 uv1 = v.texcoord1.xy;\n              OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n               o.texcoord1.xy = uv1;\n              OUTPUT_SH(o.worldNormal, o.sh);\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n              half fogFactor = ComputeFogFactor(o.pos.z);\n              o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n             o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n           return o;\n         }\n\n\n         \n\n         // fragment shader\n         half4 Frag (VertexToPixel IN\n            #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n         ) : SV_Target\n         {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n\n           ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                     , facing\n                  #endif\n               );\n           Surface l = (Surface)0;\n\n           #ifdef _DEPTHOFFSET_ON\n              l.outputDepth = outputDepth;\n           #endif\n\n           l.Albedo = half3(0.5, 0.5, 0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n           l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n           #ifdef _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n           #endif\n\n           #if _USESPECULAR || _SIMPLELIT\n              float3 specular = l.Specular;\n              float metallic = 1;\n           #else   \n              float3 specular = 0;\n              float metallic = l.Metallic;\n           #endif\n\n\n            \n           \n            InputData inputData;\n\n            inputData.positionWS = IN.worldPos;\n            #if _WORLDSPACENORMAL\n              inputData.normalWS = l.Normal;\n            #else\n              inputData.normalWS = normalize(TangentToWorldSpace(d, l.Normal));\n            #endif\n\n            inputData.viewDirectionWS = SafeNormalize(d.worldSpaceViewDir);\n\n\n            #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n                  inputData.shadowCoord = IN.shadowCoord;\n            #elif defined(MAIN_LIGHT_CALCULATE_SHADOWS)\n                  inputData.shadowCoord = TransformWorldToShadowCoord(IN.worldPos);\n            #else\n                  inputData.shadowCoord = float4(0, 0, 0, 0);\n            #endif\n\n            inputData.fogCoord = IN.fogFactorAndVertexLight.x;\n            inputData.vertexLighting = IN.fogFactorAndVertexLight.yzw;\n            #if defined(_OVERRIDE_BAKEDGI)\n               inputData.bakedGI = l.DiffuseGI;\n            #else\n               inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.sh, inputData.normalWS);\n            #endif\n            inputData.normalizedScreenSpaceUV = GetNormalizedScreenSpaceUV(IN.pos);\n            inputData.shadowMask = SAMPLE_SHADOWMASK(IN.lightmapUV);\n\n            #if defined(_OVERRIDE_SHADOWMASK)\n               float4 mulColor = saturate(dot(l.ShadowMask, _MainLightOcclusionProbes)); //unity_OcclusionMaskSelector));\n               inputData.shadowMask = mulColor;\n            #endif\n\n            #if !_UNLIT\n               #if _SIMPLELIT\n                  half4 color = UniversalFragmentBlinnPhong(\n                     inputData,\n                     l.Albedo,\n                     float4(specular * l.Smoothness, 0),\n                     l.SpecularPower * 128,\n                     l.Emission,\n                     l.Alpha);\n                  color.a = l.Alpha;\n               #else\n\n                  \n                  SurfaceData surface         = (SurfaceData)0;\n                  surface.albedo              = l.Albedo;\n                  surface.metallic            = saturate(metallic);\n                  surface.specular            = specular;\n                  surface.smoothness          = saturate(l.Smoothness),\n                  surface.occlusion           = l.Occlusion,\n                  surface.emission            = l.Emission,\n                  surface.alpha               = saturate(l.Alpha);\n                  surface.clearCoatMask       = 0;\n                  surface.clearCoatSmoothness = 1;\n\n                  #ifdef _CLEARCOAT\n                      surface.clearCoatMask       = saturate(l.CoatMask);\n                      surface.clearCoatSmoothness = saturate(l.CoatSmoothness);\n                  #endif\n\n                  half4 color = UniversalFragmentPBR(inputData, surface);\n\n               #endif\n               color.rgb = MixFog(color.rgb, inputData.fogCoord);\n\n            #else\n               half4 color = half4(l.Albedo, l.Alpha);\n               color.rgb = MixFog(color.rgb, inputData.fogCoord);\n            #endif\n            ChainFinalColorForward(l, d, color);\n\n            return color;\n\n         }\n\n         ENDHLSL\n\n      }\n\n\n      \n      \n      \n      \n        Pass\n        {\n            Name \"Meta\"\n            Tags \n            { \n                \"LightMode\" = \"Meta\"\n            }\n\n             // Render State\n            Blend One Zero, One Zero\n            Cull Back\n            ZTest LEqual\n            ZWrite On\n            // ColorMask: <None>\n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n        \n            #define SHADERPASS_META\n            #define _PASSMETA 1\n\n\n            \n\n\n   #pragma shader_feature_local_fragment _ _PACKEDFAST\n   #pragma shader_feature_local _ _TRIPLANAR\n   #pragma shader_feature_local_fragment _ _NORMALMAP \n   #pragma shader_feature_local_fragment _ _MASKMAP\n   #pragma shader_feature_local_fragment _ _DETAIL\n   #pragma shader_feature_local_fragment _ _DETAILTRIPLANAR\n   #pragma shader_feature_local_fragment _ _DETAILSTOCHASTIC\n   #pragma shader_feature_local_fragment _ _EMISSION\n   #pragma shader_feature_local_fragment _ _FLATSHADE\n   #pragma shader_feature_local _ _STOCHASTIC\n   #pragma shader_feature_local_fragment _ _PARALLAX //_POM\n   #pragma shader_feature_local_fragment _ _SPECULAR\n   #pragma shader_feature_local _ _NOISEWORLD _NOISELOCAL\n   #pragma shader_feature_local _ _NOISEHQ _NOISETEXTURE _NOISEWORLEY\n   // only for URP/Standard Forward\n   #pragma shader_feature_local_fragment _ _SIMPLELIT\n\n\n   #pragma shader_feature_local_fragment _ _TINTMASK\n\n\n    #pragma shader_feature_local _ _LAYERVERTEXMASK _LAYERTEXTUREMASK\n\n    #define _HAS_WEIGHTTEXTURE_MASK 1\n\n\n   #pragma shader_feature_local _ _USELAYER\n   #pragma shader_feature_local _ _LAYERTRIPLANAR\n   #pragma shader_feature_local _ _LAYERALBEDO\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL\n   #pragma shader_feature_local _ _LAYERMASK\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION\n   #pragma shader_feature_local _ _LAYERNOISE\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC\n   #pragma shader_feature_local _ _LAYERANGLEFILTER\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_1\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_1\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_1\n   #pragma shader_feature_local _ _LAYERMASK_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_1\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_1\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_1\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_1\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_2\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_2\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_2\n   #pragma shader_feature_local _ _LAYERMASK_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_2\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_2\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_2\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_2\n\n\n   #pragma shader_feature_local _ _TRAX_ON\n\n\n   #pragma shader_feature_local_fragment _ _WETNESS\n   #pragma shader_feature_local_fragment _ _PUDDLES\n   #pragma shader_feature_local_fragment _ _PUDDLENOISE\n   #pragma shader_feature_local_fragment _ _RAINDROPS\n\n\n   #pragma shader_feature_local _ _SNOW\n   #pragma shader_feature_local _ _SNOWMASKMAP\n   #pragma shader_feature_local _ _SNOWNOISE\n   #pragma shader_feature_local_fragment _SNOWSTOCHASTIC\n\n\n   #pragma shader_feature_local_fragment _ _WIND_ON\n\n\n\n\n   #pragma shader_feature_local_fragment _ _SURFACEGRADIENT _AUTONORMAL\n   #define _WORLDSPACENORMAL 1\n\n\n   #pragma shader_feature_local _ _DEBUG_SAMPLECOUNT\n\n\n\t#pragma shader_feature_local_fragment _ _DISSOLVE\n\n\n   #pragma multi_compile_local  LOD_FADE_CROSSFADE\n\n\n\n#pragma instancing_options procedural:setupVSPro forwardadd\n\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\nstruct IndirectShaderData\n{\n\tfloat4x4 PositionMatrix;\n\tfloat4x4 InversePositionMatrix;\n\tfloat4 ControlData;\n};\n\n#if defined(SHADER_API_GLCORE) || defined(SHADER_API_D3D11) || defined(SHADER_API_GLES3) || defined(SHADER_API_METAL) || defined(SHADER_API_VULKAN) || defined(SHADER_API_PSSL) || defined(SHADER_API_XBOXONE)\n\tuniform StructuredBuffer<IndirectShaderData> VisibleShaderDataBuffer;\n#endif\n\n#endif\n\nfloat VSPRenderingLayerMask;\n\nvoid setupVSPro()\n{\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\n    #if _HDRP\n\t    unity_RenderingLayer.x = VSPRenderingLayerMask;\n    #endif\n\n\t#ifdef unity_ObjectToWorld\n\t#undef unity_ObjectToWorld\n\t#endif\n\n\t#ifdef unity_WorldToObject\n\t#undef unity_WorldToObject\n\t#endif\n\n\tunity_ObjectToWorld = VisibleShaderDataBuffer[unity_InstanceID].PositionMatrix;\n\tunity_WorldToObject = VisibleShaderDataBuffer[unity_InstanceID].InversePositionMatrix;\n#endif\n\n}\n\n\n\t#pragma multi_compile _LIGHTMAPMODE_STANDARD _LIGHTMAPMODE_RNM _LIGHTMAPMODE_SH _LIGHTMAPMODE_VERTEX _LIGHTMAPMODE_VERTEXDIRECTIONAL _LIGHTMAPMODE_VERTEXSH\n\n    #pragma shader_feature USEBAKERY\n    #pragma shader_feature BAKERY_VERTEXLMMASK\n    #pragma shader_feature BAKERY_SHNONLINEAR\n    #pragma shader_feature BAKERY_LMSPEC\n    #pragma shader_feature BAKERY_BICUBIC\n    #pragma shader_feature BAKERY_VOLUME\n    #pragma shader_feature BAKERY_VOLROTATION\n    #pragma shader_feature BAKERY_COMPRESSED_VOLUME\n\n    #if _USEBAKERY\n\t    #define _OVERRIDE_BAKEDGI\n        #if BAKERY_VOLUME || (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)) && defined(BAKERY_VERTEXLMMASK)\n            #define _OVERRIDE_SHADOWMASK\n        #endif\n    #endif\n\n\n\n\n\n\n\n\n   #define _URP 1\n\n   #define _ALPHABLEND_ON 1\n#define _ALPHABLEND_ON 1\n#define _SURFACE_TYPE_TRANSPARENT 1\n#define NEED_FACING 1\n\n\n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/MetaInput.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n            #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl\"\n        \n\n                  #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCCOORD3;\n          float4 texcoord1 : TEXCCOORD4;\n         // float4 texcoord2 : TEXCCOORD5;\n\n          #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n         // float4 texcoord3 : TEXCCOORD6;\n          #endif\n\n          #if LOD_FADE_CROSSFADE\n          float4 screenPos : TEXCOORD7;\n          #endif\n\n          #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n          half4 vertexColor : COLOR_centroid;\n          #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n         // float4 extraV2F0 : TEXCOORD12;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n         // float4 extraV2F1 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n         // float4 extraV2F2 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n         // float4 extraV2F3 : TEXCOORD15;\n         // #endif\n\n          #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n          float4 extraV2F4 : TEXCOORD16_centroid;\n          #endif\n\n          #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n          float4 extraV2F5 : TEXCOORD17_centroid;\n          #endif\n\n          #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n          float4 extraV2F6 : TEXCOORD18_centroid;\n          #endif\n\n          #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n          float4 extraV2F7 : TEXCOORD19_centroid;\n          #endif\n            \n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD9;\n         #endif\n            float4 fogFactorAndVertexLight : TEXCOORD10;\n            float4 shadowCoord : TEXCOORD11;\n         #if UNITY_ANY_INSTANCING_ENABLED\n            uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n            uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n            uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n            FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n      };\n\n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n   half4 weightTextureMask;\n   \n\n\n   float traxBuffer;\n\n\n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // would love to strip these, but they are used in certain\n               // combinations of the lighting system, and may be used\n               // by the user as well, so no easy way to strip them.\n\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR_centroid;\n                #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                float4 extraV2F4 : TEXCOORD9_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                float4 extraV2F5 : TEXCOORD10_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F6 : TEXCOORD11_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F7 : TEXCOORD12_centroid;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n               #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n               #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n               #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n               #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()     unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n               #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V   unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n               #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V    mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n               #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n               #endif\n               #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n            CBUFFER_START(UnityPerMaterial)\n\n               \n\n\n   half4 _Tint;\n   half _UVSource;\n   half _TriplanarContrast;\n   half _AlbedoContrast;\n   half _AlbedoBrightness;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half3 _EmissionColor;\n   float _DetailUVSource;\n   half _StochasticScale;\n   half _DetailStochasticScale;\n   half _Smoothness;\n   half _Metallic;\n   half2 _SmoothnessRemap;\n   half2 _AORemap;\n   half2 _MetallicRemap;\n   half2 _HeightRemap;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n   half _AlphaThreshold;\n   half _Cutoff; // for Unity's light mapper\n   half _TriplanarSpace;\n   half _DetailTriplanarSpace;\n   half _DetailTriplanarContrast;\n   half _MicroShadowStrength;\n   half3 _FuzzyShadingColor;\n   half _FuzzyShadingOn;\n   half3 _FuzzyShadingParams;\n\n   //int _POMMaxSamples;\n   //float _POMMin;\n   //float _POMFade;\n#if _FLATSHADE\n   half _FlatShadingBlend;\n#endif\n\n   half _StochasticContrast;\n   half _DetailStochasticContrast;\n\n#if _PARALLAX || _POM\n   half _ParallaxHeight;\n#endif\n\n\n\n\tfloat4 _TintMask_ST;\n\thalf3 _RColor;\n\thalf3 _GColor;\n\thalf3 _BColor;\n\thalf3 _AColor;\n\n\n\thalf _LayerTextureMaskUVMode;\n    float4 _LayerTextureMask_ST;\n\n\n   //#if _USELAYER\n       float4 _LayerAlbedoMap_ST;\n       half3 _LayerTint;\n       half _LayerBlendMode;\n       float _LayerUVSource;\n       half _LayerAlbedoBrightness;\n       half _LayerAlbedoContrast;\n       half _LayerHeightContrast;\n       half _LayerStrength;\n       half _LayerAlbedoStrength;\n       half _LayerNormalStrength;\n       half _LayerSmoothnessStrength;\n       half _LayerSmoothness;\n       half _LayerMetallic;\n       half _LayerStochasticScale;\n       half2 _LayerSmoothnessRemap;\n       half2 _LayerAORemap;\n       half2 _LayerMetallicRemap;\n       half2 _LayerHeightRemap;\n       float4 _LayerWeightOverDistance;\n       half _LayerMicroShadowStrength;\n       //#if _LAYERNOISE\n           float _LayerNoiseFrequency;\n           float _LayerNoiseAmplitude;\n           float _LayerNoiseOffset;\n           float _LayerNoiseCenter;\n           half3 _LayerBlendTint;\n       //#endif\n       //#if _LAYERANGLEFILTER\n           half _LayerFalloff;\n           half _LayerAngleMin;\n           half _LayerHeight;\n           half _LayerInvertHeight;\n           half _LayerVertexNormalBlend;\n       //#endif\n       half _LayerTriplanarSpace;\n       half _LayerTriplanarContrast;\n       half _LayerBlendContrast;\n       half3 _LayerEmissionColor;\n       half _LayerStochasticContrast;\n       half _LayerTessStrength;\n       half3 _LayerFuzzyShadingColor;\n       half _LayerFuzzyShadingOn;\n       half3 _LayerFuzzyShadingParams;\n   //#endif\n\n\n   //#if _USELAYER_DEF_1\n       float4 _LayerAlbedoMap_Ext_1_ST;\n       half3 _LayerTint_Ext_1;\n       half _LayerBlendMode_Ext_1;\n       float _LayerUVSource_Ext_1;\n       half _LayerAlbedoBrightness_Ext_1;\n       half _LayerAlbedoContrast_Ext_1;\n       half _LayerHeightContrast_Ext_1;\n       half _LayerStrength_Ext_1;\n       half _LayerAlbedoStrength_Ext_1;\n       half _LayerNormalStrength_Ext_1;\n       half _LayerSmoothnessStrength_Ext_1;\n       half _LayerSmoothness_Ext_1;\n       half _LayerMetallic_Ext_1;\n       half _LayerStochasticScale_Ext_1;\n       half2 _LayerSmoothnessRemap_Ext_1;\n       half2 _LayerAORemap_Ext_1;\n       half2 _LayerMetallicRemap_Ext_1;\n       half2 _LayerHeightRemap_Ext_1;\n       float4 _LayerWeightOverDistance_Ext_1;\n       half _LayerMicroShadowStrength_Ext_1;\n       //#if _LAYERNOISE_DEF_1\n           float _LayerNoiseFrequency_Ext_1;\n           float _LayerNoiseAmplitude_Ext_1;\n           float _LayerNoiseOffset_Ext_1;\n           float _LayerNoiseCenter_Ext_1;\n           half3 _LayerBlendTint_Ext_1;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_1\n           half _LayerFalloff_Ext_1;\n           half _LayerAngleMin_Ext_1;\n           half _LayerHeight_Ext_1;\n           half _LayerInvertHeight_Ext_1;\n           half _LayerVertexNormalBlend_Ext_1;\n       //#endif\n       half _LayerTriplanarSpace_Ext_1;\n       half _LayerTriplanarContrast_Ext_1;\n       half _LayerBlendContrast_Ext_1;\n       half3 _LayerEmissionColor_Ext_1;\n       half _LayerStochasticContrast_Ext_1;\n       half _LayerTessStrength_Ext_1;\n       half3 _LayerFuzzyShadingColor_Ext_1;\n       half _LayerFuzzyShadingOn_Ext_1;\n       half3 _LayerFuzzyShadingParams_Ext_1;\n   //#endif\n\n\n   //#if _USELAYER_DEF_2\n       float4 _LayerAlbedoMap_Ext_2_ST;\n       half3 _LayerTint_Ext_2;\n       half _LayerBlendMode_Ext_2;\n       float _LayerUVSource_Ext_2;\n       half _LayerAlbedoBrightness_Ext_2;\n       half _LayerAlbedoContrast_Ext_2;\n       half _LayerHeightContrast_Ext_2;\n       half _LayerStrength_Ext_2;\n       half _LayerAlbedoStrength_Ext_2;\n       half _LayerNormalStrength_Ext_2;\n       half _LayerSmoothnessStrength_Ext_2;\n       half _LayerSmoothness_Ext_2;\n       half _LayerMetallic_Ext_2;\n       half _LayerStochasticScale_Ext_2;\n       half2 _LayerSmoothnessRemap_Ext_2;\n       half2 _LayerAORemap_Ext_2;\n       half2 _LayerMetallicRemap_Ext_2;\n       half2 _LayerHeightRemap_Ext_2;\n       float4 _LayerWeightOverDistance_Ext_2;\n       half _LayerMicroShadowStrength_Ext_2;\n       //#if _LAYERNOISE_DEF_2\n           float _LayerNoiseFrequency_Ext_2;\n           float _LayerNoiseAmplitude_Ext_2;\n           float _LayerNoiseOffset_Ext_2;\n           float _LayerNoiseCenter_Ext_2;\n           half3 _LayerBlendTint_Ext_2;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_2\n           half _LayerFalloff_Ext_2;\n           half _LayerAngleMin_Ext_2;\n           half _LayerHeight_Ext_2;\n           half _LayerInvertHeight_Ext_2;\n           half _LayerVertexNormalBlend_Ext_2;\n       //#endif\n       half _LayerTriplanarSpace_Ext_2;\n       half _LayerTriplanarContrast_Ext_2;\n       half _LayerBlendContrast_Ext_2;\n       half3 _LayerEmissionColor_Ext_2;\n       half _LayerStochasticContrast_Ext_2;\n       half _LayerTessStrength_Ext_2;\n       half3 _LayerFuzzyShadingColor_Ext_2;\n       half _LayerFuzzyShadingOn_Ext_2;\n       half3 _LayerFuzzyShadingParams_Ext_2;\n   //#endif\n\n\n    half _TraxDisplacementDepth;\n    half _TraxDisplacementStrength;\n    half _TraxMipBias;\n    half _TraxNormalStrength;\n    float4 _TraxAlbedo_ST;\n    half _TraxInterpContrast;\n    half _TraxHeightContrast;\n    half3 _TraxTint;\n\n\n\n    half _Porosity;\n    int _WetnessMode;\n    int _PuddleMode;\n\n    half  _PuddleAmount;\n    half  _PuddleFalloff;\n    half4 _PuddleColor;\n    half _PuddleNoiseFrequency;\n    half _PuddleNoiseAmplitude;\n    half _PuddleNoiseOffset;\n    half _PuddleNoiseCenter;\n    half _PuddleAngleMin;\n\n    half _WetnessAmount;\n\thalf _WetnessMin;\n    half _WetnessMax;\n    half _WetnessFalloff;\n\thalf _WetnessAngleMin;\n    float _WetnessShoreline;\n\n    int _RainMode;\n    half3 _RainIntensityScale;\n\n\n\n\n    float4 _SnowAlbedo_ST;\n    half3 _SnowTint;\n    half _SnowAmount;\n    half _SnowAngle;\n    half _SnowContrast;\n    half _SnowVertexHeight;\n    half _SnowMode;\n    half3 _SnowWorldFade; // z is on/off\n    float4 _SnowTraxAlbedo_ST;\n    half3 _SnowTraxTint;\n\n    half _SnowNoiseFreq; \n    half _SnowNoiseAmp;\n    half _SnowNoiseOffset;\n    half _SnowStochasticContrast;\n    half _SnowStochasticScale;\n\n\n    half     _WindParticulateSpace;\n    half     _WindParticulateRotation;\n    half      _WindParticulateSpeed;\n    float4     _WindParticulate_ST;\n    half      _WindParticulatePower;\n    half4    _WindParticulateColor;\n    half4    _WindParticulateWorldHeightMask;\n    half4    _WindParticulateAngleMask;\n    half      _WindParticulateOcclusionStrength;\n    half      _WindParticulateStrength;\n    half4    _WindParticulateEmissive;\n    half     _WindParticulateTextureHeight;\n\n\n   float _DoubleSidedNormalMode;\n\n\n\thalf _AutoNormalStrength;\n\n\n\tint _DebugSampleCountThreshold;\n\n\n\thalf _DissolveAmount;\n\thalf _DissolveEmissiveStr;\n\thalf _DissolveEdgeContrast;\n\thalf _DissolveColoration;\n\tfloat4 _DissolveTexture_ST;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n\n            \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\n#ifndef __STACKABLEFUNCLIBRARY_INCLUDES__\n#define __STACKABLEFUNCLIBRARY_INCLUDES__\n\n   #if _DEBUG_SAMPLECOUNT\n      int _sampleCount;\n      #define COUNTSAMPLE { _sampleCount++; }\n   #else\n      #define COUNTSAMPLE\n   #endif\n\n   TEXTURE2D(_NoiseTex);\n   SAMPLER(sampler_NoiseTex);\n\n\n\n   half3 AdjustContrast(half3 color, half contrast)\n   {\n       half3 comp = 0.5;\n   #if !UNITY_COLORSPACE_GAMMA\n       comp = 0.22;\n   #endif\n       color = saturate(lerp(comp, color, contrast));\n       return color;\n   }\n\n   float2 DoParallaxOffset( half h, half height, half3 viewDir)\n   {\n      h = h * height - height/2.0;\n      float3 v = normalize(viewDir);\n      v.z += 0.42;\n      return h * (v.xy / v.z);\n   }\n\n\n\n   #define SAMPLEBARY SampleTexBary\n\n   struct SampleConfig\n   {\n      float2 uv0;\n      float2 uv1;\n      float2 uv2;\n      float2 dx0;\n      float2 dy0;\n      float2 dx1;\n      float2 dy1;\n      float2 dx2;\n      float2 dy2;\n      float3 weights;\n      float3 origWeights;\n   };\n\n   struct Config\n   {\n      float2 origUV; // unscaled uv\n      float2 origScale;\n      float2 uv;        // no stocastic or triplanar\n      float2 dx;\n      float2 dy;\n      SampleConfig uvT; // just stochastic, or just triplanar\n      SampleConfig uvX; // stochastic and triplanar\n      SampleConfig uvY;\n      SampleConfig uvZ;\n\n      \n      float3 absVertNormal;\n      half3 axisSign;\n      float3 normal;\n   };\n\n\n    float2 Hash2D( float2 x )\n    {\n        float2 k = float2( 0.3183099, 0.3678794 );\n        x = x*k + k.yx;\n        return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );\n    }\n\n    float Noise2D(float2 p )\n    {\n        float2 i = floor( p );\n        float2 f = frac( p );\n         \n        float2 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), \n                        dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),\n                    lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), \n                        dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);\n    }\n      \n\n    float2 WorleyHash2D(float2 p)\n    {\n \t    return frac(cos(mul(p, float2x2(-64.2,71.3,81.4,-29.8)))*8321.3); \n    }\n    float WorleyNoise2D(float2 p)\n    {\n        float dist = 1;\n        float2 i = floor(p);\n        float2 f = frac(p);\n    \n        for(int x = -1;x<=1;x++)\n        {\n            for(int y = -1;y<=1;y++)\n            {\n                float d = distance(WorleyHash2D(i+float2(x,y))+float2(x,y),f);\n                dist = min(dist,d);\n            }\n        }\n        return dist;\n\t\n    }\n\n#ifndef PI\n    #define PI 3.14159265359\n#endif\n\n    float GetIntegerNoise(float2 p)\n    {\n        p  = 53.7 * frac( (p*0.3183099) + float2(0.71,0.113));\n        return frac( p.x*p.y*(p.x+p.y) );\n    }\n\n    float WorleyHash3D(float f)\n    {\n        return frac(sin(f)*43758.5453);\n    }\n\n    float WorleyHash31(float3 v)\n    {\n        return WorleyHash3D(dot(v, float3(253.14, 453.74, 183.3)));\n    }\n\n    float3 WorleyRandom3D( float3 p )\n    {\n        return frac(sin(float3(dot(p,float3(127.1,311.7,217.3)),dot(p,float3(269.5,183.3,431.1)), dot(p,float3(365.6,749.9,323.7))))*437158.5453);\n    }\n\n    float WorleyNoise3D(float3 uvw)\n    {\n        float noise = 0.0;\n    \n        float3 p = floor(uvw);\n        float3 f = frac(uvw);\n    \n        float4 res = 1;\n        for(int x = -1; x <=1; ++x)\n        {\n            for(int y = -1; y <=1; ++y)\n            {\n                for(int z = -1; z <=1; ++z)\n                {\n                    float3 gp = p + float3(x, y, z);\n\n                    float3 v = WorleyRandom3D(gp);\n\n\t\t\t\t    float3 diff = gp + v - uvw;\n                \n                    float d = length(diff);\n                \n                    if(d < res.x)\n                    {\n                        res.xyz = float3(d, res.x, res.y);\n                    }\n                    else if(d < res.y)\n                    {\n                        res.xyz = float3(res.x, d, res.y);\n                    }\n                    else if(d < res.z)\n                    {\n                        res.z = d;\n                    }\n                \n                    res.w = WorleyHash31(gp);\n                }\n            }\n        }\n\n        return res.x;\n    }\n    \n      \n    float3 Hash3D( float3 p )\n    {\n        p = float3( dot(p,float3(127.1,311.7, 74.7)),\n                dot(p,float3(269.5,183.3,246.1)),\n                dot(p,float3(113.5,271.9,124.6)));\n\n        return -1.0 + 2.0*frac(sin(p)*437.5453123);\n    }\n\n    float Noise3D( float3 p )\n    {\n        float3 i = floor( p );\n        float3 f = frac( p );\n         \n        float3 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),\n                    lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n    }\n\n    \n    float FBM2D(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           return SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n\n    }\n      \n    float FBM3D(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           half A = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.zy).g;\n           half B = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33).g;\n           half C = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoise(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3D(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3D(d.localSpacePosition * frequency+ offset, d.localSpaceNormal);\n        #else\n           return FBM2D(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n    \n    #if _SURFACEGRADIENT  \n\n    #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)\n\n      \n      \n    half3 SurfaceGradientFromTBN(ShaderData d, half2 deriv)\n    {\n        return deriv.x * d.TBNMatrix[0] + deriv.y * d.TBNMatrix[1];\n    }\n\n    half2 TspaceNormalToDerivative(half3 vM)\n    {\n        const half scale = 1.0/128.0;\n        const half3 vMa = abs(vM);\n        const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));\n\n        return -half2(vM.x, vM.y)/z_ma;\n    }\n\n    half3 SurfgradFromVolumeGradient(ShaderData d, half3 grad)\n    {\n        return grad - dot(d.worldSpaceNormal, grad) * d.worldSpaceNormal;\n    }\n\n    half3 SurfgradFromTriplanarProjection(ShaderData d, half3 pN, half3 xN, half3 yN, half3 zN)\n    {\n        const half w0 = pN.x;\n        const half w1 = pN.y;\n        const half w2 = pN.z;\n\n        half2 xD = TspaceNormalToDerivative(xN);\n        half2 yD = TspaceNormalToDerivative(yN);\n        half2 zD = TspaceNormalToDerivative(zN);\n\n        half3 volumeGrad = half3(w2 * zD.x + w1 * yD.y, w2 * zD.y + w0 * xD.y, w0 * xD.x + w1 * yD.x);\n\n        return SurfgradFromVolumeGradient(d, volumeGrad);\n    }\n\n    half3 ConvertNormalToGradient(ShaderData d, half3 normal)\n    {\n        half2 deriv = TspaceNormalToDerivative(normal);\n\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n    half3 ConvertNormal2ToGradient(ShaderData d, half2 packedNormal)\n    {\n        half2 tNormal = packedNormal;\n        half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF\n        half2 deriv = tNormal * -rcpZ;\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n\n    half3 ResolveNormalFromSurfaceGradient(ShaderData d, half3 gradient)\n    {\n        return normalize(d.worldSpaceNormal - gradient);\n    }\n\n    #endif // _SURFACEGRADIENT\n\n\n    // normals are in surface gradient or world space depending on settings, and can also be generated by height\n    half3 GetWorldSpaceNormal(ShaderData d, half3 normal, half pheight)\n    {\n       #if _SURFACEGRADIENT\n          return ResolveNormalFromSurfaceGradient(d, normal);\n       #elif _AUTONORMAL\n          float3 dx = ddx(d.worldSpacePosition);\n          float3 dy = ddy(d.worldSpacePosition);\n          float3 crossX = cross(float3(0,1,0), dx);\n          float3 crossY = cross(float3(0,1,0), dy);\n          float3 dt = abs(dot(crossY, dx));\n          float height = _AutoNormalStrength * 0.5 * pheight;\n          float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n          n.y *= -1.0;\n          return TangentToWorldSpace(d, normalize((dt * float3(0,1,0)) - n).xzy);\n       #else\n          return TangentToWorldSpace(d, normal);\n          \n       #endif\n       \n    }\n\n   void WaterBRDF (inout half3 albedo, inout half smoothness, half metallic, half wetFactor, half surfPorosity) \n   {\n      half porosity = saturate((( (1 - smoothness) - 0.5)) / max(surfPorosity, 0.001));\n      half factor = lerp(1, 0.2, (1 - metallic) * porosity);\n      albedo *= lerp(1.0, factor, wetFactor);\n      smoothness = lerp(smoothness, 0.92f, wetFactor);\n   }\n\n   void OffsetUV(inout Config c, float2 offset)\n   {\n       c.uv += offset;\n       c.uvT.uv0 += offset;\n       c.uvT.uv1 += offset;\n       c.uvT.uv2 += offset;\n       c.uvX.uv0 += offset;\n       c.uvX.uv1 += offset;\n       c.uvX.uv2 += offset;\n       c.uvY.uv0 += offset;\n       c.uvY.uv1 += offset;\n       c.uvY.uv2 += offset;\n       c.uvZ.uv0 += offset;\n       c.uvZ.uv1 += offset;\n       c.uvZ.uv2 += offset;\n   }\n\n\n    void TriangleGrid(float2 uv, float scale,\n       out float w1, out float w2, out float w3,\n       out int2 vertex1, out int2 vertex2, out int2 vertex3)\n    {\n       // Scaling of the input\n       uv *= 3.464 * scale; // 2 * sqrt(3)\n\n       // Skew input space into simplex triangle grid\n       const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);\n       float2 skewedCoord = mul(gridToSkewedGrid, uv);\n\n       // Compute local triangle vertex IDs and local barycentric coordinates\n       int2 baseId = int2(floor(skewedCoord));\n       float3 temp = float3(frac(skewedCoord), 0);\n       temp.z = 1.0 - temp.x - temp.y;\n       if (temp.z > 0.0)\n       {\n          w1 = temp.z;\n          w2 = temp.y;\n          w3 = temp.x;\n          vertex1 = baseId;\n          vertex2 = baseId + int2(0, 1);\n          vertex3 = baseId + int2(1, 0);\n       }\n       else\n       {\n          w1 = -temp.z;\n          w2 = 1.0 - temp.y;\n          w3 = 1.0 - temp.x;\n          vertex1 = baseId + int2(1, 1);\n          vertex2 = baseId + int2(1, 0);\n          vertex3 = baseId + int2(0, 1);\n       }\n    }\n\n    // Fast random hash function\n    float2 SimpleHash2(float2 p)\n    {\n       return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 43758.5453);\n    }\n\n\n    half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)\n    {\n        // compute weight with height map\n        const half epsilon = 1.0f / 1024.0f;\n        half3 weights = half3(iWeights.x * (tex0 + epsilon), \n                                 iWeights.y * (tex1 + epsilon),\n                                 iWeights.z * (tex2 + epsilon));\n\n        // Contrast weights\n        half maxWeight = max(weights.x, max(weights.y, weights.z));\n        half transition = contrast * maxWeight;\n        half threshold = maxWeight - transition;\n        half scale = 1.0f / transition;\n        weights = saturate((weights - threshold) * scale);\n        // Normalize weights.\n        half weightScale = 1.0f / (weights.x + weights.y + weights.z);\n        weights *= weightScale;\n        return weights;\n    }\n\n\n    half3 PackedUnpackScaleNormal(half4 packedNormal, float scale)\n   {\n       #if _PACKEDFAST\n          half3 normal;\n          normal.xy = (packedNormal.ag * 2 - 1) * scale;\n          normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n          return normal;  \n       #endif\n       return UnpackScaleNormal(packedNormal, scale);\n   }\n\n    void InitStochasticDxDy(inout SampleConfig c, Config cfg)\n    {\n      c.dx0 = ddx(cfg.origUV) * cfg.origScale;\n      c.dy0 = ddy(cfg.origUV) * cfg.origScale;\n      c.dx1 = c.dx0; c.dx1 = c.dx0;\n      c.dx2 = c.dy0; c.dy2 = c.dy0;\n    }\n\n    void PrepareStochasticUVs(float scale, float2 uv, out SampleConfig c)\n    {\n       // Get triangle info\n       ZERO_INITIALIZE(SampleConfig, c);\n       float w1, w2, w3;\n       int2 vertex1, vertex2, vertex3;\n       TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n       // Assign random offset to each triangle vertex\n       c.uv0 = uv;\n       c.uv1 = uv;\n       c.uv2 = uv;\n   \n       c.uv0.xy += SimpleHash2(vertex1);\n       c.uv1.xy += SimpleHash2(vertex2);\n       c.uv2.xy += SimpleHash2(vertex3);\n       c.weights = half3(w1, w2, w3);\n       c.origWeights = half3(w1, w2, w3);\n    }\n\n\n   half3 LitBlendDetailNormal(half3 n1, half3 n2)\n   {\n      #if _SURFACEGRADIENT\n         return n1 + n2;\n      #else\n         return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n      #endif\n   }\n\n   float3 TriplanarBlendUnpackedRNM(float3 n1, float3 n2)\n   {\n       n1.z += 1;\n       n2.xy = -n2.xy;\n       return n1 * dot(n1, n2) / n1.z - n2;\n   }\n\n   void InitConfigDxDy(inout Config c)\n   {\n      c.uvT.dx0 = ddx(c.uvT.uv0);\n      c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1);\n      c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2);\n      c.uvT.dy2 = ddy(c.uvT.uv2);\n   }\n\n   Config CreateConfig(ShaderData d, float4 scale, float space, int uvsource, half triplanarContrast)\n   {\n      Config c;\n      ZERO_INITIALIZE(Config, c);\n\n      float3 pos = d.worldSpacePosition;\n      float3 normal = d.worldSpaceNormal;\n      if (space > 0)\n      {\n         pos = d.localSpacePosition;\n         normal = d.localSpaceNormal;\n      }\n\n      c.uv = d.texcoord0.xy;\n      \n      if (uvsource == 1)\n        c.uv = d.texcoord1.xy;\n      else if (uvsource == 2)\n        c.uv = pos.yz * float2(1, -1);\n      else if (uvsource == 3)\n        c.uv = pos.xz * float2(1, -1);\n      else if (uvsource == 4)\n        c.uv = pos.xy * float2(1, -1);\n\n      c.origUV = c.uv;\n      c.origScale = scale.xy;\n\n      c.uv = c.uv * scale.xy + scale.zw;\n      c.dx = ddx(c.uv);\n      c.dy = ddy(c.uv);\n\n      c.normal = normal;\n      c.uvT.uv0 = pos.zy * scale.xy + scale.zw;\n      c.uvT.uv1 = pos.xz * scale.xy + scale.zw;\n      c.uvT.uv2 = pos.xy * scale.xy + scale.zw;\n        \n      c.uvT.uv1 += 0.33;\n      c.uvT.uv2 += 0.67;\n\n      c.uvT.dx0 = ddx(c.uvT.uv0); c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1); c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2); c.uvT.dy2 = ddy(c.uvT.uv2);\n\n      half3 triblend = saturate(pow(abs(c.normal), triplanarContrast));\n      triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n      c.uvT.weights = triblend;\n      c.uvT.origWeights = triblend;\n      c.axisSign = d.worldSpaceNormal < 0 ? -1 : 1;\n      c.absVertNormal = abs(d.worldSpaceNormal);\n     \n\n      return c;\n   }\n\n\n   half4 TriSample(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0) * c.weights.x;\n      }\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1) * c.weights.y;\n      }  \n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2) * c.weights.z;\n      }\n\n      return res;\n   }\n\n   half4 TriSampleBary(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      c.weights = BaryWeightBlend(c.origWeights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   half4 TriSampleGrad(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvX, contrast, d) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvY, contrast, d) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n           res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvZ, contrast, d) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   \n   half4 SampleTexBaryStochastic(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   half4 SampleTexBaryTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleGrad(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   \n   half4 SampleTexBary(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        COUNTSAMPLE\n        return SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv, c.dx, c.dy);\n   }\n\n   half4 SampleTexStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ) * c.uvT.weights.z;\n\n        return res;     \n   }\n\n   \n   half4 SampleTexStochastic(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n\n   half4 SampleTexTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n   \n   half4 SampleTex(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       COUNTSAMPLE\n       return SAMPLE_TEXTURE2D(tex, ss, c.uv);\n   }\n   \n\n \n   half3 SampleNormalStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n         dataX = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n         dataY = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n         dataZ = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ));\n\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n\n          return WorldToTangentSpace(d, worldNormal);\n       #endif\n   }\n\n\n   half3 SampleNormalTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n      {\n          COUNTSAMPLE\n          dataX = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv0, c.uvT.dx0, c.uvT.dy0));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n      {\n          COUNTSAMPLE\n          dataY = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv1, c.uvT.dx1, c.uvT.dy1));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n      {\n         COUNTSAMPLE\n         dataZ = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv2, c.uvT.dx2, c.uvT.dy2));\n      }\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n          return WorldToTangentSpace(d, worldNormal);\n      #endif\n   }\n\n   half3 SampleNormalStochastic(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n     half4 normal = TriSample(tex, ss, c.uvT);\n     #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half3 SampleNormal(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 normal = SAMPLE_TEXTURE2D(tex, ss, c.uv);\n      #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half HeightBlend(half h1, half h2, half slope, half contrast)\n   {\n      h2 = 1 - h2;\n      half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); \n      half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));\n      return blend;\n   }\n\n\n    #if _POM\n    float2 POM(TEXTURE2D_PARAM(tex, ss), Config c, float contrast, ShaderData d)\n    {\n       float2 curv = float2(0, 0);\n       float refPlane = 0;\n\n       float result = 0;\n       int stepIndex = 0;\n       int maxSamples = _POMMaxSamples;\n       int minSamples = 4;\n       float camDist = distance(_WorldSpaceCameraPos, d.worldSpacePosition);\n       float distanceFade = 1 - saturate((camDist - _POMMin) / max(1, _POMFade));\n       int numSteps = ( int )lerp( maxSamples, minSamples, dot( d.worldSpaceNormal, d.worldSpaceViewDir )) * distanceFade;\n       if (numSteps < 1)\n           numSteps = 1;\n       float layerHeight = 1.0 / numSteps;\n       float2 plane = _ParallaxHeight * ( d.tangentSpaceViewDir.xy / d.tangentSpaceViewDir.z ) * distanceFade;\n       OffsetUV(c, refPlane * plane);\n       float2 deltaTex = -plane * layerHeight;\n       float2 prevTexOffset = 0;\n       float prevRayZ = 1.0f;\n       float prevHeight = 0.0f;\n       float2 currTexOffset = deltaTex;\n       float currRayZ = 1.0f - layerHeight;\n       float currHeight = 0.0f;\n       float intersection = 0;\n       float2 finalTexOffset = 0;\n\n       while ( stepIndex < numSteps + 1 )\n       {\n          result = dot( curv, currTexOffset * currTexOffset );\n          Config cfg = c;\n          OffsetUV(cfg, currTexOffset);\n          currHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( currHeight > currRayZ )\n          {\n             stepIndex = numSteps + 1;\n          }\n          else\n          {\n             stepIndex++;\n             prevTexOffset = currTexOffset;\n             prevRayZ = currRayZ;\n             prevHeight = currHeight;\n             currTexOffset += deltaTex;\n             currRayZ -= layerHeight * ( 1 - result );\n          }\n       }\n       int sectionSteps = 10;\n       int sectionIndex = 0;\n       float newZ = 0;\n       float newHeight = 0;\n       while ( sectionIndex < sectionSteps )\n       {\n          intersection = ( prevHeight - prevRayZ ) / ( prevHeight - currHeight + currRayZ - prevRayZ );\n          finalTexOffset = prevTexOffset + intersection * deltaTex;\n          newZ = prevRayZ - intersection * layerHeight;\n          Config cfg = c;\n          OffsetUV(cfg, finalTexOffset);\n          newHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( newHeight > newZ )\n          {\n             currTexOffset = finalTexOffset;\n             currHeight = newHeight;\n             currRayZ = newZ;\n             deltaTex = intersection * deltaTex;\n             layerHeight = intersection * layerHeight;\n          }\n          else\n          {\n             prevTexOffset = finalTexOffset;\n             prevHeight = newHeight;\n             prevRayZ = newZ;\n             deltaTex = ( 1 - intersection ) * deltaTex;\n             layerHeight = ( 1 - intersection ) * layerHeight;\n          }\n          sectionIndex++;\n       }\n       #if _PASSHADOWS\n       if ( unity_LightShadowBias.z == 0.0 )\n       {\n       #endif\n          if ( result > 1 )\n             clip( -1 );\n       #if _PASSHADOWS\n       }\n       #endif\n       return finalTexOffset;\n    }\n    #endif\n\n   \n\n   // tess versions\n   #if _TESSELLATION_ON\n   half4 TriSampleLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias) * c.weights.x;\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias) * c.weights.y;\n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias) * c.weights.z;\n\n      return res;\n   }\n\n   half4 TriSampleBaryLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias, float contrast)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias);\n      half4 r2 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias);\n      half4 r3 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias);\n      c.weights = BaryWeightBlend(c.weights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryLODStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvX, bias, contrast) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvY, bias, contrast) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvZ, bias, contrast) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   half4 SampleTexBaryLODStochastic(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n       return TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias, contrast);\n   }\n\n   half4 SampleTexBaryLODTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return TriSampleLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias);\n   }\n\n   half4 SampleTexBaryLOD(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv, bias);\n   }\n\n\n    float FBM2DLOD(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           return SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv, _TessellationMipBias).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n        \n        \n    }\n\n    float FBM3DLOD(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           half A = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.zy, _TessellationMipBias).g;\n           half B = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33, _TessellationMipBias).g;\n           half C = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67, _TessellationMipBias).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoiseLOD(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3DLOD(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3DLOD(d.localSpacePosition * frequency + offset, d.localSpaceNormal);\n        #else\n           return FBM2DLOD(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n   #endif //_TESSELLATION_ON\n\n\n    half3 FuzzyShade(ShaderData d, half height, half3 color, half3 normal, half coreMult, half edgeMult, half power)\n    {\n        float3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half dt = saturate(dot(d.worldSpaceViewDir, worldNormal));\n        half dark = 1.0 - (coreMult * dt);\n        half edge = pow(1-dt, abs(power)) * edgeMult;\n        return color * (dark + edge);\n    }\n\n\thalf MicroShadow(ShaderData d, half3 normal, half height, half ao, half strength)\n\t{\n        float3 sun;\n\t\tfloat3 sunColor;\n\t\tGetSun(sun, sunColor);\n\t\tfloat3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half shadow = saturate(abs(dot(worldNormal, sun)) + (ao * ao * 2.0) - 1.0);\n        return 1 - ((1-shadow) * strength);\n\t}\n\n\n#endif\n\n\n\n   #if defined(_SPECULAR)\n      #define _USESPECULAR 1\n      #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n   #endif\n\n   \n   TEXTURE2D(_AlbedoMap);\n   SAMPLER(sampler_AlbedoMap);\n   TEXTURE2D(_NormalMap);\n   SAMPLER(sampler_NormalMap);\n   TEXTURE2D(_MaskMap);\n   TEXTURE2D(_DetailMap);\n   TEXTURE2D(_EmissionMap);\n\n   #if _SPECULAR\n       TEXTURE2D(_SpecularMap);\n   #endif\n\n   \n   \n   void Ext_SurfaceFunction0 (inout Surface o, inout ShaderData d)\n   {\n      // define samplers based on settings\n      #undef SAMPLEBARY\n      #undef SAMPLE\n      #undef SAMPLENORMAL\n      #if _STOCHASTIC && _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n        #define SAMPLE     SampleTexStochasticTriplanar\n        #define SAMPLENORMAL SampleNormalStochasticTriplanar\n      #elif _STOCHASTIC\n        #define SAMPLEBARY SampleTexBaryStochastic\n        #define SAMPLE     SampleTexStochastic\n        #define SAMPLENORMAL SampleNormalStochastic\n      #elif _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryTriplanar\n        #define SAMPLE     SampleTexTriplanar\n        #define SAMPLENORMAL SampleNormalTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBary\n        #define SAMPLE     SampleTex\n        #define SAMPLENORMAL SampleNormal\n      #endif\n\n      Config c = CreateConfig(d, _AlbedoMap_ST, _TriplanarSpace, _UVSource, _TriplanarContrast);\n      InitConfigDxDy(c);\n      #if _STOCHASTIC && !_TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uv, c.uvT);\n         InitStochasticDxDy(c.uvT, c);\n      #elif _STOCHASTIC && _TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv0, c.uvX);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv1, c.uvY);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv2, c.uvZ);\n         InitStochasticDxDy(c.uvX, c);\n         InitStochasticDxDy(c.uvY, c);\n         InitStochasticDxDy(c.uvZ, c);\n      #endif\n\n      #if _POM\n          // would need to handle height remapping if we ever want to ship this\n          float2 pomOffset = POM(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n          OffsetUV(c, pomOffset);\n      #endif\n\n      half4 albedo = SAMPLEBARY(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n      \n      #if _PARALLAX\n         float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n         OffsetUV(c, offset);\n         albedo = SAMPLE(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c);\n         \n      #endif\n      albedo.a = lerp(_HeightRemap.x, _HeightRemap.y, albedo.a);\n      albedo.rgb *= _Tint.rgb;\n\n      albedo.rgb = AdjustContrast(albedo.rgb, _AlbedoContrast);\n      albedo.rgb += _AlbedoBrightness;\n\n\n      if (_AlphaThreshold > 0)\n      {\n         clip(albedo.a - _AlphaThreshold);\n      }\n\n      #if defined(_FLATSHADE)\n\t\t     float3 dx = ddx(d.worldSpacePosition);\n\t\t     float3 dy = ddy(d.worldSpacePosition);\n\t\t     float3 worldNormal = normalize(cross(dy, dx));\n\t\t     worldNormal = lerp(d.worldSpaceNormal, worldNormal, _FlatShadingBlend);\n\t\t     d.worldSpaceNormal = worldNormal;\n\t\t     d.TBNMatrix[2] = worldNormal;\n      #endif\n\n\n\n      o.Albedo = albedo.rgb;\n      o.Alpha = albedo.a;\n\n      float smoothness = _Smoothness;\n      float ao = 1;\n\n      #if defined(_NORMALMAP) && !defined(_AUTONORMAL)\n         o.Normal = SAMPLENORMAL(TEXTURE2D_ARGS(_NormalMap, sampler_NormalMap), c, d, _NormalStrength, smoothness, ao);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, ao);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n      #endif\n\n      half detailMask = 1;\n      o.Smoothness = smoothness;\n      o.Occlusion = ao;\n      o.Metallic = _Metallic;\n      #if defined(_MASKMAP) && !_PACKEDFAST\n         // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = SampleTex(TEXTURE2D_ARGS(_MaskMap, sampler_AlbedoMap), c);\n         o.Metallic = lerp(_MetallicRemap.x, _MetallicRemap.y, mask.r);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, mask.g);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, mask.a);\n         detailMask = mask.b;\n      #endif // separate maps\n\n      #if _SPECULAR\n         o.Specular = SAMPLE(TEXTURE2D_ARGS(_SpecularMap, sampler_AlbedoMap), c).rgb;\n      #endif\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = SAMPLE(TEXTURE2D_ARGS(_EmissionMap, sampler_AlbedoMap), c).rgb * _EmissionColor;\n      #endif\n\n      if (_FuzzyShadingOn > 0)\n      {\n        o.Albedo *= FuzzyShade(d, albedo.a, _FuzzyShadingColor, o.Normal, _FuzzyShadingParams.x, _FuzzyShadingParams.y, _FuzzyShadingParams.z);\n      }\n\n\n      // HDRP style detail texturing\n\n      #if defined(_DETAIL)\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _DETAILSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n         Config dc = CreateConfig(d, _DetailMap_ST, _DetailTriplanarSpace, _DetailUVSource, _DetailTriplanarContrast);\n         InitConfigDxDy(dc);\n         #if _DETAILSTOCHASTIC && !_DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uv, dc.uvT);\n             InitStochasticDxDy(dc.uvT, dc);\n         #elif _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv0, dc.uvX);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv1, dc.uvY);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv2, dc.uvZ);\n             InitStochasticDxDy(dc.uvX, dc);\n             InitStochasticDxDy(dc.uvY, dc);\n             InitStochasticDxDy(dc.uvZ, dc);\n         #endif\n\n         half4 detailSample = SAMPLEBARY(TEXTURE2D_ARGS(_DetailMap, sampler_AlbedoMap), dc, _DetailStochasticContrast, d);\n         smoothness = detailSample.z;\n         #if !_AUTONORMAL\n            half3 dnormal = float3(detailSample.ag * 2 - 1, 1) * detailMask * _DetailNormalStrength;\n            dnormal.z = sqrt(1 - dnormal.x * dnormal.x - dnormal.y * dnormal.y);\n            #if _SURFACEGRADIENT\n               dnormal = ConvertNormalToGradient(d, dnormal);\n            #endif\n            o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n         #endif\n     \n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * smoothness, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n      if (_MicroShadowStrength > 0)\n      {\n        o.Occlusion *= MicroShadow(d, o.Normal, o.Alpha, o.Occlusion, _MicroShadowStrength);\n      }\n  \n      // in case something needs height in the stack..\n      o.Height = o.Alpha;\n\n\n      \n   }\n\n\n\n\t#if _TINTMASK\n\t\tTEXTURE2D(_TintMask);\n\t\tSAMPLER(sampler_TintMask);\n\t#endif\n\n\tvoid Ext_SurfaceFunction1 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _TINTMASK\n\t\t   half4 w = SAMPLE_TEXTURE2D(_TintMask, sampler_TintMask, d.texcoord0.xy * _TintMask_ST.xy + _TintMask_ST.zw);\n\t\t   // allow black to be no tint..\n\t\t   half3 tint = o.Albedo * (_RColor.rgb * 2 * w.r + _GColor.rgb * 2 * w.g + _BColor.rgb * 2 * w.b + _AColor.rgb * 2 * w.a);\n\t\t   o.Albedo = lerp(o.Albedo, tint, saturate(w.r + w.g + w.b + w.a));\n\t\t#endif\n\t}\n\n\n\n\n\t#if _LAYERTEXTUREMASK\n       TEXTURE2D(_LayerTextureMask);\n       SAMPLER(sampler_LayerTextureMask); \n    #endif\n\n   void Ext_ModifyTessellatedVertex2 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON\n          float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n\n          #if _LAYERTEXTUREMASK\n               float2 layerUV = v.texcoord0.xy;\n               if (_LayerTextureMaskUVMode == 1)\n                  layerUV = v.texcoord1.xy;\n               else if (_LayerTextureMaskUVMode == 2)\n                  layerUV = worldSpacePosition.yz;\n               else if (_LayerTextureMaskUVMode == 3)\n                  layerUV = worldSpacePosition.xz;\n               else if (_LayerTextureMaskUVMode == 4)\n                  layerUV = worldSpacePosition.xy;\n\n              e.blackboard.weightTextureMask = SAMPLE_TEXTURE2D_LOD(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw, _TessellationMipBias);\n          #endif\n      #endif\n    }\n\n\n\tvoid Ext_SurfaceFunction2 (inout Surface o, inout ShaderData d)\n\t{\n\t\t#if _LAYERTEXTUREMASK\n           float2 layerUV = d.texcoord0.xy;\n           if (_LayerTextureMaskUVMode == 1)\n              layerUV = d.texcoord1.xy;\n           else if (_LayerTextureMaskUVMode == 2)\n              layerUV = d.worldSpacePosition.yz;\n           else if (_LayerTextureMaskUVMode == 3)\n              layerUV = d.worldSpacePosition.xz;\n           else if (_LayerTextureMaskUVMode == 4)\n              layerUV = d.worldSpacePosition.xy;\n\n          d.blackboard.weightTextureMask = SAMPLE_TEXTURE2D(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw);\n      #endif\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap);\n   SAMPLER(sampler_LayerAlbedoMap);\n   TEXTURE2D(_LayerNormalMap);\n   TEXTURE2D(_LayerMaskMap);\n   TEXTURE2D(_LayerEmissionMap);\n\n   \n\n   void Ext_ModifyTessellatedVertex3 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER) && defined(_LAYERALBEDO) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n         half detailMask = 1;\n         #if _LAYERNOISE\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency,  _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin;\n            dt = saturate(dt * _LayerFalloff);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight) * _LayerFalloff);\n            if (_LayerInvertHeight > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength;\n         detailMask *= _LayerTessStrength;\n\n         #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast).a;\n         albedo = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo);\n\n         if (_LayerBlendMode == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction3 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n            // noise up the mask\n            #if _LAYERNOISE\n               mask = DoNoise(d, _LayerNoiseFrequency, _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend);\n\t    \n                dt -= _LayerAngleMin;\n                dt = saturate(dt * _LayerFalloff);\n\n                float hf = saturate((o.Height - _LayerHeight) * _LayerFalloff);\n                if (_LayerInvertHeight > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 0\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 0\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength;\n\n            #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint, 0.5);\n            #if defined(_LAYERALBEDO)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c, _LayerStochasticContrast, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c);\n                #endif\n                albedo.rgb *= _LayerTint;\n                albedo.a = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL || _LAYERMASK\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap, sampler_LayerAlbedoMap, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast);\n            albedo.rgb += _LayerAlbedoBrightness;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap, sampler_LayerAlbedoMap), c, d, _LayerNormalStrength * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO)\n                if (_LayerFuzzyShadingOn > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor.rgb, dnormal,\n                                            _LayerFuzzyShadingParams.x, _LayerFuzzyShadingParams.y, _LayerFuzzyShadingParams.z);\n                }\n\n                if (_LayerBlendMode == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast);\n                else if (_LayerBlendMode == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE\n                      float maskDif = (_LayerBlendContrast * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength);\n                   #if _LAYERNOISE\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap, sampler_LayerAlbedoMap), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength);\n                }\n\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap, sampler_LayerAlbedoMap), c).rgb * _LayerEmissionColor;\n                #if _LAYERALBEDO\n                    if (_LayerBlendMode > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_1);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_1);\n   TEXTURE2D(_LayerNormalMap_Ext_1);\n   TEXTURE2D(_LayerMaskMap_Ext_1);\n   TEXTURE2D(_LayerEmissionMap_Ext_1);\n\n   \n\n   void Ext_ModifyTessellatedVertex4 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_1) && defined(_LAYERALBEDO_DEF_1) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_1\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_1,  _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_1\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_1;\n            dt = saturate(dt * _LayerFalloff_Ext_1);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n            if (_LayerInvertHeight_Ext_1 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_1;\n         detailMask *= _LayerTessStrength_Ext_1;\n\n         #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_1).a;\n         albedo = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo);\n\n         if (_LayerBlendMode_Ext_1 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_1);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_1 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction4 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_1)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_1\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_1, _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_1\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_1);\n\t    \n                dt -= _LayerAngleMin_Ext_1;\n                dt = saturate(dt * _LayerFalloff_Ext_1);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n                if (_LayerInvertHeight_Ext_1 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 01\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 01\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_1;\n\n            #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_1, 0.5);\n            #if defined(_LAYERALBEDO_DEF_1)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, _LayerStochasticContrast_Ext_1, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_1;\n                albedo.a = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_1 || _LAYERMASK_DEF_1\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_1);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_1;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, d, _LayerNormalStrength_Ext_1 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_1)\n                if (_LayerFuzzyShadingOn_Ext_1 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_1.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_1.x, _LayerFuzzyShadingParams_Ext_1.y, _LayerFuzzyShadingParams_Ext_1.z);\n                }\n\n                if (_LayerBlendMode_Ext_1 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_1);\n                else if (_LayerBlendMode_Ext_1 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_1 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_1);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_1\n                      float maskDif = (_LayerBlendContrast_Ext_1 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_1 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                   #if _LAYERNOISE_DEF_1\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_1));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_1 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_1);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_1) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_1 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_1);\n                }\n\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_1);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_1, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_1, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_1\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c).rgb * _LayerEmissionColor_Ext_1;\n                #if _LAYERALBEDO_DEF_1\n                    if (_LayerBlendMode_Ext_1 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_2);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_2);\n   TEXTURE2D(_LayerNormalMap_Ext_2);\n   TEXTURE2D(_LayerMaskMap_Ext_2);\n   TEXTURE2D(_LayerEmissionMap_Ext_2);\n\n   \n\n   void Ext_ModifyTessellatedVertex5 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_2) && defined(_LAYERALBEDO_DEF_2) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_2\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_2,  _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_2\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_2;\n            dt = saturate(dt * _LayerFalloff_Ext_2);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n            if (_LayerInvertHeight_Ext_2 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_2;\n         detailMask *= _LayerTessStrength_Ext_2;\n\n         #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_2).a;\n         albedo = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo);\n\n         if (_LayerBlendMode_Ext_2 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_2);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_2 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction5 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_2)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_2\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_2, _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_2\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_2);\n\t    \n                dt -= _LayerAngleMin_Ext_2;\n                dt = saturate(dt * _LayerFalloff_Ext_2);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n                if (_LayerInvertHeight_Ext_2 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 02\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 02\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_2;\n\n            #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_2, 0.5);\n            #if defined(_LAYERALBEDO_DEF_2)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, _LayerStochasticContrast_Ext_2, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_2;\n                albedo.a = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_2 || _LAYERMASK_DEF_2\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_2);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_2;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, d, _LayerNormalStrength_Ext_2 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_2)\n                if (_LayerFuzzyShadingOn_Ext_2 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_2.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_2.x, _LayerFuzzyShadingParams_Ext_2.y, _LayerFuzzyShadingParams_Ext_2.z);\n                }\n\n                if (_LayerBlendMode_Ext_2 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_2);\n                else if (_LayerBlendMode_Ext_2 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_2 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_2);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_2\n                      float maskDif = (_LayerBlendContrast_Ext_2 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_2 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                   #if _LAYERNOISE_DEF_2\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_2));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_2 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_2);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_2) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_2 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_2);\n                }\n\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_2);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_2, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_2, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_2\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c).rgb * _LayerEmissionColor_Ext_2;\n                #if _LAYERALBEDO_DEF_2\n                    if (_LayerBlendMode_Ext_2 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   #if _TRAX_ON\n   TEXTURE2D(_TraxAlbedo);\n   SAMPLER(sampler_TraxAlbedo);\n   TEXTURE2D(_TraxPackedNormal);\n   TEXTURE2D(_TraxMask);\n\n   sampler2D_float _GMSTraxBuffer;\n\n   float4 _GMSTraxBuffer_TexelSize;\n   float3 _GMSTraxBufferPosition;\n   float _GMSTraxBufferWorldSize;\n   float _GMSTraxFudgeFactor;\n\n   float SampleTraxBufferLOD(float3 worldPos)\n   {    \n      // generate UVs for the buffer, which is moving\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 8);\n      uv *= 0.5;\n      uv += 0.5;\n            \n      float s =  tex2Dlod(_GMSTraxBuffer, float4(uv, 0, 0)).r;\n\n      return 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n   }\n         \n        \n   float SampleTraxBuffer(float3 worldPos, out float3 norm)\n   {\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 3);\n      uv *= 0.5;\n      uv += 0.5;\n            \n\n      float2 offset = _GMSTraxBuffer_TexelSize.xy;\n\n      float s = tex2D(_GMSTraxBuffer, uv).r;\n               \n      float s1 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, -1)).r;\n      float s2 = tex2D(_GMSTraxBuffer, uv + offset * float2(-1, 0)).r;\n      float s3 = tex2D(_GMSTraxBuffer, uv + offset * float2(1, 0)).r;\n      float s4 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, 1)).r;\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      float r = 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n \n      // generate normals\n      norm.x = (s1 - s4) * 0.25; \n      norm.y = (s2 - s3) * 0.25;\n      norm.z = 2;\n      norm = normalize(norm);\n     \n      norm.xy *= 1 - r;\n            \n      return r;\n   }\n   #endif\n\n   void Ext_ModifyTessellatedVertex6 (inout VertexData v, inout ExtraV2F d)\n   {\n       #if _TESSELLATION_ON && _TRAX_ON && _HAS_LIT_TESSELLATION\n          \n           float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n           float3 worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n           float traxBuffer = SampleTraxBufferLOD(worldSpacePosition);\n           d.blackboard.traxBuffer = traxBuffer;\n           float2 uv = worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n           half albedo = SAMPLE_TEXTURE2D_LOD(_TraxAlbedo, sampler_TraxAlbedo, uv, _TraxMipBias).a;\n\n           float traxOffset = albedo * _TraxDisplacementStrength;\n           traxOffset *= 1 - v.texcoord0.z;\n           traxOffset *= _TessellationDisplacement;\n           float dig = _TraxDisplacementDepth * (1 - v.texcoord0.z);\n           float3 traxVertex = d.blackboard.originalVertexPosition + (v.normal * (traxOffset - dig));\n           v.vertex.xyz = lerp(traxVertex, v.vertex.xyz, traxBuffer);\n\n           d.blackboard.vertexHeightOffset = lerp(traxOffset-dig, d.blackboard.vertexHeightOffset, traxBuffer);\n\n       #endif\n\n   }\n\n   void Ext_SurfaceFunction6 (inout Surface o, inout ShaderData d)\n   {\n      #if _TRAX_ON\n        float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n        float2 fsdx = ddx(uv);\n        float2 fsdy = ddy(uv);\n\n        float3 traxNormal;\n        float traxBuffer = SampleTraxBuffer(d.worldSpacePosition, traxNormal);\n        \n        #if _TESSELLATION_ON\n            traxBuffer -= _TraxDisplacementDepth;\n        #endif\n\n        d.blackboard.traxBuffer = traxBuffer;\n\n        UNITY_BRANCH\n        if (traxBuffer > 0)\n        {\n            half4 albedo = SAMPLE_TEXTURE2D_GRAD(_TraxAlbedo, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            albedo.rgb *= _TraxTint.rgb;\n            half4 normalSample = SAMPLE_TEXTURE2D_GRAD(_TraxPackedNormal, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n\n            half smoothness = normalSample.r;\n            half ao = normalSample.b;\n            half3 normal;\n            normal.xy = (normalSample.ag * 2 - 1) * _TraxNormalStrength;\n            normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n\n            \n            half h = HeightBlend(albedo.a, o.Alpha, traxBuffer, _TraxHeightContrast);\n\n            h = lerp(traxBuffer, h, _TraxInterpContrast);\n\n            o.Albedo = lerp(albedo, o.Albedo, h);\n\n            #if _SURFACEGRADIENT\n                o.Normal = lerp(normal, o.Normal, h);\n            #else\n                o.Normal = lerp(normal + traxNormal, o.Normal, h);\n            #endif\n        \n            o.Smoothness = lerp(smoothness, o.Smoothness, h);\n            o.Occlusion = lerp(ao, o.Occlusion, h);\n        }\n      #endif\n   }\n\n\n\n\n    #if _RAINDROPS\n       TEXTURE2D(_RainDropTexture);\n       SAMPLER(sampler_RainDropTexture);\n       half _Global_RainIntensity;\n    #endif\n\n    #if _WETNESS\n       half2 _Global_WetnessParams; // global, not in cbuffer\n    #endif\n   \n    #if _RAINDROPS\n    half2 ComputeRipple(float2 uv, half time, half weight)\n    {\n        half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_RainDropTexture, uv);\n        COUNTSAMPLE\n        ripple.yz = ripple.yz * 2 - 1;\n\n        half dropFrac = frac(ripple.w + time);\n        half timeFrac = dropFrac - 1.0 + ripple.x;\n        half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);\n        half finalFactor = dropFactor * ripple.x * \n                                sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);\n\n        return half2(ripple.yz * finalFactor);\n    }\n    #endif\n\n    half2 DoRain(half2 waterNorm, float2 uv, out half2 ripple)\n    {\n        #if _RAINDROPS\n            float rainIntensity = _RainIntensityScale.x;\n            if (_RainMode > 1)\n            {\n                rainIntensity = _Global_RainIntensity;\n            }\n\n            half dropStrength = rainIntensity;\n            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); \n            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);\n            half4 times = _Time.yyyy;\n            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);\n\n            float2 ruv1 = uv * _RainIntensityScale.yy;\n            float2 ruv2 = ruv1;\n\n            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);\n            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);\n            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);\n            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);\n            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);\n            weights = saturate(weights * 4);\n\n            half2 rippleNormal = half2( weights.x * ripple1.xy +\n                        weights.y * ripple2.xy + \n                        weights.z * ripple3.xy + \n                        weights.w * ripple4.xy);\n\n            ripple = rippleNormal * dropStrength * rainIntensity;\n            waterNorm = lerp(waterNorm, normalize(half3(rippleNormal.xy + rippleNormal.xy, 1)).xy, rainIntensity * dropStrength); \n            return waterNorm;                        \n        #else\n            return waterNorm;\n        #endif\n    }\n\n   half2 _Global_PuddleParams;   // this is a global, so keep it out of the cbuffer\n   void GetPuddleParams(ShaderData d, inout float puddleMask, inout float pudHeight)\n   {\n      #if _PUDDLES || _GLOBALPUDDLES\n          pudHeight = _PuddleAmount;\n          if (_PuddleMode > 0)\n             pudHeight = _Global_PuddleParams.x;    \n      \n\n          half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t      dt -= _PuddleAngleMin;\n          dt = saturate(dt * _PuddleFalloff);\n          puddleMask *= dt;\n      #endif\n   }\n   \n   void Ext_ModifyTessellatedVertex7 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _PUDDLES && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n         half mask = 1;\n         half pudHeight = 1;\n\n         // save some ops by doing this in 2d\n         #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2DLOD(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2DLOD(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #else\n                mask = (FBM2DLOD(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n         #endif\n\n         GetPuddleParams(d, mask, pudHeight);\n         float height = pudHeight * mask;\n         if (e.blackboard.vertexHeightOffset < height)\n         {\n            e.blackboard.vertexHeightOffset = height;\n            height -= _TessellationOffset; \n            // dampen cracks\n            height *= 1 - v.texcoord0.z;\n            height *= _TessellationDisplacement;\n            v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n            \n        }\n      #endif\n   }\n\n\n#if _WETNESS\n\n   float GetWetnessLevel(Surface o, ShaderData d, float wetnessMask)\n   {\n      float wetLevel = clamp(_WetnessAmount, _WetnessMin, _WetnessMax);\n      \n      if (_WetnessMode > 0)\n         wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);\n\n      wetLevel = saturate(wetLevel + (1 - saturate(d.worldSpacePosition.y - _WetnessShoreline)));\n      float3x3 tbn = float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal);\n      float dt = dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0));\n      dt -= _WetnessAngleMin;\n      dt = saturate(dt * _WetnessFalloff * wetLevel);\n      dt *= wetnessMask;\n      return dt;\n   }\n#endif\n   \n\n   void Ext_SurfaceFunction7 (inout Surface o, ShaderData d)\n   {\n      half wetnessLevel = 0;\n      #if _WETNESS\n          wetnessLevel = GetWetnessLevel(o, d, 1); // mask one day?\n      #endif\n\n      half depthMask = 0;\n      half depth = 0;\n\n      #if _PUDDLES\n          half mask = 1;\n          half pudHeight = 1;\n          #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2D(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2D(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);      \n            #else\n                mask = (FBM2D(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n          #endif\n\n          GetPuddleParams(d, mask, pudHeight);\n          pudHeight *= mask;\n          depth = pudHeight - o.Height;\n          depthMask = saturate(depth * _PuddleFalloff);\n          depthMask *= _PuddleColor.a;\n          depth = o.Height - pudHeight;\n\n          // extend wetness slighting higher than the puddle\n          half wetmask = saturate((pudHeight + 0.05 - o.Height) * _PuddleFalloff);\n          wetnessLevel = max(wetmask, wetnessLevel);\n       #endif\n\n       \n       #if _WETNESS || _PUDDLES\n          half3 waterNorm = half3(0,0,1);\n          half3 wetAlbedo = o.Albedo;\n          half wetSmoothness = o.Smoothness;\n          #if _PUDDLES\n             wetAlbedo *= _PuddleColor.rgb;\n          #endif\n          WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetnessLevel, _Porosity);\n\n          half ri = 0;\n          half2 ripple = 0;\n          #if (_RAINDROPS || _GLOBALRAIN) && (_PUDDLES || _GLOBALPUDDLES)\n             ri = _RainIntensityScale.z;\n             waterNorm.xy = DoRain(waterNorm.xy, d.texcoord0.xy, ripple) * depthMask;\n          #endif\n\n          o.Normal = lerp(o.Normal, waterNorm, depthMask);\n          o.Normal = lerp(o.Normal, LitBlendDetailNormal(o.Normal, half3(ripple.xy, 1)), saturate(ri - depthMask) * wetnessLevel);\n          o.Occlusion = lerp(o.Occlusion, 1, depthMask);\n          o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetnessLevel);\n          o.Albedo = lerp(o.Albedo, wetAlbedo, wetnessLevel);\n          o.Emission *= 1 + depth;\n          o.Metallic *= 1 + depth;\n          o.Specular *= 1 + depth;\n\n       #endif\n\n   }\n\n\n\n\n    #if _SNOW\n       TEXTURE2D(_SnowAlbedo);\n       SAMPLER(sampler_SnowAlbedo);\n       TEXTURE2D(_SnowNormal);\n       TEXTURE2D(_SnowMaskMap);\n       #if _TRAX_ON\n          TEXTURE2D(_SnowTraxAlbedo);\n          TEXTURE2D(_SnowTraxNormal);\n          TEXTURE2D(_SnowTraxMaskMap);\n       #endif\n    #endif\n\n   float _Global_SnowLevel;\n\n\n   void Ext_ModifyVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n    #if (_SNOW)\n        float amount = _SnowAmount;\n        if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n        float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n        float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n        snowAmount -= _SnowAngle;\n        snowAmount *= _SnowContrast * 0.5;\n        snowAmount = saturate(snowAmount) * amount;\n        float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n        if (_SnowWorldFade.z > 0)\n        {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n        }\n        #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n        #endif\n        snowAmount = saturate(snowAmount);\n\n        #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n        #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n        #endif\n\n        float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n        v.vertex.xyz = v.vertex.xyz + displacementVec * snowAmount * snowAmount * _SnowVertexHeight;\n    #endif\n   }\n\n   void Ext_ModifyTessellatedVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _SNOW && _HAS_LIT_TESSELLATION\n         float amount = _SnowAmount;\n         if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n         float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n         float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n         snowAmount -= _SnowAngle;\n         snowAmount *= _SnowContrast * 0.5;\n         float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n         if (_SnowWorldFade.z > 0)\n         {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n         }\n\n         snowAmount = saturate(snowAmount) * amount;\n\n         #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n         #endif\n         snowAmount = saturate(snowAmount);\n\n         #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n         #endif\n\n         float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n         half heightMap = SAMPLE_TEXTURE2D_LOD(_SnowAlbedo, sampler_SnowAlbedo, worldPos.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw, 2);\n\n         float height = max(_SnowVertexHeight * 3 * snowAmount + snowAmount * heightMap, e.blackboard.vertexHeightOffset);\n         #if _TRAX_ON\n            height *= e.blackboard.traxBuffer;\n         #endif\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n\n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n         \n      #endif\n\n   }\n\n   void SampleSnowSurface(TEXTURE2D_PARAM(alb, ss), TEXTURE2D_PARAM(norm, ss2), TEXTURE2D_PARAM(mask, ss3),\n        ShaderData d, float2 uv, float2 dx, float2 dy, out half4 albedo, out half3 normal, out half2 smoothAO)\n   {\n      #if _SNOWSTOCHASTIC\n         float w1, w2, w3;\n         int2 vertex1, vertex2, vertex3;\n         TriangleGrid(uv, _SnowStochasticScale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n         // Assign random offset to each triangle vertex\n         float2 uv0 = uv;\n         float2 uv1 = uv;\n         float2 uv2 = uv;\n   \n         uv0.xy += SimpleHash2(vertex1);\n         uv1.xy += SimpleHash2(vertex2);\n         uv2.xy += SimpleHash2(vertex3);\n         half3 weights = half3(w1, w2, w3);\n\n         half4 albedo0 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv0, dx, dy);\n         half4 albedo1 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv1, dx, dy);\n         half4 albedo2 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv2, dx, dy);\n         COUNTSAMPLE\n         COUNTSAMPLE\n         COUNTSAMPLE\n         weights = BaryWeightBlend(weights, albedo0.a, albedo1.a, albedo2.a, _SnowStochasticContrast);\n         albedo = albedo0 * weights.x + albedo1 * weights.y + albedo2 * weights.z;\n\n         normal = half3(0,0,1);\n         smoothAO = half2(0, 1);\n\n         #if !_AUTONORMAL\n            half4 n0 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv0, dx, dy);\n            half4 n1 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv1, dx, dy);\n            half4 n2 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n            half4 snowNormSamp = n0 * weights.x + n1 * weights.y + n2 * weights.z;\n\n            normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n                \n            #if _PACKEDFAST\n               smoothAO.x = snowNormSamp.r;\n               smoothAO.y = snowNormSamp.b;\n            #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask0 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv0, dx, dy);\n            half4 snowMask1 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv1, dx, dy);\n            half4 snowMask2 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n            half4 snowMask = snowMask0 * weights.x + snowMask1 * weights.y + snowMask2 * weights.z;\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n      #else // not stochastic\n          albedo = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv, dx, dy);\n          COUNTSAMPLE\n\n          normal = half3(0,0,1);\n          smoothAO = half2(0, 1);\n\n          #if !_AUTONORMAL\n             half4 snowNormSamp = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv, dx, dy);\n             COUNTSAMPLE\n             normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n             #if _SURFACEGRADIENT\n                normal = ConvertNormalToGradient(d, normal);\n             #endif\n                 \n             #if _PACKEDFAST\n                smoothAO.x = snowNormSamp.r;\n                smoothAO.y = snowNormSamp.b;\n             #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv, dx, dy);\n            COUNTSAMPLE\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n     #endif // stochastic\n   }\n\n   \n   void Ext_SurfaceFunction8 (inout Surface o, ShaderData d)\n   {\n      #if _SNOW\n          float amount = _SnowAmount;\n          if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n          float snowAmount = lerp(dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), dot(d.worldSpaceNormal, float3(0,1,0)), amount * 0.8) + 1;\n          snowAmount -= _SnowAngle;\n          snowAmount *= _SnowContrast;\n          snowAmount = saturate(snowAmount) - (1-amount) * (1-amount);\n\n          if (_SnowWorldFade.z > 0)\n          {\n             float worldFade = saturate((d.worldSpacePosition.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n             snowAmount *= worldFade;\n          }\n\n          #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(d.worldSpacePosition.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n          #endif\n          snowAmount = saturate(snowAmount);\n\n          float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw;\n          float2 dx = ddx(uv);\n          float2 dy = ddy(uv);\n\n          #if _TRAX_ON\n              float2 tuv = d.worldSpacePosition.xz * float2(1, -1) * _SnowTraxAlbedo_ST.xy + _SnowTraxAlbedo_ST.zw;\n              float2 tdx = ddx(uv);\n              float2 tdy = ddy(uv);\n          #endif\n\n          #if _LAYERVERTEXMASK\n              snowAmount *= d.vertexColor.a;\n          #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n              snowAmount *= d.blackboard.weightTextureMask.a;\n          #endif\n\n          UNITY_BRANCH\n          if (snowAmount > 0)\n          {\n             half4 snowAlbedo;\n             half3 snowNormal;\n             half2 snowSmoothAO;\n             SampleSnowSurface(TEXTURE2D_ARGS(_SnowAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowNormal, sampler_SnowAlbedo),\n                    TEXTURE2D_ARGS(_SnowMaskMap, sampler_SnowAlbedo), d, uv, dx, dy, snowAlbedo, snowNormal, snowSmoothAO);\n\n             snowAlbedo.rgb *= _SnowTint.rgb;\n\n             #if _TRAX_ON\n                half traxBuffer = 1 - d.blackboard.traxBuffer;\n                UNITY_BRANCH\n                if (traxBuffer > 0)\n                {\n                    half4 tsnowAlbedo;\n                    half3 tsnowNormal;\n                    half2 tsnowSmoothAO;\n                    SampleSnowSurface(TEXTURE2D_ARGS(_SnowTraxAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowTraxNormal, sampler_SnowAlbedo),\n                        TEXTURE2D_ARGS(_SnowTraxMaskMap, sampler_SnowAlbedo), d, tuv, tdx, tdy, tsnowAlbedo, tsnowNormal, tsnowSmoothAO);\n\n                    tsnowAlbedo.rgb *= _SnowTraxTint;\n                    half h = HeightBlend(snowAlbedo.a, tsnowAlbedo.a, traxBuffer, 0.5);\n                    snowAlbedo = lerp(snowAlbedo, tsnowAlbedo, h);\n                    snowNormal = lerp(snowNormal, tsnowNormal, h);\n                    snowSmoothAO = lerp(snowSmoothAO, tsnowSmoothAO, h);\n                }\n             #endif\n\n             #if !_AUTONORMAL\n                o.Normal = lerp(o.Normal, snowNormal, snowAmount);\n             #endif\n             o.Albedo = lerp(o.Albedo, snowAlbedo.rgb, snowAmount);\n             o.Alpha = lerp(o.Alpha, snowAlbedo.a, snowAmount);\n             o.Smoothness = lerp(o.Smoothness, snowSmoothAO.x, snowAmount);\n             o.Occlusion = lerp(o.Occlusion, snowSmoothAO.y, snowAmount);\n             o.Height = o.Alpha;\n\n          }\n      #endif\n   }\n\n   \n\n\n\n\n\n   TEXTURE2D(_WindParticulate);\n   SAMPLER(sampler_WindParticulate);\n\n// In case we want to read it more than once..\n\n#ifndef __STACKABLE_WIND_INCLUDES__\n#define __STACKABLE_WIND_INCLUDES__\n\n\n   half FilterRange(float4 range, float y)\n   {\n      half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));\n      w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));\n      return w;\n   }\n\n   \n   float2 RotateUV(float2 uv, float amt)\n   {\n      uv -=0.5;\n      float s = sin ( amt);\n      float c = cos ( amt );\n      float2x2 mtx = float2x2( c, -s, s, c);\n      mtx *= 0.5;\n      mtx += 0.5;\n      mtx = mtx * 2-1;\n      uv = mul ( uv, mtx );\n      uv += 0.5;\n      return uv;\n   }\n\n\n   half FilterWindParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)\n   {\n      float2 windDir = RotateUV(float2(1, 0), windRot);\n      float2 flow = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));\n      float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill\n      return FilterRange(range, cofacing);\n   }\n\n   half ProcessWindParticulateMask(inout half mask, float contrast)\n   {\n      mask = pow(abs(mask), abs(contrast));\n      half invMask = 1.0 - mask;\n      invMask *= invMask; \n      invMask *= invMask;\n      return invMask;\n   }\n#endif // include guard\n\n   void Ext_SurfaceFunction9 (inout Surface o, ShaderData d)\n   {\n      #if _WIND_ON && !_PASSMETA\n   \n         float3 upVector = float3(0,0,1);\n\n         half upDot = max(0.0, dot(d.worldSpaceNormal, float3(0, 1, 0)));\n\n         float2 uv = d.worldSpacePosition.xz;\n         if (_WindParticulateSpace > 0.5)\n            uv = d.texcoord0.xy;\n         float windRotation = _WindParticulateRotation;\n         float windStrength = _WindParticulateStrength;\n\n         float2 wuv = RotateUV(uv, windRotation);\n\n         half windBlend = 1.0;\n\n         float windWorldMask = FilterRange(_WindParticulateWorldHeightMask, d.worldSpacePosition.y);\n         windWorldMask *= FilterRange(_WindParticulateAngleMask, upDot);\n\n         // compute mask\n         wuv *= float2(_WindParticulate_ST.x, 1) * _WindParticulate_ST.y + _WindParticulate_ST.zw;\n         float speed = _Time.x * _WindParticulateSpeed;\n         half w1 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv * 3 + speed * float2(1,0)).g;\n         half w2 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv + speed * float2(1.1,0)).a;\n         half windMask = (w1 * w2);\n\n         windMask *= windStrength * windBlend * windWorldMask;\n         windMask *= saturate((_WindParticulateTextureHeight - o.Height) * 10);\n\n         half windInvMask = ProcessWindParticulateMask(windMask, _WindParticulatePower);\n    \n         o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);\n         o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindParticulateEmissive.rgb;\n         o.Normal.xy *= windInvMask;\n         o.Smoothness *= windInvMask;\n         o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;\n         o.Metallic *= windInvMask;\n      #endif\n\n   }\n\n\n\n\n\tvoid Ext_SurfaceFunction10 (inout Surface o, ShaderData d)\n\t{\n        if (_DoubleSidedNormalMode == 0)\n        {\n           o.Normal *= d.isFrontFace ? 1 : -1;\n        }\n        else if (_DoubleSidedNormalMode == 1)\n        {\n\t\t   o.Normal.z *= d.isFrontFace ? 1 : -1;\n        }\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction11 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _SURFACEGRADIENT\n\t\t\to.Normal = ResolveNormalFromSurfaceGradient(d, o.Normal);\n\t    #elif _AUTONORMAL\n\t        float3 dx = ddx(d.worldSpacePosition);\n\t\t\tfloat3 dy = ddy(d.worldSpacePosition);\n\t\t\tfloat3 crossX = cross(float3(0,1,0), dx);\n\t\t\tfloat3 crossY = cross(float3(0,1,0), dy);\n\t\t\tfloat3 dt = abs(dot(crossY, dx));\n\t\t\tfloat height = _AutoNormalStrength * 0.5 * o.Alpha;\n\t\t\tfloat3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n\t\t\tn.y *= -1.0;\n\t\t\to.Normal = normalize((dt * float3(0,1,0)) - n).xzy;\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#else\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#endif\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction12 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DEBUG_SAMPLECOUNT\n\t\t\tif (_sampleCount > _DebugSampleCountThreshold)\n\t\t\t{\n\t\t\t\to.Albedo.r = 1;\n\t\t\t\to.Albedo.gb *= 0.2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\to.Albedo.b = 1;\n\t\t\t}\n\n        #endif\n\t}\n\n\n\n\n\tSAMPLER(sampler_DissolveTexture);\n\tTEXTURE2D(_DissolveTexture);\n\tTEXTURE2D(_DissolveGradient);\n\n\tvoid Ext_SurfaceFunction13 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DISSOLVE\n\t\tfloat2 uv = d.texcoord0.xy * _DissolveTexture_ST.xy + _DissolveTexture_ST.zw;\n\t\tfloat2 dx = ddx(uv);\n\t\tfloat2 dy = ddy(uv);\n\n\t\tUNITY_BRANCH\n\t\tif (_DissolveAmount > 0)\n\t\t{\n\t\t\thalf dissolve = SAMPLE_TEXTURE2D_GRAD(_DissolveTexture, sampler_DissolveTexture, uv, dx, dy).g;\n\t\t\thalf cp =  saturate(_DissolveAmount - (dissolve - _DissolveAmount) * _DissolveEdgeContrast) + _DissolveAmount;\n\t\t\thalf cp2 = saturate(1.0 - abs((dissolve - _DissolveAmount) * _DissolveEdgeContrast));\n\t\t\tclip(1.0 - cp);\n\t\t\tfloat2 fuv = float2(cp2, 0.5);\n\t\t\thalf3 col = SAMPLE_TEXTURE2D_LOD(_DissolveGradient, sampler_DissolveTexture, fuv, 0).rgb;\n\t\t\t\t\n\t\t\to.Albedo = lerp(o.Albedo, col, _DissolveColoration * cp2);\n\t\t\to.Emission = lerp(o.Emission, col * _DissolveEmissiveStr, _DissolveColoration * cp2);\n\t\t}\n\t\t#endif\n\t}\n\n\n\n\n    float Dither8x8Bayer( int x, int y )\n    {\n        const float dither[ 64 ] = {\n                1, 49, 13, 61,  4, 52, 16, 64,\n            33, 17, 45, 29, 36, 20, 48, 32,\n                9, 57,  5, 53, 12, 60,  8, 56,\n            41, 25, 37, 21, 44, 28, 40, 24,\n                3, 51, 15, 63,  2, 50, 14, 62,\n            35, 19, 47, 31, 34, 18, 46, 30,\n            11, 59,  7, 55, 10, 58,  6, 54,\n            43, 27, 39, 23, 42, 26, 38, 22};\n        int r = y * 8 + x;\n        return dither[r] / 64; \n    }\n\n    void ApplyDitherCrossFadeVSP(float2 vpos, float fadeValue)\n    {\n        float dither = Dither8x8Bayer( fmod(vpos.x, 8), fmod(vpos.y, 8) );\n        float sgn = fadeValue > 0 ? 1.0f : -1.0f;\n        clip(dither - (1-fadeValue) * sgn);\n    }\n    \n\n\tvoid Ext_SurfaceFunction14 (inout Surface o, ShaderData d)\n\t{\n\t\t#if LOD_FADE_CROSSFADE\n            float4 screenPosNorm = d.screenPos / d.screenPos.w;\n            screenPosNorm.z = ( UNITY_NEAR_CLIP_VALUE >= 0 ) ? screenPosNorm.z : screenPosNorm.z * 0.5 + 0.5;\n            float2 clipScreen = screenPosNorm.xy * _ScreenParams.xy;\n            ApplyDitherCrossFadeVSP(clipScreen,unity_LODFade.x);\n        #endif\n\t}\n\n\n\n\n\n\n// declare outside of CBuffer\n\nfloat4x4 _GlobalVolumeMatrix;\nfloat4x4 _VolumeMatrix;\nfloat3 _VolumeMin;\nfloat3 _VolumeInvSize;\nfloat3 _GlobalVolumeMin;\nfloat3 _GlobalVolumeInvSize;\n\n// I inlined a section of your include. You can use includes in better shaders, but doing it via a subshader or this way\n// is much better. The reason is that this allows your shader to be all inclusive, and packed up for asset store distribition,\n// without requiring specific paths to other files, etc.\n//\n\n#ifndef BAKERY_INCLUDED\n#define BAKERY_INCLUDED\n\n#define BAKERYMODE_DEFAULT 0\n#define BAKERYMODE_VERTEXLM 1.0f\n#define BAKERYMODE_RNM 2.0f\n#define BAKERYMODE_SH 3.0f\n\n\n// can't fit vertexLM SH to sm3_0 interpolators\n#ifndef SHADER_API_D3D11\n    #undef _LIGHTMAPMODE_VERTEXSH\n#endif\n\n// can't do stuff on sm2_0 due to standard shader alrady taking up all instructions\n#if SHADER_TARGET < 30\n    #undef BAKERY_BICUBIC\n    #undef BAKERY_LMSPEC\n\n    #undef _LIGHTMAPMODE_RNM\n    #undef _LIGHTMAPMODE_SH\n    #undef _LIGHTMAPMODE_VERTEX\n#endif\n\n#define lumaConv float3(0.2125f, 0.7154f, 0.0721f)\n\n#ifdef BAKERY_VOLUME\n    #ifdef BAKERY_COMPRESSED_VOLUME\n        Texture3D _Volume3;\n    #endif\n#endif\n\n\nhalf3 LinearToGamma (half3 linRGB)\n{\n    linRGB = max(linRGB, half3(0.h, 0.h, 0.h));\n    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n    return max(1.055h * pow(linRGB, 0.416666667h) - 0.055h, 0.h);\n}\n\nfloat shEvaluateDiffuseL1Geomerics(float L0, float3 L1, float3 n)\n{\n    // average energy\n    float R0 = L0;\n\n    // avg direction of incoming light\n    float3 R1 = 0.5f * L1;\n\n    // directional brightness\n    float lenR1 = length(R1);\n\n    // linear angle between normal and direction 0-1\n    //float q = 0.5f * (1.0f + dot(R1 / lenR1, n));\n    //float q = dot(R1 / lenR1, n) * 0.5 + 0.5;\n    float q = dot(normalize(R1), n) * 0.5 + 0.5;\n\n    // power for q\n    // lerps from 1 (linear) to 3 (cubic) based on directionality\n    float p = 1.0f + 2.0f * lenR1 / R0;\n\n    // dynamic range constant\n    // should vary between 4 (highly directional) and 0 (ambient)\n    float a = (1.0f - lenR1 / R0) / (1.0f + lenR1 / R0);\n\n    return R0 * (a + (1.0f - a) * (p + 1.0f) * pow(q, p));\n}\n\n#ifdef BAKERY_VERTEXLMMASK\n    float4 unpack4NFloats(float src)\n\t{\n        //return fmod(float4(src / 262144.0, src / 4096.0, src / 64.0, src), 64.0)/64.0;\n        return frac(float4(src / (262144.0*64), src / (4096.0*64), src / (64.0*64), src));\n    }\n#endif\n\n#if defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n    float3 unpack3NFloats(float src)\n\t{\n        float r = frac(src);\n        float g = frac(src * 256.0);\n        float b = frac(src * 65536.0);\n        return float3(r, g, b);\n    }\n#endif\n\n// Unity defines these under different names in each SRP, so use our own\ninline float3 Bakery_SafeNormalize(float3 inVec)\n{\n    float dp3 = max(0.001f, dot(inVec, inVec));\n    return inVec * rsqrt(dp3);\n}\n\n#if _URP || _HDRP\n\nfloat SmoothnessToPerceptualRoughness(float smoothness)\n{\n    return (1 - smoothness);\n}\n#endif\n\n#if !_STANDARD\nhalf4 unity_Lightmap_HDR;\ninline half3 DecodeLightmap( half4 color )\n{\n    return DecodeLightmap( color, unity_Lightmap_HDR );\n}\n\n#define UNITY_INV_PI        0.31830988618f\ninline float GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return UNITY_INV_PI * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n    void BakeryVertexLMDirection(inout float3 diffuseColor, inout float3 specularColor, float3 lightDirection, float3 vertexNormalWorld, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 dominantDir = Bakery_SafeNormalize(lightDirection);\n        half halfLambert = dot(normalWorld, dominantDir) * 0.5 + 0.5;\n        half flatNormalHalfLambert = dot(vertexNormalWorld, dominantDir) * 0.5 + 0.5;\n\n        #ifdef BAKERY_LMSPEC\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = spec * diffuseColor;\n        #endif\n\n        diffuseColor *= halfLambert / max(1e-4h, flatNormalHalfLambert);\n    }\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXSH\n    void BakeryVertexLMSH(inout float3 diffuseColor, inout float3 specularColor, float3 shL1x, float3 shL1y, float3 shL1z, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 L0 = diffuseColor;\n        float3 nL1x = shL1x;\n        float3 nL1y = shL1y;\n        float3 nL1z = shL1z;\n        float3 L1x = nL1x * L0 * 2;\n        float3 L1y = nL1y * L0 * 2;\n        float3 L1z = nL1z * L0 * 2;\n\n        float3 sh;\n    #if BAKERY_SHNONLINEAR\n        //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n        //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n        //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n        float lumaL0 = dot(L0, 1);\n        float lumaL1x = dot(L1x, 1);\n        float lumaL1y = dot(L1y, 1);\n        float lumaL1z = dot(L1z, 1);\n        float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n        float regularLumaSH = dot(sh, 1);\n        //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n        sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    #else\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    #endif\n\n        diffuseColor = max(sh, 0.0);\n\n        #ifdef BAKERY_LMSPEC\n            float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n            float focus = saturate(length(dominantDir));\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = max(spec * sh, 0.0);\n        #endif\n    }\n#endif\n\n\n\n#ifdef BAKERY_BICUBIC\nfloat BakeryBicubic_w0(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-a + 3.0f) - 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w1(float a)\n{\n    return (1.0f/6.0f)*(a*a*(3.0f*a - 6.0f) + 4.0f);\n}\n\nfloat BakeryBicubic_w2(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-3.0f*a + 3.0f) + 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w3(float a)\n{\n    return (1.0f/6.0f)*(a*a*a);\n}\n\nfloat BakeryBicubic_g0(float a)\n{\n    return BakeryBicubic_w0(a) + BakeryBicubic_w1(a);\n}\n\nfloat BakeryBicubic_g1(float a)\n{\n    return BakeryBicubic_w2(a) + BakeryBicubic_w3(a);\n}\n\nfloat BakeryBicubic_h0(float a)\n{\n    return -1.0f + BakeryBicubic_w1(a) / (BakeryBicubic_w0(a) + BakeryBicubic_w1(a)) + 0.5f;\n}\n\nfloat BakeryBicubic_h1(float a)\n{\n    return 1.0f + BakeryBicubic_w3(a) / (BakeryBicubic_w2(a) + BakeryBicubic_w3(a)) + 0.5f;\n}\n#endif\n\n\n#if defined(_LIGHTMAPMODE_RNM) || defined(_LIGHTMAPMODE_SH)\nTexture2D _RNM0, _RNM1, _RNM2;\n#endif\n\n#ifdef BAKERY_VOLUME\nTexture3D _Volume0, _Volume1, _Volume2, _VolumeMask;\nSamplerState sampler_Volume0;\n#endif\n\n#if defined(BAKERY_BICUBIC) && defined(LIGHTMAP_ON) && defined(SHADER_API_D3D11)\n    // Bicubic\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\tfloat width, height;\n\t\ttex.GetDimensions(width, height);\n\t\tfloat texelSize = 1.0f / width;\n\n        float x = uv.x * width;\n        float y = uv.y * width;\n\n        x -= 0.5f;\n        y -= 0.5f;\n\n        float px = floor(x);\n        float py = floor(y);\n\n        float fx = x - px;\n        float fy = y - py;\n\n        float g0x = BakeryBicubic_g0(fx);\n        float g1x = BakeryBicubic_g1(fx);\n        float h0x = BakeryBicubic_h0(fx);\n        float h1x = BakeryBicubic_h1(fx);\n        float h0y = BakeryBicubic_h0(fy);\n        float h1y = BakeryBicubic_h1(fy);\n\n        return     BakeryBicubic_g0(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h0y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h0y) * texelSize))) +\n\n                   BakeryBicubic_g1(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h1y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h1y) * texelSize)));\n    }\n#else\n    // Bilinear\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\t#ifdef LIGHTMAP_ON\n\t\t\treturn tex.Sample(samplerunity_Lightmap, uv);\n\t\t#else\n\t\t\treturn float4(1,0,0,1);\n\t\t#endif\n    }\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\n#ifdef BAKERY_LMSPEC\nfloat BakeryDirectionalLightmapSpecular(float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 dominantDir = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap, lmUV).xyz * 2 - 1;\n    half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n    half nh = saturate(dot(normalWorld, halfDir));\n    half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n    half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n    half spec = GGXTerm(nh, roughness);\n    return spec;\n}\n#endif\n#endif\n\n\n\n#ifdef _LIGHTMAPMODE_RNM\nvoid BakeryRNM(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalMap, float smoothness, float3 viewDirT)\n{\n    const float3 rnmBasis0 = float3(0.816496580927726f, 0, 0.5773502691896258f);\n    const float3 rnmBasis1 = float3(-0.4082482904638631f, 0.7071067811865475f, 0.5773502691896258f);\n    const float3 rnmBasis2 = float3(-0.4082482904638631f, -0.7071067811865475f, 0.5773502691896258f);\n\n    float3 rnm0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 rnm1 = DecodeLightmap(BakeryTex2D(_RNM1, lmUV));\n    float3 rnm2 = DecodeLightmap(BakeryTex2D(_RNM2, lmUV));\n\n    #ifdef BAKERY_SSBUMP\n        diffuseColor = normalMap.x * rnm0\n                     + normalMap.z * rnm1\n                     + normalMap.y * rnm2;\n         diffuseColor *= 2;\n    #else\n        diffuseColor = saturate(dot(rnmBasis0, normalMap)) * rnm0\n                     + saturate(dot(rnmBasis1, normalMap)) * rnm1\n                     + saturate(dot(rnmBasis2, normalMap)) * rnm2;\n    #endif\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDirT = rnmBasis0 * dot(rnm0, lumaConv) +\n                              rnmBasis1 * dot(rnm1, lumaConv) +\n                              rnmBasis2 * dot(rnm2, lumaConv);\n\n        float3 dominantDirTN = normalize(dominantDirT);\n        float3 specColor = saturate(dot(rnmBasis0, dominantDirTN)) * rnm0 +\n                           saturate(dot(rnmBasis1, dominantDirTN)) * rnm1 +\n                           saturate(dot(rnmBasis2, dominantDirTN)) * rnm2;\n\n        half3 halfDir = Bakery_SafeNormalize(dominantDirTN - viewDirT);\n        half nh = saturate(dot(normalMap, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n        specularColor = spec * specColor;\n    #endif\n}\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\ninline half3 Unity_DecodeDirectionalLightmap(half3 color, half4 dirTex, half3 normalWorld)\n{\n    // In directional (non-specular) mode Enlighten bakes dominant light direction\n    // in a way, that using it for half Lambert and then dividing by a \"rebalancing coefficient\"\n    // gives a result close to plain diffuse response lightmaps, but normalmapped.\n\n    // Note that dir is not unit length on purpose. Its length is \"directionality\", like\n    // for the directional specular lightmaps.\n\n    half halfLambert = dot(normalWorld, dirTex.xyz - 0.5) + 0.5;\n\n    return color * halfLambert / max(1e-4h, dirTex.w);\n}\n#endif\n\n#ifdef _LIGHTMAPMODE_SH\nvoid BakerySH(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 L0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 nL1x = BakeryTex2D(_RNM0, lmUV) * 2 - 1;\n    float3 nL1y = BakeryTex2D(_RNM1, lmUV) * 2 - 1;\n    float3 nL1z = BakeryTex2D(_RNM2, lmUV) * 2 - 1;\n    float3 L1x = nL1x * L0 * 2;\n    float3 L1y = nL1y * L0 * 2;\n    float3 L1z = nL1z * L0 * 2;\n\n    float3 sh;\n#if BAKERY_SHNONLINEAR\n    float lumaL0 = dot(L0, 1);\n    float lumaL1x = dot(L1x, 1);\n    float lumaL1y = dot(L1y, 1);\n    float lumaL1z = dot(L1z, 1);\n    float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    float regularLumaSH = dot(sh, 1);\n    //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n    sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n    //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n    //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n#else\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n#endif\n\n    diffuseColor = max(sh, 0.0);\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n        float focus = saturate(length(dominantDir));\n        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n        half nh = saturate(dot(normalWorld, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n\n        sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n\n        specularColor = max(spec * sh, 0.0);\n    #endif\n}\n#endif\n\n#endif // include guards\n\n\n    void Ext_ModifyVertex15 (inout VertexData v, inout ExtraV2F e)\n    {\n        #if _USEBAKERY\n\t\t    #if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\t\t\t    // Unpack from RGBM\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.a * 8.0f;\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.rgb;\n\n\t\t\t    #ifdef BAKERY_VERTEXLMMASK\n\t\t\t\t    e.extraV2F4.xyzw = unpack4NFloats(v.texcoord1);\n\t\t\t    #endif\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXSH\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n                e.extraV2F6.xyz = unpack3NFloats(v.texcoord3.x) * 2 - 1;\n                e.extraV2F7.xyz = unpack3NFloats(v.texcoord3.y) * 2 - 1;\n            #endif\n       #endif\n    }\n\n#if _HDRP || _URP\n    half3 SHEvalLinearL0L1 (half4 normal)\n    {\n        half3 x;\n\n        // Linear (L1) + constant (L0) polynomial terms\n        x.r = dot(unity_SHAr,normal);\n        x.g = dot(unity_SHAg,normal);\n        x.b = dot(unity_SHAb,normal);\n\n        return x;\n    }\n\n    // normal should be normalized, w=1.0\n    half3 SHEvalLinearL2 (half4 normal)\n    {\n        half3 x1, x2;\n        // 4 of the quadratic (L2) polynomials\n        half4 vB = normal.xyzz * normal.yzzx;\n        x1.r = dot(unity_SHBr,vB);\n        x1.g = dot(unity_SHBg,vB);\n        x1.b = dot(unity_SHBb,vB);\n\n        // Final (5th) quadratic (L2) polynomial\n        half vC = normal.x*normal.x - normal.y*normal.y;\n        x2 = unity_SHC.rgb * vC;\n\n        return x1 + x2;\n    }\n\n    half3 ShadeSH9 (half4 normal)\n    {\n        // Linear + constant polynomial terms\n        half3 res = SHEvalLinearL0L1 (normal);\n\n        // Quadratic polynomials\n        res += SHEvalLinearL2 (normal);\n\n        #ifdef UNITY_COLORSPACE_GAMMA\n            res = LinearToGamma (res);\n        #endif\n\n        return res;\n\n    }\n#endif\n\n\n\n\tvoid DoBakeryStuff(inout float3 indDif, inout float3 indSpec, inout float4 shadowmask, float3 tangentNormal, float smoothness, ShaderData d)\n\t{\n\t\t// Quality!\n\t\tindDif = 1;\n\t\tindSpec = 0;\n\n        #if defined(_PASSFORWARD) || defined(_PASSGBUFFER) // forward pass on URP/Standard/HDRP + built-in deferred\n\n            float3 normalWorld = mul(tangentNormal, d.TBNMatrix);\n\n\t\t\t#ifdef LIGHTMAP_ON\n\n                // Static\n\n\t\t\t\tfloat2 lmUV = d.texcoord1 * unity_LightmapST.xy + unity_LightmapST.zw;\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_STANDARD\n\t\t\t\t\tindDif = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n\n\t\t\t\t\t#ifdef DIRLIGHTMAP_COMBINED\n\t\t\t\t\t\tfloat4 dirMap = BakeryTex2D(unity_LightmapInd, lmUV);\n\t\t\t\t\t\tindDif = Unity_DecodeDirectionalLightmap(indDif, dirMap, normalWorld);\n\n\t\t\t\t\t\t#ifdef BAKERY_LMSPEC\n\t\t\t\t\t\t\tindSpec = BakeryDirectionalLightmapSpecular(lmUV, normalWorld, -d.worldSpaceViewDir, smoothness) * indDif;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\n\t\t\t\t\tindDif = d.vertexColor;\n\n                    #ifdef BAKERY_VERTEXLMMASK\n                        shadowmask = d.extraV2F4;\n                    #endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n\t\t\t\t\t\t// worldSpaceNormal is per-vertex\n\t\t\t\t\t\t// normalWorld is per-pixel\n\t\t\t\t\t\tfloat3 bakedLightDirection = d.extraV2F5;\n\t\t\t\t\t\tBakeryVertexLMDirection(indDif, indSpec, bakedLightDirection, d.worldSpaceNormal, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXSH\n\t\t\t\t\t\tBakeryVertexLMSH(indDif, indSpec, d.extraV2F5, d.extraV2F6, d.extraV2F7, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_RNM\n\t\t\t\t\tBakeryRNM(indDif, indSpec, lmUV, tangentNormal, smoothness, -d.tangentSpaceViewDir);\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_SH\n\t\t\t\t\tBakerySH(indDif, indSpec, lmUV, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t#endif\n\n            #else\n\n                // Dynamic\n\n                #ifdef BAKERY_VOLUME\n\n                    bool isGlobal = dot(abs(_VolumeInvSize),1) == 0;\n                    float3 volViewDir = -d.worldSpaceViewDir;\n                    #ifdef BAKERY_VOLROTATION\n                        float4x4 volMatrix = (isGlobal ? _GlobalVolumeMatrix : _VolumeMatrix);\n                        float3 volInvSize = (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 lpUV = mul(volMatrix, float4(d.worldSpacePosition,1)).xyz * volInvSize + 0.5f;\n                        float3 volNormal = mul((float3x3)volMatrix, normalWorld);\n                        #ifdef BAKERY_LMSPEC\n                            volViewDir = mul((float3x3)volMatrix, volViewDir);\n                        #endif\n                    #else\n                        float3 lpUV = (d.worldSpacePosition - (isGlobal ? _GlobalVolumeMin : _VolumeMin)) * (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 volNormal = normalWorld;\n                    #endif\n\n                    #ifdef BAKERY_COMPRESSED_VOLUME\n                        float4 tex0, tex1, tex2, tex3;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex3 = _Volume3.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz * L0;\n                        L1y = tex2.xyz * L0;\n                        L1z = tex3.xyz * L0;\n                    #else\n                        float4 tex0, tex1, tex2;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV);\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV);\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz;\n                        L1y = tex2.xyz;\n                        L1z = float3(tex0.w, tex1.w, tex2.w);\n                    #endif\n                    indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), volNormal);\n                    indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), volNormal);\n                    indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), volNormal);\n\n                    #ifdef UNITY_COLORSPACE_GAMMA\n                        indDif = pow(indDif, 1.0f / 2.2f);\n                    #endif\n\n                    #ifdef BAKERY_LMSPEC\n                        float3 nL1x = L1x / L0;\n                        float3 nL1y = L1y / L0;\n                        float3 nL1z = L1z / L0;\n                        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n                        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - volViewDir);\n                        half nh = saturate(dot(volNormal, halfDir));\n                        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n                        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n                        half spec = GGXTerm(nh, roughness);\n                        float3 sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n                        indSpec = max(spec * sh, 0.0);\n                    #endif\n\n                    shadowmask = _VolumeMask.Sample(sampler_Volume0, lpUV);\n\n                #else\n\n                    #ifdef BAKERY_SHNONLINEAR\n                        float3 L0 = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);\n                        indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, unity_SHAr.xyz, normalWorld);\n                        indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, unity_SHAg.xyz, normalWorld);\n                        indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, unity_SHAb.xyz, normalWorld);\n                    #else\n                        indDif = ShadeSH9(float4(normalWorld,1));\n                    #endif\n\n                #endif\n\n\t\t\t#endif\n\n        #endif\n\t}\n\n\t// this is the main surface function. Surface is like a surface shader output structure, but\n\t// with our new outputs as well.\n\tvoid Ext_SurfaceFunction15 (inout Surface o, ShaderData d)\n\t{\n        #if _USEBAKERY\n\t\t    float3 indDif;\n\t\t    float3 indSpec;\n            float4 shadowmask = 1;\n\t\t    DoBakeryStuff(indDif, indSpec, shadowmask, o.Normal, o.Smoothness, d);\n\t\t    o.DiffuseGI = indDif;\n\t\t    o.BackDiffuseGI = indDif;\n\t\t    o.SpecularGI = indSpec;\n            o.ShadowMask = shadowmask;\n        #endif\n\t}\n\n\n\n\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                  Ext_SurfaceFunction1(l, d);\n                  Ext_SurfaceFunction2(l, d);\n                  Ext_SurfaceFunction3(l, d);\n                  Ext_SurfaceFunction4(l, d);\n                  Ext_SurfaceFunction5(l, d);\n                  Ext_SurfaceFunction6(l, d);\n                  Ext_SurfaceFunction7(l, d);\n                  Ext_SurfaceFunction8(l, d);\n                  Ext_SurfaceFunction9(l, d);\n\t\t            Ext_SurfaceFunction10(l, d);\n                  Ext_SurfaceFunction11(l, d);\n                  Ext_SurfaceFunction12(l, d);\n                  Ext_SurfaceFunction13(l, d);\n                  Ext_SurfaceFunction14(l, d);\n                  Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraV2F d;\n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                  Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                  Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                  #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                  v2p.extraV2F4 = d.extraV2F4;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                  v2p.extraV2F5 = d.extraV2F5;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F6 = d.extraV2F6;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F7 = d.extraV2F7;\n                  #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                d.extraV2F4 = v2p.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                d.extraV2F5 = v2p.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F6 = v2p.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F7 = v2p.extraV2F7;\n                #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n                Ext_ModifyTessellatedVertex2(v, d);\n                Ext_ModifyTessellatedVertex3(v, d);\n                Ext_ModifyTessellatedVertex4(v, d);\n                Ext_ModifyTessellatedVertex5(v, d);\n                Ext_ModifyTessellatedVertex6(v, d);\n                Ext_ModifyTessellatedVertex7(v, d);\n                Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                v2p.extraV2F4 = d.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                v2p.extraV2F5 = d.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F6 = d.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F7 = d.extraV2F7;\n                #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n            // d.texcoord3 = i.texcoord3;\n             #endif\n\n             d.isFrontFace = facing;\n             #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n             d.vertexColor = i.vertexColor;\n             #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(i.worldPos, 1)).xyz;\n            #endif\n             d.localSpaceNormal = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n             #if LOD_FADE_CROSSFADE\n             d.screenPos = i.screenPos;\n             d.screenUV = (i.screenPos.xy / i.screenPos.w);\n             #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n             #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n             d.extraV2F4 = i.extraV2F4;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n             d.extraV2F5 = i.extraV2F5;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F6 = i.extraV2F6;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F7 = i.extraV2F7;\n             #endif\n\n            return d;\n         }\n         \n\n            \n         #if defined(SHADERPASS_SHADOWCASTER)\n            float3 _LightDirection;\n         #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n            o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n            #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n           // o.texcoord3 = v.texcoord3;\n            #endif\n\n            #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n            o.vertexColor = v.vertexColor;\n            #endif\n           \n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n           o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n\n          #if defined(SHADERPASS_SHADOWCASTER)\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, _LightDirection));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif defined(SHADERPASS_META)\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n\n           #if LOD_FADE_CROSSFADE\n           o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n           #endif\n\n          #if defined(SHADERPASS_FORWARD) || (SHADERPASS == SHADERPASS_GBUFFER)\n              float2 uv1 = v.texcoord1.xy;\n              OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n               o.texcoord1.xy = uv1;\n              OUTPUT_SH(o.worldNormal, o.sh);\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n              half fogFactor = ComputeFogFactor(o.pos.z);\n              o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n             o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n           return o;\n         }\n\n\n            \n\n            // fragment shader\n            half4 Frag (VertexToPixel IN\n               #if NEED_FACING\n                  , bool facing : SV_IsFrontFace\n               #endif\n            ) : SV_Target\n            {\n               UNITY_SETUP_INSTANCE_ID(IN);\n\n               ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                     , facing\n                  #endif\n               );\n\n               Surface l = (Surface)0;\n\n               l.Albedo = half3(0.5, 0.5, 0.5);\n               l.Normal = float3(0,0,1);\n               l.Occlusion = 1;\n               l.Alpha = 1;\n\n               ChainSurfaceFunction(l, d);\n\n               MetaInput metaInput = (MetaInput)0;\n               metaInput.Albedo = l.Albedo;\n               metaInput.Emission = l.Emission;\n\n               return MetaFragment(metaInput);\n\n            }\n\n         ENDHLSL\n\n      }\n\n\n      \n        Pass\n        {\n            Name \"DepthNormals\"\n            Tags\n            {\n               \"LightMode\" = \"DepthNormals\"\n            }\n    \n            // Render State\n            Cull Back\n            Blend One Zero\n            ZTest LEqual\n            ZWrite On\n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n            #pragma multi_compile_fog\n            #pragma multi_compile_instancing\n            #pragma multi_compile _ DOTS_INSTANCING_ON\n        \n            #define SHADERPASS SHADERPASS_DEPTHNORMALSONLY\n            #define _PASSDEPTH 1\n            #define _PASSDEPTHNORMALS 1\n\n\n            \n\n\n   #pragma shader_feature_local_fragment _ _PACKEDFAST\n   #pragma shader_feature_local _ _TRIPLANAR\n   #pragma shader_feature_local_fragment _ _NORMALMAP \n   #pragma shader_feature_local_fragment _ _MASKMAP\n   #pragma shader_feature_local_fragment _ _DETAIL\n   #pragma shader_feature_local_fragment _ _DETAILTRIPLANAR\n   #pragma shader_feature_local_fragment _ _DETAILSTOCHASTIC\n   #pragma shader_feature_local_fragment _ _EMISSION\n   #pragma shader_feature_local_fragment _ _FLATSHADE\n   #pragma shader_feature_local _ _STOCHASTIC\n   #pragma shader_feature_local_fragment _ _PARALLAX //_POM\n   #pragma shader_feature_local_fragment _ _SPECULAR\n   #pragma shader_feature_local _ _NOISEWORLD _NOISELOCAL\n   #pragma shader_feature_local _ _NOISEHQ _NOISETEXTURE _NOISEWORLEY\n   // only for URP/Standard Forward\n   #pragma shader_feature_local_fragment _ _SIMPLELIT\n\n\n   #pragma shader_feature_local_fragment _ _TINTMASK\n\n\n    #pragma shader_feature_local _ _LAYERVERTEXMASK _LAYERTEXTUREMASK\n\n    #define _HAS_WEIGHTTEXTURE_MASK 1\n\n\n   #pragma shader_feature_local _ _USELAYER\n   #pragma shader_feature_local _ _LAYERTRIPLANAR\n   #pragma shader_feature_local _ _LAYERALBEDO\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL\n   #pragma shader_feature_local _ _LAYERMASK\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION\n   #pragma shader_feature_local _ _LAYERNOISE\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC\n   #pragma shader_feature_local _ _LAYERANGLEFILTER\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_1\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_1\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_1\n   #pragma shader_feature_local _ _LAYERMASK_DEF_1\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_1\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_1\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_1\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_1\n\n\n   #pragma shader_feature_local _ _USELAYER_DEF_2\n   #pragma shader_feature_local _ _LAYERTRIPLANAR_DEF_2\n   #pragma shader_feature_local _ _LAYERALBEDO_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYERNORMAL_DEF_2\n   #pragma shader_feature_local _ _LAYERMASK_DEF_2\n   #pragma shader_feature_local_fragment _ _LAYEREMISSION_DEF_2\n   #pragma shader_feature_local _ _LAYERNOISE_DEF_2\n   #pragma shader_feature_local _ _LAYERSTOCHASTIC_DEF_2\n   #pragma shader_feature_local _ _LAYERANGLEFILTER_DEF_2\n\n\n   #pragma shader_feature_local _ _TRAX_ON\n\n\n   #pragma shader_feature_local_fragment _ _WETNESS\n   #pragma shader_feature_local_fragment _ _PUDDLES\n   #pragma shader_feature_local_fragment _ _PUDDLENOISE\n   #pragma shader_feature_local_fragment _ _RAINDROPS\n\n\n   #pragma shader_feature_local _ _SNOW\n   #pragma shader_feature_local _ _SNOWMASKMAP\n   #pragma shader_feature_local _ _SNOWNOISE\n   #pragma shader_feature_local_fragment _SNOWSTOCHASTIC\n\n\n   #pragma shader_feature_local_fragment _ _WIND_ON\n\n\n\n\n   #pragma shader_feature_local_fragment _ _SURFACEGRADIENT _AUTONORMAL\n   #define _WORLDSPACENORMAL 1\n\n\n   #pragma shader_feature_local _ _DEBUG_SAMPLECOUNT\n\n\n\t#pragma shader_feature_local_fragment _ _DISSOLVE\n\n\n   #pragma multi_compile_local  LOD_FADE_CROSSFADE\n\n\n\n#pragma instancing_options procedural:setupVSPro forwardadd\n\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\nstruct IndirectShaderData\n{\n\tfloat4x4 PositionMatrix;\n\tfloat4x4 InversePositionMatrix;\n\tfloat4 ControlData;\n};\n\n#if defined(SHADER_API_GLCORE) || defined(SHADER_API_D3D11) || defined(SHADER_API_GLES3) || defined(SHADER_API_METAL) || defined(SHADER_API_VULKAN) || defined(SHADER_API_PSSL) || defined(SHADER_API_XBOXONE)\n\tuniform StructuredBuffer<IndirectShaderData> VisibleShaderDataBuffer;\n#endif\n\n#endif\n\nfloat VSPRenderingLayerMask;\n\nvoid setupVSPro()\n{\n#ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED\n\n    #if _HDRP\n\t    unity_RenderingLayer.x = VSPRenderingLayerMask;\n    #endif\n\n\t#ifdef unity_ObjectToWorld\n\t#undef unity_ObjectToWorld\n\t#endif\n\n\t#ifdef unity_WorldToObject\n\t#undef unity_WorldToObject\n\t#endif\n\n\tunity_ObjectToWorld = VisibleShaderDataBuffer[unity_InstanceID].PositionMatrix;\n\tunity_WorldToObject = VisibleShaderDataBuffer[unity_InstanceID].InversePositionMatrix;\n#endif\n\n}\n\n\n\t#pragma multi_compile _LIGHTMAPMODE_STANDARD _LIGHTMAPMODE_RNM _LIGHTMAPMODE_SH _LIGHTMAPMODE_VERTEX _LIGHTMAPMODE_VERTEXDIRECTIONAL _LIGHTMAPMODE_VERTEXSH\n\n    #pragma shader_feature USEBAKERY\n    #pragma shader_feature BAKERY_VERTEXLMMASK\n    #pragma shader_feature BAKERY_SHNONLINEAR\n    #pragma shader_feature BAKERY_LMSPEC\n    #pragma shader_feature BAKERY_BICUBIC\n    #pragma shader_feature BAKERY_VOLUME\n    #pragma shader_feature BAKERY_VOLROTATION\n    #pragma shader_feature BAKERY_COMPRESSED_VOLUME\n\n    #if _USEBAKERY\n\t    #define _OVERRIDE_BAKEDGI\n        #if BAKERY_VOLUME || (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)) && defined(BAKERY_VERTEXLMMASK)\n            #define _OVERRIDE_SHADOWMASK\n        #endif\n    #endif\n\n\n\n\n\n\n\n\n   #define _URP 1\n\n   #define _ALPHABLEND_ON 1\n#define _ALPHABLEND_ON 1\n#define _SURFACE_TYPE_TRANSPARENT 1\n#define NEED_FACING 1\n\n            // this has to be here or specular color will be ignored. Not in SG code\n            #if _SIMPLELIT\n               #define _SPECULAR_COLOR\n            #endif\n\n\n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl\"\n\n\n        \n\n               #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCCOORD3;\n          float4 texcoord1 : TEXCCOORD4;\n         // float4 texcoord2 : TEXCCOORD5;\n\n          #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n         // float4 texcoord3 : TEXCCOORD6;\n          #endif\n\n          #if LOD_FADE_CROSSFADE\n          float4 screenPos : TEXCOORD7;\n          #endif\n\n          #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n          half4 vertexColor : COLOR_centroid;\n          #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n         // float4 extraV2F0 : TEXCOORD12;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n         // float4 extraV2F1 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n         // float4 extraV2F2 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n         // float4 extraV2F3 : TEXCOORD15;\n         // #endif\n\n          #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n          float4 extraV2F4 : TEXCOORD16_centroid;\n          #endif\n\n          #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n          float4 extraV2F5 : TEXCOORD17_centroid;\n          #endif\n\n          #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n          float4 extraV2F6 : TEXCOORD18_centroid;\n          #endif\n\n          #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n          float4 extraV2F7 : TEXCOORD19_centroid;\n          #endif\n            \n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD9;\n         #endif\n            float4 fogFactorAndVertexLight : TEXCOORD10;\n            float4 shadowCoord : TEXCOORD11;\n         #if UNITY_ANY_INSTANCING_ENABLED\n            uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n            uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n            uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n            FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n      };\n\n\n         \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n   half4 weightTextureMask;\n   \n\n\n   float traxBuffer;\n\n\n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // would love to strip these, but they are used in certain\n               // combinations of the lighting system, and may be used\n               // by the user as well, so no easy way to strip them.\n\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 texcoord3 : TEXCOORD3;\n                #endif\n\n                #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n                float4 vertexColor : COLOR_centroid;\n                #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                float4 extraV2F4 : TEXCOORD9_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                float4 extraV2F5 : TEXCOORD10_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F6 : TEXCOORD11_centroid;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                float4 extraV2F7 : TEXCOORD12_centroid;\n                #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n               #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n               #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n               #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n               #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()     unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n               #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V   unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n               #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V    mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n               #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n               #endif\n               #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n         CBUFFER_START(UnityPerMaterial)\n\n            \n\n\n   half4 _Tint;\n   half _UVSource;\n   half _TriplanarContrast;\n   half _AlbedoContrast;\n   half _AlbedoBrightness;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half3 _EmissionColor;\n   float _DetailUVSource;\n   half _StochasticScale;\n   half _DetailStochasticScale;\n   half _Smoothness;\n   half _Metallic;\n   half2 _SmoothnessRemap;\n   half2 _AORemap;\n   half2 _MetallicRemap;\n   half2 _HeightRemap;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n   half _AlphaThreshold;\n   half _Cutoff; // for Unity's light mapper\n   half _TriplanarSpace;\n   half _DetailTriplanarSpace;\n   half _DetailTriplanarContrast;\n   half _MicroShadowStrength;\n   half3 _FuzzyShadingColor;\n   half _FuzzyShadingOn;\n   half3 _FuzzyShadingParams;\n\n   //int _POMMaxSamples;\n   //float _POMMin;\n   //float _POMFade;\n#if _FLATSHADE\n   half _FlatShadingBlend;\n#endif\n\n   half _StochasticContrast;\n   half _DetailStochasticContrast;\n\n#if _PARALLAX || _POM\n   half _ParallaxHeight;\n#endif\n\n\n\n\tfloat4 _TintMask_ST;\n\thalf3 _RColor;\n\thalf3 _GColor;\n\thalf3 _BColor;\n\thalf3 _AColor;\n\n\n\thalf _LayerTextureMaskUVMode;\n    float4 _LayerTextureMask_ST;\n\n\n   //#if _USELAYER\n       float4 _LayerAlbedoMap_ST;\n       half3 _LayerTint;\n       half _LayerBlendMode;\n       float _LayerUVSource;\n       half _LayerAlbedoBrightness;\n       half _LayerAlbedoContrast;\n       half _LayerHeightContrast;\n       half _LayerStrength;\n       half _LayerAlbedoStrength;\n       half _LayerNormalStrength;\n       half _LayerSmoothnessStrength;\n       half _LayerSmoothness;\n       half _LayerMetallic;\n       half _LayerStochasticScale;\n       half2 _LayerSmoothnessRemap;\n       half2 _LayerAORemap;\n       half2 _LayerMetallicRemap;\n       half2 _LayerHeightRemap;\n       float4 _LayerWeightOverDistance;\n       half _LayerMicroShadowStrength;\n       //#if _LAYERNOISE\n           float _LayerNoiseFrequency;\n           float _LayerNoiseAmplitude;\n           float _LayerNoiseOffset;\n           float _LayerNoiseCenter;\n           half3 _LayerBlendTint;\n       //#endif\n       //#if _LAYERANGLEFILTER\n           half _LayerFalloff;\n           half _LayerAngleMin;\n           half _LayerHeight;\n           half _LayerInvertHeight;\n           half _LayerVertexNormalBlend;\n       //#endif\n       half _LayerTriplanarSpace;\n       half _LayerTriplanarContrast;\n       half _LayerBlendContrast;\n       half3 _LayerEmissionColor;\n       half _LayerStochasticContrast;\n       half _LayerTessStrength;\n       half3 _LayerFuzzyShadingColor;\n       half _LayerFuzzyShadingOn;\n       half3 _LayerFuzzyShadingParams;\n   //#endif\n\n\n   //#if _USELAYER_DEF_1\n       float4 _LayerAlbedoMap_Ext_1_ST;\n       half3 _LayerTint_Ext_1;\n       half _LayerBlendMode_Ext_1;\n       float _LayerUVSource_Ext_1;\n       half _LayerAlbedoBrightness_Ext_1;\n       half _LayerAlbedoContrast_Ext_1;\n       half _LayerHeightContrast_Ext_1;\n       half _LayerStrength_Ext_1;\n       half _LayerAlbedoStrength_Ext_1;\n       half _LayerNormalStrength_Ext_1;\n       half _LayerSmoothnessStrength_Ext_1;\n       half _LayerSmoothness_Ext_1;\n       half _LayerMetallic_Ext_1;\n       half _LayerStochasticScale_Ext_1;\n       half2 _LayerSmoothnessRemap_Ext_1;\n       half2 _LayerAORemap_Ext_1;\n       half2 _LayerMetallicRemap_Ext_1;\n       half2 _LayerHeightRemap_Ext_1;\n       float4 _LayerWeightOverDistance_Ext_1;\n       half _LayerMicroShadowStrength_Ext_1;\n       //#if _LAYERNOISE_DEF_1\n           float _LayerNoiseFrequency_Ext_1;\n           float _LayerNoiseAmplitude_Ext_1;\n           float _LayerNoiseOffset_Ext_1;\n           float _LayerNoiseCenter_Ext_1;\n           half3 _LayerBlendTint_Ext_1;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_1\n           half _LayerFalloff_Ext_1;\n           half _LayerAngleMin_Ext_1;\n           half _LayerHeight_Ext_1;\n           half _LayerInvertHeight_Ext_1;\n           half _LayerVertexNormalBlend_Ext_1;\n       //#endif\n       half _LayerTriplanarSpace_Ext_1;\n       half _LayerTriplanarContrast_Ext_1;\n       half _LayerBlendContrast_Ext_1;\n       half3 _LayerEmissionColor_Ext_1;\n       half _LayerStochasticContrast_Ext_1;\n       half _LayerTessStrength_Ext_1;\n       half3 _LayerFuzzyShadingColor_Ext_1;\n       half _LayerFuzzyShadingOn_Ext_1;\n       half3 _LayerFuzzyShadingParams_Ext_1;\n   //#endif\n\n\n   //#if _USELAYER_DEF_2\n       float4 _LayerAlbedoMap_Ext_2_ST;\n       half3 _LayerTint_Ext_2;\n       half _LayerBlendMode_Ext_2;\n       float _LayerUVSource_Ext_2;\n       half _LayerAlbedoBrightness_Ext_2;\n       half _LayerAlbedoContrast_Ext_2;\n       half _LayerHeightContrast_Ext_2;\n       half _LayerStrength_Ext_2;\n       half _LayerAlbedoStrength_Ext_2;\n       half _LayerNormalStrength_Ext_2;\n       half _LayerSmoothnessStrength_Ext_2;\n       half _LayerSmoothness_Ext_2;\n       half _LayerMetallic_Ext_2;\n       half _LayerStochasticScale_Ext_2;\n       half2 _LayerSmoothnessRemap_Ext_2;\n       half2 _LayerAORemap_Ext_2;\n       half2 _LayerMetallicRemap_Ext_2;\n       half2 _LayerHeightRemap_Ext_2;\n       float4 _LayerWeightOverDistance_Ext_2;\n       half _LayerMicroShadowStrength_Ext_2;\n       //#if _LAYERNOISE_DEF_2\n           float _LayerNoiseFrequency_Ext_2;\n           float _LayerNoiseAmplitude_Ext_2;\n           float _LayerNoiseOffset_Ext_2;\n           float _LayerNoiseCenter_Ext_2;\n           half3 _LayerBlendTint_Ext_2;\n       //#endif\n       //#if _LAYERANGLEFILTER_DEF_2\n           half _LayerFalloff_Ext_2;\n           half _LayerAngleMin_Ext_2;\n           half _LayerHeight_Ext_2;\n           half _LayerInvertHeight_Ext_2;\n           half _LayerVertexNormalBlend_Ext_2;\n       //#endif\n       half _LayerTriplanarSpace_Ext_2;\n       half _LayerTriplanarContrast_Ext_2;\n       half _LayerBlendContrast_Ext_2;\n       half3 _LayerEmissionColor_Ext_2;\n       half _LayerStochasticContrast_Ext_2;\n       half _LayerTessStrength_Ext_2;\n       half3 _LayerFuzzyShadingColor_Ext_2;\n       half _LayerFuzzyShadingOn_Ext_2;\n       half3 _LayerFuzzyShadingParams_Ext_2;\n   //#endif\n\n\n    half _TraxDisplacementDepth;\n    half _TraxDisplacementStrength;\n    half _TraxMipBias;\n    half _TraxNormalStrength;\n    float4 _TraxAlbedo_ST;\n    half _TraxInterpContrast;\n    half _TraxHeightContrast;\n    half3 _TraxTint;\n\n\n\n    half _Porosity;\n    int _WetnessMode;\n    int _PuddleMode;\n\n    half  _PuddleAmount;\n    half  _PuddleFalloff;\n    half4 _PuddleColor;\n    half _PuddleNoiseFrequency;\n    half _PuddleNoiseAmplitude;\n    half _PuddleNoiseOffset;\n    half _PuddleNoiseCenter;\n    half _PuddleAngleMin;\n\n    half _WetnessAmount;\n\thalf _WetnessMin;\n    half _WetnessMax;\n    half _WetnessFalloff;\n\thalf _WetnessAngleMin;\n    float _WetnessShoreline;\n\n    int _RainMode;\n    half3 _RainIntensityScale;\n\n\n\n\n    float4 _SnowAlbedo_ST;\n    half3 _SnowTint;\n    half _SnowAmount;\n    half _SnowAngle;\n    half _SnowContrast;\n    half _SnowVertexHeight;\n    half _SnowMode;\n    half3 _SnowWorldFade; // z is on/off\n    float4 _SnowTraxAlbedo_ST;\n    half3 _SnowTraxTint;\n\n    half _SnowNoiseFreq; \n    half _SnowNoiseAmp;\n    half _SnowNoiseOffset;\n    half _SnowStochasticContrast;\n    half _SnowStochasticScale;\n\n\n    half     _WindParticulateSpace;\n    half     _WindParticulateRotation;\n    half      _WindParticulateSpeed;\n    float4     _WindParticulate_ST;\n    half      _WindParticulatePower;\n    half4    _WindParticulateColor;\n    half4    _WindParticulateWorldHeightMask;\n    half4    _WindParticulateAngleMask;\n    half      _WindParticulateOcclusionStrength;\n    half      _WindParticulateStrength;\n    half4    _WindParticulateEmissive;\n    half     _WindParticulateTextureHeight;\n\n\n   float _DoubleSidedNormalMode;\n\n\n\thalf _AutoNormalStrength;\n\n\n\tint _DebugSampleCountThreshold;\n\n\n\thalf _DissolveAmount;\n\thalf _DissolveEmissiveStr;\n\thalf _DissolveEdgeContrast;\n\thalf _DissolveColoration;\n\tfloat4 _DissolveTexture_ST;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n         CBUFFER_END\n\n         \n\n         \n\n         #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\n#ifndef __STACKABLEFUNCLIBRARY_INCLUDES__\n#define __STACKABLEFUNCLIBRARY_INCLUDES__\n\n   #if _DEBUG_SAMPLECOUNT\n      int _sampleCount;\n      #define COUNTSAMPLE { _sampleCount++; }\n   #else\n      #define COUNTSAMPLE\n   #endif\n\n   TEXTURE2D(_NoiseTex);\n   SAMPLER(sampler_NoiseTex);\n\n\n\n   half3 AdjustContrast(half3 color, half contrast)\n   {\n       half3 comp = 0.5;\n   #if !UNITY_COLORSPACE_GAMMA\n       comp = 0.22;\n   #endif\n       color = saturate(lerp(comp, color, contrast));\n       return color;\n   }\n\n   float2 DoParallaxOffset( half h, half height, half3 viewDir)\n   {\n      h = h * height - height/2.0;\n      float3 v = normalize(viewDir);\n      v.z += 0.42;\n      return h * (v.xy / v.z);\n   }\n\n\n\n   #define SAMPLEBARY SampleTexBary\n\n   struct SampleConfig\n   {\n      float2 uv0;\n      float2 uv1;\n      float2 uv2;\n      float2 dx0;\n      float2 dy0;\n      float2 dx1;\n      float2 dy1;\n      float2 dx2;\n      float2 dy2;\n      float3 weights;\n      float3 origWeights;\n   };\n\n   struct Config\n   {\n      float2 origUV; // unscaled uv\n      float2 origScale;\n      float2 uv;        // no stocastic or triplanar\n      float2 dx;\n      float2 dy;\n      SampleConfig uvT; // just stochastic, or just triplanar\n      SampleConfig uvX; // stochastic and triplanar\n      SampleConfig uvY;\n      SampleConfig uvZ;\n\n      \n      float3 absVertNormal;\n      half3 axisSign;\n      float3 normal;\n   };\n\n\n    float2 Hash2D( float2 x )\n    {\n        float2 k = float2( 0.3183099, 0.3678794 );\n        x = x*k + k.yx;\n        return -1.0 + 2.0*frac( 16.0 * k*frac( x.x*x.y*(x.x+x.y)) );\n    }\n\n    float Noise2D(float2 p )\n    {\n        float2 i = floor( p );\n        float2 f = frac( p );\n         \n        float2 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( dot( Hash2D( i + float2(0.0,0.0) ), f - float2(0.0,0.0) ), \n                        dot( Hash2D( i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),\n                    lerp( dot( Hash2D( i + float2(0.0,1.0) ), f - float2(0.0,1.0) ), \n                        dot( Hash2D( i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);\n    }\n      \n\n    float2 WorleyHash2D(float2 p)\n    {\n \t    return frac(cos(mul(p, float2x2(-64.2,71.3,81.4,-29.8)))*8321.3); \n    }\n    float WorleyNoise2D(float2 p)\n    {\n        float dist = 1;\n        float2 i = floor(p);\n        float2 f = frac(p);\n    \n        for(int x = -1;x<=1;x++)\n        {\n            for(int y = -1;y<=1;y++)\n            {\n                float d = distance(WorleyHash2D(i+float2(x,y))+float2(x,y),f);\n                dist = min(dist,d);\n            }\n        }\n        return dist;\n\t\n    }\n\n#ifndef PI\n    #define PI 3.14159265359\n#endif\n\n    float GetIntegerNoise(float2 p)\n    {\n        p  = 53.7 * frac( (p*0.3183099) + float2(0.71,0.113));\n        return frac( p.x*p.y*(p.x+p.y) );\n    }\n\n    float WorleyHash3D(float f)\n    {\n        return frac(sin(f)*43758.5453);\n    }\n\n    float WorleyHash31(float3 v)\n    {\n        return WorleyHash3D(dot(v, float3(253.14, 453.74, 183.3)));\n    }\n\n    float3 WorleyRandom3D( float3 p )\n    {\n        return frac(sin(float3(dot(p,float3(127.1,311.7,217.3)),dot(p,float3(269.5,183.3,431.1)), dot(p,float3(365.6,749.9,323.7))))*437158.5453);\n    }\n\n    float WorleyNoise3D(float3 uvw)\n    {\n        float noise = 0.0;\n    \n        float3 p = floor(uvw);\n        float3 f = frac(uvw);\n    \n        float4 res = 1;\n        for(int x = -1; x <=1; ++x)\n        {\n            for(int y = -1; y <=1; ++y)\n            {\n                for(int z = -1; z <=1; ++z)\n                {\n                    float3 gp = p + float3(x, y, z);\n\n                    float3 v = WorleyRandom3D(gp);\n\n\t\t\t\t    float3 diff = gp + v - uvw;\n                \n                    float d = length(diff);\n                \n                    if(d < res.x)\n                    {\n                        res.xyz = float3(d, res.x, res.y);\n                    }\n                    else if(d < res.y)\n                    {\n                        res.xyz = float3(res.x, d, res.y);\n                    }\n                    else if(d < res.z)\n                    {\n                        res.z = d;\n                    }\n                \n                    res.w = WorleyHash31(gp);\n                }\n            }\n        }\n\n        return res.x;\n    }\n    \n      \n    float3 Hash3D( float3 p )\n    {\n        p = float3( dot(p,float3(127.1,311.7, 74.7)),\n                dot(p,float3(269.5,183.3,246.1)),\n                dot(p,float3(113.5,271.9,124.6)));\n\n        return -1.0 + 2.0*frac(sin(p)*437.5453123);\n    }\n\n    float Noise3D( float3 p )\n    {\n        float3 i = floor( p );\n        float3 f = frac( p );\n         \n        float3 u = f*f*(3.0-2.0*f);\n\n        return lerp( lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,0.0) ), f - float3(0.0,0.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,0.0) ), f - float3(1.0,0.0,0.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,0.0) ), f - float3(0.0,1.0,0.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,0.0) ), f - float3(1.0,1.0,0.0) ), u.x), u.y),\n                    lerp( lerp( dot( Hash3D( i + float3(0.0,0.0,1.0) ), f - float3(0.0,0.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,0.0,1.0) ), f - float3(1.0,0.0,1.0) ), u.x),\n                        lerp( dot( Hash3D( i + float3(0.0,1.0,1.0) ), f - float3(0.0,1.0,1.0) ), \n                            dot( Hash3D( i + float3(1.0,1.0,1.0) ), f - float3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n    }\n\n    \n    float FBM2D(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           return SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n\n    }\n      \n    float FBM3D(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           COUNTSAMPLE\n           half A = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.zy).g;\n           half B = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33).g;\n           half C = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoise(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3D(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3D(d.localSpacePosition * frequency+ offset, d.localSpaceNormal);\n        #else\n           return FBM2D(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n    \n    #if _SURFACEGRADIENT  \n\n    #define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)\n\n      \n      \n    half3 SurfaceGradientFromTBN(ShaderData d, half2 deriv)\n    {\n        return deriv.x * d.TBNMatrix[0] + deriv.y * d.TBNMatrix[1];\n    }\n\n    half2 TspaceNormalToDerivative(half3 vM)\n    {\n        const half scale = 1.0/128.0;\n        const half3 vMa = abs(vM);\n        const half z_ma = max(vMa.z, scale*max(vMa.x, vMa.y));\n\n        return -half2(vM.x, vM.y)/z_ma;\n    }\n\n    half3 SurfgradFromVolumeGradient(ShaderData d, half3 grad)\n    {\n        return grad - dot(d.worldSpaceNormal, grad) * d.worldSpaceNormal;\n    }\n\n    half3 SurfgradFromTriplanarProjection(ShaderData d, half3 pN, half3 xN, half3 yN, half3 zN)\n    {\n        const half w0 = pN.x;\n        const half w1 = pN.y;\n        const half w2 = pN.z;\n\n        half2 xD = TspaceNormalToDerivative(xN);\n        half2 yD = TspaceNormalToDerivative(yN);\n        half2 zD = TspaceNormalToDerivative(zN);\n\n        half3 volumeGrad = half3(w2 * zD.x + w1 * yD.y, w2 * zD.y + w0 * xD.y, w0 * xD.x + w1 * yD.x);\n\n        return SurfgradFromVolumeGradient(d, volumeGrad);\n    }\n\n    half3 ConvertNormalToGradient(ShaderData d, half3 normal)\n    {\n        half2 deriv = TspaceNormalToDerivative(normal);\n\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n    half3 ConvertNormal2ToGradient(ShaderData d, half2 packedNormal)\n    {\n        half2 tNormal = packedNormal;\n        half rcpZ = rsqrt(max(1 - dot(tNormal.x, tNormal.x) - dot(tNormal.y, tNormal.y), dot(HALF_EPS, HALF_EPS))); // Clamp to avoid INF\n        half2 deriv = tNormal * -rcpZ;\n        return SurfaceGradientFromTBN(d, deriv);\n    }\n\n\n    half3 ResolveNormalFromSurfaceGradient(ShaderData d, half3 gradient)\n    {\n        return normalize(d.worldSpaceNormal - gradient);\n    }\n\n    #endif // _SURFACEGRADIENT\n\n\n    // normals are in surface gradient or world space depending on settings, and can also be generated by height\n    half3 GetWorldSpaceNormal(ShaderData d, half3 normal, half pheight)\n    {\n       #if _SURFACEGRADIENT\n          return ResolveNormalFromSurfaceGradient(d, normal);\n       #elif _AUTONORMAL\n          float3 dx = ddx(d.worldSpacePosition);\n          float3 dy = ddy(d.worldSpacePosition);\n          float3 crossX = cross(float3(0,1,0), dx);\n          float3 crossY = cross(float3(0,1,0), dy);\n          float3 dt = abs(dot(crossY, dx));\n          float height = _AutoNormalStrength * 0.5 * pheight;\n          float3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n          n.y *= -1.0;\n          return TangentToWorldSpace(d, normalize((dt * float3(0,1,0)) - n).xzy);\n       #else\n          return TangentToWorldSpace(d, normal);\n          \n       #endif\n       \n    }\n\n   void WaterBRDF (inout half3 albedo, inout half smoothness, half metallic, half wetFactor, half surfPorosity) \n   {\n      half porosity = saturate((( (1 - smoothness) - 0.5)) / max(surfPorosity, 0.001));\n      half factor = lerp(1, 0.2, (1 - metallic) * porosity);\n      albedo *= lerp(1.0, factor, wetFactor);\n      smoothness = lerp(smoothness, 0.92f, wetFactor);\n   }\n\n   void OffsetUV(inout Config c, float2 offset)\n   {\n       c.uv += offset;\n       c.uvT.uv0 += offset;\n       c.uvT.uv1 += offset;\n       c.uvT.uv2 += offset;\n       c.uvX.uv0 += offset;\n       c.uvX.uv1 += offset;\n       c.uvX.uv2 += offset;\n       c.uvY.uv0 += offset;\n       c.uvY.uv1 += offset;\n       c.uvY.uv2 += offset;\n       c.uvZ.uv0 += offset;\n       c.uvZ.uv1 += offset;\n       c.uvZ.uv2 += offset;\n   }\n\n\n    void TriangleGrid(float2 uv, float scale,\n       out float w1, out float w2, out float w3,\n       out int2 vertex1, out int2 vertex2, out int2 vertex3)\n    {\n       // Scaling of the input\n       uv *= 3.464 * scale; // 2 * sqrt(3)\n\n       // Skew input space into simplex triangle grid\n       const float2x2 gridToSkewedGrid = float2x2(1.0, 0.0, -0.57735027, 1.15470054);\n       float2 skewedCoord = mul(gridToSkewedGrid, uv);\n\n       // Compute local triangle vertex IDs and local barycentric coordinates\n       int2 baseId = int2(floor(skewedCoord));\n       float3 temp = float3(frac(skewedCoord), 0);\n       temp.z = 1.0 - temp.x - temp.y;\n       if (temp.z > 0.0)\n       {\n          w1 = temp.z;\n          w2 = temp.y;\n          w3 = temp.x;\n          vertex1 = baseId;\n          vertex2 = baseId + int2(0, 1);\n          vertex3 = baseId + int2(1, 0);\n       }\n       else\n       {\n          w1 = -temp.z;\n          w2 = 1.0 - temp.y;\n          w3 = 1.0 - temp.x;\n          vertex1 = baseId + int2(1, 1);\n          vertex2 = baseId + int2(1, 0);\n          vertex3 = baseId + int2(0, 1);\n       }\n    }\n\n    // Fast random hash function\n    float2 SimpleHash2(float2 p)\n    {\n       return frac(sin(mul(float2x2(127.1, 311.7, 269.5, 183.3), p)) * 43758.5453);\n    }\n\n\n    half3 BaryWeightBlend(half3 iWeights, half tex0, half tex1, half tex2, half contrast)\n    {\n        // compute weight with height map\n        const half epsilon = 1.0f / 1024.0f;\n        half3 weights = half3(iWeights.x * (tex0 + epsilon), \n                                 iWeights.y * (tex1 + epsilon),\n                                 iWeights.z * (tex2 + epsilon));\n\n        // Contrast weights\n        half maxWeight = max(weights.x, max(weights.y, weights.z));\n        half transition = contrast * maxWeight;\n        half threshold = maxWeight - transition;\n        half scale = 1.0f / transition;\n        weights = saturate((weights - threshold) * scale);\n        // Normalize weights.\n        half weightScale = 1.0f / (weights.x + weights.y + weights.z);\n        weights *= weightScale;\n        return weights;\n    }\n\n\n    half3 PackedUnpackScaleNormal(half4 packedNormal, float scale)\n   {\n       #if _PACKEDFAST\n          half3 normal;\n          normal.xy = (packedNormal.ag * 2 - 1) * scale;\n          normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n          return normal;  \n       #endif\n       return UnpackScaleNormal(packedNormal, scale);\n   }\n\n    void InitStochasticDxDy(inout SampleConfig c, Config cfg)\n    {\n      c.dx0 = ddx(cfg.origUV) * cfg.origScale;\n      c.dy0 = ddy(cfg.origUV) * cfg.origScale;\n      c.dx1 = c.dx0; c.dx1 = c.dx0;\n      c.dx2 = c.dy0; c.dy2 = c.dy0;\n    }\n\n    void PrepareStochasticUVs(float scale, float2 uv, out SampleConfig c)\n    {\n       // Get triangle info\n       ZERO_INITIALIZE(SampleConfig, c);\n       float w1, w2, w3;\n       int2 vertex1, vertex2, vertex3;\n       TriangleGrid(uv, scale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n       // Assign random offset to each triangle vertex\n       c.uv0 = uv;\n       c.uv1 = uv;\n       c.uv2 = uv;\n   \n       c.uv0.xy += SimpleHash2(vertex1);\n       c.uv1.xy += SimpleHash2(vertex2);\n       c.uv2.xy += SimpleHash2(vertex3);\n       c.weights = half3(w1, w2, w3);\n       c.origWeights = half3(w1, w2, w3);\n    }\n\n\n   half3 LitBlendDetailNormal(half3 n1, half3 n2)\n   {\n      #if _SURFACEGRADIENT\n         return n1 + n2;\n      #else\n         return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n      #endif\n   }\n\n   float3 TriplanarBlendUnpackedRNM(float3 n1, float3 n2)\n   {\n       n1.z += 1;\n       n2.xy = -n2.xy;\n       return n1 * dot(n1, n2) / n1.z - n2;\n   }\n\n   void InitConfigDxDy(inout Config c)\n   {\n      c.uvT.dx0 = ddx(c.uvT.uv0);\n      c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1);\n      c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2);\n      c.uvT.dy2 = ddy(c.uvT.uv2);\n   }\n\n   Config CreateConfig(ShaderData d, float4 scale, float space, int uvsource, half triplanarContrast)\n   {\n      Config c;\n      ZERO_INITIALIZE(Config, c);\n\n      float3 pos = d.worldSpacePosition;\n      float3 normal = d.worldSpaceNormal;\n      if (space > 0)\n      {\n         pos = d.localSpacePosition;\n         normal = d.localSpaceNormal;\n      }\n\n      c.uv = d.texcoord0.xy;\n      \n      if (uvsource == 1)\n        c.uv = d.texcoord1.xy;\n      else if (uvsource == 2)\n        c.uv = pos.yz * float2(1, -1);\n      else if (uvsource == 3)\n        c.uv = pos.xz * float2(1, -1);\n      else if (uvsource == 4)\n        c.uv = pos.xy * float2(1, -1);\n\n      c.origUV = c.uv;\n      c.origScale = scale.xy;\n\n      c.uv = c.uv * scale.xy + scale.zw;\n      c.dx = ddx(c.uv);\n      c.dy = ddy(c.uv);\n\n      c.normal = normal;\n      c.uvT.uv0 = pos.zy * scale.xy + scale.zw;\n      c.uvT.uv1 = pos.xz * scale.xy + scale.zw;\n      c.uvT.uv2 = pos.xy * scale.xy + scale.zw;\n        \n      c.uvT.uv1 += 0.33;\n      c.uvT.uv2 += 0.67;\n\n      c.uvT.dx0 = ddx(c.uvT.uv0); c.uvT.dy0 = ddy(c.uvT.uv0);\n      c.uvT.dx1 = ddx(c.uvT.uv1); c.uvT.dy1 = ddy(c.uvT.uv1);\n      c.uvT.dx2 = ddx(c.uvT.uv2); c.uvT.dy2 = ddy(c.uvT.uv2);\n\n      half3 triblend = saturate(pow(abs(c.normal), triplanarContrast));\n      triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n      c.uvT.weights = triblend;\n      c.uvT.origWeights = triblend;\n      c.axisSign = d.worldSpaceNormal < 0 ? -1 : 1;\n      c.absVertNormal = abs(d.worldSpaceNormal);\n     \n\n      return c;\n   }\n\n\n   half4 TriSample(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0) * c.weights.x;\n      }\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1) * c.weights.y;\n      }  \n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n      {\n         COUNTSAMPLE\n         res += SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2) * c.weights.z;\n      }\n\n      return res;\n   }\n\n   half4 TriSampleBary(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      c.weights = BaryWeightBlend(c.origWeights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   half4 TriSampleGrad(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float contrast, ShaderData d)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv0, c.dx0, c.dy0);\n      half4 r2 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv1, c.dx1, c.dy1);\n      half4 r3 = SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv2, c.dx2, c.dy2);\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvX, contrast, d) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvY, contrast, d) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n           res += TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvZ, contrast, d) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   \n   half4 SampleTexBaryStochastic(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleBary(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   half4 SampleTexBaryTriplanar(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        half4 ret = TriSampleGrad(TEXTURE2D_ARGS(tex, ss), c.uvT, contrast, d);\n        return ret;\n   }\n\n   \n   half4 SampleTexBary(TEXTURE2D_PARAM(tex, ss), inout Config c, float contrast, ShaderData d)\n   {\n        COUNTSAMPLE\n        return SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uv, c.dx, c.dy);\n   }\n\n   half4 SampleTexStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ) * c.uvT.weights.z;\n\n        return res;     \n   }\n\n   \n   half4 SampleTexStochastic(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n\n   half4 SampleTexTriplanar(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       return TriSample(TEXTURE2D_ARGS(tex, ss), c.uvT);\n   }\n   \n   half4 SampleTex(TEXTURE2D_PARAM(tex, ss), Config c)\n   {\n       COUNTSAMPLE\n       return SAMPLE_TEXTURE2D(tex, ss, c.uv);\n   }\n   \n\n \n   half3 SampleNormalStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n         dataX = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvX));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n         dataY = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvY));\n\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n         dataZ = (TriSample(TEXTURE2D_ARGS(tex, ss), c.uvZ));\n\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n\n          return WorldToTangentSpace(d, worldNormal);\n       #endif\n   }\n\n\n   half3 SampleNormalTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 dataX = half4(0.5,0.5,1,0);\n      half4 dataY = half4(0.5,0.5,1,0);\n      half4 dataZ = half4(0.5,0.5,1,0);\n\n      UNITY_BRANCH\n      if (c.uvT.weights.x > 0)\n      {\n          COUNTSAMPLE\n          dataX = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv0, c.uvT.dx0, c.uvT.dy0));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.y > 0)\n      {\n          COUNTSAMPLE\n          dataY = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv1, c.uvT.dx1, c.uvT.dy1));\n      }\n      UNITY_BRANCH\n      if (c.uvT.weights.z > 0)\n      {\n         COUNTSAMPLE\n         dataZ = (SAMPLE_TEXTURE2D_GRAD(tex, ss, c.uvT.uv2, c.uvT.dx2, c.uvT.dy2));\n      }\n\n      half3 tnormalX = PackedUnpackScaleNormal(dataX, normalStrength);\n      half3 tnormalY = PackedUnpackScaleNormal(dataY, normalStrength);\n      half3 tnormalZ = PackedUnpackScaleNormal(dataZ, normalStrength);\n\n      #if _PACKEDFAST\n         smoothness = dataX.r * c.uvT.weights.x + dataY.r * c.uvT.weights.y + dataZ.r * c.uvT.weights.z;\n         ao = dataX.b * c.uvT.weights.x + dataY.b * c.uvT.weights.y + dataZ.b * c.uvT.weights.z;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return SurfgradFromTriplanarProjection(d, c.uvT.weights, tnormalX, tnormalY, tnormalZ);\n      #else\n\n          // Swizzle world normals to match tangent space and apply RNM blend\n          tnormalX = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.zy, c.absVertNormal.x), tnormalX);\n          tnormalY = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xz, c.absVertNormal.y), tnormalY);\n          tnormalZ = TriplanarBlendUnpackedRNM(half3(d.worldSpaceNormal.xy, c.absVertNormal.z), tnormalZ);\n\n          tnormalX.z *= c.axisSign.x;\n          tnormalY.z *= c.axisSign.y;\n          tnormalZ.z *= c.axisSign.z;\n          // Triblend normals and add to world normal\n          half3 worldNormal = normalize(tnormalX.zyx * c.uvT.weights.x + tnormalY.xzy * c.uvT.weights.y + tnormalZ.xyz * c.uvT.weights.z);\n          return WorldToTangentSpace(d, worldNormal);\n      #endif\n   }\n\n   half3 SampleNormalStochastic(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n     half4 normal = TriSample(tex, ss, c.uvT);\n     #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half3 SampleNormal(TEXTURE2D_PARAM(tex, ss), Config c, ShaderData d, half normalStrength, inout half smoothness, inout half ao)\n   {\n      half4 normal = SAMPLE_TEXTURE2D(tex, ss, c.uv);\n      #if _PACKEDFAST\n        smoothness = normal.r;\n        ao = normal.b;\n      #endif\n\n      #if _SURFACEGRADIENT\n         return ConvertNormalToGradient(d, PackedUnpackScaleNormal(normal, normalStrength));\n      #else\n         return PackedUnpackScaleNormal(normal, normalStrength);\n      #endif\n   }\n\n   half HeightBlend(half h1, half h2, half slope, half contrast)\n   {\n      h2 = 1 - h2;\n      half tween = saturate((slope - min(h1, h2)) / max(abs(h1 - h2), 0.001)); \n      half blend = saturate( ( tween - (1-contrast) ) / max(contrast, 0.001));\n      return blend;\n   }\n\n\n    #if _POM\n    float2 POM(TEXTURE2D_PARAM(tex, ss), Config c, float contrast, ShaderData d)\n    {\n       float2 curv = float2(0, 0);\n       float refPlane = 0;\n\n       float result = 0;\n       int stepIndex = 0;\n       int maxSamples = _POMMaxSamples;\n       int minSamples = 4;\n       float camDist = distance(_WorldSpaceCameraPos, d.worldSpacePosition);\n       float distanceFade = 1 - saturate((camDist - _POMMin) / max(1, _POMFade));\n       int numSteps = ( int )lerp( maxSamples, minSamples, dot( d.worldSpaceNormal, d.worldSpaceViewDir )) * distanceFade;\n       if (numSteps < 1)\n           numSteps = 1;\n       float layerHeight = 1.0 / numSteps;\n       float2 plane = _ParallaxHeight * ( d.tangentSpaceViewDir.xy / d.tangentSpaceViewDir.z ) * distanceFade;\n       OffsetUV(c, refPlane * plane);\n       float2 deltaTex = -plane * layerHeight;\n       float2 prevTexOffset = 0;\n       float prevRayZ = 1.0f;\n       float prevHeight = 0.0f;\n       float2 currTexOffset = deltaTex;\n       float currRayZ = 1.0f - layerHeight;\n       float currHeight = 0.0f;\n       float intersection = 0;\n       float2 finalTexOffset = 0;\n\n       while ( stepIndex < numSteps + 1 )\n       {\n          result = dot( curv, currTexOffset * currTexOffset );\n          Config cfg = c;\n          OffsetUV(cfg, currTexOffset);\n          currHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( currHeight > currRayZ )\n          {\n             stepIndex = numSteps + 1;\n          }\n          else\n          {\n             stepIndex++;\n             prevTexOffset = currTexOffset;\n             prevRayZ = currRayZ;\n             prevHeight = currHeight;\n             currTexOffset += deltaTex;\n             currRayZ -= layerHeight * ( 1 - result );\n          }\n       }\n       int sectionSteps = 10;\n       int sectionIndex = 0;\n       float newZ = 0;\n       float newHeight = 0;\n       while ( sectionIndex < sectionSteps )\n       {\n          intersection = ( prevHeight - prevRayZ ) / ( prevHeight - currHeight + currRayZ - prevRayZ );\n          finalTexOffset = prevTexOffset + intersection * deltaTex;\n          newZ = prevRayZ - intersection * layerHeight;\n          Config cfg = c;\n          OffsetUV(cfg, finalTexOffset);\n          newHeight = SAMPLEBARY(TEXTURE2D_ARGS(tex, ss), cfg, contrast, d).a * (1 - result);\n\n          if ( newHeight > newZ )\n          {\n             currTexOffset = finalTexOffset;\n             currHeight = newHeight;\n             currRayZ = newZ;\n             deltaTex = intersection * deltaTex;\n             layerHeight = intersection * layerHeight;\n          }\n          else\n          {\n             prevTexOffset = finalTexOffset;\n             prevHeight = newHeight;\n             prevRayZ = newZ;\n             deltaTex = ( 1 - intersection ) * deltaTex;\n             layerHeight = ( 1 - intersection ) * layerHeight;\n          }\n          sectionIndex++;\n       }\n       #if _PASSHADOWS\n       if ( unity_LightShadowBias.z == 0.0 )\n       {\n       #endif\n          if ( result > 1 )\n             clip( -1 );\n       #if _PASSHADOWS\n       }\n       #endif\n       return finalTexOffset;\n    }\n    #endif\n\n   \n\n   // tess versions\n   #if _TESSELLATION_ON\n   half4 TriSampleLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias)\n   {\n      half4 res = 0;\n      UNITY_BRANCH\n      if (c.weights.x > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias) * c.weights.x;\n\n      UNITY_BRANCH\n      if (c.weights.y > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias) * c.weights.y;\n\n      UNITY_BRANCH\n      if (c.weights.z > 0)\n         res += SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias) * c.weights.z;\n\n      return res;\n   }\n\n   half4 TriSampleBaryLOD(TEXTURE2D_PARAM(tex, ss), inout SampleConfig c, float bias, float contrast)\n   {\n      half4 r1 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv0, bias);\n      half4 r2 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv1, bias);\n      half4 r3 = SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv2, bias);\n      c.weights = BaryWeightBlend(c.weights, r1.a, r2.a, r3.a, contrast);\n      return r1 * c.weights.x + r2 * c.weights.y + r3 * c.weights.z;\n   }\n\n   \n   half4 SampleTexBaryLODStochasticTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n        half4 res = 0;\n        UNITY_BRANCH\n        if (c.uvT.weights.x > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvX, bias, contrast) * c.uvT.weights.x;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.y > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvY, bias, contrast) * c.uvT.weights.y;\n\n        UNITY_BRANCH\n        if (c.uvT.weights.z > 0)\n            res += TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvZ, bias, contrast) * c.uvT.weights.z;\n\n        return res;\n   }\n\n   half4 SampleTexBaryLODStochastic(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n       return TriSampleBaryLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias, contrast);\n   }\n\n   half4 SampleTexBaryLODTriplanar(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return TriSampleLOD(TEXTURE2D_ARGS(tex, ss), c.uvT, bias);\n   }\n\n   half4 SampleTexBaryLOD(TEXTURE2D_PARAM(tex, ss), Config c, float bias, float contrast)\n   {\n      return SAMPLE_TEXTURE2D_LOD(tex, ss, c.uv, bias);\n   }\n\n\n    float FBM2DLOD(float2 uv)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise2D( uv ); uv *= 2.01;\n           f += 0.2500*Noise2D( uv ); uv *= 1.96;\n           f += 0.1250*Noise2D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           return SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv, _TessellationMipBias).g;\n        #elif _NOISEWORLEY\n           return WorleyNoise2D(uv);\n        #else\n           return Noise2D(uv);\n        #endif\n        \n        \n    }\n\n    float FBM3DLOD(float3 uv, float3 pN)\n    {\n        #if _NOISEHQ\n           float f = 0.5000*Noise3D( uv ); uv *= 2.01;\n           f += 0.2500*Noise3D( uv ); uv *= 1.96;\n           f += 0.1250*Noise3D( uv );\n           return f;\n        #elif _NOISETEXTURE\n           half A = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.zy, _TessellationMipBias).g;\n           half B = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xz + 0.33, _TessellationMipBias).g;\n           half C = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, uv.xy + 0.67, _TessellationMipBias).g;\n           half3 triblend = saturate(pow(pN, 4));\n           triblend /= max(dot(triblend, half3(1,1,1)), 0.0001);\n           return A * triblend.x + B * triblend.y + C * triblend.z;\n        #elif _NOISEWORLEY\n           return WorleyNoise3D(uv);\n        #else\n           return Noise3D(uv);\n        #endif\n        \n    }\n\n    float DoNoiseLOD(ShaderData d, float frequency, float offset)\n    {\n        #if _NOISEWORLD\n           return FBM3DLOD(d.worldSpacePosition * frequency + offset, d.worldSpaceNormal);\n        #elif _NOISELOCAL\n           return FBM3DLOD(d.localSpacePosition * frequency + offset, d.localSpaceNormal);\n        #else\n           return FBM2DLOD(d.texcoord0.xy * frequency + offset);\n        #endif\n    }\n\n   #endif //_TESSELLATION_ON\n\n\n    half3 FuzzyShade(ShaderData d, half height, half3 color, half3 normal, half coreMult, half edgeMult, half power)\n    {\n        float3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half dt = saturate(dot(d.worldSpaceViewDir, worldNormal));\n        half dark = 1.0 - (coreMult * dt);\n        half edge = pow(1-dt, abs(power)) * edgeMult;\n        return color * (dark + edge);\n    }\n\n\thalf MicroShadow(ShaderData d, half3 normal, half height, half ao, half strength)\n\t{\n        float3 sun;\n\t\tfloat3 sunColor;\n\t\tGetSun(sun, sunColor);\n\t\tfloat3 worldNormal = GetWorldSpaceNormal(d, normal, height);\n        half shadow = saturate(abs(dot(worldNormal, sun)) + (ao * ao * 2.0) - 1.0);\n        return 1 - ((1-shadow) * strength);\n\t}\n\n\n#endif\n\n\n\n   #if defined(_SPECULAR)\n      #define _USESPECULAR 1\n      #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n   #endif\n\n   \n   TEXTURE2D(_AlbedoMap);\n   SAMPLER(sampler_AlbedoMap);\n   TEXTURE2D(_NormalMap);\n   SAMPLER(sampler_NormalMap);\n   TEXTURE2D(_MaskMap);\n   TEXTURE2D(_DetailMap);\n   TEXTURE2D(_EmissionMap);\n\n   #if _SPECULAR\n       TEXTURE2D(_SpecularMap);\n   #endif\n\n   \n   \n   void Ext_SurfaceFunction0 (inout Surface o, inout ShaderData d)\n   {\n      // define samplers based on settings\n      #undef SAMPLEBARY\n      #undef SAMPLE\n      #undef SAMPLENORMAL\n      #if _STOCHASTIC && _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n        #define SAMPLE     SampleTexStochasticTriplanar\n        #define SAMPLENORMAL SampleNormalStochasticTriplanar\n      #elif _STOCHASTIC\n        #define SAMPLEBARY SampleTexBaryStochastic\n        #define SAMPLE     SampleTexStochastic\n        #define SAMPLENORMAL SampleNormalStochastic\n      #elif _TRIPLANAR\n        #define SAMPLEBARY SampleTexBaryTriplanar\n        #define SAMPLE     SampleTexTriplanar\n        #define SAMPLENORMAL SampleNormalTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBary\n        #define SAMPLE     SampleTex\n        #define SAMPLENORMAL SampleNormal\n      #endif\n\n      Config c = CreateConfig(d, _AlbedoMap_ST, _TriplanarSpace, _UVSource, _TriplanarContrast);\n      InitConfigDxDy(c);\n      #if _STOCHASTIC && !_TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uv, c.uvT);\n         InitStochasticDxDy(c.uvT, c);\n      #elif _STOCHASTIC && _TRIPLANAR\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv0, c.uvX);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv1, c.uvY);\n         PrepareStochasticUVs(_StochasticScale, c.uvT.uv2, c.uvZ);\n         InitStochasticDxDy(c.uvX, c);\n         InitStochasticDxDy(c.uvY, c);\n         InitStochasticDxDy(c.uvZ, c);\n      #endif\n\n      #if _POM\n          // would need to handle height remapping if we ever want to ship this\n          float2 pomOffset = POM(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n          OffsetUV(c, pomOffset);\n      #endif\n\n      half4 albedo = SAMPLEBARY(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c, _StochasticContrast, d);\n      \n      #if _PARALLAX\n         float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n         OffsetUV(c, offset);\n         albedo = SAMPLE(TEXTURE2D_ARGS(_AlbedoMap, sampler_AlbedoMap), c);\n         \n      #endif\n      albedo.a = lerp(_HeightRemap.x, _HeightRemap.y, albedo.a);\n      albedo.rgb *= _Tint.rgb;\n\n      albedo.rgb = AdjustContrast(albedo.rgb, _AlbedoContrast);\n      albedo.rgb += _AlbedoBrightness;\n\n\n      if (_AlphaThreshold > 0)\n      {\n         clip(albedo.a - _AlphaThreshold);\n      }\n\n      #if defined(_FLATSHADE)\n\t\t     float3 dx = ddx(d.worldSpacePosition);\n\t\t     float3 dy = ddy(d.worldSpacePosition);\n\t\t     float3 worldNormal = normalize(cross(dy, dx));\n\t\t     worldNormal = lerp(d.worldSpaceNormal, worldNormal, _FlatShadingBlend);\n\t\t     d.worldSpaceNormal = worldNormal;\n\t\t     d.TBNMatrix[2] = worldNormal;\n      #endif\n\n\n\n      o.Albedo = albedo.rgb;\n      o.Alpha = albedo.a;\n\n      float smoothness = _Smoothness;\n      float ao = 1;\n\n      #if defined(_NORMALMAP) && !defined(_AUTONORMAL)\n         o.Normal = SAMPLENORMAL(TEXTURE2D_ARGS(_NormalMap, sampler_NormalMap), c, d, _NormalStrength, smoothness, ao);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, ao);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n      #endif\n\n      half detailMask = 1;\n      o.Smoothness = smoothness;\n      o.Occlusion = ao;\n      o.Metallic = _Metallic;\n      #if defined(_MASKMAP) && !_PACKEDFAST\n         // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = SampleTex(TEXTURE2D_ARGS(_MaskMap, sampler_AlbedoMap), c);\n         o.Metallic = lerp(_MetallicRemap.x, _MetallicRemap.y, mask.r);\n         o.Occlusion = lerp(_AORemap.x, _AORemap.y, mask.g);\n         o.Smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, mask.a);\n         detailMask = mask.b;\n      #endif // separate maps\n\n      #if _SPECULAR\n         o.Specular = SAMPLE(TEXTURE2D_ARGS(_SpecularMap, sampler_AlbedoMap), c).rgb;\n      #endif\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = SAMPLE(TEXTURE2D_ARGS(_EmissionMap, sampler_AlbedoMap), c).rgb * _EmissionColor;\n      #endif\n\n      if (_FuzzyShadingOn > 0)\n      {\n        o.Albedo *= FuzzyShade(d, albedo.a, _FuzzyShadingColor, o.Normal, _FuzzyShadingParams.x, _FuzzyShadingParams.y, _FuzzyShadingParams.z);\n      }\n\n\n      // HDRP style detail texturing\n\n      #if defined(_DETAIL)\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _DETAILSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _DETAILTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n         Config dc = CreateConfig(d, _DetailMap_ST, _DetailTriplanarSpace, _DetailUVSource, _DetailTriplanarContrast);\n         InitConfigDxDy(dc);\n         #if _DETAILSTOCHASTIC && !_DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uv, dc.uvT);\n             InitStochasticDxDy(dc.uvT, dc);\n         #elif _DETAILSTOCHASTIC && _DETAILTRIPLANAR\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv0, dc.uvX);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv1, dc.uvY);\n             PrepareStochasticUVs(_DetailStochasticScale, dc.uvT.uv2, dc.uvZ);\n             InitStochasticDxDy(dc.uvX, dc);\n             InitStochasticDxDy(dc.uvY, dc);\n             InitStochasticDxDy(dc.uvZ, dc);\n         #endif\n\n         half4 detailSample = SAMPLEBARY(TEXTURE2D_ARGS(_DetailMap, sampler_AlbedoMap), dc, _DetailStochasticContrast, d);\n         smoothness = detailSample.z;\n         #if !_AUTONORMAL\n            half3 dnormal = float3(detailSample.ag * 2 - 1, 1) * detailMask * _DetailNormalStrength;\n            dnormal.z = sqrt(1 - dnormal.x * dnormal.x - dnormal.y * dnormal.y);\n            #if _SURFACEGRADIENT\n               dnormal = ConvertNormalToGradient(d, dnormal);\n            #endif\n            o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n         #endif\n     \n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * smoothness, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n      if (_MicroShadowStrength > 0)\n      {\n        o.Occlusion *= MicroShadow(d, o.Normal, o.Alpha, o.Occlusion, _MicroShadowStrength);\n      }\n  \n      // in case something needs height in the stack..\n      o.Height = o.Alpha;\n\n\n      \n   }\n\n\n\n\t#if _TINTMASK\n\t\tTEXTURE2D(_TintMask);\n\t\tSAMPLER(sampler_TintMask);\n\t#endif\n\n\tvoid Ext_SurfaceFunction1 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _TINTMASK\n\t\t   half4 w = SAMPLE_TEXTURE2D(_TintMask, sampler_TintMask, d.texcoord0.xy * _TintMask_ST.xy + _TintMask_ST.zw);\n\t\t   // allow black to be no tint..\n\t\t   half3 tint = o.Albedo * (_RColor.rgb * 2 * w.r + _GColor.rgb * 2 * w.g + _BColor.rgb * 2 * w.b + _AColor.rgb * 2 * w.a);\n\t\t   o.Albedo = lerp(o.Albedo, tint, saturate(w.r + w.g + w.b + w.a));\n\t\t#endif\n\t}\n\n\n\n\n\t#if _LAYERTEXTUREMASK\n       TEXTURE2D(_LayerTextureMask);\n       SAMPLER(sampler_LayerTextureMask); \n    #endif\n\n   void Ext_ModifyTessellatedVertex2 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON\n          float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n\n          #if _LAYERTEXTUREMASK\n               float2 layerUV = v.texcoord0.xy;\n               if (_LayerTextureMaskUVMode == 1)\n                  layerUV = v.texcoord1.xy;\n               else if (_LayerTextureMaskUVMode == 2)\n                  layerUV = worldSpacePosition.yz;\n               else if (_LayerTextureMaskUVMode == 3)\n                  layerUV = worldSpacePosition.xz;\n               else if (_LayerTextureMaskUVMode == 4)\n                  layerUV = worldSpacePosition.xy;\n\n              e.blackboard.weightTextureMask = SAMPLE_TEXTURE2D_LOD(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw, _TessellationMipBias);\n          #endif\n      #endif\n    }\n\n\n\tvoid Ext_SurfaceFunction2 (inout Surface o, inout ShaderData d)\n\t{\n\t\t#if _LAYERTEXTUREMASK\n           float2 layerUV = d.texcoord0.xy;\n           if (_LayerTextureMaskUVMode == 1)\n              layerUV = d.texcoord1.xy;\n           else if (_LayerTextureMaskUVMode == 2)\n              layerUV = d.worldSpacePosition.yz;\n           else if (_LayerTextureMaskUVMode == 3)\n              layerUV = d.worldSpacePosition.xz;\n           else if (_LayerTextureMaskUVMode == 4)\n              layerUV = d.worldSpacePosition.xy;\n\n          d.blackboard.weightTextureMask = SAMPLE_TEXTURE2D(_LayerTextureMask, sampler_LayerTextureMask, layerUV * _LayerTextureMask_ST.xy + _LayerTextureMask_ST.zw);\n      #endif\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap);\n   SAMPLER(sampler_LayerAlbedoMap);\n   TEXTURE2D(_LayerNormalMap);\n   TEXTURE2D(_LayerMaskMap);\n   TEXTURE2D(_LayerEmissionMap);\n\n   \n\n   void Ext_ModifyTessellatedVertex3 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER) && defined(_LAYERALBEDO) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n         half detailMask = 1;\n         #if _LAYERNOISE\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency,  _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin;\n            dt = saturate(dt * _LayerFalloff);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight) * _LayerFalloff);\n            if (_LayerInvertHeight > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 0\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength;\n         detailMask *= _LayerTessStrength;\n\n         #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast).a;\n         albedo = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo);\n\n         if (_LayerBlendMode == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction3 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_ST, _LayerTriplanarSpace, _LayerUVSource, _LayerTriplanarContrast);\n            // noise up the mask\n            #if _LAYERNOISE\n               mask = DoNoise(d, _LayerNoiseFrequency, _LayerNoiseOffset) * _LayerNoiseAmplitude + _LayerNoiseCenter;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend);\n\t    \n                dt -= _LayerAngleMin;\n                dt = saturate(dt * _LayerFalloff);\n\n                float hf = saturate((o.Height - _LayerHeight) * _LayerFalloff);\n                if (_LayerInvertHeight > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance.y + _LayerWeightOverDistance.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance.y, _LayerWeightOverDistance.w, saturate((camDist-_LayerWeightOverDistance.x) / _LayerWeightOverDistance.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 0\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 0\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength;\n\n            #if _LAYERSTOCHASTIC && !_LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC && _LAYERTRIPLANAR\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint, 0.5);\n            #if defined(_LAYERALBEDO)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c, _LayerStochasticContrast, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap, sampler_LayerAlbedoMap), c);\n                #endif\n                albedo.rgb *= _LayerTint;\n                albedo.a = lerp(_LayerHeightRemap.x, _LayerHeightRemap.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL || _LAYERMASK\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap, sampler_LayerAlbedoMap, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast);\n            albedo.rgb += _LayerAlbedoBrightness;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap, sampler_LayerAlbedoMap), c, d, _LayerNormalStrength * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO)\n                if (_LayerFuzzyShadingOn > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor.rgb, dnormal,\n                                            _LayerFuzzyShadingParams.x, _LayerFuzzyShadingParams.y, _LayerFuzzyShadingParams.z);\n                }\n\n                if (_LayerBlendMode == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast);\n                else if (_LayerBlendMode == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE\n                      float maskDif = (_LayerBlendContrast * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength);\n                   #if _LAYERNOISE\n                      o.Albedo *= lerp(_LayerBlendTint, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap, sampler_LayerAlbedoMap), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength);\n                }\n\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO\n                   if (_LayerBlendMode > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap, sampler_LayerAlbedoMap), c).rgb * _LayerEmissionColor;\n                #if _LAYERALBEDO\n                    if (_LayerBlendMode > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_1);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_1);\n   TEXTURE2D(_LayerNormalMap_Ext_1);\n   TEXTURE2D(_LayerMaskMap_Ext_1);\n   TEXTURE2D(_LayerEmissionMap_Ext_1);\n\n   \n\n   void Ext_ModifyTessellatedVertex4 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_1\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_1) && defined(_LAYERALBEDO_DEF_1) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_1\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_1,  _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_1\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_1;\n            dt = saturate(dt * _LayerFalloff_Ext_1);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n            if (_LayerInvertHeight_Ext_1 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 01\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_1;\n         detailMask *= _LayerTessStrength_Ext_1;\n\n         #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_1).a;\n         albedo = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo);\n\n         if (_LayerBlendMode_Ext_1 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_1);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_1 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction4 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_1\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_1\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_1)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_1_ST, _LayerTriplanarSpace_Ext_1, _LayerUVSource_Ext_1, _LayerTriplanarContrast_Ext_1);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_1\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_1, _LayerNoiseOffset_Ext_1) * _LayerNoiseAmplitude_Ext_1 + _LayerNoiseCenter_Ext_1;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_1\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_1);\n\t    \n                dt -= _LayerAngleMin_Ext_1;\n                dt = saturate(dt * _LayerFalloff_Ext_1);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_1) * _LayerFalloff_Ext_1);\n                if (_LayerInvertHeight_Ext_1 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_1.y + _LayerWeightOverDistance_Ext_1.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_1.y, _LayerWeightOverDistance_Ext_1.w, saturate((camDist-_LayerWeightOverDistance_Ext_1.x) / _LayerWeightOverDistance_Ext_1.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 01\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 01\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_1;\n\n            #if _LAYERSTOCHASTIC_DEF_1 && !_LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_1 && _LAYERTRIPLANAR_DEF_1\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_1, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_1, 0.5);\n            #if defined(_LAYERALBEDO_DEF_1)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, _LayerStochasticContrast_Ext_1, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_1;\n                albedo.a = lerp(_LayerHeightRemap_Ext_1.x, _LayerHeightRemap_Ext_1.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_1 || _LAYERMASK_DEF_1\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_1, sampler_LayerAlbedoMap_Ext_1, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_1);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_1;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c, d, _LayerNormalStrength_Ext_1 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_1)\n                if (_LayerFuzzyShadingOn_Ext_1 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_1.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_1.x, _LayerFuzzyShadingParams_Ext_1.y, _LayerFuzzyShadingParams_Ext_1.z);\n                }\n\n                if (_LayerBlendMode_Ext_1 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_1);\n                else if (_LayerBlendMode_Ext_1 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_1 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_1);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_1\n                      float maskDif = (_LayerBlendContrast_Ext_1 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_1 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                   #if _LAYERNOISE_DEF_1\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_1, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_1));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_1) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_1 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_1);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_1) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_1 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_1);\n                }\n\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_1);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_1);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_1\n                   if (_LayerBlendMode_Ext_1 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_1, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_1, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_1\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_1, sampler_LayerAlbedoMap_Ext_1), c).rgb * _LayerEmissionColor_Ext_1;\n                #if _LAYERALBEDO_DEF_1\n                    if (_LayerBlendMode_Ext_1 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_1);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   TEXTURE2D(_LayerAlbedoMap_Ext_2);\n   SAMPLER(sampler_LayerAlbedoMap_Ext_2);\n   TEXTURE2D(_LayerNormalMap_Ext_2);\n   TEXTURE2D(_LayerMaskMap_Ext_2);\n   TEXTURE2D(_LayerEmissionMap_Ext_2);\n\n   \n\n   void Ext_ModifyTessellatedVertex5 (inout VertexData v, inout ExtraV2F e)\n   {\n      #undef SAMPLEBARY\n      #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochasticTriplanar\n      #elif _LAYERSTOCHASTIC_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODStochastic\n      #elif _LAYERTRIPLANAR_DEF_2\n        #define SAMPLEBARY SampleTexBaryLODTriplanar\n      #else\n        #define SAMPLEBARY SampleTexBaryLOD\n      #endif\n\n      #if defined(_USELAYER_DEF_2) && defined(_LAYERALBEDO_DEF_2) && _TESSELLATION_ON && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n         Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n         half detailMask = 1;\n         #if _LAYERNOISE_DEF_2\n            detailMask = DoNoiseLOD(d, _LayerNoiseFrequency_Ext_2,  _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n            detailMask = saturate(detailMask);\n         #endif\n\n         #if _LAYERANGLEFILTER_DEF_2\n            half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t    \n            dt -= _LayerAngleMin_Ext_2;\n            dt = saturate(dt * _LayerFalloff_Ext_2);\n\n            float hf = saturate((e.blackboard.vertexHeightOffset - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n            if (_LayerInvertHeight_Ext_2 > 0.5)\n\t            hf = 1.0 - hf;\n            dt *= hf;\n            detailMask *= dt;\n         #endif\n\n         if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n         {\n            float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n            detailMask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n         }  \n\n         // this is a little trick to select the channel based on the stack index. The\n         // Better Shaders parser will replace the stackidx with the actual stack number in the shader.\n\n         #if _LAYERVERTEXMASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= v.vertexColor.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= v.vertexColor.g;\n            }\n            else\n            {\n               detailMask *= v.vertexColor.r;\n            }\n            #undef STACKINDEX\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            #define STACKINDEX 02\n\n            if (STACKINDEX > 1)\n            {\n               detailMask *= e.blackboard.weightTextureMask.b;\n            }\n            else if (STACKINDEX > 0)\n            {\n               detailMask *= e.blackboard.weightTextureMask.g;\n            }\n            else\n            {\n               detailMask *= e.blackboard.weightTextureMask.r;\n            }\n            #undef STACKINDEX\n         #endif\n\n         detailMask *= _LayerStrength_Ext_2;\n         detailMask *= _LayerTessStrength_Ext_2;\n\n         #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n         #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n             PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n         #endif\n\n         half height = e.blackboard.vertexHeightOffset;\n         half albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_AlbedoMap), c, _TessellationMipBias,_LayerStochasticContrast_Ext_2).a;\n         albedo = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo);\n\n         if (_LayerBlendMode_Ext_2 == 2)\n         {\n            half heightBlend = HeightBlend(height, albedo, detailMask, _LayerHeightContrast_Ext_2);\n            height = lerp(height, albedo, heightBlend);\n         }\n         else if (_LayerBlendMode_Ext_2 = 1)\n         {\n            height = lerp(height, albedo,  detailMask);\n         }\n         else\n         {\n            height = lerp(height, height * 2 * albedo,  detailMask);\n         }\n\n\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n         \n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n      #endif\n   }\n\n\n\tvoid Ext_SurfaceFunction5 (inout Surface o, ShaderData d)\n\t{\n        #undef SAMPLEBARY\n        #undef SAMPLE\n        #undef SAMPLENORMAL\n        #if _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochasticTriplanar\n          #define SAMPLE     SampleTexStochasticTriplanar\n          #define SAMPLENORMAL SampleNormalStochasticTriplanar\n        #elif _LAYERSTOCHASTIC_DEF_2\n          #define SAMPLEBARY SampleTexBaryStochastic\n          #define SAMPLE     SampleTexStochastic\n          #define SAMPLENORMAL SampleNormalStochastic\n        #elif _LAYERTRIPLANAR_DEF_2\n          #define SAMPLEBARY SampleTexBaryTriplanar\n          #define SAMPLE     SampleTexTriplanar\n          #define SAMPLENORMAL SampleNormalTriplanar\n        #else\n          #define SAMPLEBARY SampleTexBary\n          #define SAMPLE     SampleTex\n          #define SAMPLENORMAL SampleNormal\n        #endif\n\n\n\t\t#if defined(_USELAYER_DEF_2)\n            float mask = 1;\n            Config c = CreateConfig(d, _LayerAlbedoMap_Ext_2_ST, _LayerTriplanarSpace_Ext_2, _LayerUVSource_Ext_2, _LayerTriplanarContrast_Ext_2);\n            // noise up the mask\n            #if _LAYERNOISE_DEF_2\n               mask = DoNoise(d, _LayerNoiseFrequency_Ext_2, _LayerNoiseOffset_Ext_2) * _LayerNoiseAmplitude_Ext_2 + _LayerNoiseCenter_Ext_2;\n               mask = saturate(mask);\n            #endif\n\n            #if _LAYERANGLEFILTER_DEF_2\n                half dt = lerp(dot(d.worldSpaceNormal, float3(0,1,0)), dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), _LayerVertexNormalBlend_Ext_2);\n\t    \n                dt -= _LayerAngleMin_Ext_2;\n                dt = saturate(dt * _LayerFalloff_Ext_2);\n\n                float hf = saturate((o.Height - _LayerHeight_Ext_2) * _LayerFalloff_Ext_2);\n                if (_LayerInvertHeight_Ext_2 > 0.5)\n\t                hf = 1.0 - hf;\n                dt *= hf;\n                mask *= dt;\n            #endif\n\n            if (_LayerWeightOverDistance_Ext_2.y + _LayerWeightOverDistance_Ext_2.w < 2)\n            {\n               float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);\n               mask *= lerp(_LayerWeightOverDistance_Ext_2.y, _LayerWeightOverDistance_Ext_2.w, saturate((camDist-_LayerWeightOverDistance_Ext_2.x) / _LayerWeightOverDistance_Ext_2.z));\n            }\n\n           #if _LAYERVERTEXMASK\n                #define STACKINDEX 02\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.vertexColor.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.vertexColor.g;\n                }\n                else\n                {\n                   mask *= d.vertexColor.r;\n                }\n                #undef STACKINDEX\n            #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n                #define STACKINDEX 02\n\n                if (STACKINDEX > 1)\n                {\n                   mask *= d.blackboard.weightTextureMask.b;\n                }\n                else if (STACKINDEX > 0)\n                {\n                   mask *= d.blackboard.weightTextureMask.g;\n                }\n                else\n                {\n                   mask *= d.blackboard.weightTextureMask.r;\n                }\n                #undef STACKINDEX\n             #endif\n\n            mask *= _LayerStrength_Ext_2;\n\n            #if _LAYERSTOCHASTIC_DEF_2 && !_LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uv, c.uvT);\n                InitStochasticDxDy(c.uvT, c);\n            #elif _LAYERSTOCHASTIC_DEF_2 && _LAYERTRIPLANAR_DEF_2\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv0, c.uvX);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv1, c.uvY);\n                PrepareStochasticUVs(_LayerStochasticScale_Ext_2, c.uvT.uv2, c.uvZ);\n                InitStochasticDxDy(c.uvX, c);\n                InitStochasticDxDy(c.uvY, c);\n                InitStochasticDxDy(c.uvZ, c);\n            #endif\n            \n            half heightBlend = 0;\n            half alpha = 0.5;\n            half4 albedo = half4(_LayerTint_Ext_2, 0.5);\n            #if defined(_LAYERALBEDO_DEF_2)\n                albedo = SAMPLEBARY(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, _LayerStochasticContrast_Ext_2, d);\n                #if _PARALLAX\n                   float2 offset = DoParallaxOffset(albedo.a, _ParallaxHeight, d.tangentSpaceViewDir);\n                   OffsetUV(c, offset);\n                   albedo = SAMPLE(TEXTURE2D_ARGS(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                #endif\n                albedo.rgb *= _LayerTint_Ext_2;\n                albedo.a = lerp(_LayerHeightRemap_Ext_2.x, _LayerHeightRemap_Ext_2.y, albedo.a);\n                alpha = albedo.a;\n            #elif _LAYERNORMAL_DEF_2 || _LAYERMASK_DEF_2\n                // Unity will strip the sampler if it's not used, so if we have any other texture to sample,\n                // we have to sample the albedo anyway, making sure it could contribute to the output,\n                // and also do it in such a way that it's fast. Wish we could just [NoStrip] the sampler or something.\n                o.Albedo *= saturate(1 + SAMPLE_TEXTURE2D_LOD(_LayerAlbedoMap_Ext_2, sampler_LayerAlbedoMap_Ext_2, float2(0,0), 12).r);\n            #endif // layer albedo\n\n            albedo.rgb = AdjustContrast(albedo.rgb, _LayerAlbedoContrast_Ext_2);\n            albedo.rgb += _LayerAlbedoBrightness_Ext_2;\n\n            half smoothness = 0;\n            half ao = 1;\n            half3 dnormal = half3(0,0,1);  // might not be correct for surfgrad, would be in worldspace?\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                dnormal = SAMPLENORMAL(TEXTURE2D_ARGS(_LayerNormalMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c, d, _LayerNormalStrength_Ext_2 * mask, smoothness, ao);\n            #endif\n\n            #if defined(_LAYERALBEDO_DEF_2)\n                if (_LayerFuzzyShadingOn_Ext_2 > 0)\n                {\n                   albedo.rgb *= FuzzyShade(d, albedo.a, _LayerFuzzyShadingColor_Ext_2.rgb, dnormal,\n                                            _LayerFuzzyShadingParams_Ext_2.x, _LayerFuzzyShadingParams_Ext_2.y, _LayerFuzzyShadingParams_Ext_2.z);\n                }\n\n                if (_LayerBlendMode_Ext_2 == 2)\n                   heightBlend = HeightBlend(o.Alpha, albedo.a, mask, _LayerHeightContrast_Ext_2);\n                else if (_LayerBlendMode_Ext_2 == 1)\n                   heightBlend =  mask;\n\n\n                if (_LayerBlendMode_Ext_2 > 0)\n                {\n                   o.Albedo = lerp(o.Albedo, albedo.rgb, heightBlend * _LayerAlbedoStrength_Ext_2);\n                   o.Alpha = lerp(o.Alpha, albedo.a, heightBlend);\n                   #if _LAYERNOISE_DEF_2\n                      float maskDif = (_LayerBlendContrast_Ext_2 * 2) / 16.0;\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(HeightBlend(o.Alpha, albedo.a, _LayerAlbedoStrength_Ext_2 * mask, maskDif) - 0.5) * 2));\n                   #endif\n                }\n                else\n                {\n                   o.Albedo = lerp(o.Albedo, o.Albedo * 2 * albedo.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                   #if _LAYERNOISE_DEF_2\n                      o.Albedo *= lerp(_LayerBlendTint_Ext_2, half3(1,1,1), saturate(abs(mask - 0.5) * _LayerBlendContrast_Ext_2));\n                   #endif\n                }\n            #endif\n         \n\n            \n\n            #if defined(_LAYERNORMAL_DEF_2) && !defined(_AUTONORMAL)\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                      o.Normal = lerp(o.Normal, dnormal, heightBlend);\n                   else\n                      o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #else\n                   o.Normal = LitBlendDetailNormal(o.Normal, dnormal);\n                #endif\n\n                #if _PACKEDFAST\n                    smoothness = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, smoothness);\n                    ao = lerp(_AORemap.x, _AORemap.y, ao);\n                    if (_LayerMicroShadowStrength_Ext_2 > 0)\n                    {\n                      ao *= MicroShadow(d, dnormal, alpha, ao, _LayerMicroShadowStrength_Ext_2);\n                    }\n\n                    o.Smoothness = lerp(o.Smoothness, smoothness, heightBlend);\n                    o.Occlusion = lerp(o.Occlusion, ao, heightBlend);\n                #endif\n            #endif\n\n            #if defined(_LAYERMASK_DEF_2) && !_PACKEDFAST\n                half4 dmask = SAMPLE(TEXTURE2D_ARGS(_LayerMaskMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c);\n                dmask.w = lerp(_SmoothnessRemap.x, _SmoothnessRemap.y, dmask.a);\n                dmask.y = lerp(_AORemap.x, _AORemap.y, dmask.y);\n                dmask.x = lerp(_MetallicRemap.x, _MetallicRemap.y, dmask.x);\n\n                if (_LayerMicroShadowStrength_Ext_2 > 0)\n                {\n                  ao *= MicroShadow(d, dnormal, alpha, dmask.y, _LayerMicroShadowStrength_Ext_2);\n                }\n\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, heightBlend);\n                       o.Metallic = lerp(o.Metallic, dmask.x, heightBlend);\n                   }\n                   else\n                   {\n                       o.Smoothness = lerp(o.Smoothness, dmask.a, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Occlusion = lerp(o.Occlusion, o.Occlusion * dmask.y, mask * _LayerSmoothnessStrength_Ext_2);\n                       o.Metallic = lerp(o.Metallic, dmask.x, mask * _LayerSmoothnessStrength_Ext_2);\n                   }\n                #endif\n            #else\n                #if _LAYERALBEDO_DEF_2\n                   if (_LayerBlendMode_Ext_2 > 0)\n                   {\n                       o.Smoothness = lerp(o.Smoothness, _LayerSmoothness_Ext_2, heightBlend);\n                       o.Occlusion = lerp(o.Occlusion, 1, heightBlend);\n                       o.Metallic = lerp(o.Metallic, _LayerMetallic_Ext_2, heightBlend);\n                   }\n                #endif\n            #endif\n\n            #if _LAYEREMISSION_DEF_2\n                half3 emission = SAMPLE(TEXTURE2D_ARGS(_LayerEmissionMap_Ext_2, sampler_LayerAlbedoMap_Ext_2), c).rgb * _LayerEmissionColor_Ext_2;\n                #if _LAYERALBEDO_DEF_2\n                    if (_LayerBlendMode_Ext_2 > 0)\n                       o.Emission = lerp(o.Emission, emission.rgb, heightBlend);\n                    else\n                       o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #else\n                    o.Emission = lerp(o.Emission, o.Emission * 2 * emission.rgb,  mask * _LayerAlbedoStrength_Ext_2);\n                #endif\n            #endif\n       #endif // use layer\n\t}\n\n\n\n\n   #if _TRAX_ON\n   TEXTURE2D(_TraxAlbedo);\n   SAMPLER(sampler_TraxAlbedo);\n   TEXTURE2D(_TraxPackedNormal);\n   TEXTURE2D(_TraxMask);\n\n   sampler2D_float _GMSTraxBuffer;\n\n   float4 _GMSTraxBuffer_TexelSize;\n   float3 _GMSTraxBufferPosition;\n   float _GMSTraxBufferWorldSize;\n   float _GMSTraxFudgeFactor;\n\n   float SampleTraxBufferLOD(float3 worldPos)\n   {    \n      // generate UVs for the buffer, which is moving\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 8);\n      uv *= 0.5;\n      uv += 0.5;\n            \n      float s =  tex2Dlod(_GMSTraxBuffer, float4(uv, 0, 0)).r;\n\n      return 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n   }\n         \n        \n   float SampleTraxBuffer(float3 worldPos, out float3 norm)\n   {\n      float2 uv = worldPos.xz;\n      uv -= _GMSTraxBufferPosition.xz;\n      uv /= max(_GMSTraxBufferWorldSize, 1);\n      float fade = saturate(distance(uv, float2(0.0, 0.0)));\n      fade = 1 - pow(fade, 3);\n      uv *= 0.5;\n      uv += 0.5;\n            \n\n      float2 offset = _GMSTraxBuffer_TexelSize.xy;\n\n      float s = tex2D(_GMSTraxBuffer, uv).r;\n               \n      float s1 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, -1)).r;\n      float s2 = tex2D(_GMSTraxBuffer, uv + offset * float2(-1, 0)).r;\n      float s3 = tex2D(_GMSTraxBuffer, uv + offset * float2(1, 0)).r;\n      float s4 = tex2D(_GMSTraxBuffer, uv + offset * float2(0, 1)).r;\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      COUNTSAMPLE\n      float r = 1 - saturate((worldPos.y + _GMSTraxFudgeFactor) - s) * fade;\n \n      // generate normals\n      norm.x = (s1 - s4) * 0.25; \n      norm.y = (s2 - s3) * 0.25;\n      norm.z = 2;\n      norm = normalize(norm);\n     \n      norm.xy *= 1 - r;\n            \n      return r;\n   }\n   #endif\n\n   void Ext_ModifyTessellatedVertex6 (inout VertexData v, inout ExtraV2F d)\n   {\n       #if _TESSELLATION_ON && _TRAX_ON && _HAS_LIT_TESSELLATION\n          \n           float3 worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n           float3 worldSpaceNormal = TransformObjectToWorld(v.normal);\n\n           float traxBuffer = SampleTraxBufferLOD(worldSpacePosition);\n           d.blackboard.traxBuffer = traxBuffer;\n           float2 uv = worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n           half albedo = SAMPLE_TEXTURE2D_LOD(_TraxAlbedo, sampler_TraxAlbedo, uv, _TraxMipBias).a;\n\n           float traxOffset = albedo * _TraxDisplacementStrength;\n           traxOffset *= 1 - v.texcoord0.z;\n           traxOffset *= _TessellationDisplacement;\n           float dig = _TraxDisplacementDepth * (1 - v.texcoord0.z);\n           float3 traxVertex = d.blackboard.originalVertexPosition + (v.normal * (traxOffset - dig));\n           v.vertex.xyz = lerp(traxVertex, v.vertex.xyz, traxBuffer);\n\n           d.blackboard.vertexHeightOffset = lerp(traxOffset-dig, d.blackboard.vertexHeightOffset, traxBuffer);\n\n       #endif\n\n   }\n\n   void Ext_SurfaceFunction6 (inout Surface o, inout ShaderData d)\n   {\n      #if _TRAX_ON\n        float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _TraxAlbedo_ST.xy + _TraxAlbedo_ST.zw;\n        float2 fsdx = ddx(uv);\n        float2 fsdy = ddy(uv);\n\n        float3 traxNormal;\n        float traxBuffer = SampleTraxBuffer(d.worldSpacePosition, traxNormal);\n        \n        #if _TESSELLATION_ON\n            traxBuffer -= _TraxDisplacementDepth;\n        #endif\n\n        d.blackboard.traxBuffer = traxBuffer;\n\n        UNITY_BRANCH\n        if (traxBuffer > 0)\n        {\n            half4 albedo = SAMPLE_TEXTURE2D_GRAD(_TraxAlbedo, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            albedo.rgb *= _TraxTint.rgb;\n            half4 normalSample = SAMPLE_TEXTURE2D_GRAD(_TraxPackedNormal, sampler_TraxAlbedo, uv, fsdx, fsdy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n\n            half smoothness = normalSample.r;\n            half ao = normalSample.b;\n            half3 normal;\n            normal.xy = (normalSample.ag * 2 - 1) * _TraxNormalStrength;\n            normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n\n            \n            half h = HeightBlend(albedo.a, o.Alpha, traxBuffer, _TraxHeightContrast);\n\n            h = lerp(traxBuffer, h, _TraxInterpContrast);\n\n            o.Albedo = lerp(albedo, o.Albedo, h);\n\n            #if _SURFACEGRADIENT\n                o.Normal = lerp(normal, o.Normal, h);\n            #else\n                o.Normal = lerp(normal + traxNormal, o.Normal, h);\n            #endif\n        \n            o.Smoothness = lerp(smoothness, o.Smoothness, h);\n            o.Occlusion = lerp(ao, o.Occlusion, h);\n        }\n      #endif\n   }\n\n\n\n\n    #if _RAINDROPS\n       TEXTURE2D(_RainDropTexture);\n       SAMPLER(sampler_RainDropTexture);\n       half _Global_RainIntensity;\n    #endif\n\n    #if _WETNESS\n       half2 _Global_WetnessParams; // global, not in cbuffer\n    #endif\n   \n    #if _RAINDROPS\n    half2 ComputeRipple(float2 uv, half time, half weight)\n    {\n        half4 ripple = SAMPLE_TEXTURE2D(_RainDropTexture, sampler_RainDropTexture, uv);\n        COUNTSAMPLE\n        ripple.yz = ripple.yz * 2 - 1;\n\n        half dropFrac = frac(ripple.w + time);\n        half timeFrac = dropFrac - 1.0 + ripple.x;\n        half dropFactor = saturate(0.2f + weight * 0.8 - dropFrac);\n        half finalFactor = dropFactor * ripple.x * \n                                sin( clamp(timeFrac * 9.0f, 0.0f, 3.0f) * 3.14159265359);\n\n        return half2(ripple.yz * finalFactor);\n    }\n    #endif\n\n    half2 DoRain(half2 waterNorm, float2 uv, out half2 ripple)\n    {\n        #if _RAINDROPS\n            float rainIntensity = _RainIntensityScale.x;\n            if (_RainMode > 1)\n            {\n                rainIntensity = _Global_RainIntensity;\n            }\n\n            half dropStrength = rainIntensity;\n            const float4 timeMul = float4(1.0f, 0.85f, 0.93f, 1.13f); \n            half4 timeAdd = float4(0.0f, 0.2f, 0.45f, 0.7f);\n            half4 times = _Time.yyyy;\n            times = frac((times * float4(1, 0.85, 0.93, 1.13) + float4(0, 0.2, 0.45, 0.7)) * 1.6);\n\n            float2 ruv1 = uv * _RainIntensityScale.yy;\n            float2 ruv2 = ruv1;\n\n            half4 weights = rainIntensity.xxxx - float4(0, 0.25, 0.5, 0.75);\n            half2 ripple1 = ComputeRipple(ruv1 + float2( 0.25f,0.0f), times.x, weights.x);\n            half2 ripple2 = ComputeRipple(ruv2 + float2(-0.55f,0.3f), times.y, weights.y);\n            half2 ripple3 = ComputeRipple(ruv1 + float2(0.6f, 0.85f), times.z, weights.z);\n            half2 ripple4 = ComputeRipple(ruv2 + float2(0.5f,-0.75f), times.w, weights.w);\n            weights = saturate(weights * 4);\n\n            half2 rippleNormal = half2( weights.x * ripple1.xy +\n                        weights.y * ripple2.xy + \n                        weights.z * ripple3.xy + \n                        weights.w * ripple4.xy);\n\n            ripple = rippleNormal * dropStrength * rainIntensity;\n            waterNorm = lerp(waterNorm, normalize(half3(rippleNormal.xy + rippleNormal.xy, 1)).xy, rainIntensity * dropStrength); \n            return waterNorm;                        \n        #else\n            return waterNorm;\n        #endif\n    }\n\n   half2 _Global_PuddleParams;   // this is a global, so keep it out of the cbuffer\n   void GetPuddleParams(ShaderData d, inout float puddleMask, inout float pudHeight)\n   {\n      #if _PUDDLES || _GLOBALPUDDLES\n          pudHeight = _PuddleAmount;\n          if (_PuddleMode > 0)\n             pudHeight = _Global_PuddleParams.x;    \n      \n\n          half dt = dot(d.worldSpaceNormal, float3(0,1,0));\n\t      dt -= _PuddleAngleMin;\n          dt = saturate(dt * _PuddleFalloff);\n          puddleMask *= dt;\n      #endif\n   }\n   \n   void Ext_ModifyTessellatedVertex7 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _PUDDLES && _HAS_LIT_TESSELLATION\n         ShaderData d;\n         ZERO_INITIALIZE(ShaderData, d);\n         d.texcoord0 = v.texcoord0;\n         d.localSpacePosition = v.vertex.xyz;\n         d.localSpaceNormal = v.normal;\n         d.worldSpacePosition = TransformObjectToWorld(v.vertex.xyz);\n         d.worldSpaceNormal = TransformObjectToWorld(v.normal);\n         half mask = 1;\n         half pudHeight = 1;\n\n         // save some ops by doing this in 2d\n         #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2DLOD(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2DLOD(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #else\n                mask = (FBM2DLOD(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n         #endif\n\n         GetPuddleParams(d, mask, pudHeight);\n         float height = pudHeight * mask;\n         if (e.blackboard.vertexHeightOffset < height)\n         {\n            e.blackboard.vertexHeightOffset = height;\n            height -= _TessellationOffset; \n            // dampen cracks\n            height *= 1 - v.texcoord0.z;\n            height *= _TessellationDisplacement;\n            v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n            \n        }\n      #endif\n   }\n\n\n#if _WETNESS\n\n   float GetWetnessLevel(Surface o, ShaderData d, float wetnessMask)\n   {\n      float wetLevel = clamp(_WetnessAmount, _WetnessMin, _WetnessMax);\n      \n      if (_WetnessMode > 0)\n         wetLevel = clamp(wetLevel, _Global_WetnessParams.x, _Global_WetnessParams.y);\n\n      wetLevel = saturate(wetLevel + (1 - saturate(d.worldSpacePosition.y - _WetnessShoreline)));\n      float3x3 tbn = float3x3(d.worldSpaceTangent, cross(d.worldSpaceTangent, d.worldSpaceNormal), d.worldSpaceNormal);\n      float dt = dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0));\n      dt -= _WetnessAngleMin;\n      dt = saturate(dt * _WetnessFalloff * wetLevel);\n      dt *= wetnessMask;\n      return dt;\n   }\n#endif\n   \n\n   void Ext_SurfaceFunction7 (inout Surface o, ShaderData d)\n   {\n      half wetnessLevel = 0;\n      #if _WETNESS\n          wetnessLevel = GetWetnessLevel(o, d, 1); // mask one day?\n      #endif\n\n      half depthMask = 0;\n      half depth = 0;\n\n      #if _PUDDLES\n          half mask = 1;\n          half pudHeight = 1;\n          #if _PUDDLENOISE\n            #if _NOISEWORLD\n                mask = (FBM2D(d.worldSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #elif _NOISELOCAL\n                mask = (FBM2D(d.localSpacePosition.xz * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);      \n            #else\n                mask = (FBM2D(d.texcoord0.xy * _PuddleNoiseFrequency + _PuddleNoiseOffset) * _PuddleNoiseAmplitude + _PuddleNoiseCenter);\n                mask = saturate(mask);\n            #endif\n          #endif\n\n          GetPuddleParams(d, mask, pudHeight);\n          pudHeight *= mask;\n          depth = pudHeight - o.Height;\n          depthMask = saturate(depth * _PuddleFalloff);\n          depthMask *= _PuddleColor.a;\n          depth = o.Height - pudHeight;\n\n          // extend wetness slighting higher than the puddle\n          half wetmask = saturate((pudHeight + 0.05 - o.Height) * _PuddleFalloff);\n          wetnessLevel = max(wetmask, wetnessLevel);\n       #endif\n\n       \n       #if _WETNESS || _PUDDLES\n          half3 waterNorm = half3(0,0,1);\n          half3 wetAlbedo = o.Albedo;\n          half wetSmoothness = o.Smoothness;\n          #if _PUDDLES\n             wetAlbedo *= _PuddleColor.rgb;\n          #endif\n          WaterBRDF(wetAlbedo, wetSmoothness, o.Metallic, wetnessLevel, _Porosity);\n\n          half ri = 0;\n          half2 ripple = 0;\n          #if (_RAINDROPS || _GLOBALRAIN) && (_PUDDLES || _GLOBALPUDDLES)\n             ri = _RainIntensityScale.z;\n             waterNorm.xy = DoRain(waterNorm.xy, d.texcoord0.xy, ripple) * depthMask;\n          #endif\n\n          o.Normal = lerp(o.Normal, waterNorm, depthMask);\n          o.Normal = lerp(o.Normal, LitBlendDetailNormal(o.Normal, half3(ripple.xy, 1)), saturate(ri - depthMask) * wetnessLevel);\n          o.Occlusion = lerp(o.Occlusion, 1, depthMask);\n          o.Smoothness = lerp(o.Smoothness, wetSmoothness, wetnessLevel);\n          o.Albedo = lerp(o.Albedo, wetAlbedo, wetnessLevel);\n          o.Emission *= 1 + depth;\n          o.Metallic *= 1 + depth;\n          o.Specular *= 1 + depth;\n\n       #endif\n\n   }\n\n\n\n\n    #if _SNOW\n       TEXTURE2D(_SnowAlbedo);\n       SAMPLER(sampler_SnowAlbedo);\n       TEXTURE2D(_SnowNormal);\n       TEXTURE2D(_SnowMaskMap);\n       #if _TRAX_ON\n          TEXTURE2D(_SnowTraxAlbedo);\n          TEXTURE2D(_SnowTraxNormal);\n          TEXTURE2D(_SnowTraxMaskMap);\n       #endif\n    #endif\n\n   float _Global_SnowLevel;\n\n\n   void Ext_ModifyVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n    #if (_SNOW)\n        float amount = _SnowAmount;\n        if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n        float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n        float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n        snowAmount -= _SnowAngle;\n        snowAmount *= _SnowContrast * 0.5;\n        snowAmount = saturate(snowAmount) * amount;\n        float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n        if (_SnowWorldFade.z > 0)\n        {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n        }\n        #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n        #endif\n        snowAmount = saturate(snowAmount);\n\n        #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n        #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n        #endif\n\n        float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n        v.vertex.xyz = v.vertex.xyz + displacementVec * snowAmount * snowAmount * _SnowVertexHeight;\n    #endif\n   }\n\n   void Ext_ModifyTessellatedVertex8 (inout VertexData v, inout ExtraV2F e)\n   {\n      #if _TESSELLATION_ON && _SNOW && _HAS_LIT_TESSELLATION\n         float amount = _SnowAmount;\n         if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n         float3 worldNormal = mul((float3x3)unity_ObjectToWorld, v.normal);\n         float snowAmount = dot(worldNormal, float3(0,1,0)) + 1;\n         snowAmount -= _SnowAngle;\n         snowAmount *= _SnowContrast * 0.5;\n         float3 worldPos = TransformObjectToWorld(v.vertex.xyz);\n         if (_SnowWorldFade.z > 0)\n         {\n            float worldFade = saturate((worldPos.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n            snowAmount *= worldFade;\n         }\n\n         snowAmount = saturate(snowAmount) * amount;\n\n         #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(worldPos.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n         #endif\n         snowAmount = saturate(snowAmount);\n\n         #if _LAYERVERTEXMASK\n            snowAmount *= v.vertexColor.a;\n         #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n            snowAmount *= e.blackboard.weightTextureMask.a;\n         #endif\n\n         float3 displacementVec = mul((float3x3)unity_WorldToObject, float3(0,1,0));\n         half heightMap = SAMPLE_TEXTURE2D_LOD(_SnowAlbedo, sampler_SnowAlbedo, worldPos.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw, 2);\n\n         float height = max(_SnowVertexHeight * 3 * snowAmount + snowAmount * heightMap, e.blackboard.vertexHeightOffset);\n         #if _TRAX_ON\n            height *= e.blackboard.traxBuffer;\n         #endif\n         e.blackboard.vertexHeightOffset = height;\n\n         height -= _TessellationOffset; \n         // dampen cracks\n         height *= 1 - v.texcoord0.z;\n         height *= _TessellationDisplacement;\n\n         v.vertex.xyz = e.blackboard.originalVertexPosition + v.normal * height;\n         \n      #endif\n\n   }\n\n   void SampleSnowSurface(TEXTURE2D_PARAM(alb, ss), TEXTURE2D_PARAM(norm, ss2), TEXTURE2D_PARAM(mask, ss3),\n        ShaderData d, float2 uv, float2 dx, float2 dy, out half4 albedo, out half3 normal, out half2 smoothAO)\n   {\n      #if _SNOWSTOCHASTIC\n         float w1, w2, w3;\n         int2 vertex1, vertex2, vertex3;\n         TriangleGrid(uv, _SnowStochasticScale, w1, w2, w3, vertex1, vertex2, vertex3);\n\n         // Assign random offset to each triangle vertex\n         float2 uv0 = uv;\n         float2 uv1 = uv;\n         float2 uv2 = uv;\n   \n         uv0.xy += SimpleHash2(vertex1);\n         uv1.xy += SimpleHash2(vertex2);\n         uv2.xy += SimpleHash2(vertex3);\n         half3 weights = half3(w1, w2, w3);\n\n         half4 albedo0 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv0, dx, dy);\n         half4 albedo1 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv1, dx, dy);\n         half4 albedo2 = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv2, dx, dy);\n         COUNTSAMPLE\n         COUNTSAMPLE\n         COUNTSAMPLE\n         weights = BaryWeightBlend(weights, albedo0.a, albedo1.a, albedo2.a, _SnowStochasticContrast);\n         albedo = albedo0 * weights.x + albedo1 * weights.y + albedo2 * weights.z;\n\n         normal = half3(0,0,1);\n         smoothAO = half2(0, 1);\n\n         #if !_AUTONORMAL\n            half4 n0 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv0, dx, dy);\n            half4 n1 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv1, dx, dy);\n            half4 n2 = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n\n            half4 snowNormSamp = n0 * weights.x + n1 * weights.y + n2 * weights.z;\n\n            normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n            #if _SURFACEGRADIENT\n               normal = ConvertNormalToGradient(d, normal);\n            #endif\n                \n            #if _PACKEDFAST\n               smoothAO.x = snowNormSamp.r;\n               smoothAO.y = snowNormSamp.b;\n            #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask0 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv0, dx, dy);\n            half4 snowMask1 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv1, dx, dy);\n            half4 snowMask2 = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv2, dx, dy);\n            COUNTSAMPLE\n            COUNTSAMPLE\n            COUNTSAMPLE\n            half4 snowMask = snowMask0 * weights.x + snowMask1 * weights.y + snowMask2 * weights.z;\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n      #else // not stochastic\n          albedo = SAMPLE_TEXTURE2D_GRAD(alb, ss, uv, dx, dy);\n          COUNTSAMPLE\n\n          normal = half3(0,0,1);\n          smoothAO = half2(0, 1);\n\n          #if !_AUTONORMAL\n             half4 snowNormSamp = SAMPLE_TEXTURE2D_GRAD(norm, ss2, uv, dx, dy);\n             COUNTSAMPLE\n             normal = PackedUnpackScaleNormal(snowNormSamp, 1);\n             #if _SURFACEGRADIENT\n                normal = ConvertNormalToGradient(d, normal);\n             #endif\n                 \n             #if _PACKEDFAST\n                smoothAO.x = snowNormSamp.r;\n                smoothAO.y = snowNormSamp.b;\n             #endif\n         #endif\n\n         #if _SNOWMASKMAP && !_PACKEDFAST\n            half4 snowMask = SAMPLE_TEXTURE2D_GRAD(mask, ss3, uv, dx, dy);\n            COUNTSAMPLE\n            smoothAO.x = snowMask.a;\n            smoothAO.y = snowMask.g;\n         #endif\n     #endif // stochastic\n   }\n\n   \n   void Ext_SurfaceFunction8 (inout Surface o, ShaderData d)\n   {\n      #if _SNOW\n          float amount = _SnowAmount;\n          if (_SnowMode > 0)\n           amount = _Global_SnowLevel;\n\n          float snowAmount = lerp(dot(GetWorldSpaceNormal(d, o.Normal, o.Alpha), float3(0,1,0)), dot(d.worldSpaceNormal, float3(0,1,0)), amount * 0.8) + 1;\n          snowAmount -= _SnowAngle;\n          snowAmount *= _SnowContrast;\n          snowAmount = saturate(snowAmount) - (1-amount) * (1-amount);\n\n          if (_SnowWorldFade.z > 0)\n          {\n             float worldFade = saturate((d.worldSpacePosition.y - _SnowWorldFade.x) / max(_SnowWorldFade.y, 1));\n             snowAmount *= worldFade;\n          }\n\n          #if _SNOWNOISE\n            snowAmount *= 1 - saturate(1 - (snowAmount * 2 - 1)) * Noise2D(d.worldSpacePosition.xz * _SnowNoiseFreq + _SnowNoiseOffset) * _SnowNoiseAmp;\n          #endif\n          snowAmount = saturate(snowAmount);\n\n          float2 uv = d.worldSpacePosition.xz * float2(1, -1) * _SnowAlbedo_ST.xy + _SnowAlbedo_ST.zw;\n          float2 dx = ddx(uv);\n          float2 dy = ddy(uv);\n\n          #if _TRAX_ON\n              float2 tuv = d.worldSpacePosition.xz * float2(1, -1) * _SnowTraxAlbedo_ST.xy + _SnowTraxAlbedo_ST.zw;\n              float2 tdx = ddx(uv);\n              float2 tdy = ddy(uv);\n          #endif\n\n          #if _LAYERVERTEXMASK\n              snowAmount *= d.vertexColor.a;\n          #elif _LAYERTEXTUREMASK && _HAS_WEIGHTTEXTURE_MASK\n              snowAmount *= d.blackboard.weightTextureMask.a;\n          #endif\n\n          UNITY_BRANCH\n          if (snowAmount > 0)\n          {\n             half4 snowAlbedo;\n             half3 snowNormal;\n             half2 snowSmoothAO;\n             SampleSnowSurface(TEXTURE2D_ARGS(_SnowAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowNormal, sampler_SnowAlbedo),\n                    TEXTURE2D_ARGS(_SnowMaskMap, sampler_SnowAlbedo), d, uv, dx, dy, snowAlbedo, snowNormal, snowSmoothAO);\n\n             snowAlbedo.rgb *= _SnowTint.rgb;\n\n             #if _TRAX_ON\n                half traxBuffer = 1 - d.blackboard.traxBuffer;\n                UNITY_BRANCH\n                if (traxBuffer > 0)\n                {\n                    half4 tsnowAlbedo;\n                    half3 tsnowNormal;\n                    half2 tsnowSmoothAO;\n                    SampleSnowSurface(TEXTURE2D_ARGS(_SnowTraxAlbedo, sampler_SnowAlbedo), TEXTURE2D_ARGS(_SnowTraxNormal, sampler_SnowAlbedo),\n                        TEXTURE2D_ARGS(_SnowTraxMaskMap, sampler_SnowAlbedo), d, tuv, tdx, tdy, tsnowAlbedo, tsnowNormal, tsnowSmoothAO);\n\n                    tsnowAlbedo.rgb *= _SnowTraxTint;\n                    half h = HeightBlend(snowAlbedo.a, tsnowAlbedo.a, traxBuffer, 0.5);\n                    snowAlbedo = lerp(snowAlbedo, tsnowAlbedo, h);\n                    snowNormal = lerp(snowNormal, tsnowNormal, h);\n                    snowSmoothAO = lerp(snowSmoothAO, tsnowSmoothAO, h);\n                }\n             #endif\n\n             #if !_AUTONORMAL\n                o.Normal = lerp(o.Normal, snowNormal, snowAmount);\n             #endif\n             o.Albedo = lerp(o.Albedo, snowAlbedo.rgb, snowAmount);\n             o.Alpha = lerp(o.Alpha, snowAlbedo.a, snowAmount);\n             o.Smoothness = lerp(o.Smoothness, snowSmoothAO.x, snowAmount);\n             o.Occlusion = lerp(o.Occlusion, snowSmoothAO.y, snowAmount);\n             o.Height = o.Alpha;\n\n          }\n      #endif\n   }\n\n   \n\n\n\n\n\n   TEXTURE2D(_WindParticulate);\n   SAMPLER(sampler_WindParticulate);\n\n// In case we want to read it more than once..\n\n#ifndef __STACKABLE_WIND_INCLUDES__\n#define __STACKABLE_WIND_INCLUDES__\n\n\n   half FilterRange(float4 range, float y)\n   {\n      half w = saturate((y - range.x) / max(range.y - range.x, 0.0001));\n      w *= 1.0 - saturate((y - range.z) / max(range.w - range.z, 0.0001));\n      return w;\n   }\n\n   \n   float2 RotateUV(float2 uv, float amt)\n   {\n      uv -=0.5;\n      float s = sin ( amt);\n      float c = cos ( amt );\n      float2x2 mtx = float2x2( c, -s, s, c);\n      mtx *= 0.5;\n      mtx += 0.5;\n      mtx = mtx * 2-1;\n      uv = mul ( uv, mtx );\n      uv += 0.5;\n      return uv;\n   }\n\n\n   half FilterWindParticulateSlope(float4 range, float3 worldNormalVertex, float windRot)\n   {\n      float2 windDir = RotateUV(float2(1, 0), windRot);\n      float2 flow = lerp(worldNormalVertex.xz, normalize(worldNormalVertex.xz), max(0.1, worldNormalVertex.z));\n      float cofacing = dot(windDir, flow); // 1 going downhill, -1 going uphill\n      return FilterRange(range, cofacing);\n   }\n\n   half ProcessWindParticulateMask(inout half mask, float contrast)\n   {\n      mask = pow(abs(mask), abs(contrast));\n      half invMask = 1.0 - mask;\n      invMask *= invMask; \n      invMask *= invMask;\n      return invMask;\n   }\n#endif // include guard\n\n   void Ext_SurfaceFunction9 (inout Surface o, ShaderData d)\n   {\n      #if _WIND_ON && !_PASSMETA\n   \n         float3 upVector = float3(0,0,1);\n\n         half upDot = max(0.0, dot(d.worldSpaceNormal, float3(0, 1, 0)));\n\n         float2 uv = d.worldSpacePosition.xz;\n         if (_WindParticulateSpace > 0.5)\n            uv = d.texcoord0.xy;\n         float windRotation = _WindParticulateRotation;\n         float windStrength = _WindParticulateStrength;\n\n         float2 wuv = RotateUV(uv, windRotation);\n\n         half windBlend = 1.0;\n\n         float windWorldMask = FilterRange(_WindParticulateWorldHeightMask, d.worldSpacePosition.y);\n         windWorldMask *= FilterRange(_WindParticulateAngleMask, upDot);\n\n         // compute mask\n         wuv *= float2(_WindParticulate_ST.x, 1) * _WindParticulate_ST.y + _WindParticulate_ST.zw;\n         float speed = _Time.x * _WindParticulateSpeed;\n         half w1 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv * 3 + speed * float2(1,0)).g;\n         half w2 = SAMPLE_TEXTURE2D(_WindParticulate, sampler_WindParticulate, wuv + speed * float2(1.1,0)).a;\n         half windMask = (w1 * w2);\n\n         windMask *= windStrength * windBlend * windWorldMask;\n         windMask *= saturate((_WindParticulateTextureHeight - o.Height) * 10);\n\n         half windInvMask = ProcessWindParticulateMask(windMask, _WindParticulatePower);\n    \n         o.Albedo = lerp(o.Albedo, _WindParticulateColor.rgb, windMask * _WindParticulateColor.a);\n         o.Emission += _WindParticulateColor.rgb * windMask * _WindParticulateColor.a * _WindParticulateEmissive.rgb;\n         o.Normal.xy *= windInvMask;\n         o.Smoothness *= windInvMask;\n         o.Occlusion -= (1.0 - windInvMask) * _WindParticulateOcclusionStrength;\n         o.Metallic *= windInvMask;\n      #endif\n\n   }\n\n\n\n\n\tvoid Ext_SurfaceFunction10 (inout Surface o, ShaderData d)\n\t{\n        if (_DoubleSidedNormalMode == 0)\n        {\n           o.Normal *= d.isFrontFace ? 1 : -1;\n        }\n        else if (_DoubleSidedNormalMode == 1)\n        {\n\t\t   o.Normal.z *= d.isFrontFace ? 1 : -1;\n        }\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction11 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _SURFACEGRADIENT\n\t\t\to.Normal = ResolveNormalFromSurfaceGradient(d, o.Normal);\n\t    #elif _AUTONORMAL\n\t        float3 dx = ddx(d.worldSpacePosition);\n\t\t\tfloat3 dy = ddy(d.worldSpacePosition);\n\t\t\tfloat3 crossX = cross(float3(0,1,0), dx);\n\t\t\tfloat3 crossY = cross(float3(0,1,0), dy);\n\t\t\tfloat3 dt = abs(dot(crossY, dx));\n\t\t\tfloat height = _AutoNormalStrength * 0.5 * o.Alpha;\n\t\t\tfloat3 n = ((((height + ddx(height)) - height) * crossY) + (((height + ddy(height)) - height) * crossX)) * sign(dt);\n\t\t\tn.y *= -1.0;\n\t\t\to.Normal = normalize((dt * float3(0,1,0)) - n).xzy;\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#else\n\t\t\to.Normal = (TangentToWorldSpace(d, o.Normal));\n\t\t#endif\n\t}\n\n\n\n\n\tvoid Ext_SurfaceFunction12 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DEBUG_SAMPLECOUNT\n\t\t\tif (_sampleCount > _DebugSampleCountThreshold)\n\t\t\t{\n\t\t\t\to.Albedo.r = 1;\n\t\t\t\to.Albedo.gb *= 0.2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\to.Albedo.b = 1;\n\t\t\t}\n\n        #endif\n\t}\n\n\n\n\n\tSAMPLER(sampler_DissolveTexture);\n\tTEXTURE2D(_DissolveTexture);\n\tTEXTURE2D(_DissolveGradient);\n\n\tvoid Ext_SurfaceFunction13 (inout Surface o, ShaderData d)\n\t{\n\t\t#if _DISSOLVE\n\t\tfloat2 uv = d.texcoord0.xy * _DissolveTexture_ST.xy + _DissolveTexture_ST.zw;\n\t\tfloat2 dx = ddx(uv);\n\t\tfloat2 dy = ddy(uv);\n\n\t\tUNITY_BRANCH\n\t\tif (_DissolveAmount > 0)\n\t\t{\n\t\t\thalf dissolve = SAMPLE_TEXTURE2D_GRAD(_DissolveTexture, sampler_DissolveTexture, uv, dx, dy).g;\n\t\t\thalf cp =  saturate(_DissolveAmount - (dissolve - _DissolveAmount) * _DissolveEdgeContrast) + _DissolveAmount;\n\t\t\thalf cp2 = saturate(1.0 - abs((dissolve - _DissolveAmount) * _DissolveEdgeContrast));\n\t\t\tclip(1.0 - cp);\n\t\t\tfloat2 fuv = float2(cp2, 0.5);\n\t\t\thalf3 col = SAMPLE_TEXTURE2D_LOD(_DissolveGradient, sampler_DissolveTexture, fuv, 0).rgb;\n\t\t\t\t\n\t\t\to.Albedo = lerp(o.Albedo, col, _DissolveColoration * cp2);\n\t\t\to.Emission = lerp(o.Emission, col * _DissolveEmissiveStr, _DissolveColoration * cp2);\n\t\t}\n\t\t#endif\n\t}\n\n\n\n\n    float Dither8x8Bayer( int x, int y )\n    {\n        const float dither[ 64 ] = {\n                1, 49, 13, 61,  4, 52, 16, 64,\n            33, 17, 45, 29, 36, 20, 48, 32,\n                9, 57,  5, 53, 12, 60,  8, 56,\n            41, 25, 37, 21, 44, 28, 40, 24,\n                3, 51, 15, 63,  2, 50, 14, 62,\n            35, 19, 47, 31, 34, 18, 46, 30,\n            11, 59,  7, 55, 10, 58,  6, 54,\n            43, 27, 39, 23, 42, 26, 38, 22};\n        int r = y * 8 + x;\n        return dither[r] / 64; \n    }\n\n    void ApplyDitherCrossFadeVSP(float2 vpos, float fadeValue)\n    {\n        float dither = Dither8x8Bayer( fmod(vpos.x, 8), fmod(vpos.y, 8) );\n        float sgn = fadeValue > 0 ? 1.0f : -1.0f;\n        clip(dither - (1-fadeValue) * sgn);\n    }\n    \n\n\tvoid Ext_SurfaceFunction14 (inout Surface o, ShaderData d)\n\t{\n\t\t#if LOD_FADE_CROSSFADE\n            float4 screenPosNorm = d.screenPos / d.screenPos.w;\n            screenPosNorm.z = ( UNITY_NEAR_CLIP_VALUE >= 0 ) ? screenPosNorm.z : screenPosNorm.z * 0.5 + 0.5;\n            float2 clipScreen = screenPosNorm.xy * _ScreenParams.xy;\n            ApplyDitherCrossFadeVSP(clipScreen,unity_LODFade.x);\n        #endif\n\t}\n\n\n\n\n\n\n// declare outside of CBuffer\n\nfloat4x4 _GlobalVolumeMatrix;\nfloat4x4 _VolumeMatrix;\nfloat3 _VolumeMin;\nfloat3 _VolumeInvSize;\nfloat3 _GlobalVolumeMin;\nfloat3 _GlobalVolumeInvSize;\n\n// I inlined a section of your include. You can use includes in better shaders, but doing it via a subshader or this way\n// is much better. The reason is that this allows your shader to be all inclusive, and packed up for asset store distribition,\n// without requiring specific paths to other files, etc.\n//\n\n#ifndef BAKERY_INCLUDED\n#define BAKERY_INCLUDED\n\n#define BAKERYMODE_DEFAULT 0\n#define BAKERYMODE_VERTEXLM 1.0f\n#define BAKERYMODE_RNM 2.0f\n#define BAKERYMODE_SH 3.0f\n\n\n// can't fit vertexLM SH to sm3_0 interpolators\n#ifndef SHADER_API_D3D11\n    #undef _LIGHTMAPMODE_VERTEXSH\n#endif\n\n// can't do stuff on sm2_0 due to standard shader alrady taking up all instructions\n#if SHADER_TARGET < 30\n    #undef BAKERY_BICUBIC\n    #undef BAKERY_LMSPEC\n\n    #undef _LIGHTMAPMODE_RNM\n    #undef _LIGHTMAPMODE_SH\n    #undef _LIGHTMAPMODE_VERTEX\n#endif\n\n#define lumaConv float3(0.2125f, 0.7154f, 0.0721f)\n\n#ifdef BAKERY_VOLUME\n    #ifdef BAKERY_COMPRESSED_VOLUME\n        Texture3D _Volume3;\n    #endif\n#endif\n\n\nhalf3 LinearToGamma (half3 linRGB)\n{\n    linRGB = max(linRGB, half3(0.h, 0.h, 0.h));\n    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n    return max(1.055h * pow(linRGB, 0.416666667h) - 0.055h, 0.h);\n}\n\nfloat shEvaluateDiffuseL1Geomerics(float L0, float3 L1, float3 n)\n{\n    // average energy\n    float R0 = L0;\n\n    // avg direction of incoming light\n    float3 R1 = 0.5f * L1;\n\n    // directional brightness\n    float lenR1 = length(R1);\n\n    // linear angle between normal and direction 0-1\n    //float q = 0.5f * (1.0f + dot(R1 / lenR1, n));\n    //float q = dot(R1 / lenR1, n) * 0.5 + 0.5;\n    float q = dot(normalize(R1), n) * 0.5 + 0.5;\n\n    // power for q\n    // lerps from 1 (linear) to 3 (cubic) based on directionality\n    float p = 1.0f + 2.0f * lenR1 / R0;\n\n    // dynamic range constant\n    // should vary between 4 (highly directional) and 0 (ambient)\n    float a = (1.0f - lenR1 / R0) / (1.0f + lenR1 / R0);\n\n    return R0 * (a + (1.0f - a) * (p + 1.0f) * pow(q, p));\n}\n\n#ifdef BAKERY_VERTEXLMMASK\n    float4 unpack4NFloats(float src)\n\t{\n        //return fmod(float4(src / 262144.0, src / 4096.0, src / 64.0, src), 64.0)/64.0;\n        return frac(float4(src / (262144.0*64), src / (4096.0*64), src / (64.0*64), src));\n    }\n#endif\n\n#if defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n    float3 unpack3NFloats(float src)\n\t{\n        float r = frac(src);\n        float g = frac(src * 256.0);\n        float b = frac(src * 65536.0);\n        return float3(r, g, b);\n    }\n#endif\n\n// Unity defines these under different names in each SRP, so use our own\ninline float3 Bakery_SafeNormalize(float3 inVec)\n{\n    float dp3 = max(0.001f, dot(inVec, inVec));\n    return inVec * rsqrt(dp3);\n}\n\n#if _URP || _HDRP\n\nfloat SmoothnessToPerceptualRoughness(float smoothness)\n{\n    return (1 - smoothness);\n}\n#endif\n\n#if !_STANDARD\nhalf4 unity_Lightmap_HDR;\ninline half3 DecodeLightmap( half4 color )\n{\n    return DecodeLightmap( color, unity_Lightmap_HDR );\n}\n\n#define UNITY_INV_PI        0.31830988618f\ninline float GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return UNITY_INV_PI * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n    void BakeryVertexLMDirection(inout float3 diffuseColor, inout float3 specularColor, float3 lightDirection, float3 vertexNormalWorld, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 dominantDir = Bakery_SafeNormalize(lightDirection);\n        half halfLambert = dot(normalWorld, dominantDir) * 0.5 + 0.5;\n        half flatNormalHalfLambert = dot(vertexNormalWorld, dominantDir) * 0.5 + 0.5;\n\n        #ifdef BAKERY_LMSPEC\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = spec * diffuseColor;\n        #endif\n\n        diffuseColor *= halfLambert / max(1e-4h, flatNormalHalfLambert);\n    }\n#endif\n\n#ifdef _LIGHTMAPMODE_VERTEXSH\n    void BakeryVertexLMSH(inout float3 diffuseColor, inout float3 specularColor, float3 shL1x, float3 shL1y, float3 shL1z, float3 normalWorld, float3 viewDir, float smoothness)\n    {\n        float3 L0 = diffuseColor;\n        float3 nL1x = shL1x;\n        float3 nL1y = shL1y;\n        float3 nL1z = shL1z;\n        float3 L1x = nL1x * L0 * 2;\n        float3 L1y = nL1y * L0 * 2;\n        float3 L1z = nL1z * L0 * 2;\n\n        float3 sh;\n    #if BAKERY_SHNONLINEAR\n        //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n        //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n        //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n        float lumaL0 = dot(L0, 1);\n        float lumaL1x = dot(L1x, 1);\n        float lumaL1y = dot(L1y, 1);\n        float lumaL1z = dot(L1z, 1);\n        float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n        float regularLumaSH = dot(sh, 1);\n        //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n        sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    #else\n        sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    #endif\n\n        diffuseColor = max(sh, 0.0);\n\n        #ifdef BAKERY_LMSPEC\n            float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n            float focus = saturate(length(dominantDir));\n            half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n            half nh = saturate(dot(normalWorld, halfDir));\n            half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n            half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n            half spec = GGXTerm(nh, roughness);\n            specularColor = max(spec * sh, 0.0);\n        #endif\n    }\n#endif\n\n\n\n#ifdef BAKERY_BICUBIC\nfloat BakeryBicubic_w0(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-a + 3.0f) - 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w1(float a)\n{\n    return (1.0f/6.0f)*(a*a*(3.0f*a - 6.0f) + 4.0f);\n}\n\nfloat BakeryBicubic_w2(float a)\n{\n    return (1.0f/6.0f)*(a*(a*(-3.0f*a + 3.0f) + 3.0f) + 1.0f);\n}\n\nfloat BakeryBicubic_w3(float a)\n{\n    return (1.0f/6.0f)*(a*a*a);\n}\n\nfloat BakeryBicubic_g0(float a)\n{\n    return BakeryBicubic_w0(a) + BakeryBicubic_w1(a);\n}\n\nfloat BakeryBicubic_g1(float a)\n{\n    return BakeryBicubic_w2(a) + BakeryBicubic_w3(a);\n}\n\nfloat BakeryBicubic_h0(float a)\n{\n    return -1.0f + BakeryBicubic_w1(a) / (BakeryBicubic_w0(a) + BakeryBicubic_w1(a)) + 0.5f;\n}\n\nfloat BakeryBicubic_h1(float a)\n{\n    return 1.0f + BakeryBicubic_w3(a) / (BakeryBicubic_w2(a) + BakeryBicubic_w3(a)) + 0.5f;\n}\n#endif\n\n\n#if defined(_LIGHTMAPMODE_RNM) || defined(_LIGHTMAPMODE_SH)\nTexture2D _RNM0, _RNM1, _RNM2;\n#endif\n\n#ifdef BAKERY_VOLUME\nTexture3D _Volume0, _Volume1, _Volume2, _VolumeMask;\nSamplerState sampler_Volume0;\n#endif\n\n#if defined(BAKERY_BICUBIC) && defined(LIGHTMAP_ON) && defined(SHADER_API_D3D11)\n    // Bicubic\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\tfloat width, height;\n\t\ttex.GetDimensions(width, height);\n\t\tfloat texelSize = 1.0f / width;\n\n        float x = uv.x * width;\n        float y = uv.y * width;\n\n        x -= 0.5f;\n        y -= 0.5f;\n\n        float px = floor(x);\n        float py = floor(y);\n\n        float fx = x - px;\n        float fy = y - py;\n\n        float g0x = BakeryBicubic_g0(fx);\n        float g1x = BakeryBicubic_g1(fx);\n        float h0x = BakeryBicubic_h0(fx);\n        float h1x = BakeryBicubic_h1(fx);\n        float h0y = BakeryBicubic_h0(fy);\n        float h1y = BakeryBicubic_h1(fy);\n\n        return     BakeryBicubic_g0(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h0y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h0y) * texelSize))) +\n\n                   BakeryBicubic_g1(fy) * ( g0x * tex.Sample(samplerunity_Lightmap, (float2(px + h0x, py + h1y) * texelSize))   +\n                              g1x * tex.Sample(samplerunity_Lightmap, (float2(px + h1x, py + h1y) * texelSize)));\n    }\n#else\n    // Bilinear\n    float4 BakeryTex2D(Texture2D tex, float2 uv)\n    {\n\t\t#ifdef LIGHTMAP_ON\n\t\t\treturn tex.Sample(samplerunity_Lightmap, uv);\n\t\t#else\n\t\t\treturn float4(1,0,0,1);\n\t\t#endif\n    }\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\n#ifdef BAKERY_LMSPEC\nfloat BakeryDirectionalLightmapSpecular(float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 dominantDir = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap, lmUV).xyz * 2 - 1;\n    half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n    half nh = saturate(dot(normalWorld, halfDir));\n    half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n    half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n    half spec = GGXTerm(nh, roughness);\n    return spec;\n}\n#endif\n#endif\n\n\n\n#ifdef _LIGHTMAPMODE_RNM\nvoid BakeryRNM(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalMap, float smoothness, float3 viewDirT)\n{\n    const float3 rnmBasis0 = float3(0.816496580927726f, 0, 0.5773502691896258f);\n    const float3 rnmBasis1 = float3(-0.4082482904638631f, 0.7071067811865475f, 0.5773502691896258f);\n    const float3 rnmBasis2 = float3(-0.4082482904638631f, -0.7071067811865475f, 0.5773502691896258f);\n\n    float3 rnm0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 rnm1 = DecodeLightmap(BakeryTex2D(_RNM1, lmUV));\n    float3 rnm2 = DecodeLightmap(BakeryTex2D(_RNM2, lmUV));\n\n    #ifdef BAKERY_SSBUMP\n        diffuseColor = normalMap.x * rnm0\n                     + normalMap.z * rnm1\n                     + normalMap.y * rnm2;\n         diffuseColor *= 2;\n    #else\n        diffuseColor = saturate(dot(rnmBasis0, normalMap)) * rnm0\n                     + saturate(dot(rnmBasis1, normalMap)) * rnm1\n                     + saturate(dot(rnmBasis2, normalMap)) * rnm2;\n    #endif\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDirT = rnmBasis0 * dot(rnm0, lumaConv) +\n                              rnmBasis1 * dot(rnm1, lumaConv) +\n                              rnmBasis2 * dot(rnm2, lumaConv);\n\n        float3 dominantDirTN = normalize(dominantDirT);\n        float3 specColor = saturate(dot(rnmBasis0, dominantDirTN)) * rnm0 +\n                           saturate(dot(rnmBasis1, dominantDirTN)) * rnm1 +\n                           saturate(dot(rnmBasis2, dominantDirTN)) * rnm2;\n\n        half3 halfDir = Bakery_SafeNormalize(dominantDirTN - viewDirT);\n        half nh = saturate(dot(normalMap, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n        specularColor = spec * specColor;\n    #endif\n}\n#endif\n\n#ifdef DIRLIGHTMAP_COMBINED\ninline half3 Unity_DecodeDirectionalLightmap(half3 color, half4 dirTex, half3 normalWorld)\n{\n    // In directional (non-specular) mode Enlighten bakes dominant light direction\n    // in a way, that using it for half Lambert and then dividing by a \"rebalancing coefficient\"\n    // gives a result close to plain diffuse response lightmaps, but normalmapped.\n\n    // Note that dir is not unit length on purpose. Its length is \"directionality\", like\n    // for the directional specular lightmaps.\n\n    half halfLambert = dot(normalWorld, dirTex.xyz - 0.5) + 0.5;\n\n    return color * halfLambert / max(1e-4h, dirTex.w);\n}\n#endif\n\n#ifdef _LIGHTMAPMODE_SH\nvoid BakerySH(inout float3 diffuseColor, inout float3 specularColor, float2 lmUV, float3 normalWorld, float3 viewDir, float smoothness)\n{\n    float3 L0 = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n    float3 nL1x = BakeryTex2D(_RNM0, lmUV) * 2 - 1;\n    float3 nL1y = BakeryTex2D(_RNM1, lmUV) * 2 - 1;\n    float3 nL1z = BakeryTex2D(_RNM2, lmUV) * 2 - 1;\n    float3 L1x = nL1x * L0 * 2;\n    float3 L1y = nL1y * L0 * 2;\n    float3 L1z = nL1z * L0 * 2;\n\n    float3 sh;\n#if BAKERY_SHNONLINEAR\n    float lumaL0 = dot(L0, 1);\n    float lumaL1x = dot(L1x, 1);\n    float lumaL1y = dot(L1y, 1);\n    float lumaL1z = dot(L1z, 1);\n    float lumaSH = shEvaluateDiffuseL1Geomerics(lumaL0, float3(lumaL1x, lumaL1y, lumaL1z), normalWorld);\n\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n    float regularLumaSH = dot(sh, 1);\n    //sh *= regularLumaSH < 0.001 ? 1 : (lumaSH / regularLumaSH);\n    sh *= lerp(1, lumaSH / regularLumaSH, saturate(regularLumaSH*16));\n\n    //sh.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), normalWorld);\n    //sh.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), normalWorld);\n    //sh.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), normalWorld);\n\n#else\n    sh = L0 + normalWorld.x * L1x + normalWorld.y * L1y + normalWorld.z * L1z;\n#endif\n\n    diffuseColor = max(sh, 0.0);\n\n    #ifdef BAKERY_LMSPEC\n        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n        float focus = saturate(length(dominantDir));\n        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - viewDir);\n        half nh = saturate(dot(normalWorld, halfDir));\n        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness );//* sqrt(focus));\n        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n        half spec = GGXTerm(nh, roughness);\n\n        sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n\n        specularColor = max(spec * sh, 0.0);\n    #endif\n}\n#endif\n\n#endif // include guards\n\n\n    void Ext_ModifyVertex15 (inout VertexData v, inout ExtraV2F e)\n    {\n        #if _USEBAKERY\n\t\t    #if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\t\t\t    // Unpack from RGBM\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.a * 8.0f;\n\t\t\t    v.vertexColor.rgb *= v.vertexColor.rgb;\n\n\t\t\t    #ifdef BAKERY_VERTEXLMMASK\n\t\t\t\t    e.extraV2F4.xyzw = unpack4NFloats(v.texcoord1);\n\t\t\t    #endif\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n\t\t    #endif\n\n            #ifdef _LIGHTMAPMODE_VERTEXSH\n                e.extraV2F5.xyz = unpack3NFloats(v.texcoord1.y) * 2 - 1;\n                e.extraV2F6.xyz = unpack3NFloats(v.texcoord3.x) * 2 - 1;\n                e.extraV2F7.xyz = unpack3NFloats(v.texcoord3.y) * 2 - 1;\n            #endif\n       #endif\n    }\n\n#if _HDRP || _URP\n    half3 SHEvalLinearL0L1 (half4 normal)\n    {\n        half3 x;\n\n        // Linear (L1) + constant (L0) polynomial terms\n        x.r = dot(unity_SHAr,normal);\n        x.g = dot(unity_SHAg,normal);\n        x.b = dot(unity_SHAb,normal);\n\n        return x;\n    }\n\n    // normal should be normalized, w=1.0\n    half3 SHEvalLinearL2 (half4 normal)\n    {\n        half3 x1, x2;\n        // 4 of the quadratic (L2) polynomials\n        half4 vB = normal.xyzz * normal.yzzx;\n        x1.r = dot(unity_SHBr,vB);\n        x1.g = dot(unity_SHBg,vB);\n        x1.b = dot(unity_SHBb,vB);\n\n        // Final (5th) quadratic (L2) polynomial\n        half vC = normal.x*normal.x - normal.y*normal.y;\n        x2 = unity_SHC.rgb * vC;\n\n        return x1 + x2;\n    }\n\n    half3 ShadeSH9 (half4 normal)\n    {\n        // Linear + constant polynomial terms\n        half3 res = SHEvalLinearL0L1 (normal);\n\n        // Quadratic polynomials\n        res += SHEvalLinearL2 (normal);\n\n        #ifdef UNITY_COLORSPACE_GAMMA\n            res = LinearToGamma (res);\n        #endif\n\n        return res;\n\n    }\n#endif\n\n\n\n\tvoid DoBakeryStuff(inout float3 indDif, inout float3 indSpec, inout float4 shadowmask, float3 tangentNormal, float smoothness, ShaderData d)\n\t{\n\t\t// Quality!\n\t\tindDif = 1;\n\t\tindSpec = 0;\n\n        #if defined(_PASSFORWARD) || defined(_PASSGBUFFER) // forward pass on URP/Standard/HDRP + built-in deferred\n\n            float3 normalWorld = mul(tangentNormal, d.TBNMatrix);\n\n\t\t\t#ifdef LIGHTMAP_ON\n\n                // Static\n\n\t\t\t\tfloat2 lmUV = d.texcoord1 * unity_LightmapST.xy + unity_LightmapST.zw;\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_STANDARD\n\t\t\t\t\tindDif = DecodeLightmap(BakeryTex2D(unity_Lightmap, lmUV));\n\n\t\t\t\t\t#ifdef DIRLIGHTMAP_COMBINED\n\t\t\t\t\t\tfloat4 dirMap = BakeryTex2D(unity_LightmapInd, lmUV);\n\t\t\t\t\t\tindDif = Unity_DecodeDirectionalLightmap(indDif, dirMap, normalWorld);\n\n\t\t\t\t\t\t#ifdef BAKERY_LMSPEC\n\t\t\t\t\t\t\tindSpec = BakeryDirectionalLightmapSpecular(lmUV, normalWorld, -d.worldSpaceViewDir, smoothness) * indDif;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)\n\n\t\t\t\t\tindDif = d.vertexColor;\n\n                    #ifdef BAKERY_VERTEXLMMASK\n                        shadowmask = d.extraV2F4;\n                    #endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXDIRECTIONAL\n\t\t\t\t\t\t// worldSpaceNormal is per-vertex\n\t\t\t\t\t\t// normalWorld is per-pixel\n\t\t\t\t\t\tfloat3 bakedLightDirection = d.extraV2F5;\n\t\t\t\t\t\tBakeryVertexLMDirection(indDif, indSpec, bakedLightDirection, d.worldSpaceNormal, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef _LIGHTMAPMODE_VERTEXSH\n\t\t\t\t\t\tBakeryVertexLMSH(indDif, indSpec, d.extraV2F5, d.extraV2F6, d.extraV2F7, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_RNM\n\t\t\t\t\tBakeryRNM(indDif, indSpec, lmUV, tangentNormal, smoothness, -d.tangentSpaceViewDir);\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef _LIGHTMAPMODE_SH\n\t\t\t\t\tBakerySH(indDif, indSpec, lmUV, normalWorld, -d.worldSpaceViewDir, smoothness);\n\t\t\t\t#endif\n\n            #else\n\n                // Dynamic\n\n                #ifdef BAKERY_VOLUME\n\n                    bool isGlobal = dot(abs(_VolumeInvSize),1) == 0;\n                    float3 volViewDir = -d.worldSpaceViewDir;\n                    #ifdef BAKERY_VOLROTATION\n                        float4x4 volMatrix = (isGlobal ? _GlobalVolumeMatrix : _VolumeMatrix);\n                        float3 volInvSize = (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 lpUV = mul(volMatrix, float4(d.worldSpacePosition,1)).xyz * volInvSize + 0.5f;\n                        float3 volNormal = mul((float3x3)volMatrix, normalWorld);\n                        #ifdef BAKERY_LMSPEC\n                            volViewDir = mul((float3x3)volMatrix, volViewDir);\n                        #endif\n                    #else\n                        float3 lpUV = (d.worldSpacePosition - (isGlobal ? _GlobalVolumeMin : _VolumeMin)) * (isGlobal ? _GlobalVolumeInvSize : _VolumeInvSize);\n                        float3 volNormal = normalWorld;\n                    #endif\n\n                    #ifdef BAKERY_COMPRESSED_VOLUME\n                        float4 tex0, tex1, tex2, tex3;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        tex3 = _Volume3.Sample(sampler_Volume0, lpUV) * 2 - 1;\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz * L0;\n                        L1y = tex2.xyz * L0;\n                        L1z = tex3.xyz * L0;\n                    #else\n                        float4 tex0, tex1, tex2;\n                        float3 L0, L1x, L1y, L1z;\n                        tex0 = _Volume0.Sample(sampler_Volume0, lpUV);\n                        tex1 = _Volume1.Sample(sampler_Volume0, lpUV);\n                        tex2 = _Volume2.Sample(sampler_Volume0, lpUV);\n                        L0 = tex0.xyz;\n                        L1x = tex1.xyz;\n                        L1y = tex2.xyz;\n                        L1z = float3(tex0.w, tex1.w, tex2.w);\n                    #endif\n                    indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, float3(L1x.r, L1y.r, L1z.r), volNormal);\n                    indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, float3(L1x.g, L1y.g, L1z.g), volNormal);\n                    indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, float3(L1x.b, L1y.b, L1z.b), volNormal);\n\n                    #ifdef UNITY_COLORSPACE_GAMMA\n                        indDif = pow(indDif, 1.0f / 2.2f);\n                    #endif\n\n                    #ifdef BAKERY_LMSPEC\n                        float3 nL1x = L1x / L0;\n                        float3 nL1y = L1y / L0;\n                        float3 nL1z = L1z / L0;\n                        float3 dominantDir = float3(dot(nL1x, lumaConv), dot(nL1y, lumaConv), dot(nL1z, lumaConv));\n                        half3 halfDir = Bakery_SafeNormalize(normalize(dominantDir) - volViewDir);\n                        half nh = saturate(dot(volNormal, halfDir));\n                        half perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n                        half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n                        half spec = GGXTerm(nh, roughness);\n                        float3 sh = L0 + dominantDir.x * L1x + dominantDir.y * L1y + dominantDir.z * L1z;\n                        indSpec = max(spec * sh, 0.0);\n                    #endif\n\n                    shadowmask = _VolumeMask.Sample(sampler_Volume0, lpUV);\n\n                #else\n\n                    #ifdef BAKERY_SHNONLINEAR\n                        float3 L0 = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);\n                        indDif.r = shEvaluateDiffuseL1Geomerics(L0.r, unity_SHAr.xyz, normalWorld);\n                        indDif.g = shEvaluateDiffuseL1Geomerics(L0.g, unity_SHAg.xyz, normalWorld);\n                        indDif.b = shEvaluateDiffuseL1Geomerics(L0.b, unity_SHAb.xyz, normalWorld);\n                    #else\n                        indDif = ShadeSH9(float4(normalWorld,1));\n                    #endif\n\n                #endif\n\n\t\t\t#endif\n\n        #endif\n\t}\n\n\t// this is the main surface function. Surface is like a surface shader output structure, but\n\t// with our new outputs as well.\n\tvoid Ext_SurfaceFunction15 (inout Surface o, ShaderData d)\n\t{\n        #if _USEBAKERY\n\t\t    float3 indDif;\n\t\t    float3 indSpec;\n            float4 shadowmask = 1;\n\t\t    DoBakeryStuff(indDif, indSpec, shadowmask, o.Normal, o.Smoothness, d);\n\t\t    o.DiffuseGI = indDif;\n\t\t    o.BackDiffuseGI = indDif;\n\t\t    o.SpecularGI = indSpec;\n            o.ShadowMask = shadowmask;\n        #endif\n\t}\n\n\n\n\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                  Ext_SurfaceFunction1(l, d);\n                  Ext_SurfaceFunction2(l, d);\n                  Ext_SurfaceFunction3(l, d);\n                  Ext_SurfaceFunction4(l, d);\n                  Ext_SurfaceFunction5(l, d);\n                  Ext_SurfaceFunction6(l, d);\n                  Ext_SurfaceFunction7(l, d);\n                  Ext_SurfaceFunction8(l, d);\n                  Ext_SurfaceFunction9(l, d);\n\t\t            Ext_SurfaceFunction10(l, d);\n                  Ext_SurfaceFunction11(l, d);\n                  Ext_SurfaceFunction12(l, d);\n                  Ext_SurfaceFunction13(l, d);\n                  Ext_SurfaceFunction14(l, d);\n                  Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraV2F d;\n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                  Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                  Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                  #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                  v2p.extraV2F4 = d.extraV2F4;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                  v2p.extraV2F5 = d.extraV2F5;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F6 = d.extraV2F6;\n                  #endif\n\n                  #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                  v2p.extraV2F7 = d.extraV2F7;\n                  #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                d.extraV2F4 = v2p.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                d.extraV2F5 = v2p.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F6 = v2p.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                d.extraV2F7 = v2p.extraV2F7;\n                #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n                Ext_ModifyTessellatedVertex2(v, d);\n                Ext_ModifyTessellatedVertex3(v, d);\n                Ext_ModifyTessellatedVertex4(v, d);\n                Ext_ModifyTessellatedVertex5(v, d);\n                Ext_ModifyTessellatedVertex6(v, d);\n                Ext_ModifyTessellatedVertex7(v, d);\n                Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n                #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n                v2p.extraV2F4 = d.extraV2F4;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n                v2p.extraV2F5 = d.extraV2F5;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F6 = d.extraV2F6;\n                #endif\n\n                #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n                v2p.extraV2F7 = d.extraV2F7;\n                #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n\n\n\n         \n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n            // d.texcoord3 = i.texcoord3;\n             #endif\n\n             d.isFrontFace = facing;\n             #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n             d.vertexColor = i.vertexColor;\n             #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                 d.localSpacePosition = mul(unity_WorldToObject, float4(i.worldPos, 1)).xyz;\n            #endif\n             d.localSpaceNormal = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n             #if LOD_FADE_CROSSFADE\n             d.screenPos = i.screenPos;\n             d.screenUV = (i.screenPos.xy / i.screenPos.w);\n             #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n             #if _USEBAKERY && defined(BAKERY_VERTEXLMMASK) && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH))\n             d.extraV2F4 = i.extraV2F4;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL)\n             d.extraV2F5 = i.extraV2F5;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F6 = i.extraV2F6;\n             #endif\n\n             #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n             d.extraV2F7 = i.extraV2F7;\n             #endif\n\n            return d;\n         }\n         \n\n         \n         #if defined(SHADERPASS_SHADOWCASTER)\n            float3 _LightDirection;\n         #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n            o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n            #if _USEBAKERY && defined(_LIGHTMAPMODE_VERTEXSH)\n           // o.texcoord3 = v.texcoord3;\n            #endif\n\n            #if _LAYERVERTEXMASK || (_USEBAKERY && (defined(_LIGHTMAPMODE_VERTEX) || defined(_LIGHTMAPMODE_VERTEXDIRECTIONAL) || defined(_LIGHTMAPMODE_VERTEXSH)))\n            o.vertexColor = v.vertexColor;\n            #endif\n           \n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n           o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n\n          #if defined(SHADERPASS_SHADOWCASTER)\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, _LightDirection));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif defined(SHADERPASS_META)\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n\n           #if LOD_FADE_CROSSFADE\n           o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n           #endif\n\n          #if defined(SHADERPASS_FORWARD) || (SHADERPASS == SHADERPASS_GBUFFER)\n              float2 uv1 = v.texcoord1.xy;\n              OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n               o.texcoord1.xy = uv1;\n              OUTPUT_SH(o.worldNormal, o.sh);\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n              half fogFactor = ComputeFogFactor(o.pos.z);\n              o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n             o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n           return o;\n         }\n\n\n         \n\n         // fragment shader\n         half4 Frag (VertexToPixel IN\n            #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n         ) : SV_Target\n         {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n\n           ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                     , facing\n                  #endif\n               );\n           Surface l = (Surface)0;\n\n           #ifdef _DEPTHOFFSET_ON\n              l.outputDepth = outputDepth;\n           #endif\n\n           l.Albedo = half3(0.5, 0.5, 0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n           l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n           #ifdef _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n           #endif\n\n            #if _WORLDSPACENORMAL\n              l.Normal = l.Normal;\n            #else\n              l.Normal = normalize(TangentToWorldSpace(d, l.Normal));\n            #endif\n\n           return float4(PackNormalOctRectEncode(TransformWorldToViewDir(l.Normal, true)), 0.0, 0.0);\n\n         }\n\n         ENDHLSL\n\n      }\n\n\n      \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      \n\n   }\n   \n   \n   CustomEditor \"JBooth.BetterLit.LitBaseMaterialEditor\"\n}\n"}],"betterShader":{"fileID":-6465566751694194690,"guid":"a68a0c4bd3e0a4da08c04d1dd47a94b6","type":3},"betterShaderPath":"Packages/com.jbooth.better-lit-shader/Shaders/BetterShadersSource/LitAlpha-Dev.surfshader","optionOverrides":{"shaderName":"Hidden/Better Lit/Lit Alpha","useCustomEditor":true,"customEditor":"JBooth.BetterLit.LitBaseMaterialEditor","fallback":{"instanceID":0}}}}